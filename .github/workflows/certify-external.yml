# Certify External Verus Projects
#
# This workflow allows BAIF to certify Verus projects outside the organization.
# It's triggered manually with a GitHub repository URL.
#
# The certification badge is hosted in THIS repo (certify), so external projects
# just need to add a badge URL pointing here - no write access required.

name: Certify External Project

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'GitHub repository URL (e.g., https://github.com/owner/repo)'
        required: true
        type: string
      project_path:
        description: 'Path to Verus project within repo (default: . for root)'
        required: false
        default: '.'
        type: string
      package:
        description: 'Package name for workspace projects (optional)'
        required: false
        default: ''
        type: string
      ref:
        description: 'Git ref to certify (branch, tag, or commit SHA)'
        required: false
        default: 'main'
        type: string
      network:
        description: 'Ethereum network for certification'
        required: false
        default: 'mainnet'
        type: choice
        options:
          - mainnet
          - sepolia
      taxonomy_config:
        description: 'Path to spec taxonomy TOML (relative to project root). Auto-detects spec-taxonomy.toml if left empty.'
        required: false
        default: ''
        type: string

permissions:
  contents: write  # To update certifications directory

jobs:
  certify-external:
    runs-on: ubuntu-latest
    steps:
      - name: Parse repository info
        id: repo
        run: |
          REPO_URL="${{ inputs.repo_url }}"
          
          # Extract owner/repo from URL
          # Handles: https://github.com/owner/repo or https://github.com/owner/repo.git
          REPO_PATH=$(echo "$REPO_URL" | sed -E 's|https://github.com/||' | sed 's|\.git$||' | sed 's|/$||')
          OWNER=$(echo "$REPO_PATH" | cut -d'/' -f1)
          REPO=$(echo "$REPO_PATH" | cut -d'/' -f2)
          
          # Create a safe directory name for storing certification
          CERT_ID=$(echo "$REPO_PATH" | tr '/' '-' | tr '[:upper:]' '[:lower:]')
          
          echo "repo_path=$REPO_PATH" >> $GITHUB_OUTPUT
          echo "owner=$OWNER" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "cert_id=$CERT_ID" >> $GITHUB_OUTPUT
          
          echo "Repository: $OWNER/$REPO"
          echo "Certification ID: $CERT_ID"

      - name: Checkout certify repo
        uses: actions/checkout@v4
        with:
          path: certify
          submodules: recursive

      - name: Checkout target project
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.repo.outputs.repo_path }}
          ref: ${{ inputs.ref }}
          path: target

      - name: Get commit SHA
        id: commit
        working-directory: target
        run: |
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Commit SHA: $COMMIT_SHA"

      # ═══════════════════════════════════════════════════════════════
      # Common tooling (needed by both proof generation and certify)
      # ═══════════════════════════════════════════════════════════════
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Install certify dependencies
        working-directory: certify
        run: uv sync

      # ═══════════════════════════════════════════════════════════════
      # STEP 1: Run Verus Verification + Spec Extraction
      # ═══════════════════════════════════════════════════════════════
      - name: Run Verus verification (with SMT logging)
        uses: beneficial-ai-foundation/probe-verus/action@v1
        id: verify
        with:
          project-path: target/${{ inputs.project_path }}
          package: ${{ inputs.package }}
          output-dir: ./output
          verus-args: '--log smt --log-dir ./verus-smt-logs -V spinoff-all'

      - name: Extract Verus specifications
        id: specify
        run: |
          # Run probe-verus specify to extract the spec manifest.
          # Requires atoms.json (produced by the verify action's atomize step).
          # --with-spec-text includes the actual requires/ensures clause text.
          # --taxonomy-config classifies each spec by category (optional).
          SPECS_FILE="./output/specs.json"
          ATOMS_FILE="${{ steps.verify.outputs.atoms-file }}"
          PROJECT_SRC="target/${{ inputs.project_path }}"
          TAXONOMY_CONFIG="${{ inputs.taxonomy_config }}"
          
          if [ -z "$ATOMS_FILE" ] || [ ! -f "$ATOMS_FILE" ]; then
            echo "::warning::atoms.json not found — skipping spec extraction"
            echo "specs_file=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "=== Running probe-verus specify ==="
          echo "Source:     $PROJECT_SRC"
          echo "Atoms:      $ATOMS_FILE"
          echo "Output:     $SPECS_FILE"
          
          # Build command with optional taxonomy config
          CMD="probe-verus specify $PROJECT_SRC -a $ATOMS_FILE -o $SPECS_FILE --with-spec-text"
          
          # Resolve taxonomy config: explicit input > auto-detect at project root
          TAXONOMY_PATH=""
          if [ -n "$TAXONOMY_CONFIG" ]; then
            TAXONOMY_PATH="target/${{ inputs.project_path }}/$TAXONOMY_CONFIG"
          else
            # Auto-detect spec-taxonomy.toml at the project root
            DEFAULT_PATH="target/${{ inputs.project_path }}/spec-taxonomy.toml"
            if [ -f "$DEFAULT_PATH" ]; then
              TAXONOMY_PATH="$DEFAULT_PATH"
            fi
          fi
          
          if [ -n "$TAXONOMY_PATH" ] && [ -f "$TAXONOMY_PATH" ]; then
            echo "Taxonomy:   $TAXONOMY_PATH"
            CMD="$CMD --taxonomy-config $TAXONOMY_PATH"
          elif [ -n "$TAXONOMY_CONFIG" ]; then
            echo "::warning::Taxonomy config not found at $TAXONOMY_PATH — skipping classification"
          fi
          
          eval $CMD
          
          if [ -f "$SPECS_FILE" ]; then
            echo "specs_file=$(realpath "$SPECS_FILE")" >> $GITHUB_OUTPUT
            SPEC_COUNT=$(jq 'length' "$SPECS_FILE")
            echo "Specs extracted: $SPEC_COUNT functions"
            
            # Extract taxonomy summary if spec-labels are present
            LABELED=$(jq '[.[] | select(."spec-labels" and (."spec-labels" | length > 0))] | length' "$SPECS_FILE")
            if [ "$LABELED" -gt 0 ]; then
              echo "Classified: $LABELED / $SPEC_COUNT functions"
              # Build label counts
              LABEL_SUMMARY=$(jq -r '[.[].["spec-labels"] // [] | .[]] | group_by(.) | map("\(length) \(.[0])") | join(", ")' "$SPECS_FILE")
              echo "Labels:     $LABEL_SUMMARY"
              echo "taxonomy_summary=$LABEL_SUMMARY" >> $GITHUB_OUTPUT
            fi
          else
            echo "::warning::probe-verus specify did not produce specs.json"
            echo "specs_file=" >> $GITHUB_OUTPUT
          fi

      - name: Generate Z3 proof certificates
        id: proofs
        working-directory: certify
        run: |
          RESULTS_FILE="${{ steps.verify.outputs.results-file }}"
          SPECS_FILE="${{ steps.specify.outputs.specs_file }}"
          PROJECT_PATH="../target/${{ inputs.project_path }}"
          SMT_LOG_DIR="$PROJECT_PATH/verus-smt-logs"
          PROOF_BUNDLE_DIR="./output/proof-bundle"
          
          # Check if SMT logs were produced
          if [ ! -d "$SMT_LOG_DIR" ]; then
            echo "::warning::SMT log directory not found at $SMT_LOG_DIR — skipping proof generation"
            echo "proof_bundle_dir=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          SMT_COUNT=$(ls "$SMT_LOG_DIR"/*.smt2 2>/dev/null | wc -l)
          echo "Found $SMT_COUNT .smt2 files in $SMT_LOG_DIR"
          
          if [ "$SMT_COUNT" -eq 0 ]; then
            echo "::warning::No .smt2 files found — skipping proof generation"
            echo "proof_bundle_dir=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Locate the Z3 binary bundled with Verus
          Z3_BIN="$HOME/.cargo/bin/verus-x86-linux/z3"
          if [ ! -x "$Z3_BIN" ]; then
            # Fallback: try system z3
            Z3_BIN="z3"
          fi
          echo "Using Z3: $Z3_BIN"
          
          # Build command -- produces a self-contained bundle directory:
          #   proof-bundle/proofs.json       (the index)
          #   proof-bundle/smt_queries/*.smt2 (the Z3 formulas)
          #   proof-bundle/z3_proofs/*.proof   (the Z3 proofs)
          CMD="uv run python3 -m certify_cli generate-proofs"
          CMD="$CMD --smt-log-dir $SMT_LOG_DIR"
          CMD="$CMD --results-file $RESULTS_FILE"
          CMD="$CMD --output-dir $PROOF_BUNDLE_DIR"
          CMD="$CMD --z3-binary $Z3_BIN"
          CMD="$CMD --timeout 300"
          
          if [ -n "$SPECS_FILE" ] && [ -f "$SPECS_FILE" ]; then
            CMD="$CMD --specs-file $SPECS_FILE"
          fi
          
          echo "Running: $CMD"
          eval $CMD
          
          PROOFS_FILE="$PROOF_BUNDLE_DIR/proofs.json"
          if [ -f "$PROOFS_FILE" ]; then
            echo "proof_bundle_dir=$(realpath "$PROOF_BUNDLE_DIR")" >> $GITHUB_OUTPUT
            PROOF_COUNT=$(jq 'length' "$PROOFS_FILE")
            echo "Proof bundle: $PROOF_COUNT functions in $PROOF_BUNDLE_DIR"
            echo "  smt_queries: $(ls "$PROOF_BUNDLE_DIR/smt_queries/"*.smt2 2>/dev/null | wc -l) files"
            echo "  z3_proofs:   $(ls "$PROOF_BUNDLE_DIR/z3_proofs/"*.proof 2>/dev/null | wc -l) files"
          else
            echo "::warning::proofs.json was not produced"
            echo "proof_bundle_dir=" >> $GITHUB_OUTPUT
          fi

      - name: Verification summary
        run: |
          echo "## Verification Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ steps.repo.outputs.repo_path }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Ref**: ${{ inputs.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ steps.commit.outputs.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Verified**: ${{ steps.verify.outputs.verified-count }} / ${{ steps.verify.outputs.total-functions }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.specify.outputs.specs_file }}" ]; then
            echo "- **Specs**: Extracted (Merkle certification)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ steps.proofs.outputs.proof_bundle_dir }}" ]; then
            echo "- **Proof Certificates**: Generated (Z3 formulas + proofs archived)" >> $GITHUB_STEP_SUMMARY
          fi
          TAXONOMY_SUMMARY="${{ steps.specify.outputs.taxonomy_summary }}"
          if [ -n "$TAXONOMY_SUMMARY" ]; then
            echo "- **Taxonomy**: $TAXONOMY_SUMMARY" >> $GITHUB_STEP_SUMMARY
          fi

      # ═══════════════════════════════════════════════════════════════
      # STEP 2: Certify on Ethereum
      # ═══════════════════════════════════════════════════════════════
      - name: Setup certify environment
        working-directory: certify
        run: |
          # Create certify.conf
          RESULTS_PATH="$(realpath ../output/results.json)"
          SPECS_FILE="${{ steps.specify.outputs.specs_file }}"
          PROOF_BUNDLE_DIR="${{ steps.proofs.outputs.proof_bundle_dir }}"
          
          cat > certify.conf << EOF
          CERTIFY_SOURCE="$RESULTS_PATH"
          CERTIFY_DESCRIPTION="BAIF Certification: ${{ steps.repo.outputs.repo_path }}@${{ inputs.ref }} - ${{ steps.verify.outputs.verified-count }}/${{ steps.verify.outputs.total-functions }} verified"
          EOF
          
          # Add specs source for Merkle certification if available
          if [ -n "$SPECS_FILE" ] && [ -f "$SPECS_FILE" ]; then
            SPECS_PATH="$(realpath "$SPECS_FILE")"
            echo "CERTIFY_SPECS_SOURCE=\"$SPECS_PATH\"" >> certify.conf
          fi
          
          # Note: proof bundle is archived separately in the registry step.
          # It is not yet included in the on-chain Merkle hash (Phase 3 milestone).
          # When ready, uncomment the following to include proofs in the hash:
          # if [ -n "$PROOF_BUNDLE_DIR" ] && [ -f "$PROOF_BUNDLE_DIR/proofs.json" ]; then
          #   echo "CERTIFY_PROOFS_SOURCE=\"$PROOF_BUNDLE_DIR/proofs.json\"" >> certify.conf
          # fi
          
          cat certify.conf

      - name: Certify on ${{ inputs.network }}
        id: certify
        working-directory: certify
        env:
          MAINNET_RPC_URL: ${{ secrets.MAINNET_RPC_URL }}
          MAINNET_PRIVATE_KEY: ${{ secrets.MAINNET_PRIVATE_KEY }}
          SEPOLIA_RPC_URL: ${{ secrets.SEPOLIA_RPC_URL }}
          SEPOLIA_PRIVATE_KEY: ${{ secrets.SEPOLIA_PRIVATE_KEY }}
          CERTIFY_ADDRESS: ${{ inputs.network == 'mainnet' && vars.MAINNET_CERTIFIER_ADDRESS || vars.SEPOLIA_CERTIFIER_ADDRESS }}
        run: |
          NETWORK="${{ inputs.network }}"
          
          # Build command
          CMD="uv run python3 -m certify_cli certify --network $NETWORK"
          
          # Add Safe for mainnet
          if [ "$NETWORK" = "mainnet" ]; then
            SAFE_ADDR="${{ vars.MAINNET_SAFE_ADDRESS }}"
            CMD="$CMD --safe \"$SAFE_ADDR\" --execute"
          fi
          
          echo "Running: $CMD"
          
          set +e
          OUTPUT=$($CMD 2>&1)
          EXIT_CODE=$?
          set -e
          
          echo "$OUTPUT"
          
          # Extract outputs
          # Handle both "Tx Hash: 0x..." and "Tx Hash: ..." (without 0x prefix)
          TX_HASH=$(echo "$OUTPUT" | grep -Eo 'Tx Hash:[[:space:]]*(0x)?[a-fA-F0-9]{64}' | head -1 | sed -E 's/.*Tx Hash:[[:space:]]*(0x)?/0x/')
          CONTENT_HASH=$(echo "$OUTPUT" | grep -Eio 'Content Hash:[[:space:]]*0x[0-9a-fA-F]+' | head -1 | sed -E 's/.*(0x[0-9a-fA-F]+)/\1/')
          
          # Extract Merkle sub-hashes (present when specs source is configured)
          RESULTS_HASH=$(echo "$OUTPUT" | grep -Eio 'Results Hash:[[:space:]]*0x[0-9a-fA-F]+' | head -1 | sed -E 's/.*(0x[0-9a-fA-F]+)/\1/')
          SPECS_HASH=$(echo "$OUTPUT" | grep -Eio 'Specs Hash:[[:space:]]*0x[0-9a-fA-F]+' | head -1 | sed -E 's/.*(0x[0-9a-fA-F]+)/\1/')
          
          echo "tx_hash=$TX_HASH" >> $GITHUB_OUTPUT
          echo "content_hash=$CONTENT_HASH" >> $GITHUB_OUTPUT
          echo "results_hash=$RESULTS_HASH" >> $GITHUB_OUTPUT
          echo "specs_hash=$SPECS_HASH" >> $GITHUB_OUTPUT
          
          # Build Etherscan URL
          if [ "$NETWORK" = "mainnet" ]; then
            echo "etherscan_url=https://etherscan.io/tx/$TX_HASH" >> $GITHUB_OUTPUT
          else
            echo "etherscan_url=https://sepolia.etherscan.io/tx/$TX_HASH" >> $GITHUB_OUTPUT
          fi
          
          if [ -z "$TX_HASH" ]; then
            echo "::error::Certification failed - no transaction hash"
            exit 1
          fi

      # ═══════════════════════════════════════════════════════════════
      # STEP 3: Update Certification Registry
      # ═══════════════════════════════════════════════════════════════
      - name: Update certification registry
        working-directory: certify
        run: |
          # Build command with required args
          CMD="uv run python3 -m certify_cli update-registry"
          CMD="$CMD --cert-id \"${{ steps.repo.outputs.cert_id }}\""
          CMD="$CMD --repo \"${{ steps.repo.outputs.repo_path }}\""
          CMD="$CMD --ref \"${{ inputs.ref }}\""
          CMD="$CMD --network \"${{ inputs.network }}\""
          CMD="$CMD --verified \"${{ steps.verify.outputs.verified-count }}\""
          CMD="$CMD --total \"${{ steps.verify.outputs.total-functions }}\""
          CMD="$CMD --tx-hash \"${{ steps.certify.outputs.tx_hash }}\""
          CMD="$CMD --content-hash \"${{ steps.certify.outputs.content_hash }}\""
          CMD="$CMD --commit-sha \"${{ steps.commit.outputs.sha }}\""
          
          # Add optional toolchain info if available
          VERUS_VERSION="${{ steps.verify.outputs.verus-version }}"
          RUST_VERSION="${{ steps.verify.outputs.rust-version }}"
          RESULTS_FILE="${{ steps.verify.outputs.results-file }}"
          
          if [ -n "$VERUS_VERSION" ]; then
            CMD="$CMD --verus-version \"$VERUS_VERSION\""
          fi
          if [ -n "$RUST_VERSION" ]; then
            CMD="$CMD --rust-version \"$RUST_VERSION\""
          fi
          if [ -n "$RESULTS_FILE" ] && [ -f "$RESULTS_FILE" ]; then
            CMD="$CMD --results-file \"$RESULTS_FILE\""
          fi
          
          # Add Merkle sub-hashes and specs file if available
          RESULTS_HASH="${{ steps.certify.outputs.results_hash }}"
          SPECS_HASH="${{ steps.certify.outputs.specs_hash }}"
          SPECS_FILE="${{ steps.specify.outputs.specs_file }}"
          
          if [ -n "$RESULTS_HASH" ]; then
            CMD="$CMD --results-hash \"$RESULTS_HASH\""
          fi
          if [ -n "$SPECS_HASH" ]; then
            CMD="$CMD --specs-hash \"$SPECS_HASH\""
          fi
          if [ -n "$SPECS_FILE" ] && [ -f "$SPECS_FILE" ]; then
            CMD="$CMD --specs-file \"$SPECS_FILE\""
          fi
          
          # Add proof bundle directory if available
          PROOF_BUNDLE_DIR="${{ steps.proofs.outputs.proof_bundle_dir }}"
          if [ -n "$PROOF_BUNDLE_DIR" ] && [ -d "$PROOF_BUNDLE_DIR" ]; then
            CMD="$CMD --proof-bundle-dir \"$PROOF_BUNDLE_DIR\""
          fi
          
          echo "Running: $CMD"
          eval $CMD
          
          echo "=== Certification files created ==="
          ls -la "certifications/${{ steps.repo.outputs.cert_id }}/"
          
          # Show results directory if it exists
          if [ -d "certifications/${{ steps.repo.outputs.cert_id }}/results" ]; then
            echo "=== Results files ==="
            ls -la "certifications/${{ steps.repo.outputs.cert_id }}/results/"
          fi

      - name: Commit certification
        working-directory: certify
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add certifications/
          
          if ! git diff --cached --quiet; then
            git commit -m "cert: ${{ steps.repo.outputs.repo_path }}@${{ inputs.ref }} (${{ steps.verify.outputs.verified-count }}/${{ steps.verify.outputs.total-functions }})"
            git push
            echo "✅ Certification committed"
          else
            echo "No changes to commit"
          fi

      # ═══════════════════════════════════════════════════════════════
      # STEP 4: Summary
      # ═══════════════════════════════════════════════════════════════
      - name: Final summary
        run: |
          CERT_ID="${{ steps.repo.outputs.cert_id }}"
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Certification Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Transaction**: [${{ steps.certify.outputs.tx_hash }}](${{ steps.certify.outputs.etherscan_url }})" >> $GITHUB_STEP_SUMMARY
          TAXONOMY_SUMMARY="${{ steps.specify.outputs.taxonomy_summary }}"
          if [ -n "$TAXONOMY_SUMMARY" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Spec Taxonomy**: $TAXONOMY_SUMMARY" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Badge for ${{ steps.repo.outputs.repo_path }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "![BAIF Certified](https://raw.githubusercontent.com/Beneficial-AI-Foundation/eth_certify/main/certifications/${CERT_ID}/badge.svg)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Add to README (SVG - recommended):" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`markdown" >> $GITHUB_STEP_SUMMARY
          echo "[![BAIF Certified](https://raw.githubusercontent.com/Beneficial-AI-Foundation/eth_certify/main/certifications/${CERT_ID}/badge.svg)](https://github.com/Beneficial-AI-Foundation/eth_certify/blob/main/certifications/${CERT_ID}/history.json)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
