{
  "probe:pmemlog/0.1.0/logimpl_v/bytes_to_header()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 208,
      "lines-end": 225
    },
    "mode": "exec",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            bytes@.len() == header_size",
    "ensures_text": "ensures\n            out == spec_bytes_to_header(bytes@)",
    "ensures-calls": [
      "spec_bytes_to_header"
    ],
    "requires-calls": [
      "len"
    ],
    "ensures-calls-full": [
      "spec_bytes_to_header"
    ],
    "requires-calls-full": [
      "len"
    ],
    "ensures-fn-calls": [
      "spec_bytes_to_header"
    ],
    "requires-method-calls": [
      "len"
    ],
    "spec-labels": [
      "persistence-encoding"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/bytes_to_metadata()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 249,
      "lines-end": 264
    },
    "mode": "exec",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            bytes@.len() == header_size - 8",
    "ensures_text": "ensures\n            out == spec_bytes_to_metadata(bytes@)",
    "ensures-calls": [
      "spec_bytes_to_metadata"
    ],
    "requires-calls": [
      "len"
    ],
    "ensures-calls-full": [
      "spec_bytes_to_metadata"
    ],
    "requires-calls-full": [
      "len"
    ],
    "ensures-fn-calls": [
      "spec_bytes_to_metadata"
    ],
    "requires-method-calls": [
      "len"
    ],
    "spec-labels": [
      "persistence-encoding"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/crc_and_metadata_bytes_to_header()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 295,
      "lines-end": 315
    },
    "mode": "exec",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            crc_bytes@.len() == 8,\n            header_bytes@.len() == header_size - 8",
    "ensures_text": "ensures\n            out.crc == spec_u64_from_le_bytes(crc_bytes@),\n            out.metadata == spec_bytes_to_metadata(header_bytes@)",
    "ensures-calls": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "requires-calls": [
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "requires-calls-full": [
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "requires-method-calls": [
      "len",
      "len"
    ],
    "spec-labels": [
      "persistence-encoding"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/header_to_bytes()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 227,
      "lines-end": 247
    },
    "mode": "exec",
    "context": "standalone",
    "specified": true,
    "has_requires": false,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "ensures_text": "ensures\n            header == spec_bytes_to_header(out@),\n            spec_u64_from_le_bytes(out@.subrange(header_crc_offset as int, header_crc_offset + 8)) == header.crc,\n            spec_bytes_to_metadata(out@.subrange(header_head_offset as int, header_size as int)) == header.metadata,\n            out@.len() == header_size",
    "ensures-calls": [
      "spec_bytes_to_header",
      "spec_u64_from_le_bytes",
      "subrange",
      "spec_bytes_to_metadata",
      "subrange",
      "len"
    ],
    "ensures-calls-full": [
      "spec_bytes_to_header",
      "spec_u64_from_le_bytes",
      "subrange",
      "spec_bytes_to_metadata",
      "subrange",
      "len"
    ],
    "ensures-fn-calls": [
      "spec_bytes_to_header",
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "ensures-method-calls": [
      "subrange",
      "subrange",
      "len"
    ],
    "spec-labels": [
      "persistence-encoding"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_append_data_update_view()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 458,
      "lines-end": 496
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(pm) is Some,\n            pm.len() > contents_offset,\n            contents_offset <= write_addr < pm.len(),\n            ({\n                // write must be a valid write and not overlap the live log\n                let live_header = spec_get_live_header(pm);\n                let physical_head = spec_addr_logical_to_physical(live_header.metadata.head as int, live_header.metadata.log_size as int);\n                let physical_tail = spec_addr_logical_to_physical(live_header.metadata.tail as int, live_header.metadata.log_size as int);\n                &&& physical_head <= physical_tail ==> {\n                        &&& write_addr + new_bytes.len() <= live_header.metadata.log_size + contents_offset\n                        &&& write_addr < physical_head ==> write_addr + new_bytes.len() <= physical_head\n                        &&& (physical_tail <= write_addr || write_addr < physical_head)\n                }\n                &&& physical_tail < physical_head ==> {\n                        &&& physical_tail <= write_addr <= write_addr + new_bytes.len() < physical_head\n                }\n            }),",
    "ensures_text": "ensures\n            UntrustedLogImpl::recover(pm) is Some,\n            update_data_view_postcond(pm, new_bytes, write_addr),",
    "ensures-calls": [
      "recover",
      "update_data_view_postcond"
    ],
    "requires-calls": [
      "recover",
      "len",
      "len",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "UntrustedLogImpl::recover",
      "update_data_view_postcond"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "len",
      "len",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "recover",
      "update_data_view_postcond"
    ],
    "requires-fn-calls": [
      "recover",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len",
      "len",
      "len"
    ],
    "spec-labels": [
      "crash-safety",
      "write-effect",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_append_data_update_view_crash()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 498,
      "lines-end": 535
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(pm) is Some,\n            pm.len() > contents_offset,\n            contents_offset <= write_addr < pm.len(),\n            ({\n                // write must be a valid write and not overlap the live log\n                let live_header = spec_get_live_header(pm);\n                let physical_head = spec_addr_logical_to_physical(live_header.metadata.head as int, live_header.metadata.log_size as int);\n                let physical_tail = spec_addr_logical_to_physical(live_header.metadata.tail as int, live_header.metadata.log_size as int);\n                &&& physical_head <= physical_tail ==> write_addr + new_bytes.len() <= live_header.metadata.log_size + contents_offset\n                &&& physical_tail < physical_head ==> write_addr + new_bytes.len() < physical_head\n            })",
    "ensures_text": "ensures\n            UntrustedLogImpl::recover(pm) is Some,\n            ({\n                let new_pm = update_contents_to_reflect_partially_flushed_write(pm, write_addr, new_bytes, chunks_flushed);\n                let (old_ib, old_headers, old_data) = pm_to_views(pm);\n                let (new_ib, new_headers, new_data) = pm_to_views(new_pm);\n                &&& old_ib == new_ib\n                &&& old_headers == new_headers\n                &&& new_data.len() == old_data.len()\n                &&& new_data.subrange(0, write_addr - contents_offset) =~= old_data.subrange(0, write_addr - contents_offset)\n                &&& new_data.subrange(write_addr - contents_offset + new_bytes.len(), new_data.len() as int) =~=\n                        old_data.subrange(write_addr - contents_offset + new_bytes.len(), old_data.len() as int)\n                &&& UntrustedLogImpl::recover(new_pm) is Some\n            })",
    "ensures-calls": [
      "recover",
      "update_contents_to_reflect_partially_flushed_write",
      "pm_to_views",
      "pm_to_views",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "len",
      "len",
      "subrange",
      "len",
      "len",
      "recover"
    ],
    "requires-calls": [
      "recover",
      "len",
      "len",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "UntrustedLogImpl::recover",
      "update_contents_to_reflect_partially_flushed_write",
      "pm_to_views",
      "pm_to_views",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "len",
      "len",
      "subrange",
      "len",
      "len",
      "UntrustedLogImpl::recover"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "len",
      "len",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "recover",
      "update_contents_to_reflect_partially_flushed_write",
      "pm_to_views",
      "pm_to_views",
      "recover"
    ],
    "ensures-method-calls": [
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "len",
      "len",
      "subrange",
      "len",
      "len"
    ],
    "requires-fn-calls": [
      "recover",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len",
      "len"
    ],
    "spec-labels": [
      "crash-safety",
      "data-invariant",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_append_ib_update()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 781,
      "lines-end": 869
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            pm.len() > contents_offset,\n            UntrustedLogImpl::recover(pm) is Some,\n            new_ib == cdb0_val || new_ib == cdb1_val,\n            new_ib == cdb0_val ==>\n                pm.subrange(header1_pos as int, header1_pos + header_size) == new_header_bytes,\n            new_ib == cdb1_val ==>\n                pm.subrange(header2_pos as int, header2_pos + header_size) == new_header_bytes,\n            new_header_bytes.subrange(header_crc_offset as int, header_crc_offset + 8) ==\n                spec_crc_bytes(new_header_bytes.subrange(header_head_offset as int, header_size as int)),\n            ({\n                let new_header = spec_bytes_to_header(new_header_bytes);\n                let live_header = spec_get_live_header(pm);\n                &&& new_header.metadata.tail == live_header.metadata.tail + bytes_to_append.len()\n                &&& new_header.metadata.head == live_header.metadata.head\n                &&& new_header.metadata.log_size == live_header.metadata.log_size\n                &&& new_header.metadata.tail - new_header.metadata.head < new_header.metadata.log_size\n            }),\n            perm.check_permission(pm),\n            permissions_depend_only_on_recovery_view(perm),\n            ({\n                let live_header = spec_get_live_header(pm);\n                let physical_head = spec_addr_logical_to_physical(live_header.metadata.head as int, live_header.metadata.log_size as int);\n                let physical_tail = spec_addr_logical_to_physical(live_header.metadata.tail as int, live_header.metadata.log_size as int);\n                let contents_end = (live_header.metadata.log_size + contents_offset) as int;\n                let append_size = bytes_to_append.len();\n                let len1 = (contents_end - physical_tail);\n                let len2 = bytes_to_append.len() - len1;\n\n                &&& physical_tail + append_size >= contents_end ==> {\n                    &&& pm.subrange(physical_tail, contents_end) =~= bytes_to_append.subrange(0, len1)\n                    &&& pm.subrange(contents_offset as int, contents_offset + len2) =~= bytes_to_append.subrange(len1 as int, append_size as int)\n                    &&& bytes_to_append =~= pm.subrange(physical_tail, contents_end) + pm.subrange(contents_offset as int, contents_offset + len2)\n                }\n                &&& physical_head <= physical_tail && physical_tail + append_size < contents_end ==> {\n                    pm.subrange(physical_tail, physical_tail + append_size) =~= bytes_to_append\n                }\n                &&& physical_tail < physical_head ==> {\n                    &&& physical_tail + append_size < physical_head\n                    &&& pm.subrange(physical_tail, physical_tail + append_size) =~= bytes_to_append\n                }\n            }),\n            ({\n                let old_log_state = UntrustedLogImpl::recover(pm);\n                forall |pm_state| #[trigger] perm.check_permission(pm_state) <==> {\n                    let log_state = UntrustedLogImpl::recover(pm_state);\n                    log_state == old_log_state || log_state == Some(old_log_state.unwrap().append(bytes_to_append))\n                }\n            }),",
    "ensures_text": "ensures\n            ({\n                let ib_bytes = spec_u64_to_le_bytes(new_ib);\n                let new_pm = update_contents_to_reflect_write(pm, incorruptible_bool_pos as int, ib_bytes);\n                let old_log_state = UntrustedLogImpl::recover(pm);\n                let new_log_state = UntrustedLogImpl::recover(new_pm);\n                let new_live_header = spec_get_live_header(new_pm);\n                let (new_pm_ib, _, _) = pm_to_views(new_pm);\n                &&& match (old_log_state, new_log_state) {\n                        (Some(old_log_state), Some(new_log_state)) => {\n                            &&& new_log_state =~= old_log_state.append(bytes_to_append)\n                            &&& perm.check_permission(new_pm)\n                        }\n                        _ => false,\n                    }\n                &&& new_live_header == spec_bytes_to_header(new_header_bytes)\n                &&& new_ib == new_pm_ib\n            }),\n            forall |chunks_flushed| {\n                let new_pm = #[trigger] update_contents_to_reflect_partially_flushed_write(\n                    pm, incorruptible_bool_pos as int, spec_u64_to_le_bytes(new_ib), chunks_flushed);\n                &&& perm.check_permission(new_pm)\n            },",
    "ensures-calls": [
      "spec_u64_to_le_bytes",
      "update_contents_to_reflect_write",
      "recover",
      "recover",
      "spec_get_live_header",
      "pm_to_views",
      "append",
      "check_permission",
      "spec_bytes_to_header",
      "update_contents_to_reflect_partially_flushed_write",
      "spec_u64_to_le_bytes",
      "check_permission"
    ],
    "requires-calls": [
      "len",
      "recover",
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange",
      "spec_bytes_to_header",
      "spec_get_live_header",
      "len",
      "check_permission",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "recover",
      "check_permission",
      "recover",
      "Some",
      "append",
      "unwrap"
    ],
    "ensures-calls-full": [
      "spec_u64_to_le_bytes",
      "update_contents_to_reflect_write",
      "UntrustedLogImpl::recover",
      "UntrustedLogImpl::recover",
      "spec_get_live_header",
      "pm_to_views",
      "append",
      "check_permission",
      "spec_bytes_to_header",
      "update_contents_to_reflect_partially_flushed_write",
      "spec_u64_to_le_bytes",
      "check_permission"
    ],
    "requires-calls-full": [
      "len",
      "UntrustedLogImpl::recover",
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange",
      "spec_bytes_to_header",
      "spec_get_live_header",
      "len",
      "check_permission",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "UntrustedLogImpl::recover",
      "check_permission",
      "UntrustedLogImpl::recover",
      "Some",
      "append",
      "unwrap"
    ],
    "ensures-fn-calls": [
      "spec_u64_to_le_bytes",
      "update_contents_to_reflect_write",
      "recover",
      "recover",
      "spec_get_live_header",
      "pm_to_views",
      "spec_bytes_to_header",
      "update_contents_to_reflect_partially_flushed_write",
      "spec_u64_to_le_bytes"
    ],
    "ensures-method-calls": [
      "append",
      "check_permission",
      "check_permission"
    ],
    "requires-fn-calls": [
      "recover",
      "spec_crc_bytes",
      "spec_bytes_to_header",
      "spec_get_live_header",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "recover",
      "recover",
      "Some"
    ],
    "requires-method-calls": [
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "len",
      "check_permission",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "check_permission",
      "append",
      "unwrap"
    ],
    "spec-labels": [
      "crash-safety",
      "data-invariant",
      "persistence-encoding",
      "write-effect",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_append_ib_update_effect_on_committed()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 632,
      "lines-end": 779
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            pm.len() > contents_offset,\n            UntrustedLogImpl::recover(pm) is Some,\n            new_ib == cdb0_val || new_ib == cdb1_val,\n            new_ib == cdb0_val ==>\n                pm.subrange(header1_pos as int, header1_pos + header_size) == new_header_bytes,\n            new_ib == cdb1_val ==>\n                pm.subrange(header2_pos as int, header2_pos + header_size) == new_header_bytes,\n            new_header_bytes.subrange(header_crc_offset as int, header_crc_offset + 8) ==\n                spec_crc_bytes(new_header_bytes.subrange(header_head_offset as int, header_size as int)),\n            ({\n                let new_header = spec_bytes_to_header(new_header_bytes);\n                let live_header = spec_get_live_header(pm);\n                &&& new_header.metadata.tail == live_header.metadata.tail + bytes_to_append.len()\n                &&& new_header.metadata.head == live_header.metadata.head\n                &&& new_header.metadata.log_size == live_header.metadata.log_size\n                &&& new_header.metadata.tail - new_header.metadata.head < new_header.metadata.log_size\n            }),\n            perm.check_permission(pm),\n            permissions_depend_only_on_recovery_view(perm),\n            ({\n                let live_header = spec_get_live_header(pm);\n                let physical_head = spec_addr_logical_to_physical(live_header.metadata.head as int, live_header.metadata.log_size as int);\n                let physical_tail = spec_addr_logical_to_physical(live_header.metadata.tail as int, live_header.metadata.log_size as int);\n                let contents_end = (live_header.metadata.log_size + contents_offset) as int;\n                let append_size = bytes_to_append.len();\n                let len1 = (contents_end - physical_tail);\n                let len2 = bytes_to_append.len() - len1;\n\n                &&& physical_tail + append_size >= contents_end ==> {\n                    &&& pm.subrange(physical_tail, contents_end) =~= bytes_to_append.subrange(0, len1)\n                    &&& pm.subrange(contents_offset as int, contents_offset + len2) =~= bytes_to_append.subrange(len1 as int, append_size as int)\n                    &&& bytes_to_append =~= pm.subrange(physical_tail, contents_end) + pm.subrange(contents_offset as int, contents_offset + len2)\n                }\n                &&& physical_head <= physical_tail && physical_tail + append_size < contents_end ==> {\n                    pm.subrange(physical_tail, physical_tail + append_size) =~= bytes_to_append\n                }\n                &&& physical_tail < physical_head ==> {\n                    &&& physical_tail + append_size < physical_head\n                    &&& pm.subrange(physical_tail, physical_tail + append_size) =~= bytes_to_append\n                }\n            }),\n            ({\n                let old_log_state = UntrustedLogImpl::recover(pm);\n                forall |pm_state| #[trigger] perm.check_permission(pm_state) <==> {\n                    let log_state = UntrustedLogImpl::recover(pm_state);\n                    log_state == old_log_state || log_state == Some(old_log_state.unwrap().append(bytes_to_append))\n                }\n            }),",
    "ensures_text": "ensures\n            ({\n                let ib_bytes = spec_u64_to_le_bytes(new_ib);\n                let new_pm = update_contents_to_reflect_write(pm, incorruptible_bool_pos as int, ib_bytes);\n                let old_log_state = UntrustedLogImpl::recover(pm);\n                let new_log_state = UntrustedLogImpl::recover(new_pm);\n                let new_live_header = spec_get_live_header(new_pm);\n                let (new_pm_ib, _, _) = pm_to_views(new_pm);\n                &&& match (old_log_state, new_log_state) {\n                        (Some(old_log_state), Some(new_log_state)) => {\n                            &&& new_log_state =~= old_log_state.append(bytes_to_append)\n                            &&& perm.check_permission(new_pm)\n                        }\n                        _ => false,\n                    }\n                &&& new_live_header == spec_bytes_to_header(new_header_bytes)\n                &&& new_ib == new_pm_ib\n            }),",
    "ensures-calls": [
      "spec_u64_to_le_bytes",
      "update_contents_to_reflect_write",
      "recover",
      "recover",
      "spec_get_live_header",
      "pm_to_views",
      "append",
      "check_permission",
      "spec_bytes_to_header"
    ],
    "requires-calls": [
      "len",
      "recover",
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange",
      "spec_bytes_to_header",
      "spec_get_live_header",
      "len",
      "check_permission",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "recover",
      "check_permission",
      "recover",
      "Some",
      "append",
      "unwrap"
    ],
    "ensures-calls-full": [
      "spec_u64_to_le_bytes",
      "update_contents_to_reflect_write",
      "UntrustedLogImpl::recover",
      "UntrustedLogImpl::recover",
      "spec_get_live_header",
      "pm_to_views",
      "append",
      "check_permission",
      "spec_bytes_to_header"
    ],
    "requires-calls-full": [
      "len",
      "UntrustedLogImpl::recover",
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange",
      "spec_bytes_to_header",
      "spec_get_live_header",
      "len",
      "check_permission",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "UntrustedLogImpl::recover",
      "check_permission",
      "UntrustedLogImpl::recover",
      "Some",
      "append",
      "unwrap"
    ],
    "ensures-fn-calls": [
      "spec_u64_to_le_bytes",
      "update_contents_to_reflect_write",
      "recover",
      "recover",
      "spec_get_live_header",
      "pm_to_views",
      "spec_bytes_to_header"
    ],
    "ensures-method-calls": [
      "append",
      "check_permission"
    ],
    "requires-fn-calls": [
      "recover",
      "spec_crc_bytes",
      "spec_bytes_to_header",
      "spec_get_live_header",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "recover",
      "recover",
      "Some"
    ],
    "requires-method-calls": [
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "len",
      "check_permission",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "check_permission",
      "append",
      "unwrap"
    ],
    "spec-labels": [
      "crash-safety",
      "data-invariant",
      "persistence-encoding",
      "write-effect",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_bytes_combine_into_header()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 126,
      "lines-end": 147
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            crc_bytes.len() == 8,\n            metadata_bytes.len() == header_size - 8,\n            spec_bytes_to_header((crc_bytes + metadata_bytes)) == header,",
    "ensures_text": "ensures\n            ({\n                let combined_header = PersistentHeader { crc: spec_u64_from_le_bytes(crc_bytes), metadata: spec_bytes_to_metadata(metadata_bytes) };\n                header == combined_header\n            })",
    "ensures-calls": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "requires-calls": [
      "len",
      "len",
      "spec_bytes_to_header"
    ],
    "ensures-calls-full": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "spec_bytes_to_header"
    ],
    "ensures-fn-calls": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata"
    ],
    "requires-fn-calls": [
      "spec_bytes_to_header"
    ],
    "requires-method-calls": [
      "len",
      "len"
    ],
    "spec-labels": [
      "persistence-encoding",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_data_write_is_safe()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 379,
      "lines-end": 431
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(pm) is Some,\n            pm.len() > contents_offset,\n            contents_offset <= write_addr < pm.len(),\n            perm.check_permission(pm),\n            permissions_depend_only_on_recovery_view(perm),\n            ({\n                // write must be a valid write and not overlap the live log\n                let live_header = spec_get_live_header(pm);\n                let physical_head = spec_addr_logical_to_physical(live_header.metadata.head as int, live_header.metadata.log_size as int);\n                let physical_tail = spec_addr_logical_to_physical(live_header.metadata.tail as int, live_header.metadata.log_size as int);\n                &&& physical_head <= physical_tail ==> {\n                    &&& write_addr + bytes.len() <= live_header.metadata.log_size + contents_offset\n                    &&& write_addr < physical_head ==> write_addr + bytes.len() <= physical_head\n                    &&& (physical_tail <= write_addr || write_addr < physical_head)\n                }\n                &&& physical_tail < physical_head ==> {\n                    &&& physical_tail <= write_addr <= write_addr + bytes.len() < physical_head\n                }\n            }),",
    "ensures_text": "ensures\n            UntrustedLogImpl::recover(pm) is Some,\n            forall |chunks_flushed| {\n                let new_pm = #[trigger] update_contents_to_reflect_partially_flushed_write(\n                    pm, write_addr, bytes, chunks_flushed);\n                perm.check_permission(new_pm)\n            },\n            ({\n                let new_pm = update_contents_to_reflect_write(pm, write_addr, bytes);\n                perm.check_permission(new_pm)\n            }),\n            update_data_view_postcond(pm, bytes, write_addr),",
    "ensures-calls": [
      "recover",
      "update_contents_to_reflect_partially_flushed_write",
      "check_permission",
      "update_contents_to_reflect_write",
      "check_permission",
      "update_data_view_postcond"
    ],
    "requires-calls": [
      "recover",
      "len",
      "len",
      "check_permission",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "UntrustedLogImpl::recover",
      "update_contents_to_reflect_partially_flushed_write",
      "check_permission",
      "update_contents_to_reflect_write",
      "check_permission",
      "update_data_view_postcond"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "len",
      "len",
      "check_permission",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical",
      "len",
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "recover",
      "update_contents_to_reflect_partially_flushed_write",
      "update_contents_to_reflect_write",
      "update_data_view_postcond"
    ],
    "ensures-method-calls": [
      "check_permission",
      "check_permission"
    ],
    "requires-fn-calls": [
      "recover",
      "permissions_depend_only_on_recovery_view",
      "spec_get_live_header",
      "spec_addr_logical_to_physical",
      "spec_addr_logical_to_physical"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "check_permission",
      "len",
      "len",
      "len"
    ],
    "spec-labels": [
      "crash-safety",
      "write-effect",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_header_correct()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1053,
      "lines-end": 1073
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            pm.len() > contents_offset,\n            header_bytes.len() == header_size,\n            header_pos == header1_pos || header_pos == header2_pos,\n            header_bytes.subrange(header_crc_offset as int, header_crc_offset + 8) =~=\n                spec_crc_bytes(header_bytes.subrange(header_head_offset as int, header_size as int)),\n            pm.subrange(header_pos, header_pos + header_size) =~= header_bytes",
    "ensures_text": "ensures\n            pm.subrange(header_pos + header_crc_offset, header_pos + header_crc_offset + 8) =~=\n                header_bytes.subrange(header_crc_offset as int, header_crc_offset + 8),\n            pm.subrange(header_pos + header_head_offset, header_pos + header_size) =~=\n                header_bytes.subrange(header_head_offset as int, header_size as int),\n            pm.subrange(header_pos + header_crc_offset, header_pos + header_crc_offset + 8) =~=\n                spec_crc_bytes(pm.subrange(header_pos + header_head_offset, header_pos + header_size))",
    "ensures-calls": [
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange"
    ],
    "requires-calls": [
      "len",
      "len",
      "subrange",
      "spec_crc_bytes",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "subrange",
      "spec_crc_bytes",
      "subrange",
      "subrange"
    ],
    "ensures-fn-calls": [
      "spec_crc_bytes"
    ],
    "ensures-method-calls": [
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "requires-fn-calls": [
      "spec_crc_bytes"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "corruption-detection",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_header_crc_correct()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1036,
      "lines-end": 1051
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            header_bytes.len() == header_size,\n            crc_bytes.len() == 8,\n            metadata_bytes.len() == header_size - 8,\n            crc_bytes =~= spec_crc_bytes(metadata_bytes),\n            header_bytes =~= crc_bytes + metadata_bytes",
    "ensures_text": "ensures\n            header_bytes.subrange(header_crc_offset as int, header_crc_offset + 8) =~= crc_bytes,\n            header_bytes.subrange(header_head_offset as int, header_size as int) =~= metadata_bytes,\n            header_bytes.subrange(header_crc_offset as int, header_crc_offset + 8) =~=\n                spec_crc_bytes(header_bytes.subrange(header_head_offset as int, header_size as int))",
    "ensures-calls": [
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange"
    ],
    "requires-calls": [
      "len",
      "len",
      "len",
      "spec_crc_bytes"
    ],
    "ensures-calls-full": [
      "subrange",
      "subrange",
      "subrange",
      "spec_crc_bytes",
      "subrange"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "len",
      "spec_crc_bytes"
    ],
    "ensures-fn-calls": [
      "spec_crc_bytes"
    ],
    "ensures-method-calls": [
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "requires-fn-calls": [
      "spec_crc_bytes"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len"
    ],
    "spec-labels": [
      "corruption-detection",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_header_match()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 98,
      "lines-end": 124
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            pm.len() > contents_offset,\n            header_pos == header1_pos || header_pos == header2_pos,\n            spec_bytes_to_header(pm.subrange(header_pos as int, header_pos + header_size)) == header,",
    "ensures_text": "ensures\n            ({\n                let (_, headers, _) = pm_to_views(pm);\n                &&& header_pos == header1_pos ==>\n                        headers.header1 == header\n                &&& header_pos == header2_pos ==>\n                        headers.header2 == header\n            })",
    "ensures-calls": [
      "pm_to_views"
    ],
    "requires-calls": [
      "len",
      "spec_bytes_to_header",
      "subrange"
    ],
    "ensures-calls-full": [
      "pm_to_views"
    ],
    "requires-calls-full": [
      "len",
      "spec_bytes_to_header",
      "subrange"
    ],
    "ensures-fn-calls": [
      "pm_to_views"
    ],
    "requires-fn-calls": [
      "spec_bytes_to_header"
    ],
    "requires-method-calls": [
      "len",
      "subrange"
    ],
    "spec-labels": [
      "data-invariant",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_header_split_into_bytes()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 149,
      "lines-end": 174
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            crc_bytes.len() == 8,\n            metadata_bytes.len() == header_size - 8,\n            header_bytes.len() == header_size,\n            ({\n                let header = PersistentHeader { crc: spec_u64_from_le_bytes(crc_bytes), metadata: spec_bytes_to_metadata(metadata_bytes) };\n                spec_bytes_to_header(header_bytes) == header\n            }),",
    "ensures_text": "ensures\n            crc_bytes + metadata_bytes =~= header_bytes",
    "requires-calls": [
      "len",
      "len",
      "len",
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata",
      "spec_bytes_to_header"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "len",
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata",
      "spec_bytes_to_header"
    ],
    "requires-fn-calls": [
      "spec_u64_from_le_bytes",
      "spec_bytes_to_metadata",
      "spec_bytes_to_header"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len"
    ],
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_headers_unchanged()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1007,
      "lines-end": 1021
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            old_pm.len() == new_pm.len(),\n            old_pm.len() >= contents_offset,\n            old_pm.subrange(header1_pos as int, header1_pos + header_size) =~= new_pm.subrange(header1_pos as int, header1_pos + header_size),\n            old_pm.subrange(header2_pos as int, header2_pos + header_size) =~= new_pm.subrange(header2_pos as int, header2_pos + header_size),",
    "ensures_text": "ensures\n            ({\n                let (_, old_headers, _) = pm_to_views(old_pm);\n                let (_, new_headers, _) = pm_to_views(new_pm);\n                old_headers == new_headers\n            })",
    "ensures-calls": [
      "pm_to_views",
      "pm_to_views"
    ],
    "requires-calls": [
      "len",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "pm_to_views",
      "pm_to_views"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "ensures-fn-calls": [
      "pm_to_views",
      "pm_to_views"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "data-invariant",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_inactive_header_update_view()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 537,
      "lines-end": 582
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(pm) is Some,\n            header_pos == header1_pos || header_pos == header2_pos,\n            ({\n                // the new bytes must be written to the inactive header\n                let (old_ib, old_headers, old_data) = pm_to_views(pm);\n                &&& old_ib == cdb0_val ==> header_pos == header2_pos\n                &&& old_ib == cdb1_val ==> header_pos == header1_pos\n            }),\n            new_header_bytes.len() == header_size,\n            pm.len() > contents_offset,",
    "ensures_text": "ensures\n            ({\n                let new_pm = update_contents_to_reflect_write(pm, header_pos, new_header_bytes);\n                let (old_ib, old_headers, old_data) = pm_to_views(pm);\n                let (new_ib, new_headers, new_data) = pm_to_views(new_pm);\n                &&& old_ib == new_ib\n                &&& old_data =~= old_data\n                &&& header_pos == header1_pos ==>\n                    old_headers.header2 == new_headers.header2\n                &&& header_pos == header2_pos ==>\n                    old_headers.header1 == new_headers.header1\n                &&& UntrustedLogImpl::recover(new_pm) is Some\n            })",
    "ensures-calls": [
      "update_contents_to_reflect_write",
      "pm_to_views",
      "pm_to_views",
      "recover"
    ],
    "requires-calls": [
      "recover",
      "pm_to_views",
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "update_contents_to_reflect_write",
      "pm_to_views",
      "pm_to_views",
      "UntrustedLogImpl::recover"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "pm_to_views",
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "update_contents_to_reflect_write",
      "pm_to_views",
      "pm_to_views",
      "recover"
    ],
    "requires-fn-calls": [
      "recover",
      "pm_to_views"
    ],
    "requires-method-calls": [
      "len",
      "len"
    ],
    "spec-labels": [
      "crash-safety",
      "data-invariant",
      "write-effect",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_inactive_header_update_view_crash()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 584,
      "lines-end": 630
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(pm) is Some,\n            header_pos == header1_pos || header_pos == header2_pos,\n            ({\n                // the new bytes must be written to the inactive header\n                let (old_ib, old_headers, old_data) = pm_to_views(pm);\n                &&& old_ib == cdb0_val ==> header_pos == header2_pos\n                &&& old_ib == cdb1_val ==> header_pos == header1_pos\n            }),\n            new_header_bytes.len() == header_size,\n            pm.len() > contents_offset,",
    "ensures_text": "ensures\n            ({\n                let new_pm = update_contents_to_reflect_partially_flushed_write(\n                    pm, header_pos, new_header_bytes, chunks_flushed);\n                let (old_ib, old_headers, old_data) = pm_to_views(pm);\n                let (new_ib, new_headers, new_data) = pm_to_views(new_pm);\n                &&& old_ib == new_ib\n                &&& old_data =~= old_data\n                &&& header_pos == header1_pos ==>\n                    old_headers.header2 == new_headers.header2\n                &&& header_pos == header2_pos ==>\n                    old_headers.header1 == new_headers.header1\n                &&& UntrustedLogImpl::recover(new_pm) is Some\n            })",
    "ensures-calls": [
      "update_contents_to_reflect_partially_flushed_write",
      "pm_to_views",
      "pm_to_views",
      "recover"
    ],
    "requires-calls": [
      "recover",
      "pm_to_views",
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "update_contents_to_reflect_partially_flushed_write",
      "pm_to_views",
      "pm_to_views",
      "UntrustedLogImpl::recover"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "pm_to_views",
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "update_contents_to_reflect_partially_flushed_write",
      "pm_to_views",
      "pm_to_views",
      "recover"
    ],
    "requires-fn-calls": [
      "recover",
      "pm_to_views"
    ],
    "requires-method-calls": [
      "len",
      "len"
    ],
    "spec-labels": [
      "crash-safety",
      "data-invariant",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_incorruptible_bool_unchanged()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1023,
      "lines-end": 1034
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            old_pm.len() == new_pm.len(),\n            old_pm.len() >= contents_offset,\n            old_pm.subrange(incorruptible_bool_pos as int, incorruptible_bool_pos + 8) =~= new_pm.subrange(incorruptible_bool_pos as int, incorruptible_bool_pos + 8)",
    "ensures_text": "ensures\n            ({\n                let (old_ib, _, _) = pm_to_views(old_pm);\n                let (new_ib, _, _) = pm_to_views(new_pm);\n                old_ib == new_ib\n            })",
    "ensures-calls": [
      "pm_to_views",
      "pm_to_views"
    ],
    "requires-calls": [
      "len",
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "pm_to_views",
      "pm_to_views"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-fn-calls": [
      "pm_to_views",
      "pm_to_views"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "data-invariant",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_metadata_bytes_eq()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 331,
      "lines-end": 365
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            bytes1.len() == header_size - 8,\n            bytes2.len() == header_size - 8,\n            metadata == spec_bytes_to_metadata(bytes1),\n            metadata == spec_bytes_to_metadata(bytes2),",
    "ensures_text": "ensures\n            bytes1 =~= bytes2",
    "requires-calls": [
      "len",
      "len",
      "spec_bytes_to_metadata",
      "spec_bytes_to_metadata"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "spec_bytes_to_metadata",
      "spec_bytes_to_metadata"
    ],
    "requires-fn-calls": [
      "spec_bytes_to_metadata",
      "spec_bytes_to_metadata"
    ],
    "requires-method-calls": [
      "len",
      "len"
    ],
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_pm_state_header()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1108,
      "lines-end": 1152
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(pm) is Some,\n            ({\n                let header = spec_get_live_header(pm);\n                header.metadata.tail - header.metadata.head < header.metadata.log_size\n            })",
    "ensures_text": "ensures\n            ({\n                let pm_state = UntrustedLogImpl::recover(pm);\n                let header = spec_get_live_header(pm);\n                match pm_state {\n                    Some(pm_state) => {\n                        &&& header.metadata.head == pm_state.head\n                        &&& pm_state.log.len() == header.metadata.tail - header.metadata.head\n                    }\n                    None => false\n                }\n            })",
    "ensures-calls": [
      "recover",
      "spec_get_live_header",
      "len"
    ],
    "requires-calls": [
      "recover",
      "spec_get_live_header"
    ],
    "ensures-calls-full": [
      "UntrustedLogImpl::recover",
      "spec_get_live_header",
      "len"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "spec_get_live_header"
    ],
    "ensures-fn-calls": [
      "recover",
      "spec_get_live_header"
    ],
    "ensures-method-calls": [
      "len"
    ],
    "requires-fn-calls": [
      "recover",
      "spec_get_live_header"
    ],
    "spec-labels": [
      "crash-safety",
      "persistence-encoding",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_same_log_state()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 894,
      "lines-end": 953
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            UntrustedLogImpl::recover(old_pm) is Some,\n            UntrustedLogImpl::recover(new_pm) is Some,\n            live_data_view_eq(old_pm, new_pm),\n            ({\n                let (old_ib, old_headers, old_data) = pm_to_views(old_pm);\n                let (new_ib, new_headers, new_data) = pm_to_views(new_pm);\n                &&& old_ib == cdb0_val || old_ib == cdb1_val\n                &&& old_ib == new_ib\n                &&& old_ib == cdb0_val ==> {\n                    &&& old_headers.header1 == new_headers.header1\n                }\n                &&& old_ib == cdb1_val ==> {\n                    &&& old_headers.header2 == new_headers.header2\n                }\n            })",
    "ensures_text": "ensures\n            UntrustedLogImpl::recover(old_pm) =~=\n                UntrustedLogImpl::recover(new_pm)",
    "ensures-calls": [
      "recover",
      "recover"
    ],
    "requires-calls": [
      "recover",
      "recover",
      "live_data_view_eq",
      "pm_to_views",
      "pm_to_views"
    ],
    "ensures-calls-full": [
      "UntrustedLogImpl::recover",
      "UntrustedLogImpl::recover"
    ],
    "requires-calls-full": [
      "UntrustedLogImpl::recover",
      "UntrustedLogImpl::recover",
      "live_data_view_eq",
      "pm_to_views",
      "pm_to_views"
    ],
    "ensures-fn-calls": [
      "recover",
      "recover"
    ],
    "requires-fn-calls": [
      "recover",
      "recover",
      "live_data_view_eq",
      "pm_to_views",
      "pm_to_views"
    ],
    "spec-labels": [
      "crash-safety",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_same_permissions()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 89,
      "lines-end": 96
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            recovery_view()(pm1) =~= recovery_view()(pm2),\n            perm.check_permission(pm1),\n            permissions_depend_only_on_recovery_view(perm)",
    "ensures_text": "ensures\n            perm.check_permission(pm2)",
    "ensures-calls": [
      "check_permission"
    ],
    "requires-calls": [
      "recovery_view",
      "recovery_view",
      "check_permission",
      "permissions_depend_only_on_recovery_view"
    ],
    "ensures-calls-full": [
      "check_permission"
    ],
    "requires-calls-full": [
      "recovery_view",
      "recovery_view",
      "check_permission",
      "permissions_depend_only_on_recovery_view"
    ],
    "ensures-method-calls": [
      "check_permission"
    ],
    "requires-fn-calls": [
      "recovery_view",
      "recovery_view",
      "permissions_depend_only_on_recovery_view"
    ],
    "requires-method-calls": [
      "check_permission"
    ],
    "spec-labels": [
      "crash-safety",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_seq_addition()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 176,
      "lines-end": 187
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": false,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "ensures_text": "ensures\n            ({\n                let i = bytes1.len() as int;\n                let j = bytes2.len() as int;\n                &&& (bytes1 + bytes2).subrange(0, i) =~= bytes1\n                &&& (bytes1 + bytes2).subrange(i, i + j) =~= bytes2\n            })",
    "ensures-calls": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-method-calls": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_single_write_crash()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1089,
      "lines-end": 1106
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            bytes_to_write.len() == persistence_chunk_size,\n            write_addr % persistence_chunk_size == 0, // currently seems to succeed without nonlinear arith\n            0 <= write_addr < pm.len(),\n            write_addr + bytes_to_write.len() <= pm.len()",
    "ensures_text": "ensures\n            ({\n                forall |chunks_flushed: Set<int>| {\n                    let new_crash_contents = #[trigger] update_contents_to_reflect_partially_flushed_write(\n                        pm, write_addr, bytes_to_write, chunks_flushed);\n                    let new_contents = update_contents_to_reflect_write(pm, write_addr, bytes_to_write);\n                    new_crash_contents =~= pm || new_crash_contents =~= new_contents\n                }\n            })",
    "ensures-calls": [
      "update_contents_to_reflect_partially_flushed_write",
      "update_contents_to_reflect_write"
    ],
    "requires-calls": [
      "len",
      "len",
      "len",
      "len"
    ],
    "ensures-calls-full": [
      "update_contents_to_reflect_partially_flushed_write",
      "update_contents_to_reflect_write"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "len",
      "len"
    ],
    "ensures-fn-calls": [
      "update_contents_to_reflect_partially_flushed_write",
      "update_contents_to_reflect_write"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "len",
      "len"
    ],
    "spec-labels": [
      "crash-safety",
      "write-effect",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_subrange_eq()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1082,
      "lines-end": 1087
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            bytes1 =~= bytes2",
    "ensures_text": "ensures\n            forall |i: int, j: int| 0 <= i < j < bytes1.len() ==> bytes1.subrange(i, j) =~= bytes2.subrange(i, j)",
    "ensures-calls": [
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-method-calls": [
      "len",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_subrange_equality_implies_index_equality()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 955,
      "lines-end": 968
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            0 <= i <= j <= s1.len(),\n            j <= s2.len(),\n            s1.subrange(i, j) == s2.subrange(i, j)",
    "ensures_text": "ensures\n            forall |k| i <= k < j ==> s1[k] == s2[k]",
    "requires-calls": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_subrange_equality_implies_subsubrange_equality()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 970,
      "lines-end": 982
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            0 <= i <= j <= s1.len(),\n            j <= s2.len(),\n            s1.subrange(i, j) == s2.subrange(i, j)",
    "ensures_text": "ensures\n            forall |k, m| i <= k <= m <= j ==> s1.subrange(k, m) == s2.subrange(k, m)",
    "ensures-calls": [
      "subrange",
      "subrange"
    ],
    "requires-calls": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "subrange",
      "subrange"
    ],
    "requires-calls-full": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "ensures-method-calls": [
      "subrange",
      "subrange"
    ],
    "requires-method-calls": [
      "len",
      "len",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_subrange_equality_implies_subsubrange_equality_forall()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 984,
      "lines-end": 1005
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": false,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "ensures_text": "ensures\n            forall |s1: Seq<T>, s2: Seq<T>, i: int, j: int, k: int, m: int|\n                {\n                    &&& 0 <= i <= j <= s1.len()\n                    &&& j <= s2.len()\n                    &&& s1.subrange(i, j) == s2.subrange(i, j)\n                    &&& i <= k <= m <= j\n                }\n                ==> s1.subrange(k, m) == s2.subrange(k, m)",
    "ensures-calls": [
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "ensures-calls-full": [
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "ensures-method-calls": [
      "len",
      "len",
      "subrange",
      "subrange",
      "subrange",
      "subrange"
    ],
    "spec-labels": [
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/lemma_u64_bytes_eq()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1075,
      "lines-end": 1080
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            val1 == val2",
    "ensures_text": "ensures\n            spec_u64_to_le_bytes(val1) =~= spec_u64_to_le_bytes(val2)",
    "ensures-calls": [
      "spec_u64_to_le_bytes",
      "spec_u64_to_le_bytes"
    ],
    "ensures-calls-full": [
      "spec_u64_to_le_bytes",
      "spec_u64_to_le_bytes"
    ],
    "ensures-fn-calls": [
      "spec_u64_to_le_bytes",
      "spec_u64_to_le_bytes"
    ],
    "spec-labels": [
      "persistence-encoding",
      "algebraic-property"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/live_data_view_eq()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 871,
      "lines-end": 892
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/metadata_to_bytes()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 266,
      "lines-end": 293
    },
    "mode": "exec",
    "context": "standalone",
    "specified": true,
    "has_requires": false,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "ensures_text": "ensures\n            metadata == spec_bytes_to_metadata(out@),\n            out@.len() == header_size - 8,",
    "ensures-calls": [
      "spec_bytes_to_metadata",
      "len"
    ],
    "ensures-calls-full": [
      "spec_bytes_to_metadata",
      "len"
    ],
    "ensures-fn-calls": [
      "spec_bytes_to_metadata"
    ],
    "ensures-method-calls": [
      "len"
    ],
    "spec-labels": [
      "persistence-encoding"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/permissions_depend_only_on_recovery_view()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 84,
      "lines-end": 87
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/pm_to_views()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 45,
      "lines-end": 72
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/spec_addr_logical_to_physical()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 1154,
      "lines-end": 1156
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/spec_bytes_to_header()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 367,
      "lines-end": 377
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/spec_bytes_to_metadata()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 317,
      "lines-end": 329
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/spec_get_live_header()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 74,
      "lines-end": 82
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/logimpl_v/update_data_view_postcond()": {
    "code-path": "src/logimpl_v.rs",
    "spec-text": {
      "lines-start": 433,
      "lines-end": 456
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/main()": {
    "code-path": "src/main.rs",
    "spec-text": {
      "lines-start": 20,
      "lines-end": 40
    },
    "mode": "exec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false
  },
  "probe:pmemlog/0.1.0/main_t/read_correct_modulo_corruption()": {
    "code-path": "src/main_t.rs",
    "spec-text": {
      "lines-start": 20,
      "lines-end": 32
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/main_t/recovery_view()": {
    "code-path": "src/main_t.rs",
    "spec-text": {
      "lines-start": 15,
      "lines-end": 18
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_div_relation_when_mods_have_different_order()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 99,
      "lines-end": 129
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x < y,\n            y - x <= d,\n            y % d <= x % d",
    "ensures_text": "ensures\n            y / d == x / d + 1",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_div_relation_when_mods_have_different_order_alt()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 131,
      "lines-end": 161
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x <= y,\n            y - x < d,\n            y % d < x % d",
    "ensures_text": "ensures\n            y / d == x / d + 1",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_div_relation_when_mods_have_same_order()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 41,
      "lines-end": 69
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x < y,\n            y - x <= d,\n            x % d < y % d",
    "ensures_text": "ensures\n            y / d == x / d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_div_relation_when_mods_have_same_order_alt()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 71,
      "lines-end": 97
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x <= y,\n            y - x < d,\n            x % d <= y % d",
    "ensures_text": "ensures\n            y / d == x / d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_addition_when_bounded()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 230,
      "lines-end": 241
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            y >= 0,\n            (x % d) + y < d,",
    "ensures_text": "ensures\n            (x + y) % d == (x % d) + y",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_auto_basics()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 8,
      "lines-end": 39
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            n > 0",
    "ensures_text": "ensures\n            (x + n) % n == x % n,\n            (x - n) % n == x % n,\n            (x + n) / n == x / n + 1,\n            (x - n) / n == x / n - 1,\n            0 <= x < n <==> x % n == x,",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_between()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 163,
      "lines-end": 195
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x % d < y % d,\n            y - x <= d,\n            x <= z <= y",
    "ensures_text": "ensures\n            x % d <= z % d <= y % d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_difference_equal()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 243,
      "lines-end": 261
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x <= y,\n            x % d <= y % d,\n            y - x < d",
    "ensures_text": "ensures\n            y % d - x % d == y - x",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_equal()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 283,
      "lines-end": 293
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x <= y,\n            x % d == y % d,\n            y - x < d",
    "ensures_text": "ensures\n            x == y",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_equal_converse()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 295,
      "lines-end": 301
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires \n            d > 0,\n            x == y,",
    "ensures_text": "ensures \n            x % d == y % d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_not_between()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 197,
      "lines-end": 228
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            y % d < x % d,\n            y - x <= d,\n            x <= z <= y",
    "ensures_text": "ensures\n            z % d <= y % d || z % d >= x % d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_not_equal()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 303,
      "lines-end": 322
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires \n            d > 0,\n            y - x < d,\n            y - x >= 0,\n            x != y,",
    "ensures_text": "ensures \n            x % d != y % d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_subtract()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 332,
      "lines-end": 351
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            (x % d) + y >= d,\n            0 <= y < d",
    "ensures_text": "ensures\n            (x % d) + y - d == (x + y) % d",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mod_wrapped_len()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 263,
      "lines-end": 281
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            d > 0,\n            x <= y,\n            x % d > y % d,\n            y - x < d",
    "ensures_text": "ensures\n            d - (x % d) + (y % d) == y - x",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/math_v/lemma_mul_div_equal()": {
    "code-path": "src/math_v.rs",
    "spec-text": {
      "lines-start": 324,
      "lines-end": 330
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            q * d <= x < (q + 1) * d",
    "ensures_text": "ensures\n            (x / d) == q",
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/all_elements_unique()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 25,
      "lines-end": 27
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/axiom_bytes_uncorrupted()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 68,
      "lines-end": 80
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            maybe_corrupted(x_c, x, x_addrs),\n            maybe_corrupted(y_c, y, y_addrs),\n            y == spec_crc_bytes(x),\n            y_c == spec_crc_bytes(x_c),\n            all_elements_unique(x_addrs),\n            all_elements_unique(y_addrs)",
    "ensures_text": "ensures\n            x == x_c",
    "requires-calls": [
      "maybe_corrupted",
      "maybe_corrupted",
      "spec_crc_bytes",
      "spec_crc_bytes",
      "all_elements_unique",
      "all_elements_unique"
    ],
    "requires-calls-full": [
      "maybe_corrupted",
      "maybe_corrupted",
      "spec_crc_bytes",
      "spec_crc_bytes",
      "all_elements_unique",
      "all_elements_unique"
    ],
    "requires-fn-calls": [
      "maybe_corrupted",
      "maybe_corrupted",
      "spec_crc_bytes",
      "spec_crc_bytes",
      "all_elements_unique",
      "all_elements_unique"
    ],
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/axiom_corruption_detecting_boolean()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 96,
      "lines-end": 105
    },
    "mode": "proof",
    "context": "standalone",
    "specified": true,
    "has_requires": true,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "requires_text": "requires\n            maybe_corrupted(spec_u64_to_le_bytes(cdb_c), spec_u64_to_le_bytes(cdb), addrs),\n            all_elements_unique(addrs),\n            cdb == cdb0_val || cdb == cdb1_val,\n            cdb_c == cdb0_val || cdb_c == cdb1_val,",
    "ensures_text": "ensures\n            cdb_c == cdb",
    "requires-calls": [
      "maybe_corrupted",
      "spec_u64_to_le_bytes",
      "spec_u64_to_le_bytes",
      "all_elements_unique"
    ],
    "requires-calls-full": [
      "maybe_corrupted",
      "spec_u64_to_le_bytes",
      "spec_u64_to_le_bytes",
      "all_elements_unique"
    ],
    "requires-fn-calls": [
      "maybe_corrupted",
      "spec_u64_to_le_bytes",
      "spec_u64_to_le_bytes",
      "all_elements_unique"
    ],
    "spec-labels": [
      "arithmetic-lemma"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/bytes_crc()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 40,
      "lines-end": 54
    },
    "mode": "exec",
    "context": "standalone",
    "specified": true,
    "has_requires": false,
    "has_ensures": true,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "ensures_text": "ensures\n            spec_crc_bytes(header_bytes@) == out@,\n            out@.len() == crc_size",
    "ensures-calls": [
      "spec_crc_bytes",
      "len"
    ],
    "ensures-calls-full": [
      "spec_crc_bytes",
      "len"
    ],
    "ensures-fn-calls": [
      "spec_crc_bytes"
    ],
    "ensures-method-calls": [
      "len"
    ],
    "spec-labels": [
      "corruption-detection"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/maybe_corrupted()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 31,
      "lines-end": 34
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/maybe_corrupted_byte()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 29,
      "lines-end": 29
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/spec_crc_bytes()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 38,
      "lines-end": 38
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/update_byte_to_reflect_partially_flushed_write()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 187,
      "lines-end": 203
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/update_byte_to_reflect_write()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 159,
      "lines-end": 171
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/update_contents_to_reflect_partially_flushed_write()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 205,
      "lines-end": 221
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/pmemspec_t/update_contents_to_reflect_write()": {
    "code-path": "src/pmemspec_t.rs",
    "spec-text": {
      "lines-start": 173,
      "lines-end": 185
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  },
  "probe:pmemlog/0.1.0/sccf/is_state_allowable()": {
    "code-path": "src/sccf.rs",
    "spec-text": {
      "lines-start": 9,
      "lines-end": 24
    },
    "mode": "spec",
    "context": "standalone",
    "specified": false,
    "has_requires": false,
    "has_ensures": false,
    "has_decreases": false,
    "has_trusted_assumption": false,
    "spec-labels": [
      "specification-definition"
    ]
  }
}