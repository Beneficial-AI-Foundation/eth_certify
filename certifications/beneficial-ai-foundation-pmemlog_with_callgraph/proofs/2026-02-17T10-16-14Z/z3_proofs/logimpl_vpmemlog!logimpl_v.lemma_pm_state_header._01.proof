(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 12449)
(:version "4.12.5")
unsat
((proof
(let ((?x46673 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x48939 (pmemlog!logimpl_v.pm_to_views.? ?x46673)))
 (let ((?x48913 (Poly%tuple%3. ?x48939)))
 (let ((?x48928 (%Poly%tuple%3. ?x48913)))
 (let ((?x48947 (tuple%3./tuple%3/1 ?x48928)))
 (let ((?x48948 (%Poly%pmemlog!logimpl_v.HeaderView. ?x48947)))
 (let ((?x48949 (Poly%pmemlog!logimpl_v.HeaderView. ?x48948)))
 (let ((?x48950 (%Poly%pmemlog!logimpl_v.HeaderView. ?x48949)))
 (let ((?x48952 (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x48950)))
 (let ((?x48951 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x48950)))
 (let ((?x48944 (tuple%3./tuple%3/0 ?x48928)))
 (let ((?x48945 (%I ?x48944)))
 (let (($x48946 (= ?x48945 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x48954 (ite $x48946 ?x48951 ?x48952)))
 (let ((?x50793 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x48954)))
 (let ((?x50809 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x50793)))
 (let ((?x50825 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x50809)))
 (let ((?x50826 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x50825)))
 (let ((?x50827 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x50826)))
 (let ((?x50835 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x50827)))
 (let ((?x51138 (* (- 1) ?x50835)))
 (let ((?x50828 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x50827)))
 (let ((?x51139 (+ ?x50828 ?x51138)))
 (let (($x51140 (<= ?x51139 0)))
 (let (($x51141 (not $x51140)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x49331 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7451 ?x7453)))
 (let ((?x51127 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x49331)))
 (let ((?x51128 (Poly%vstd!seq.Seq<u8.>. ?x51127)))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x49327 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x51132 (ext_eq false ?x1968 ?x49327 ?x51128)))
 (let (($x51133 (not $x51132)))
 (let ((?x51129 (vstd!bytes.spec_u64_from_le_bytes.? ?x51128)))
 (let ((?x51114 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x50809)))
 (let (($x51130 (= ?x51114 ?x51129)))
 (let (($x51131 (not $x51130)))
 (let (($x51134 (or $x51131 $x51133)))
 (let (($x51135 (not $x51134)))
 (let (($x51089 (= ?x48945 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x51126 (not $x51089)))
 (let (($x51136 (or $x51126 $x51135)))
 (let (($x51137 (not $x51136)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x49320 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7445 ?x7447)))
 (let ((?x51115 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x49320)))
 (let ((?x51116 (Poly%vstd!seq.Seq<u8.>. ?x51115)))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x49316 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7433 ?x7435)))
 (let (($x51120 (ext_eq false ?x1968 ?x49316 ?x51116)))
 (let (($x51121 (not $x51120)))
 (let ((?x51117 (vstd!bytes.spec_u64_from_le_bytes.? ?x51116)))
 (let (($x51118 (= ?x51114 ?x51117)))
 (let (($x51119 (not $x51118)))
 (let (($x51122 (or $x51119 $x51121)))
 (let (($x51123 (not $x51122)))
 (let (($x49301 (not $x48946)))
 (let (($x51124 (or $x49301 $x51123)))
 (let (($x51125 (not $x51124)))
 (let ((?x51110 (Sub ?x50835 ?x50828)))
 (let ((?x51111 (* (- 1) ?x51110)))
 (let ((?x50831 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x50827)))
 (let ((?x51112 (+ ?x50831 ?x51111)))
 (let (($x51113 (<= ?x51112 0)))
 (let ((?x49340 (vstd!seq.Seq.len.? $ ?x1876 ?x46673)))
 (let ((?x50843 (Add ?x50831 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x51108 (= ?x50843 ?x49340)))
 (let (($x51109 (not $x51108)))
 (let (($x51107 (<= ?x50831 0)))
 (let (($x51105 (<= ?x50843 18446744073709551615)))
 (let (($x51106 (not $x51105)))
 (let (($x51090 (or $x48946 $x51089)))
 (let (($x51104 (not $x51090)))
 (let (($x51142 (or $x51104 $x51106 $x51107 $x51109 $x51113 $x51125 $x51137 $x51141)))
 (let (($x51207 (not $x51142)))
 (let (($x50820 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? ?x46673)))
 (let (($x51143 (= $x51142 $x50820)))
 (let (($x51144 (not $x51143)))
 (let (($x17177 (forall ((pm! Poly) )(! (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x17134 (or (not (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))) (not $x7574))))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7591 (<= ?x7556 0)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x17153 (not $x7558)))
 (let (($x17159 (or $x17153 (not (<= ?x7559 18446744073709551615)) $x7591 (not $x7564) $x7617 (not (or $x7631 (not $x17134))) (not (or $x7643 (not (or (not $x7581) (not $x7582))))) (not $x7657))))
 (not (= $x17159 $x7546)))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.log_state_is_valid.?_definition))
 ))
 (let (($x7545 (fuel_bool fuel%pmemlog!logimpl_v.impl&%0.log_state_is_valid.)))
 (let (($x7543 (fuel_bool_default fuel%pmemlog!logimpl_v.impl&%0.log_state_is_valid.)))
 (let (($x50775 (= $x7545 $x7543)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x46671 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x10025 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x10030 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x10025) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x10034 (mp (mp~ @x37 @x10030 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x47707 (unit-resolution @x10034 @x46671 $x30)))
 (let ((@x50789 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.impl&%0.log_state_is_valid.) (or (not $x30) $x50775)) @x47707 (hypothesis (not $x50775)) false)))
 (let ((@x50802 (lemma @x50789 $x50775)))
 (let ((@x7544 (asserted $x7543)))
 (let ((@x50781 (def-axiom (or (not $x50775) $x7545 (not $x7543)))))
 (let ((@x51947 (unit-resolution (unit-resolution @x50781 @x7544 (or (not $x50775) $x7545)) @x50802 $x7545)))
 (let (($x7638 (not $x7545)))
 (let (($x17145 (or $x7638 $x17177)))
 (let (($x7593 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7560 (<= ?x7559 18446744073709551615)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x7663 (and $x7558 $x7560 (not (<= ?x7556 0)) $x7564 (not $x7617) (or $x7631 $x7575) (or $x7643 $x7583) $x7657)))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (= $x7546 $x7663)))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.log_state_is_valid.?_definition))
 ))
 (let (($x7626 (or $x7638 $x7593)))
 (let ((?x13540 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7560 (<= ?x7559 18446744073709551615)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x7663 (and $x7558 $x7560 (not (<= ?x7556 0)) $x7564 (not $x7617) (or $x7631 $x7575) (or $x7643 $x7583) $x7657)))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let (($x7668 (= $x7546 $x7663)))
 (refl (~ $x7668 $x7668)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x13545 (monotonicity (refl (~ $x7638 $x7638)) (nnf-pos (proof-bind ?x13540) (~ $x7593 $x7593)) (~ $x7626 $x7626))))
 (let (($x7588 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7566 (Sub ?x7555 ?x7554)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7565 (and (and (and (or $x7513 $x7557) (<= ?x7559 18446744073709551615)) (> ?x7556 0)) $x7564)))
 (let (($x7587 (and (and (and (and $x7565 (< ?x7566 ?x7556)) (=> $x7513 $x7575)) (=> $x7557 $x7583)) (<= ?x7554 ?x7555))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (= $x7546 $x7587)))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.log_state_is_valid.?_definition))
 ))
 (let (($x7589 (=> $x7545 $x7588)))
 (let ((?x7594 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7560 (<= ?x7559 18446744073709551615)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x7663 (and $x7558 $x7560 (not (<= ?x7556 0)) $x7564 (not $x7617) (or $x7631 $x7575) (or $x7643 $x7583) $x7657)))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let (($x7668 (= $x7546 $x7663)))
 (let (($x7568 (and (and (and (and $x7558 $x7560) (> ?x7556 0)) $x7564) (< (Sub ?x7555 ?x7554) ?x7556))))
 (let (($x7547 (= $x7546 (and (and (and $x7568 (=> $x7513 $x7575)) (=> $x7557 $x7583)) (<= ?x7554 ?x7555)))))
 (rewrite (= $x7547 $x7668)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x7606 (monotonicity (quant-intro (proof-bind ?x7594) (= $x7588 $x7593)) (= $x7589 (=> $x7545 $x7593)))))
 (let ((@x7599 (mp (asserted $x7589) (trans @x7606 (rewrite (= (=> $x7545 $x7593) $x7626)) (= $x7589 $x7626)) $x7626)))
 (let ((@x17136 (mp (mp (mp~ @x7599 @x13545 $x7626) (rewrite (= $x7626 $x7626)) $x7626) (rewrite (= $x7626 $x17145)) $x17145)))
 (let (($x51150 (or (not $x17177) $x51144)))
 (let ((@x51153 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) $x51150)))
 (let ((?x50859 (Sub ?x50831 1)))
 (let ((?x50860 (I ?x50859)))
 (let ((?x50861 (%I ?x50860)))
 (let ((?x50832 (I ?x50831)))
 (let ((?x50836 (I ?x50835)))
 (let ((?x50837 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x50836 ?x50832)))
 (let ((?x50848 (I ?x50837)))
 (let ((?x50829 (I ?x50828)))
 (let ((?x50833 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x50829 ?x50832)))
 (let ((?x50842 (I ?x50833)))
 (let ((?x50854 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x50842 ?x50848)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x50849 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7471 ?x50848)))
 (let ((?x50850 (%Poly%vstd!seq.Seq<u8.>. ?x50849)))
 (let ((?x50851 (Poly%vstd!seq.Seq<u8.>. ?x50850)))
 (let ((?x50844 (I ?x50843)))
 (let ((?x50845 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x50842 ?x50844)))
 (let ((?x50846 (%Poly%vstd!seq.Seq<u8.>. ?x50845)))
 (let ((?x50847 (Poly%vstd!seq.Seq<u8.>. ?x50846)))
 (let ((?x50852 (vstd!seq.Seq.add.? $ ?x1876 ?x50847 ?x50851)))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x50838 (* (- 1) ?x50837)))
 (let ((?x50839 (+ ?x50833 ?x50838)))
 (let (($x50841 (<= ?x50839 0)))
 (let ((?x50853 (ite $x50841 ?x7133 ?x50852)))
 (let (($x50840 (>= ?x50839 0)))
 (let ((?x50855 (ite $x50840 ?x50853 ?x50854)))
 (let ((?x50856 (%Poly%vstd!seq.Seq<u8.>. ?x50855)))
 (let ((?x50857 (Poly%vstd!seq.Seq<u8.>. ?x50856)))
 (let ((?x50858 (%Poly%vstd!seq.Seq<u8.>. ?x50857)))
 (let ((?x50830 (%I ?x50829)))
 (let ((?x50862 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x50830 ?x50858 ?x50861)))
 (let ((?x50863 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x50862)))
 (let ((?x50864 (core!option.Option./Some ?x50863)))
 (let ((?x50865 (ite $x50820 ?x50864 core!option.Option./None)))
 (let (($x50873 (= core!option.Option./None ?x50865)))
 (let ((?x46674 (pmemlog!logimpl_v.impl&%0.recover.? ?x46673)))
 (let ((?x47477 (core!option.Option./Some/?0 ?x46674)))
 (let ((?x47478 (core!option.Option./Some ?x47477)))
 (let (($x50866 (= ?x46674 ?x50865)))
 (let (($x7695 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7713 (ite (>= (+ ?x7637 (* (- 1) ?x7640)) 0) (ite (<= (+ ?x7637 (* (- 1) ?x7640)) 0) ?x7133 ?x7659) ?x7646)))
 (let ((?x7719 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7713)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 ?x7719 ?x7672)))
 (let ((?x7688 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7683))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (= ?x7629 (ite $x7546 ?x7688 core!option.Option./None))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.recover.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.recover.?_definition))
 ))
 (let (($x7628 (fuel_bool fuel%pmemlog!logimpl_v.impl&%0.recover.)))
 (let (($x7625 (fuel_bool_default fuel%pmemlog!logimpl_v.impl&%0.recover.)))
 (let (($x50804 (= $x7628 $x7625)))
 (let ((@x50821 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.impl&%0.recover.) (or (not $x30) $x50804)) @x47707 (hypothesis (not $x50804)) false)))
 (let ((@x50834 (lemma @x50821 $x50804)))
 (let ((@x7627 (asserted $x7625)))
 (let ((@x50812 (def-axiom (or (not $x50804) $x7628 (not $x7625)))))
 (let ((@x51776 (unit-resolution (unit-resolution @x50812 @x7627 (or (not $x50804) $x7628)) @x50834 $x7628)))
 (let (($x7690 (not $x7628)))
 (let (($x7692 (or $x7690 $x7695)))
 (let ((?x13568 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7713 (ite (>= (+ ?x7637 (* (- 1) ?x7640)) 0) (ite (<= (+ ?x7637 (* (- 1) ?x7640)) 0) ?x7133 ?x7659) ?x7646)))
 (let ((?x7719 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7713)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 ?x7719 ?x7672)))
 (let ((?x7688 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7683))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let (($x7708 (= ?x7629 (ite $x7546 ?x7688 core!option.Option./None))))
 (refl (~ $x7708 $x7708)))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x13573 (monotonicity (refl (~ $x7690 $x7690)) (nnf-pos (proof-bind ?x13568) (~ $x7695 $x7695)) (~ $x7692 $x7692))))
 (let (($x7677 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7662 (%Poly%vstd!seq.Seq<u8.>. (ite (< ?x7637 ?x7640) ?x7646 (ite (< ?x7640 ?x7637) ?x7659 ?x7133)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7673 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. ?x7662)) ?x7672)))
 (let ((?x7675 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7673))))
 (let ((?x7676 (ite (not (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)) core!option.Option./None ?x7675)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (= ?x7629 ?x7676))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.recover.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.recover.?_definition))
 ))
 (let (($x7678 (=> $x7628 $x7677)))
 (let ((?x7698 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7713 (ite (>= (+ ?x7637 (* (- 1) ?x7640)) 0) (ite (<= (+ ?x7637 (* (- 1) ?x7640)) 0) ?x7133 ?x7659) ?x7646)))
 (let ((?x7719 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7713)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 ?x7719 ?x7672)))
 (let ((?x7688 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7683))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let (($x7708 (= ?x7629 (ite $x7546 ?x7688 core!option.Option./None))))
 (let ((?x7662 (%Poly%vstd!seq.Seq<u8.>. (ite (< ?x7637 ?x7640) ?x7646 (ite (< ?x7640 ?x7637) ?x7659 ?x7133)))))
 (let ((?x7673 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. ?x7662)) ?x7672)))
 (let ((?x7675 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7673))))
 (let (($x7630 (= ?x7629 (ite (not $x7546) core!option.Option./None ?x7675))))
 (rewrite (= $x7630 $x7708)))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x7689 (monotonicity (quant-intro (proof-bind ?x7698) (= $x7677 $x7695)) (= $x7678 (=> $x7628 $x7695)))))
 (let ((@x7702 (mp (asserted $x7678) (trans @x7689 (rewrite (= (=> $x7628 $x7695) $x7692)) (= $x7678 $x7692)) $x7692)))
 (let ((@x13577 (mp (mp~ @x7702 @x13573 $x7692) (rewrite (= $x7692 $x7692)) $x7692)))
 (let (($x50870 (or (not $x7695) $x50866)))
 (let ((@x50871 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) $x50870)))
 (let ((@x51778 (unit-resolution @x50871 (unit-resolution @x13577 @x51776 $x7695) $x50866)))
 (let (($x47479 (= ?x46674 ?x47478)))
 (let (($x46677 ((_ is core!option.Option./Some ) ?x46674)))
 (let ((@x46680 (mp (asserted ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x46674)) (rewrite (= ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x46674) $x46677)) $x46677)))
 (let ((@x51783 (symm (unit-resolution ((_ th-lemma datatype) (or $x47479 (not $x46677))) @x46680 $x47479) (= ?x47478 ?x46674))))
 (let ((@x51787 (trans* @x51783 @x51778 (symm (hypothesis $x50873) (= ?x50865 core!option.Option./None)) (= ?x47478 core!option.Option./None))))
 (let ((@x51790 (lemma ((_ th-lemma datatype) @x51787 false) (not $x50873))))
 (let ((@x50952 (def-axiom (or $x50820 $x50873))))
 (let ((@x51950 (unit-resolution @x50952 @x51790 $x50820)))
 (let ((@x51217 (def-axiom (or $x51143 $x51207 (not $x50820)))))
 (let ((@x51951 (unit-resolution @x51217 @x51950 (unit-resolution @x51153 (unit-resolution @x17136 @x51947 $x17177) $x51144) $x51207)))
 (let ((@x51206 (def-axiom (or $x51142 $x51140))))
 (let ((@x52328 (unit-resolution @x51206 @x51951 $x51140)))
 (let ((?x46802 (Poly%core!option.Option. ?x46674)))
 (let ((?x46803 (%Poly%core!option.Option. ?x46802)))
 (let ((?x46804 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x46803)))
 (let ((?x46805 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x46804)))
 (let ((?x46806 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x46805)))
 (let ((?x46807 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x46806)))
 (let ((?x46810 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/log ?x46807)))
 (let ((?x46811 (Poly%vstd!seq.Seq<u8.>. ?x46810)))
 (let ((?x46812 (vstd!seq.Seq.len.? $ ?x1876 ?x46811)))
 (let ((?x52741 (* (- 1) ?x46812)))
 (let ((?x46681 (pmemlog!logimpl_v.spec_get_live_header.? ?x46673)))
 (let ((?x46682 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x46681)))
 (let ((?x46683 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x46682)))
 (let ((?x46684 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x46683)))
 (let ((?x46685 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x46684)))
 (let ((?x46686 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x46685)))
 (let ((?x46688 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x46686)))
 (let ((?x46687 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x46686)))
 (let ((?x46689 (Sub ?x46687 ?x46688)))
 (let ((?x52792 (+ ?x46689 ?x52741)))
 (let (($x52761 (>= ?x52792 0)))
 (let (($x55337 (not $x52761)))
 (let (($x52793 (<= ?x52792 0)))
 (let ((?x46941 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x46683)))
 (let ((?x46946 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46941)))
 (let ((?x51524 (* (- 1) ?x46946)))
 (let ((?x46943 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46941)))
 (let ((?x52154 (+ ?x46943 ?x51524)))
 (let (($x56187 (>= ?x52154 0)))
 (let (($x55878 (= ?x46943 ?x46946)))
 (let ((?x46948 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46941)))
 (let (($x55890 (ens%pmemlog!math_v.lemma_mod_equal. ?x46943 ?x46946 ?x46948)))
 (let (($x56146 (= $x55890 $x55878)))
 (let (($x9957 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x1385 (= x! y!)))
 (let (($x9956 (ens%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (= $x9956 $x1385))) :pattern ( (ens%pmemlog!math_v.lemma_mod_equal. x! y! d!) ) :qid internal_ens__pmemlog!math_v.lemma_mod_equal._definition))
 ))
 (let ((?x14511 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x1385 (= x! y!)))
 (let (($x9956 (ens%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (let (($x9961 (= $x9956 $x1385)))
 (refl (~ $x9961 $x9961))))))
 ))
 (let ((@x14515 (mp~ (asserted $x9957) (nnf-pos (proof-bind ?x14511) (~ $x9957 $x9957)) $x9957)))
 (let (($x56149 (not $x9957)))
 (let (($x56152 (or $x56149 $x56146)))
 (let ((?x46940 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x46683)))
 (let ((?x46961 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x46940 ?x46941)))
 (let ((?x46976 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x46961)))
 (let ((?x46984 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46976)))
 (let ((?x46979 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46976)))
 (let ((?x46978 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46976)))
 (let ((?x46985 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x46978 ?x46979 ?x46984)))
 (let ((?x46991 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985)))
 (let ((?x46987 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985)))
 (let (($x55722 (= ?x46987 ?x46991)))
 (let ((?x46994 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)))
 (let (($x55721 (ens%pmemlog!math_v.lemma_mod_equal. ?x46987 ?x46991 ?x46994)))
 (let (($x55889 (= $x55721 $x55722)))
 (let (($x56179 (or $x56149 $x55889)))
 (let (($x56181 (= $x56179 $x56152)))
 (let ((@x56185 (trans (monotonicity (rewrite (= $x55889 $x56146)) $x56181) (rewrite (= $x56152 $x56152)) $x56181)))
 (let ((@x56186 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x56179) @x56185 $x56152)))
 (let ((?x46711 (Poly%pmemlog!logimpl_v.PersistentHeader. header@)))
 (let ((?x46712 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x46711)))
 (let ((?x46713 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x46712)))
 (let ((?x46714 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x46713)))
 (let ((?x46715 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x46714)))
 (let ((?x46719 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x46715)))
 (let (($x46739 (= log_size@ ?x46719)))
 (let (($x46813 (= ?x46812 ?x46689)))
 (let (($x47011 (not $x46813)))
 (let ((?x46808 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/head ?x46807)))
 (let (($x46809 (= ?x46688 ?x46808)))
 (let (($x47010 (not $x46809)))
 (let (($x47009 (not $x46677)))
 (let (($x47012 (or $x47009 $x47010 $x47011)))
 (let (($x47013 (not $x47012)))
 (let (($x46927 (not %%location_label%%6)))
 (let (($x47016 (or $x46927 $x47013)))
 (let (($x47020 (not $x47016)))
 (let (($x47021 (or %%switch_label%%0 $x47020)))
 (let (($x47022 (not $x47021)))
 (let (($x46866 (not %%location_label%%5)))
 (let (($x46844 ((_ is core!option.Option./Some ) pm_state@)))
 (let (($x46897 (or $x46844 $x46866)))
 (let (($x47002 (not $x46897)))
 (let (($x46800 (not %%switch_label%%0)))
 (let (($x46988 (or %%switch_label%%1 $x46800)))
 (let (($x46989 (not $x46988)))
 (let (($x46789 (not %%switch_label%%1)))
 (let (($x46967 (or %%switch_label%%2 $x46789)))
 (let (($x46968 (not $x46967)))
 (let (($x46779 (ens%pmemlog!math_v.lemma_mod_equal. head@ tail@ log_size@)))
 (let (($x46917 (not $x46779)))
 (let (($x46918 (or $x46917 %%switch_label%%2)))
 (let (($x46953 (not $x46918)))
 (let (($x46777 (req%pmemlog!math_v.lemma_mod_equal. head@ tail@ log_size@)))
 (let (($x46913 (not %%location_label%%4)))
 (let (($x46914 (or $x46913 $x46777)))
 (let (($x46950 (not $x46914)))
 (let (($x46954 (or $x46950 $x46953)))
 (let (($x46955 (not $x46954)))
 (let ((?x46853 (* (- 1) physical_tail@)))
 (let ((?x46854 (+ physical_head@ ?x46853)))
 (let (($x46885 (<= ?x46854 0)))
 (let (($x46888 (not $x46885)))
 (let (($x46959 (or $x46888 $x46955)))
 (let (($x46956 (not $x46959)))
 (let (($x46770 (ens%pmemlog!math_v.lemma_mod_wrapped_len. head@ tail@ log_size@)))
 (let (($x46895 (not $x46770)))
 (let (($x46896 (or $x46895 %%switch_label%%2)))
 (let (($x46923 (not $x46896)))
 (let (($x46768 (req%pmemlog!math_v.lemma_mod_wrapped_len. head@ tail@ log_size@)))
 (let (($x46890 (not %%location_label%%3)))
 (let (($x46892 (or $x46890 $x46768)))
 (let (($x46924 (not $x46892)))
 (let (($x46925 (or $x46924 $x46923)))
 (let (($x46838 (not $x46925)))
 (let (($x46869 (or $x46885 $x46838)))
 (let (($x46949 (not $x46869)))
 (let (($x46842 (or $x46949 $x46956)))
 (let (($x46843 (not $x46842)))
 (let (($x46851 (>= ?x46854 0)))
 (let (($x46856 (not $x46851)))
 (let (($x46971 (or $x46856 $x46843 $x46968)))
 (let (($x46981 (not $x46971)))
 (let (($x46760 (ens%pmemlog!math_v.lemma_mod_difference_equal. head@ tail@ log_size@)))
 (let (($x46863 (not $x46760)))
 (let (($x46864 (or $x46863 %%switch_label%%1)))
 (let (($x46848 (not $x46864)))
 (let (($x46758 (req%pmemlog!math_v.lemma_mod_difference_equal. head@ tail@ log_size@)))
 (let (($x46858 (not %%location_label%%2)))
 (let (($x46860 (or $x46858 $x46758)))
 (let (($x46847 (not $x46860)))
 (let (($x46849 (or $x46847 $x46848)))
 (let (($x46850 (not $x46849)))
 (let (($x46855 (or $x46851 $x46850)))
 (let (($x46980 (not $x46855)))
 (let (($x46982 (or $x46980 $x46981)))
 (let (($x46983 (not $x46982)))
 (let ((?x46751 (Poly%core!option.Option. pm_state@)))
 (let ((?x46752 (%Poly%core!option.Option. ?x46751)))
 (let ((?x46753 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x46752)))
 (let ((?x46754 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x46753)))
 (let (($x46755 (= pm_state$1@ ?x46754)))
 (let (($x46906 (not $x46755)))
 (let (($x46920 (not $x46844)))
 (let (($x46992 (or $x46920 $x46906 $x46983 $x46989)))
 (let (($x47001 (not $x46992)))
 (let (($x47003 (or $x47001 $x47002)))
 (let (($x47004 (not $x47003)))
 (let ((?x46742 (I log_size@)))
 (let ((?x46746 (I tail@)))
 (let ((?x46747 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x46746 ?x46742)))
 (let (($x46748 (= physical_tail@ ?x46747)))
 (let (($x46932 (not $x46748)))
 (let ((?x46741 (I head@)))
 (let ((?x46743 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x46741 ?x46742)))
 (let (($x46744 (= physical_head@ ?x46743)))
 (let (($x46875 (not $x46744)))
 (let (($x46911 (not $x46739)))
 (let ((?x46726 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x46715)))
 (let (($x46737 (= tail@ ?x46726)))
 (let (($x46933 (not $x46737)))
 (let ((?x46716 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x46715)))
 (let (($x46735 (= head@ ?x46716)))
 (let (($x46942 (not $x46735)))
 (let (($x46733 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. tmp%3 tmp%4)))
 (let (($x46951 (not $x46733)))
 (let (($x47027 (or $x46951 $x46942 $x46933 $x46911 $x46875 $x46932 $x47004 $x47022)))
 (let (($x47037 (not $x47027)))
 (let (($x46731 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. tmp%3 tmp%4)))
 (let (($x46840 (not %%location_label%%1)))
 (let (($x46841 (or $x46840 $x46731)))
 (let (($x51998 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. ?x46946 ?x46948)))
 (let (($x52018 (not $x51998)))
 (let (($x46729 (= tmp%4 ?x46719)))
 (let (($x47036 (not $x46841)))
 (let (($x47038 (or $x47036 $x47037)))
 (let (($x47039 (not $x47038)))
 (let (($x46879 (not $x46729)))
 (let (($x46727 (= tmp%3 ?x46726)))
 (let (($x46903 (not $x46727)))
 (let (($x46724 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. tmp%1 tmp%2)))
 (let (($x46910 (not $x46724)))
 (let (($x47044 (or $x46910 $x46903 $x46879 $x47039)))
 (let (($x47051 (not $x47044)))
 (let (($x46722 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. tmp%1 tmp%2)))
 (let (($x46836 (not %%location_label%%0)))
 (let (($x46837 (or $x46836 $x46722)))
 (let (($x51736 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. ?x46943 ?x46948)))
 (let (($x51814 (not $x51736)))
 (let (($x46720 (= tmp%2 ?x46719)))
 (let (($x46791 (and $x46789 %%switch_label%%0)))
 (let (($x46784 (not %%switch_label%%2)))
 (let (($x46785 (and $x46784 %%switch_label%%1)))
 (let (($x46919 (or $x46856 (and (or $x46885 (and $x46892 $x46896)) (or $x46888 (and $x46914 $x46918))) $x46785)))
 (let (($x46952 (or $x46951 $x46942 $x46933 $x46911 $x46875 $x46932 (and (or $x46920 $x46906 (and (or $x46851 (and $x46860 $x46864)) $x46919) $x46791) $x46897) (and $x46800 (or $x46927 (and $x46677 $x46809 $x46813))))))
 (let (($x46957 (and $x46841 $x46952)))
 (let (($x46912 (or $x46910 $x46903 $x46879 $x46957)))
 (let (($x46868 (and $x46837 $x46912)))
 (let (($x46938 (or (not (= pm_state@ ?x46674)) (not (= header@ ?x46681)) (not (= tmp%1 ?x46716)) (not $x46720) $x46868)))
 (let (($x46944 (not $x46938)))
 (let (($x46816 (=> %%location_label%%6 (and ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x46674) (and $x46809 $x46813)))))
 (let (($x46798 (=> (and (not ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) pm_state@)) %%location_label%%5) false)))
 (let (($x46782 (=> (not (< physical_tail@ physical_head@)) (and (=> %%location_label%%4 $x46777) (=> $x46779 %%switch_label%%2)))))
 (let (($x46766 (< physical_tail@ physical_head@)))
 (let (($x46774 (=> $x46766 (and (=> %%location_label%%3 $x46768) (=> $x46770 %%switch_label%%2)))))
 (let (($x46787 (=> (not (< physical_head@ physical_tail@)) (or (and $x46774 $x46782) $x46785))))
 (let (($x46756 (< physical_head@ physical_tail@)))
 (let (($x46764 (=> $x46756 (and (=> %%location_label%%2 $x46758) (=> $x46760 %%switch_label%%1)))))
 (let (($x46749 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) pm_state@)))
 (let (($x46818 (or (and (=> (and $x46749 $x46755) (or (and $x46764 $x46787) $x46791)) $x46798) (and $x46800 $x46816))))
 (let (($x46825 (and (=> %%location_label%%1 $x46731) (=> (and $x46733 $x46735 $x46737 $x46739 $x46744 $x46748) $x46818))))
 (let (($x46829 (and (=> %%location_label%%0 $x46722) (=> (and $x46724 $x46727 $x46729) $x46825))))
 (let (($x46717 (= tmp%1 ?x46716)))
 (let (($x46709 (= header@ ?x46681)))
 (let (($x46707 (= pm_state@ ?x46674)))
 (let (($x46834 (not (=> (and $x46707 $x46709 $x46717 $x46720) $x46829))))
 (let ((@x46870 (mp (asserted $x46834) (rewrite (= $x46834 $x46944)) $x46944)))
 (let ((@x46865 (not-or-elim @x46870 $x46720)))
 (let ((@x47474 (symm @x46865 (= ?x46719 tmp%2))))
 (let ((?x46690 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x46686)))
 (let ((@x51852 (monotonicity (monotonicity (not-or-elim @x46870 $x46709) (= ?x46711 ?x46682)) (= ?x46712 ?x46683))))
 (let ((@x51858 (monotonicity (monotonicity (monotonicity @x51852 (= ?x46713 ?x46684)) (= ?x46714 ?x46685)) (= ?x46715 ?x46686))))
 (let ((@x51868 (monotonicity @x51858 (= ?x46719 ?x46690))))
 (let ((@x51881 (symm @x51868 (= ?x46690 ?x46719))))
 (let ((?x47018 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46686)))
 (let ((?x47015 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46686)))
 (let ((?x47014 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46686)))
 (let ((?x47023 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x47014 ?x47015 ?x47018)))
 (let ((?x47618 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x47023)))
 (let (($x47024 (= ?x46686 ?x47023)))
 (let ((@x51836 ((_ th-lemma datatype) $x47024)))
 (let ((@x51870 (monotonicity @x51836 (= ?x46690 ?x47618))))
 (let ((@x51879 (symm @x51870 (= ?x47618 ?x46690))))
 (let (($x47622 (= ?x47618 ?x47018)))
 (let (($x2815 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2812 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size x)))
 (let ((?x2811 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size x)))
 (= ?x2811 ?x2812))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size x) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size_accessor_definition))
 ))
 (let ((?x11208 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2812 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size x)))
 (let ((?x2811 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size x)))
 (let (($x2813 (= ?x2811 ?x2812)))
 (refl (~ $x2813 $x2813))))))
 ))
 (let ((@x11212 (mp~ (asserted $x2815) (nnf-pos (proof-bind ?x11208) (~ $x2815 $x2815)) $x2815)))
 (let (($x47624 (not $x2815)))
 (let (($x47626 (or $x47624 $x47622)))
 (let ((?x47030 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x47023)))
 (let (($x47619 (= ?x47618 ?x47030)))
 (let (($x47627 (or $x47624 $x47619)))
 (let (($x47629 (= $x47627 $x47626)))
 (let ((@x47633 (trans (monotonicity (rewrite (= $x47619 $x47622)) $x47629) (rewrite (= $x47626 $x47626)) $x47629)))
 (let ((@x47634 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x47014 ?x47015 ?x47018)) $x47627) @x47633 $x47626)))
 (let ((@x51848 (unit-resolution @x47634 @x11212 $x47622)))
 (let ((@x51877 (symm @x51848 (= ?x47018 ?x47618))))
 (let (($x47620 (= ?x47030 ?x47018)))
 (let (($x47031 (= ?x47018 ?x47030)))
 (let ((@x51847 ((_ th-lemma datatype) $x47031)))
 (let ((@x51875 (symm @x51847 $x47620)))
 (let (($x46986 (= ?x46976 ?x46985)))
 (let ((@x51822 ((_ th-lemma datatype) $x46986)))
 (let (($x46977 (= ?x46941 ?x46976)))
 (let ((@x51823 ((_ th-lemma datatype) $x46977)))
 (let ((?x47510 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x46961)))
 (let (($x47547 (= ?x47510 ?x46941)))
 (let (($x2685 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x)))
 (= ?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata x))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_accessor_definition))
 ))
 (let ((?x11138 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x)))
 (let (($x2683 (= ?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata x))))
 (refl (~ $x2683 $x2683)))))
 ))
 (let ((@x11142 (mp~ (asserted $x2685) (nnf-pos (proof-bind ?x11138) (~ $x2685 $x2685)) $x2685)))
 (let (($x47549 (not $x2685)))
 (let (($x47551 (or $x47549 $x47547)))
 (let (($x47511 (= ?x47510 ?x46976)))
 (let (($x47552 (or $x47549 $x47511)))
 (let (($x47554 (= $x47552 $x47551)))
 (let ((@x47558 (trans (monotonicity (rewrite (= $x47511 $x47547)) $x47554) (rewrite (= $x47551 $x47551)) $x47554)))
 (let ((@x47559 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x46940 ?x46941)) $x47552) @x47558 $x47551)))
 (let ((?x46998 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46684)))
 (let ((?x46997 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46684)))
 (let ((?x46996 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46684)))
 (let ((?x46999 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x46996 ?x46997 ?x46998)))
 (let ((@x51831 (symm ((_ th-lemma datatype) (= ?x46684 ?x46999)) (= ?x46999 ?x46684))))
 (let ((?x47571 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x46999)))
 (let ((?x47572 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x47571)))
 (let (($x47573 (= ?x46999 ?x47572)))
 (let (($x2729 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_box_axiom_definition))
 ))
 (let ((?x11159 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2727 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))))
 (refl (~ $x2727 $x2727)))))
 ))
 (let ((@x11163 (mp~ (asserted $x2729) (nnf-pos (proof-bind ?x11159) (~ $x2729 $x2729)) $x2729)))
 (let (($x47576 (not $x2729)))
 (let (($x47577 (or $x47576 $x47573)))
 (let ((@x47578 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x46996 ?x46997 ?x46998)) $x47577)))
 (let ((@x51840 (monotonicity (symm (monotonicity @x51831 (= ?x47571 ?x46685)) (= ?x46685 ?x47571)) (= ?x46686 ?x47572))))
 (let ((@x51846 (trans* (symm @x51836 (= ?x47023 ?x46686)) @x51840 (symm (unit-resolution @x47578 @x11163 $x47573) (= ?x47572 ?x46999)) @x51831 (monotonicity ((_ th-lemma datatype) (= ?x46683 ?x46961)) (= ?x46684 ?x47510)) (unit-resolution @x47559 @x11142 $x47547) @x51823 @x51822 (= ?x47023 ?x46985))))
 (let ((@x51872 (monotonicity @x51846 (= ?x47030 ?x46994))))
 (let ((@x51874 (symm @x51872 (= ?x46994 ?x47030))))
 (let ((?x46962 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x46943 ?x46946 ?x46948)))
 (let ((?x46972 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46962)))
 (let ((@x51863 (trans* (symm ((_ th-lemma datatype) (= ?x46941 ?x46962)) (= ?x46962 ?x46941)) @x51823 @x51822 (= ?x46962 ?x46985))))
 (let ((@x51866 (monotonicity @x51863 (= ?x46972 ?x46994))))
 (let (($x46973 (= ?x46948 ?x46972)))
 (let ((@x51864 ((_ th-lemma datatype) $x46973)))
 (let ((@x46960 (not-or-elim @x46870 $x46717)))
 (let ((@x47472 (symm @x46960 (= ?x46716 tmp%1))))
 (let ((@x51890 (monotonicity @x51858 (= ?x46716 ?x46688))))
 (let ((@x51903 (symm @x51890 (= ?x46688 ?x46716))))
 (let ((?x47635 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x47023)))
 (let ((@x51892 (monotonicity @x51836 (= ?x46688 ?x47635))))
 (let ((@x51901 (symm @x51892 (= ?x47635 ?x46688))))
 (let (($x47639 (= ?x47635 ?x47014)))
 (let (($x2773 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2770 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head x)))
 (let ((?x2769 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head x)))
 (= ?x2769 ?x2770))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head x) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head_accessor_definition))
 ))
 (let ((?x11180 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2770 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head x)))
 (let ((?x2769 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head x)))
 (let (($x2771 (= ?x2769 ?x2770)))
 (refl (~ $x2771 $x2771))))))
 ))
 (let ((@x11184 (mp~ (asserted $x2773) (nnf-pos (proof-bind ?x11180) (~ $x2773 $x2773)) $x2773)))
 (let (($x47641 (not $x2773)))
 (let (($x47643 (or $x47641 $x47639)))
 (let ((?x47025 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x47023)))
 (let (($x47636 (= ?x47635 ?x47025)))
 (let (($x47644 (or $x47641 $x47636)))
 (let (($x47646 (= $x47644 $x47643)))
 (let ((@x47650 (trans (monotonicity (rewrite (= $x47636 $x47639)) $x47646) (rewrite (= $x47643 $x47643)) $x47646)))
 (let ((@x47651 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x47014 ?x47015 ?x47018)) $x47644) @x47650 $x47643)))
 (let ((@x51885 (unit-resolution @x47651 @x11184 $x47639)))
 (let ((@x51899 (symm @x51885 (= ?x47014 ?x47635))))
 (let (($x47637 (= ?x47025 ?x47014)))
 (let (($x47026 (= ?x47014 ?x47025)))
 (let ((@x51884 ((_ th-lemma datatype) $x47026)))
 (let ((@x51897 (symm @x51884 $x47637)))
 (let ((@x51894 (monotonicity @x51846 (= ?x47025 ?x46987))))
 (let ((@x51896 (symm @x51894 (= ?x46987 ?x47025))))
 (let ((?x46965 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46962)))
 (let ((@x51888 (monotonicity @x51863 (= ?x46965 ?x46987))))
 (let (($x46966 (= ?x46943 ?x46965)))
 (let ((@x51886 ((_ th-lemma datatype) $x46966)))
 (let ((@x51907 (monotonicity (trans* @x51886 @x51888 @x51896 @x51897 @x51899 @x51901 @x51903 @x47472 (= ?x46943 tmp%1)) (trans* @x51864 @x51866 @x51874 @x51875 @x51877 @x51879 @x51881 @x47474 (= ?x46948 tmp%2)) (= $x51736 $x46722))))
 (let ((@x51912 (mp (hypothesis (not $x46722)) (monotonicity (symm @x51907 (= $x46722 $x51736)) (= (not $x46722) $x51814)) $x51814)))
 (let (($x51293 (<= ?x46948 0)))
 (let (($x51738 (not $x51293)))
 (let (($x5891 (not %%global_location_label%%4)))
 (let (($x51772 (or $x5891 $x51738)))
 (let (($x51792 (= $x51736 $x51772)))
 (let (($x5886 (forall ((x! Int) (m! Int) )(! (let (($x5878 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (= $x5878 (or (not %%global_location_label%%4) (not (<= m! 0))))) :pattern ( (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!) ) :qid internal_req__vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor._definition))
 ))
 (let ((?x12697 (lambda ((x! Int) (m! Int) )(let (($x5878 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (let (($x5897 (= $x5878 (or (not %%global_location_label%%4) (not (<= m! 0))))))
 (refl (~ $x5897 $x5897)))))
 ))
 (let (($x5884 (forall ((x! Int) (m! Int) )(! (let (($x5878 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (= $x5878 (=> %%global_location_label%%4 (> m! 0)))) :pattern ( (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!) ) :qid internal_req__vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor._definition))
 ))
 (let ((?x5887 (lambda ((x! Int) (m! Int) )(let (($x5878 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (let (($x5897 (= $x5878 (or (not %%global_location_label%%4) (not (<= m! 0))))))
 (let (($x5882 (= $x5878 (=> %%global_location_label%%4 (> m! 0)))))
 (rewrite (= $x5882 $x5897))))))
 ))
 (let ((@x5893 (mp (asserted $x5884) (quant-intro (proof-bind ?x5887) (= $x5884 $x5886)) $x5886)))
 (let ((@x12701 (mp~ @x5893 (nnf-pos (proof-bind ?x12697) (~ $x5886 $x5886)) $x5886)))
 (let (($x51743 (not $x5886)))
 (let (($x51793 (or $x51743 $x51792)))
 (let (($x51350 (<= ?x46994 0)))
 (let (($x51690 (not $x51350)))
 (let (($x51734 (or $x5891 $x51690)))
 (let (($x51717 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. ?x46987 ?x46994)))
 (let (($x51735 (= $x51717 $x51734)))
 (let (($x51795 (or $x51743 $x51735)))
 (let (($x51798 (= $x51795 $x51793)))
 (let ((@x51802 (trans (monotonicity (rewrite (= $x51735 $x51792)) $x51798) (rewrite (= $x51793 $x51793)) $x51798)))
 (let ((@x51803 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x51795) @x51802 $x51793)))
 (let ((?x51044 (* (- 1) ?x46948)))
 (let ((?x51163 (+ ?x46690 ?x51044)))
 (let (($x51147 (<= ?x51163 0)))
 (let (($x51161 (= ?x46690 ?x46948)))
 (let ((@x51919 (trans* @x51870 @x51848 @x51847 @x51872 (symm @x51866 (= ?x46994 ?x46972)) (symm @x51864 (= ?x46972 ?x46948)) $x51161)))
 (let ((@x51920 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51161) $x51147)) @x51919 $x51147)))
 (let ((?x51146 (* (- 1) ?x50831)))
 (let ((?x51218 (+ ?x46690 ?x51146)))
 (let (($x51220 (>= ?x51218 0)))
 (let (($x51145 (= ?x46690 ?x50831)))
 (let (($x48955 (= ?x46681 ?x48954)))
 (let (($x7521 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7507 (pmemlog!logimpl_v.spec_get_live_header.? pm!)))
 (= ?x7507 ?x7518)))))))))) :pattern ( (pmemlog!logimpl_v.spec_get_live_header.? pm!) ) :qid internal_pmemlog!logimpl_v.spec_get_live_header.?_definition))
 ))
 (let (($x7506 (fuel_bool fuel%pmemlog!logimpl_v.spec_get_live_header.)))
 (let (($x7504 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_get_live_header.)))
 (let (($x48923 (= $x7506 $x7504)))
 (let ((@x48940 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_get_live_header.) (or (not $x30) $x48923)) @x47707 (hypothesis (not $x48923)) false)))
 (let ((@x48953 (lemma @x48940 $x48923)))
 (let ((@x7505 (asserted $x7504)))
 (let ((@x48931 (def-axiom (or (not $x48923) $x7506 (not $x7504)))))
 (let ((@x51926 (unit-resolution (unit-resolution @x48931 @x7505 (or (not $x48923) $x7506)) @x48953 $x7506)))
 (let (($x7524 (not $x7506)))
 (let (($x7525 (or $x7524 $x7521)))
 (let ((?x13519 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7507 (pmemlog!logimpl_v.spec_get_live_header.? pm!)))
 (let (($x7519 (= ?x7507 ?x7518)))
 (refl (~ $x7519 $x7519)))))))))))))
 ))
 (let ((@x13524 (monotonicity (refl (~ $x7524 $x7524)) (nnf-pos (proof-bind ?x13519) (~ $x7521 $x7521)) (~ $x7525 $x7525))))
 (let ((@x7528 (mp (asserted (=> $x7506 $x7521)) (rewrite (= (=> $x7506 $x7521) $x7525)) $x7525)))
 (let ((@x13528 (mp (mp~ @x7528 @x13524 $x7525) (rewrite (= $x7525 $x7525)) $x7525)))
 (let (($x48959 (or (not $x7521) $x48955)))
 (let ((@x48960 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) $x48959)))
 (let ((@x51930 (symm (unit-resolution @x48960 (unit-resolution @x13528 @x51926 $x7521) $x48955) (= ?x48954 ?x46681))))
 (let ((@x51936 (monotonicity (monotonicity (monotonicity @x51930 (= ?x50793 ?x46682)) (= ?x50809 ?x46683)) (= ?x50825 ?x46684))))
 (let ((@x51940 (monotonicity (monotonicity @x51936 (= ?x50826 ?x46685)) (= ?x50827 ?x46686))))
 (let ((@x51943 (symm (monotonicity @x51940 (= ?x50831 ?x46690)) $x51145)))
 (let ((@x51957 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x51107 (not $x51220) $x51738 (not $x51147))) (unit-resolution (def-axiom (or $x51142 (not $x51107))) @x51951 (not $x51107)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51145) $x51220)) @x51943 $x51220) @x51920 $x51738)))
 (let ((@x51807 (def-axiom (or $x51772 $x51293))))
 (let ((@x51958 (unit-resolution @x51807 @x51957 $x51772)))
 (let ((@x51813 (def-axiom (or (not $x51792) $x51736 (not $x51772)))))
 (let ((@x51961 (unit-resolution (unit-resolution @x51813 @x51958 (or (not $x51792) $x51736)) (unit-resolution @x51803 @x12701 $x51792) $x51736)))
 (let ((@x51963 (lemma (unit-resolution @x51961 @x51912 false) $x46722)))
 (let ((@x47229 (def-axiom (or $x46837 (not $x46722)))))
 (let (($x47050 (not $x46837)))
 (let (($x47052 (or $x47050 $x47051)))
 (let (($x47096 (or %%switch_label%%0 (not (or $x46927 (not (or (or $x47009 $x47010) $x47011)))))))
 (let (($x47097 (not $x47096)))
 (let (($x47071 (not (or $x46980 (not (or (or $x46856 $x46843) $x46968))))))
 (let (($x47079 (or $x47071 $x46989)))
 (let (($x47078 (or $x46920 $x46906)))
 (let (($x47080 (or $x47078 $x47079)))
 (let (($x47086 (not (or (not $x47080) $x47002))))
 (let (($x47107 (or $x47086 $x47097)))
 (let (($x47106 (or $x46875 $x46932)))
 (let (($x47109 (or $x47106 $x47107)))
 (let (($x47105 (or $x46933 $x46911)))
 (let (($x47104 (or $x46951 $x46942)))
 (let (($x47108 (or $x47104 $x47105)))
 (let (($x47110 (or $x47108 $x47109)))
 (let (($x47116 (not (or $x47036 (not $x47110)))))
 (let (($x47124 (or $x46879 $x47116)))
 (let (($x47123 (or $x46910 $x46903)))
 (let (($x47125 (or $x47123 $x47124)))
 (let (($x47132 (or $x47050 (not $x47125))))
 (let ((@x47057 (trans (monotonicity (rewrite (= $x46912 $x47044)) (= $x46868 (and $x46837 $x47044))) (rewrite (= (and $x46837 $x47044) (not $x47052))) (= $x46868 (not $x47052)))))
 (let ((@x47064 (trans (monotonicity @x47057 (= (not $x46868) (not (not $x47052)))) (rewrite (= (not (not $x47052)) $x47052)) (= (not $x46868) $x47052))))
 (let (($x46872 (not $x46868)))
 (let ((@x46935 (monotonicity (monotonicity (rewrite (= $x46957 $x46957)) (= $x46912 $x46912)) (= $x46868 $x46868))))
 (let ((@x47065 (mp (mp (not-or-elim @x46870 $x46872) (monotonicity @x46935 (= $x46872 $x46872)) $x46872) @x47064 $x47052)))
 (let ((@x47231 (mp (mp @x47065 (rewrite (= $x47052 $x47132)) $x47132) (rewrite (= $x47132 $x47052)) $x47052)))
 (let ((@x52029 (unit-resolution @x47231 (unit-resolution @x47229 @x51963 $x46837) $x47051)))
 (let ((@x47456 (def-axiom (or $x47044 $x46729))))
 (let ((@x52034 (trans* @x51864 @x51866 @x51874 @x51875 @x51877 @x51879 @x51881 (symm (unit-resolution @x47456 @x52029 $x46729) (= ?x46719 tmp%4)) (= ?x46948 tmp%4))))
 (let ((@x52057 (symm (unit-resolution (def-axiom (or $x47044 $x46727)) @x52029 $x46727) (= ?x46726 tmp%3))))
 (let ((@x52042 (monotonicity @x51858 (= ?x46726 ?x46687))))
 (let ((@x52055 (symm @x52042 (= ?x46687 ?x46726))))
 (let ((?x47652 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x47023)))
 (let ((@x52044 (monotonicity @x51836 (= ?x46687 ?x47652))))
 (let ((@x52053 (symm @x52044 (= ?x47652 ?x46687))))
 (let (($x47656 (= ?x47652 ?x47015)))
 (let (($x2794 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2791 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail x)))
 (let ((?x2790 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail x)))
 (= ?x2790 ?x2791))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail x) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail_accessor_definition))
 ))
 (let ((?x11194 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2791 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail x)))
 (let ((?x2790 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail x)))
 (let (($x2792 (= ?x2790 ?x2791)))
 (refl (~ $x2792 $x2792))))))
 ))
 (let ((@x11198 (mp~ (asserted $x2794) (nnf-pos (proof-bind ?x11194) (~ $x2794 $x2794)) $x2794)))
 (let (($x47658 (not $x2794)))
 (let (($x47660 (or $x47658 $x47656)))
 (let ((?x47028 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x47023)))
 (let (($x47653 (= ?x47652 ?x47028)))
 (let (($x47661 (or $x47658 $x47653)))
 (let (($x47663 (= $x47661 $x47660)))
 (let ((@x47667 (trans (monotonicity (rewrite (= $x47653 $x47656)) $x47663) (rewrite (= $x47660 $x47660)) $x47663)))
 (let ((@x47668 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x47014 ?x47015 ?x47018)) $x47661) @x47667 $x47660)))
 (let ((@x52036 (unit-resolution @x47668 @x11198 $x47656)))
 (let ((@x52051 (symm @x52036 (= ?x47015 ?x47652))))
 (let (($x47654 (= ?x47028 ?x47015)))
 (let (($x47029 (= ?x47015 ?x47028)))
 (let ((@x52035 ((_ th-lemma datatype) $x47029)))
 (let ((@x52049 (symm @x52035 $x47654)))
 (let ((@x52046 (monotonicity @x51846 (= ?x47028 ?x46991))))
 (let ((@x52048 (symm @x52046 (= ?x46991 ?x47028))))
 (let ((?x46969 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46962)))
 (let (($x52039 (= ?x46969 ?x46991)))
 (let ((@x52040 (monotonicity @x51863 $x52039)))
 (let (($x46970 (= ?x46946 ?x46969)))
 (let ((@x52038 ((_ th-lemma datatype) $x46970)))
 (let ((@x52059 (trans* @x52038 @x52040 @x52048 @x52049 @x52051 @x52053 @x52055 @x52057 (= ?x46946 tmp%3))))
 (let ((@x52065 (monotonicity (symm (monotonicity @x52059 @x52034 (= $x51998 $x46731)) (= $x46731 $x51998)) (= (not $x46731) $x52018))))
 (let (($x52002 (= $x51998 $x51772)))
 (let (($x52005 (or $x51743 $x52002)))
 (let (($x51984 (req%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. ?x46991 ?x46994)))
 (let (($x51985 (= $x51984 $x51734)))
 (let (($x52007 (or $x51743 $x51985)))
 (let (($x52009 (= $x52007 $x52005)))
 (let ((@x52013 (trans (monotonicity (rewrite (= $x51985 $x52002)) $x52009) (rewrite (= $x52005 $x52005)) $x52009)))
 (let ((@x52014 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x52007) @x52013 $x52005)))
 (let ((@x52017 (def-axiom (or (not $x52002) $x51998 (not $x51772)))))
 (let ((@x52070 (unit-resolution (unit-resolution @x52017 @x51958 (or (not $x52002) $x51998)) (unit-resolution @x52014 @x12701 $x52002) $x51998)))
 (let ((@x52072 (lemma (unit-resolution @x52070 (mp (hypothesis (not $x46731)) @x52065 $x52018) false) $x46731)))
 (let ((@x47217 (def-axiom (or $x46841 (not $x46731)))))
 (let ((@x47450 (def-axiom (or $x47039 $x47036 $x47037))))
 (let ((@x52338 (unit-resolution @x47450 (unit-resolution (def-axiom (or $x47044 $x47038)) @x52029 $x47038) $x47038)))
 (let ((@x52339 (unit-resolution @x52338 (unit-resolution @x47217 @x52072 $x46841) $x47037)))
 (let ((@x47434 (def-axiom (or $x47027 $x46739))))
 (let ((@x52340 (unit-resolution @x47434 @x52339 $x46739)))
 (let ((@x52344 (trans* @x51864 @x51866 @x51874 @x51875 @x51877 @x51879 @x51881 (symm @x52340 (= ?x46719 log_size@)) (= ?x46948 log_size@))))
 (let (($x52348 (= ?x46946 tail@)))
 (let ((@x47432 (def-axiom (or $x47027 $x46737))))
 (let ((@x52345 (unit-resolution @x47432 @x52339 $x46737)))
 (let ((@x52347 (symm @x52345 (= ?x46726 tail@))))
 (let (($x51015 (= ?x46991 ?x46969)))
 (let (($x50959 (= ?x46985 ?x46962)))
 (let (($x46964 (= ?x46941 ?x46962)))
 (let ((@x51859 ((_ th-lemma datatype) $x46964)))
 (let ((@x56390 (trans* (symm @x51822 (= ?x46985 ?x46976)) (symm @x51823 (= ?x46976 ?x46941)) @x51859 $x50959)))
 (let ((@x56391 (monotonicity @x56390 $x51015)))
 (let ((@x47430 (def-axiom (or $x47027 $x46735))))
 (let ((@x52350 (unit-resolution @x47430 @x52339 $x46735)))
 (let ((@x52354 (trans* @x51886 @x51888 @x51896 @x51897 @x51899 @x51901 @x51903 (symm @x52350 (= ?x46716 head@)) (= ?x46943 head@))))
 (let ((@x56395 (monotonicity @x52354 (trans* @x52038 (symm @x56391 $x52039) @x52048 @x52049 @x52051 @x52053 @x52055 @x52347 $x52348) @x52344 (= $x55890 $x46779))))
 (let (($x52661 (req%pmemlog!math_v.lemma_mod_equal. ?x46943 ?x46946 ?x46948)))
 (let (($x52720 (not $x52661)))
 (let ((@x52349 (trans* @x52038 @x52040 @x52048 @x52049 @x52051 @x52053 @x52055 @x52347 $x52348)))
 (let ((@x52806 (monotonicity (symm (monotonicity @x52354 @x52349 @x52344 (= $x52661 $x46777)) (= $x46777 $x52661)) (= (not $x46777) $x52720))))
 (let ((?x52190 (Sub ?x46946 ?x46943)))
 (let ((?x52193 (* (- 1) ?x52190)))
 (let ((?x52196 (+ ?x46948 ?x52193)))
 (let (($x52195 (<= ?x52196 0)))
 (let (($x52198 (not $x52195)))
 (let (($x9966 (not %%global_location_label%%108)))
 (let (($x52587 (or $x9966 $x52198)))
 (let (($x52651 (not $x52587)))
 (let ((?x51407 (EucMod ?x46946 ?x46948)))
 (let ((?x51255 (EucMod ?x46943 ?x46948)))
 (let (($x52579 (= ?x51255 ?x51407)))
 (let (($x9951 (not %%global_location_label%%107)))
 (let (($x52617 (or $x9951 $x52579)))
 (let (($x52609 (not $x52617)))
 (let (($x52155 (<= ?x52154 0)))
 (let (($x9843 (not %%global_location_label%%106)))
 (let (($x52567 (or $x9843 $x52155)))
 (let (($x52574 (not $x52567)))
 (let (($x9899 (not %%global_location_label%%105)))
 (let (($x52562 (or $x9899 $x51738)))
 (let (($x52564 (not $x52562)))
 (let (($x52654 (or $x52564 $x52574 $x52609 $x52651)))
 (let (($x52663 (= $x52654 $x52661)))
 (let (($x52666 (not $x52663)))
 (let (($x18663 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9930 (req%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9966 (not %%global_location_label%%108)))
 (let (($x9967 (or $x9966 $x9885)))
 (let ((?x999 (EucMod y! d!)))
 (let ((?x9829 (EucMod x! d!)))
 (let (($x9944 (= ?x9829 ?x999)))
 (let (($x9951 (not %%global_location_label%%107)))
 (let (($x9952 (or $x9951 $x9944)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9843 (not %%global_location_label%%106)))
 (let (($x9846 (or $x9843 $x9850)))
 (let (($x18647 (or (not (or (not %%global_location_label%%105) (not (<= d! 0)))) (not $x9846) (not $x9952) (not $x9967))))
 (not (= $x18647 $x9930))))))))))))))))) :pattern ( (req%pmemlog!math_v.lemma_mod_equal. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_equal._definition))
 ))
 (let (($x9973 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9966 (not %%global_location_label%%108)))
 (let (($x9967 (or $x9966 $x9885)))
 (let ((?x999 (EucMod y! d!)))
 (let ((?x9829 (EucMod x! d!)))
 (let (($x9944 (= ?x9829 ?x999)))
 (let (($x9951 (not %%global_location_label%%107)))
 (let (($x9952 (or $x9951 $x9944)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9843 (not %%global_location_label%%106)))
 (let (($x9846 (or $x9843 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9899 (not %%global_location_label%%105)))
 (let (($x9901 (or $x9899 $x1155)))
 (let (($x9972 (and $x9901 $x9846 $x9952 $x9967)))
 (let (($x9930 (req%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (= $x9930 $x9972)))))))))))))))))))) :pattern ( (req%pmemlog!math_v.lemma_mod_equal. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_equal._definition))
 ))
 (let ((?x18664 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9930 (req%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9966 (not %%global_location_label%%108)))
 (let (($x9967 (or $x9966 $x9885)))
 (let ((?x999 (EucMod y! d!)))
 (let ((?x9829 (EucMod x! d!)))
 (let (($x9944 (= ?x9829 ?x999)))
 (let (($x9951 (not %%global_location_label%%107)))
 (let (($x9952 (or $x9951 $x9944)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9843 (not %%global_location_label%%106)))
 (let (($x9846 (or $x9843 $x9850)))
 (let (($x18647 (or (not (or (not %%global_location_label%%105) (not (<= d! 0)))) (not $x9846) (not $x9952) (not $x9967))))
 (let (($x18655 (not (= $x18647 $x9930))))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9899 (not %%global_location_label%%105)))
 (let (($x9901 (or $x9899 $x1155)))
 (let (($x9972 (and $x9901 $x9846 $x9952 $x9967)))
 (let (($x9962 (= $x9930 $x9972)))
 (let (($x18658 (= $x9962 $x18655)))
 (let ((@x18653 (monotonicity (rewrite (= $x9972 (not $x18647))) (= $x9962 (= $x9930 (not $x18647))))))
 (trans (trans @x18653 (rewrite (= (= $x9930 (not $x18647)) $x18655)) $x18658) (rewrite (= $x18655 $x18655)) $x18658))))))))))))))))))))))))))
 ))
 (let ((?x14504 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9966 (not %%global_location_label%%108)))
 (let (($x9967 (or $x9966 $x9885)))
 (let ((?x999 (EucMod y! d!)))
 (let ((?x9829 (EucMod x! d!)))
 (let (($x9944 (= ?x9829 ?x999)))
 (let (($x9951 (not %%global_location_label%%107)))
 (let (($x9952 (or $x9951 $x9944)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9843 (not %%global_location_label%%106)))
 (let (($x9846 (or $x9843 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9899 (not %%global_location_label%%105)))
 (let (($x9901 (or $x9899 $x1155)))
 (let (($x9972 (and $x9901 $x9846 $x9952 $x9967)))
 (let (($x9930 (req%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (let (($x9962 (= $x9930 $x9972)))
 (refl (~ $x9962 $x9962)))))))))))))))))))))))
 ))
 (let (($x9921 (forall ((x! Int) (y! Int) (d! Int) )(! (let ((?x999 (EucMod y! d!)))
 (let ((?x9829 (EucMod x! d!)))
 (let (($x9944 (= ?x9829 ?x999)))
 (let (($x9918 (and (=> %%global_location_label%%105 (> d! 0)) (=> %%global_location_label%%106 (<= x! y!)) (=> %%global_location_label%%107 $x9944) (=> %%global_location_label%%108 (< (Sub y! x!) d!)))))
 (let (($x9930 (req%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (= $x9930 $x9918)))))) :pattern ( (req%pmemlog!math_v.lemma_mod_equal. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_equal._definition))
 ))
 (let ((?x9975 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9966 (not %%global_location_label%%108)))
 (let (($x9967 (or $x9966 $x9885)))
 (let ((?x999 (EucMod y! d!)))
 (let ((?x9829 (EucMod x! d!)))
 (let (($x9944 (= ?x9829 ?x999)))
 (let (($x9951 (not %%global_location_label%%107)))
 (let (($x9952 (or $x9951 $x9944)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9843 (not %%global_location_label%%106)))
 (let (($x9846 (or $x9843 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9899 (not %%global_location_label%%105)))
 (let (($x9901 (or $x9899 $x1155)))
 (let (($x9972 (and $x9901 $x9846 $x9952 $x9967)))
 (let (($x9930 (req%pmemlog!math_v.lemma_mod_equal. x! y! d!)))
 (let (($x9962 (= $x9930 $x9972)))
 (let (($x9918 (and (=> %%global_location_label%%105 (> d! 0)) (=> %%global_location_label%%106 (<= x! y!)) (=> %%global_location_label%%107 $x9944) (=> %%global_location_label%%108 (< (Sub y! x!) d!)))))
 (let (($x9919 (= $x9930 $x9918)))
 (rewrite (= $x9919 $x9962)))))))))))))))))))))))))
 ))
 (let ((@x9955 (mp (asserted $x9921) (quant-intro (proof-bind ?x9975) (= $x9921 $x9973)) $x9973)))
 (let ((@x18668 (mp (mp~ @x9955 (nnf-pos (proof-bind ?x14504) (~ $x9973 $x9973)) $x9973) (quant-intro (proof-bind ?x18664) (= $x9973 $x18663)) $x18663)))
 (let (($x52673 (not $x18663)))
 (let (($x52674 (or $x52673 $x52666)))
 (let (($x52559 (req%pmemlog!math_v.lemma_mod_equal. ?x46987 ?x46991 ?x46994)))
 (let (($x52128 (not (<= (+ ?x46994 (* (- 1) (Sub ?x46991 ?x46987))) 0))))
 (let (($x52554 (or $x9966 $x52128)))
 (let (($x52555 (not $x52554)))
 (let ((?x51402 (EucMod ?x46991 ?x46994)))
 (let ((?x51246 (EucMod ?x46987 ?x46994)))
 (let (($x52549 (= ?x51246 ?x51402)))
 (let (($x52550 (or $x9951 $x52549)))
 (let (($x52553 (not $x52550)))
 (let ((?x52115 (* (- 1) ?x46987)))
 (let ((?x52116 (+ ?x46991 ?x52115)))
 (let (($x52117 (>= ?x52116 0)))
 (let (($x52547 (or $x9843 $x52117)))
 (let (($x52548 (not $x52547)))
 (let (($x52538 (or $x9899 $x51690)))
 (let (($x52541 (not $x52538)))
 (let (($x52556 (or $x52541 $x52548 $x52553 $x52555)))
 (let (($x52560 (= $x52556 $x52559)))
 (let (($x52561 (not $x52560)))
 (let (($x52675 (or $x52673 $x52561)))
 (let (($x52677 (= $x52675 $x52674)))
 (let (($x52668 (= $x52561 $x52666)))
 (let ((@x52672 (trans (monotonicity (rewrite (= $x52560 $x52663)) $x52668) (rewrite (= $x52666 $x52666)) $x52668)))
 (let ((@x52682 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x52675) (trans (monotonicity @x52672 $x52677) (rewrite (= $x52674 $x52674)) $x52677) $x52674)))
 (let ((@x52796 (unit-resolution @x52682 @x18668 $x52666)))
 (let (($x52717 (not $x52654)))
 (let ((?x46699 (* (- 1) ?x46690)))
 (let ((?x46700 (+ ?x46689 ?x46699)))
 (let (($x46697 (>= ?x46700 0)))
 (let (($x46702 (not $x46697)))
 (let ((@x46701 (trans (rewrite (= (< ?x46689 ?x46690) (not (<= ?x46690 ?x46689)))) (rewrite (= (not (<= ?x46690 ?x46689)) $x46702)) (= (< ?x46689 ?x46690) $x46702))))
 (let ((@x46704 (mp (asserted (< ?x46689 ?x46690)) @x46701 $x46702)))
 (let ((?x52270 (+ ?x46689 ?x52193)))
 (let (($x52272 (>= ?x52270 0)))
 (let (($x52105 (= ?x46689 ?x52190)))
 (let ((@x52516 (monotonicity (trans* @x52038 @x52040 @x52048 @x52049 @x52051 @x52053 (= ?x46946 ?x46687)) (trans* @x51886 @x51888 @x51896 @x51897 @x51899 @x51901 (= ?x46943 ?x46688)) (= ?x52190 ?x46689))))
 (let ((@x52517 (symm @x52516 $x52105)))
 (let ((@x52518 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x52105) $x52272)) @x52517 $x52272)))
 (let ((@x52522 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 1) (or $x52198 (not $x52272) (not $x51147) $x46697)) @x52518 @x51920 @x46704 $x52198)))
 (let ((@x52706 (def-axiom (or $x52587 $x52195))))
 (let ((@x52811 (unit-resolution @x52706 @x52522 $x52587)))
 (let ((?x51484 (* (- 1) ?x51407)))
 (let ((?x52179 (+ ?x51255 ?x51484)))
 (let (($x52180 (<= ?x52179 0)))
 (let ((?x51074 (%I ?x50832)))
 (let ((?x51075 (EucMod ?x50830 ?x51074)))
 (let ((?x55454 (Sub ?x46948 ?x51075)))
 (let ((?x55789 (* (- 1) ?x55454)))
 (let ((?x55415 (Sub ?x46948 ?x51255)))
 (let ((?x55809 (+ ?x55415 ?x55789)))
 (let (($x55769 (>= ?x55809 0)))
 (let (($x55787 (= ?x55415 ?x55454)))
 (let (($x51536 (= ?x51075 ?x51255)))
 (let ((@x52403 (trans* @x51864 @x51866 @x51874 @x51875 @x51877 @x51879 @x51943 (= ?x46948 ?x50831))))
 (let ((@x52409 (monotonicity (symm (monotonicity @x52403 (= (I ?x46948) ?x50832)) (= ?x50832 (I ?x46948))) (= ?x51074 (%I (I ?x46948))))))
 (let ((?x50996 (I ?x46948)))
 (let ((?x50998 (%I ?x50996)))
 (let (($x51001 (= ?x46948 ?x50998)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x10191 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x10195 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x10191) (~ $x237 $x237)) $x237)))
 (let (($x49974 (not $x237)))
 (let (($x51000 (or $x49974 $x51001)))
 (let (($x50989 (= ?x46994 (%I (I ?x46994)))))
 (let (($x51002 (or $x49974 $x50989)))
 (let (($x51006 (= $x51002 $x51000)))
 (let ((@x51010 (trans (monotonicity (rewrite (= $x50989 $x51001)) $x51006) (rewrite (= $x51000 $x51000)) $x51006)))
 (let ((@x51011 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x51002) @x51010 $x51000)))
 (let ((@x52401 (unit-resolution @x51011 @x10195 $x51001)))
 (let ((@x52415 (trans* @x52401 (symm @x52409 (= ?x50998 ?x51074)) (= ?x46948 ?x51074))))
 (let ((@x52301 (symm (monotonicity @x51940 (= ?x50828 ?x46688)) (= ?x46688 ?x50828))))
 (let ((@x52442 (monotonicity (trans* @x51886 @x51888 @x51896 @x51897 @x51899 @x51901 @x52301 (= ?x46943 ?x50828)) (= (I ?x46943) ?x50829))))
 (let ((@x52446 (monotonicity (symm @x52442 (= ?x50829 (I ?x46943))) (= ?x50830 (%I (I ?x46943))))))
 (let ((@x52450 (symm @x52446 (= (%I (I ?x46943)) ?x50830))))
 (let ((?x50968 (I ?x46943)))
 (let ((?x50970 (%I ?x50968)))
 (let (($x50973 (= ?x46943 ?x50970)))
 (let (($x50972 (or $x49974 $x50973)))
 (let (($x50953 (= ?x46987 (%I (I ?x46987)))))
 (let (($x50974 (or $x49974 $x50953)))
 (let (($x50978 (= $x50974 $x50972)))
 (let ((@x50982 (trans (monotonicity (rewrite (= $x50953 $x50973)) $x50978) (rewrite (= $x50972 $x50972)) $x50978)))
 (let ((@x50983 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985)) $x50974) @x50982 $x50972)))
 (let ((@x52438 (unit-resolution @x50983 @x10195 $x50973)))
 (let ((@x52455 (symm (monotonicity (trans* @x52438 @x52450 (= ?x46943 ?x50830)) @x52415 (= ?x51255 ?x51075)) $x51536)))
 (let ((@x56060 (symm (monotonicity @x52455 (= ?x55454 ?x55415)) $x55787)))
 (let ((?x55518 (vstd!seq.Seq.len.? $ ?x1876 ?x50849)))
 (let ((?x55645 (Add ?x55415 ?x55518)))
 (let ((?x55713 (* (- 1) ?x55645)))
 (let ((?x55806 (+ ?x52190 ?x55713)))
 (let (($x55807 (<= ?x55806 0)))
 (let (($x55805 (= ?x52190 ?x55645)))
 (let ((?x51078 (%I ?x50836)))
 (let ((?x51079 (EucMod ?x51078 ?x51074)))
 (let ((?x51083 (Add ?x51079 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x55704 (Sub ?x51083 72)))
 (let ((?x55436 (* (- 1) ?x55704)))
 (let ((?x55437 (+ ?x51083 ?x55436)))
 (let (($x55423 (<= ?x55437 72)))
 (let (($x55391 (= ?x55437 72)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x10436 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x10440 (mp~ @x956 (nnf-pos (proof-bind ?x10436) (~ $x951 $x951)) $x951)))
 (let (($x47606 (not $x951)))
 (let (($x55439 (or $x47606 $x55391)))
 (let (($x55706 (= (+ 72 (* (- 1) ?x51083) ?x55704) 0)))
 (let (($x55440 (or $x47606 $x55706)))
 (let (($x55442 (= $x55440 $x55439)))
 (let ((@x55422 (trans (monotonicity (rewrite (= $x55706 $x55391)) $x55442) (rewrite (= $x55439 $x55439)) $x55442)))
 (let ((@x55424 (mp ((_ quant-inst (Add ?x51079 pmemlog!logimpl_v.contents_offset.?) 72) $x55440) @x55422 $x55439)))
 (let ((@x55665 (unit-resolution @x55424 @x10440 $x55391)))
 (let (($x55426 (>= ?x55437 72)))
 (let ((?x7409 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_log_size_offset.?)))
 (let ((?x7410 (uClip 64 ?x7409)))
 (let ((?x7411 (Add ?x7410 8)))
 (let ((?x7412 (uClip 64 ?x7411)))
 (let ((?x51238 (Add ?x51079 ?x7412)))
 (let ((?x51239 (* (- 1) ?x51238)))
 (let ((?x51244 (+ ?x7412 ?x51079 ?x51239)))
 (let (($x51250 (<= ?x51244 0)))
 (let (($x51245 (= ?x51244 0)))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x10429 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x10433 (mp~ @x925 (nnf-pos (proof-bind ?x10429) (~ $x920 $x920)) $x920)))
 (let (($x48868 (not $x920)))
 (let (($x51248 (or $x48868 $x51245)))
 (let ((@x51249 ((_ quant-inst (EucMod ?x51078 ?x51074) (uClip 64 ?x7411)) $x51248)))
 (let ((@x52490 (unit-resolution @x51249 @x10433 $x51245)))
 (let ((@x52627 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51245) $x51250)) @x52490 $x51250)))
 (let (($x51251 (>= ?x51244 0)))
 (let ((@x52491 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51245) $x51251)) @x52490 $x51251)))
 (let ((?x51533 (+ ?x50837 ?x51239)))
 (let (($x51534 (<= ?x51533 0)))
 (let (($x51532 (= ?x50837 ?x51238)))
 (let (($x7413 (= pmemlog!logimpl_v.contents_offset.? ?x7412)))
 (let (($x7407 (fuel_bool fuel%pmemlog!logimpl_v.contents_offset.)))
 (let (($x7405 (fuel_bool_default fuel%pmemlog!logimpl_v.contents_offset.)))
 (let (($x48679 (= $x7407 $x7405)))
 (let ((@x48696 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.contents_offset.) (or (not $x30) $x48679)) @x47707 (hypothesis (not $x48679)) false)))
 (let ((@x48709 (lemma @x48696 $x48679)))
 (let ((@x7406 (asserted $x7405)))
 (let ((@x48687 (def-axiom (or (not $x48679) $x7407 (not $x7405)))))
 (let ((@x52462 (unit-resolution (unit-resolution @x48687 @x7406 (or (not $x48679) $x7407)) @x48709 $x7407)))
 (let (($x7416 (not $x7407)))
 (let (($x7417 (or $x7416 $x7413)))
 (let ((@x7420 (mp (asserted (=> $x7407 $x7413)) (rewrite (= (=> $x7407 $x7413) $x7417)) $x7417)))
 (let ((@x52465 (symm (unit-resolution @x7420 @x52462 $x7413) (= ?x7412 pmemlog!logimpl_v.contents_offset.?))))
 (let (($x51084 (= ?x50837 ?x51083)))
 (let (($x7609 (forall ((addr! Poly) (log_size! Poly) )(! (let ((?x7603 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? addr! log_size!)))
 (= ?x7603 (Add (EucMod (%I addr!) (%I log_size!)) pmemlog!logimpl_v.contents_offset.?))) :pattern ( (pmemlog!logimpl_v.spec_addr_logical_to_physical.? addr! log_size!) ) :qid internal_pmemlog!logimpl_v.spec_addr_logical_to_physical.?_definition))
 ))
 (let (($x7602 (fuel_bool fuel%pmemlog!logimpl_v.spec_addr_logical_to_physical.)))
 (let (($x7600 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_addr_logical_to_physical.)))
 (let (($x50788 (= $x7602 $x7600)))
 (let ((@x50805 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_addr_logical_to_physical.) (or (not $x30) $x50788)) @x47707 (hypothesis (not $x50788)) false)))
 (let ((@x50818 (lemma @x50805 $x50788)))
 (let ((@x7601 (asserted $x7600)))
 (let ((@x50796 (def-axiom (or (not $x50788) $x7602 (not $x7600)))))
 (let ((@x52468 (unit-resolution (unit-resolution @x50796 @x7601 (or (not $x50788) $x7602)) @x50818 $x7602)))
 (let (($x7614 (not $x7602)))
 (let (($x7618 (or $x7614 $x7609)))
 (let ((?x13554 (lambda ((addr! Poly) (log_size! Poly) )(let ((?x7603 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? addr! log_size!)))
 (let (($x7607 (= ?x7603 (Add (EucMod (%I addr!) (%I log_size!)) pmemlog!logimpl_v.contents_offset.?))))
 (refl (~ $x7607 $x7607)))))
 ))
 (let ((@x13559 (monotonicity (refl (~ $x7614 $x7614)) (nnf-pos (proof-bind ?x13554) (~ $x7609 $x7609)) (~ $x7618 $x7618))))
 (let ((@x7624 (mp (asserted (=> $x7602 $x7609)) (rewrite (= (=> $x7602 $x7609) $x7618)) $x7618)))
 (let ((@x13563 (mp (mp~ @x7624 @x13559 $x7618) (rewrite (= $x7618 $x7618)) $x7618)))
 (let ((@x52469 (unit-resolution @x13563 @x52468 $x7609)))
 (let (($x51080 (not $x7609)))
 (let (($x51087 (or $x51080 $x51084)))
 (let ((@x51088 ((_ quant-inst (I ?x50835) (I ?x50831)) $x51087)))
 (let ((@x52470 (unit-resolution @x51088 @x52469 $x51084)))
 (let ((@x52475 (trans* @x52470 (symm (monotonicity @x52465 (= ?x51238 ?x51083)) (= ?x51083 ?x51238)) $x51532)))
 (let ((@x52476 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51532) $x51534)) @x52475 $x51534)))
 (let (($x51535 (>= ?x51533 0)))
 (let ((@x52621 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51532) $x51535)) @x52475 $x51535)))
 (let ((?x51541 (+ ?x51079 ?x51484)))
 (let (($x51542 (<= ?x51541 0)))
 (let (($x51540 (= ?x51079 ?x51407)))
 (let ((@x52745 (trans* @x52409 (symm @x52401 (= ?x50998 ?x46948)) (= ?x51074 ?x46948))))
 (let ((?x51021 (I ?x46946)))
 (let ((?x51023 (%I ?x51021)))
 (let (($x51026 (= ?x46946 ?x51023)))
 (let (($x51025 (or $x49974 $x51026)))
 (let (($x51014 (= ?x46991 (%I (I ?x46991)))))
 (let (($x51027 (or $x49974 $x51014)))
 (let (($x51031 (= $x51027 $x51025)))
 (let ((@x51035 (trans (monotonicity (rewrite (= $x51014 $x51026)) $x51031) (rewrite (= $x51025 $x51025)) $x51031)))
 (let ((@x51036 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985)) $x51027) @x51035 $x51025)))
 (let ((@x52416 (unit-resolution @x51036 @x10195 $x51026)))
 (let (($x51226 (= ?x46687 ?x50835)))
 (let ((@x52326 (symm (monotonicity @x51940 (= ?x50835 ?x46687)) $x51226)))
 (let ((@x52420 (monotonicity (trans* @x52038 @x52040 @x52048 @x52049 @x52051 @x52053 @x52326 (= ?x46946 ?x50835)) (= ?x51021 ?x50836))))
 (let ((@x52424 (monotonicity (symm @x52420 (= ?x50836 ?x51021)) (= ?x51078 ?x51023))))
 (let ((@x55875 (monotonicity (trans* @x52424 (symm @x52416 (= ?x51023 ?x46946)) (= ?x51078 ?x46946)) @x52745 $x51540)))
 (let ((@x52400 ((_ th-lemma arith triangle-eq) (or (not $x51540) $x51542))))
 (let ((@x55897 (unit-resolution @x52400 @x55875 $x51542)))
 (let (($x51543 (>= ?x51541 0)))
 (let ((@x52608 ((_ th-lemma arith triangle-eq) (or (not $x51540) $x51543))))
 (let ((@x55858 (unit-resolution @x52608 @x55875 $x51543)))
 (let ((?x48799 (* (- 1) ?x7410)))
 (let ((?x48839 (+ ?x7409 ?x48799)))
 (let (($x48840 (<= ?x48839 0)))
 (let (($x48788 (= ?x7409 ?x7410)))
 (let ((?x48812 (* (- 1) ?x7409)))
 (let ((?x441 (uHi 64)))
 (let ((?x48813 (+ ?x441 ?x48812)))
 (let (($x48814 (<= ?x48813 0)))
 (let (($x48784 (>= ?x7409 0)))
 (let (($x48785 (not $x48784)))
 (let (($x48819 (or $x48785 $x48814 $x48788)))
 (let (($x48825 (not $x48819)))
 (let ((?x48800 (+ ?x441 ?x48799)))
 (let (($x48801 (<= ?x48800 0)))
 (let (($x48780 (>= ?x7410 0)))
 (let (($x48781 (not $x48780)))
 (let (($x48827 (or $x48781 $x48801 $x48825)))
 (let (($x48834 (not $x48827)))
 (let (($x14565 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x14549 (or $x540 $x578 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (not (or (not (>= ?x543 0)) $x564 (not $x14549)))))))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let (($x586 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (and $x558 $x569 $x587)))))))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let ((?x14566 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x14549 (or $x540 $x578 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x14560 (not (or (not (>= ?x543 0)) $x564 (not $x14549)))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (let ((@x14538 (rewrite (= $x584 (not (or $x540 $x578))))))
 (let ((@x14545 (trans (monotonicity @x14538 (= $x581 (not (not (or $x540 $x578))))) (rewrite (= (not (not (or $x540 $x578))) (or $x540 $x578))) (= $x581 (or $x540 $x578)))))
 (let ((@x14553 (trans (monotonicity @x14545 (= $x587 (or (or $x540 $x578) $x550))) (rewrite (= (or (or $x540 $x578) $x550) $x14549)) (= $x587 $x14549))))
 (trans (monotonicity @x14553 (= $x593 (and $x558 $x569 $x14549))) (rewrite (= (and $x558 $x569 $x14549) $x14560)) (= $x593 $x14560))))))))))))))))))))
 ))
 (let ((?x10289 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (refl (~ $x593 $x593)))))))))))))
 ))
 (let (($x554 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (and (<= 0 ?x543) (< ?x543 (uHi bits)) (=> $x548 $x550)))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let ((?x588 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (let (($x552 (and (<= 0 ?x543) (< ?x543 (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) $x550))))
 (rewrite (= $x552 $x593))))))))))))))
 ))
 (let ((@x571 (mp (asserted $x554) (quant-intro (proof-bind ?x588) (= $x554 $x586)) $x586)))
 (let ((@x14570 (mp (mp~ @x571 (nnf-pos (proof-bind ?x10289) (~ $x586 $x586)) $x586) (quant-intro (proof-bind ?x14566) (= $x586 $x14565)) $x14565)))
 (let (($x48744 (not $x14565)))
 (let (($x48826 (or $x48744 $x48834)))
 (let ((?x45959 (* (- 1) ?x441)))
 (let ((?x48782 (+ ?x7410 ?x45959)))
 (let (($x48783 (>= ?x48782 0)))
 (let (($x48792 (not (or $x48781 $x48783 (not (or $x48785 (>= (+ ?x7409 ?x45959) 0) $x48788))))))
 (let (($x48828 (or $x48744 $x48792)))
 (let (($x48830 (= $x48828 $x48826)))
 (let ((@x48836 (trans (monotonicity (rewrite (= $x48792 $x48834)) $x48830) (rewrite (= $x48826 $x48826)) $x48830)))
 (let ((@x48838 (mp ((_ quant-inst 64 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_log_size_offset.?)) $x48828) @x48836 $x48826)))
 (let ((@x55157 (unit-resolution @x48838 @x14570 $x48834)))
 (let ((@x48858 (def-axiom (or $x48827 $x48819))))
 (let (($x48909 (>= ?x7409 64)))
 (let (($x48907 (= ?x7409 64)))
 (let ((?x48880 (Add 40 24)))
 (let (($x48891 (= ?x48880 64)))
 (let (($x48895 (or $x48868 $x48891)))
 (let ((?x48881 (* (- 1) ?x48880)))
 (let ((?x48882 (+ 24 40 ?x48881)))
 (let (($x48883 (= ?x48882 0)))
 (let (($x48896 (or $x48868 $x48883)))
 (let (($x48898 (= $x48896 $x48895)))
 (let ((@x48889 (monotonicity (rewrite (= ?x48882 (+ 64 ?x48881))) (= $x48883 (= (+ 64 ?x48881) 0)))))
 (let ((@x48894 (trans @x48889 (rewrite (= (= (+ 64 ?x48881) 0) $x48891)) (= $x48883 $x48891))))
 (let ((@x48903 (mp ((_ quant-inst 40 24) $x48896) (trans (monotonicity @x48894 $x48898) (rewrite (= $x48895 $x48895)) $x48898) $x48895)))
 (let (($x7306 (= pmemlog!logimpl_v.header_log_size_offset.? 24)))
 (let (($x7303 (fuel_bool fuel%pmemlog!logimpl_v.header_log_size_offset.)))
 (let (($x7301 (fuel_bool_default fuel%pmemlog!logimpl_v.header_log_size_offset.)))
 (let (($x48614 (= $x7303 $x7301)))
 (let ((@x48644 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_log_size_offset.) (or (not $x30) $x48614)) @x47707 (hypothesis (not $x48614)) false)))
 (let ((@x48657 (lemma @x48644 $x48614)))
 (let ((@x7302 (asserted $x7301)))
 (let ((@x48635 (def-axiom (or (not $x48614) $x7303 (not $x7301)))))
 (let ((@x54862 (unit-resolution (unit-resolution @x48635 @x7302 (or (not $x48614) $x7303)) @x48657 $x7303)))
 (let (($x7309 (not $x7303)))
 (let (($x7310 (or $x7309 $x7306)))
 (let ((@x7313 (mp (asserted (=> $x7303 $x7306)) (rewrite (= (=> $x7303 $x7306) $x7310)) $x7310)))
 (let ((@x54863 (unit-resolution @x7313 @x54862 $x7306)))
 (let (($x7249 (= pmemlog!logimpl_v.header2_pos.? 40)))
 (let (($x7246 (fuel_bool fuel%pmemlog!logimpl_v.header2_pos.)))
 (let (($x7244 (fuel_bool_default fuel%pmemlog!logimpl_v.header2_pos.)))
 (let (($x48543 (= $x7246 $x7244)))
 (let ((@x48573 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header2_pos.) (or (not $x30) $x48543)) @x47707 (hypothesis (not $x48543)) false)))
 (let ((@x48586 (lemma @x48573 $x48543)))
 (let ((@x7245 (asserted $x7244)))
 (let ((@x48564 (def-axiom (or (not $x48543) $x7246 (not $x7244)))))
 (let ((@x54430 (unit-resolution (unit-resolution @x48564 @x7245 (or (not $x48543) $x7246)) @x48586 $x7246)))
 (let (($x7252 (not $x7246)))
 (let (($x7253 (or $x7252 $x7249)))
 (let ((@x7256 (mp (asserted (=> $x7246 $x7249)) (rewrite (= (=> $x7246 $x7249) $x7253)) $x7253)))
 (let ((@x54431 (unit-resolution @x7256 @x54430 $x7249)))
 (let ((@x55136 (trans* (monotonicity @x54431 @x54863 (= ?x7409 ?x48880)) (unit-resolution @x48903 @x10433 $x48891) $x48907)))
 (let ((@x55122 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48907) $x48909)) @x55136 $x48909)))
 (let ((@x55123 (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x48909) $x48784)) @x55122 $x48784)))
 (let (($x48844 (not $x48814)))
 (let (($x46667 (>= ?x441 18446744073709551616)))
 (let (($x443 (= ?x441 18446744073709551616)))
 (let ((@x444 (asserted $x443)))
 (let ((@x55155 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x443) $x46667)) @x444 $x46667)))
 (let (($x48908 (<= ?x7409 64)))
 (let ((@x55151 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48907) $x48908)) @x55136 $x48908)))
 (let ((@x55156 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x48844 (not $x46667) (not $x48908))) @x55151 @x55155 $x48844)))
 (let ((@x48851 (def-axiom (or $x48825 $x48785 $x48814 $x48788))))
 (let ((@x55164 (unit-resolution @x48851 @x55156 @x55123 (unit-resolution @x48858 @x55157 $x48819) $x48788)))
 (let ((@x55196 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48788) $x48840)) @x55164 $x48840)))
 (let (($x48841 (>= ?x48839 0)))
 (let ((@x55143 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48788) $x48841)) @x55164 $x48841)))
 (let ((?x48730 (* (- 1) ?x7411)))
 (let ((?x48864 (+ ?x7410 ?x48730)))
 (let (($x48878 (<= ?x48864 (- 8))))
 (let (($x48865 (= ?x48864 (- 8))))
 (let (($x48869 (or $x48868 $x48865)))
 (let (($x48862 (= (+ 8 ?x7410 ?x48730) 0)))
 (let (($x48870 (or $x48868 $x48862)))
 (let (($x48872 (= $x48870 $x48869)))
 (let ((@x48876 (trans (monotonicity (rewrite (= $x48862 $x48865)) $x48872) (rewrite (= $x48869 $x48869)) $x48872)))
 (let ((@x48877 (mp ((_ quant-inst (uClip 64 ?x7409) 8) $x48870) @x48876 $x48869)))
 (let ((@x55160 (unit-resolution @x48877 @x10433 $x48865)))
 (let ((@x55171 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48865) $x48878)) @x55160 $x48878)))
 (let (($x48879 (>= ?x48864 (- 8))))
 (let ((@x55161 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48865) $x48879)) @x55160 $x48879)))
 (let ((?x48717 (* (- 1) ?x7412)))
 (let ((?x48758 (+ ?x7411 ?x48717)))
 (let (($x48759 (<= ?x48758 0)))
 (let (($x48705 (= ?x7411 ?x7412)))
 (let ((?x48731 (+ ?x441 ?x48730)))
 (let (($x48732 (<= ?x48731 0)))
 (let (($x48701 (>= ?x7411 0)))
 (let (($x48702 (not $x48701)))
 (let (($x48737 (or $x48702 $x48732 $x48705)))
 (let (($x48743 (not $x48737)))
 (let ((?x48718 (+ ?x441 ?x48717)))
 (let (($x48719 (<= ?x48718 0)))
 (let (($x48695 (>= ?x7412 0)))
 (let (($x48668 (not $x48695)))
 (let (($x48745 (or $x48668 $x48719 $x48743)))
 (let (($x48752 (not $x48745)))
 (let (($x48746 (or $x48744 $x48752)))
 (let ((?x48684 (+ ?x7412 ?x45959)))
 (let (($x48700 (>= ?x48684 0)))
 (let (($x48710 (not (or $x48668 $x48700 (not (or $x48702 (>= (+ ?x7411 ?x45959) 0) $x48705))))))
 (let (($x48747 (or $x48744 $x48710)))
 (let (($x48749 (= $x48747 $x48746)))
 (let ((@x48756 (trans (monotonicity (rewrite (= $x48710 $x48752)) $x48749) (rewrite (= $x48746 $x48746)) $x48749)))
 (let ((@x48757 (mp ((_ quant-inst 64 (Add ?x7410 8)) $x48747) @x48756 $x48746)))
 (let ((@x48777 (def-axiom (or $x48745 $x48737))))
 (let ((@x55172 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x48701 $x48781 (not $x48878))) (unit-resolution (def-axiom (or $x48827 $x48780)) @x55157 $x48780) @x55171 $x48701)))
 (let (($x48763 (not $x48732)))
 (let ((@x55165 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1) (or $x48763 (not $x46667) (not $x48879) (not $x48908) (not $x48841))) @x55143 @x55155 @x55161 @x55151 $x48763)))
 (let ((@x48770 (def-axiom (or $x48743 $x48702 $x48732 $x48705))))
 (let ((@x55173 (unit-resolution @x48770 @x55165 @x55172 (unit-resolution @x48777 (unit-resolution @x48757 @x14570 $x48752) $x48737) $x48705)))
 (let ((@x55174 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48705) $x48759)) @x55173 $x48759)))
 (let (($x48760 (>= ?x48758 0)))
 (let ((@x55546 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48705) $x48760)) @x55173 $x48760)))
 (let ((?x54968 (* (- 1) ?x51083)))
 (let ((?x54983 (+ ?x50837 ?x54968)))
 (let (($x54770 (<= ?x54983 0)))
 (let ((@x55205 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51084) $x54770)) @x52470 $x54770)))
 (let (($x54771 (>= ?x54983 0)))
 (let ((@x55076 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51084) $x54771)) @x52470 $x54771)))
 (let ((@x55667 ((_ th-lemma arith eq-propagate 1 1 1 1 1 1 -1 -1 1 1 -1 -1 -1 -1 1 1 1 1) @x55076 @x55205 @x55546 @x55174 @x55161 @x55171 @x55122 @x55151 @x55143 @x55196 @x55858 @x55897 @x52621 @x52476 @x52491 @x52627 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55391) $x55426)) @x55665 $x55426) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55391) $x55423)) @x55665 $x55423) (= ?x51407 ?x55704))))
 (let ((?x55612 (%I ?x7471)))
 (let ((?x55621 (* (- 1) ?x55612)))
 (let ((?x55670 (+ ?x7412 ?x55621)))
 (let (($x55671 (<= ?x55670 0)))
 (let (($x54717 (= ?x7412 ?x55612)))
 (let ((@x54801 (monotonicity @x52465 (= (I ?x7412) ?x7471))))
 (let ((?x50032 (I ?x7412)))
 (let ((?x50033 (%I ?x50032)))
 (let (($x50036 (= ?x7412 ?x50033)))
 (let (($x50039 (or $x49974 $x50036)))
 (let ((@x50040 ((_ quant-inst (uClip 64 ?x7411)) $x50039)))
 (let ((@x55489 (trans* (unit-resolution @x50040 @x10195 $x50036) (monotonicity @x54801 (= ?x50033 ?x55612)) $x54717)))
 (let ((@x55490 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54717) $x55671)) @x55489 $x55671)))
 (let (($x55672 (>= ?x55670 0)))
 (let ((@x55855 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54717) $x55672)) @x55489 $x55672)))
 (let ((@x55650 ((_ th-lemma arith eq-propagate 1 1 1 1 1 1 -1 -1 1 1) @x55855 @x55490 @x55546 @x55174 @x55161 @x55171 @x55122 @x55151 @x55143 @x55196 (= ?x55612 72))))
 (let ((?x54712 (%I ?x50848)))
 (let ((?x54713 (I ?x54712)))
 (let (($x54767 (= ?x50848 ?x54713)))
 (let (($x52275 (has_type ?x50848 INT)))
 (let ((?x52279 (I ?x51083)))
 (let (($x55085 (has_type ?x52279 INT)))
 (let (($x55097 (not $x55085)))
 (let ((@x55092 (monotonicity (symm @x52470 (= ?x51083 ?x50837)) (= ?x52279 ?x50848))))
 (let ((@x55099 (monotonicity (symm (monotonicity @x55092 (= $x55085 $x52275)) (= $x52275 $x55085)) (= (not $x52275) $x55097))))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x10331 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x10335 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x10331) (~ $x698 $x698)) $x698)))
 (let ((@x55102 (unit-resolution (unit-resolution ((_ quant-inst (Add ?x51079 pmemlog!logimpl_v.contents_offset.?)) (or (not $x698) $x55085)) @x10335 $x55085) (mp (hypothesis (not $x52275)) @x55099 $x55097) false)))
 (let ((@x55103 (lemma @x55102 $x52275)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x10212 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x10216 (mp~ @x280 (nnf-pos (proof-bind ?x10212) (~ $x275 $x275)) $x275)))
 (let (($x52276 (not $x52275)))
 (let (($x54732 (not $x275)))
 (let (($x54759 (or $x54732 $x52276 $x54767)))
 (let ((@x54711 (mp ((_ quant-inst (I ?x50837)) (or $x54732 (or $x52276 $x54767))) (rewrite (= (or $x54732 (or $x52276 $x54767)) $x54759)) $x54759)))
 (let ((@x55112 (symm (unit-resolution @x54711 @x10216 @x55103 $x54767) (= ?x54713 ?x50848))))
 (let ((@x55282 (symm (monotonicity @x55112 (= (%I ?x54713) ?x54712)) (= ?x54712 (%I ?x54713)))))
 (let ((@x55280 (symm (monotonicity (symm @x55092 (= ?x50848 ?x52279)) (= ?x54712 (%I ?x52279))) (= (%I ?x52279) ?x54712))))
 (let ((?x52280 (%I ?x52279)))
 (let (($x52287 (= ?x51083 ?x52280)))
 (let (($x54783 (or $x49974 $x52287)))
 (let ((@x54784 ((_ quant-inst (Add ?x51079 pmemlog!logimpl_v.contents_offset.?)) $x54783)))
 (let ((@x55270 (unit-resolution @x54784 @x10195 $x52287)))
 (let ((@x55317 (trans* @x55270 @x55280 @x55282 (= ?x51083 (%I ?x54713)))))
 (let ((@x55703 (monotonicity @x55317 (symm @x55650 (= 72 ?x55612)) (= ?x55704 (Sub (%I ?x54713) ?x55612)))))
 (let ((?x54928 (%I ?x54713)))
 (let ((?x55626 (Sub ?x54928 ?x55612)))
 (let ((?x55388 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7471 ?x54713)))
 (let ((?x55625 (vstd!seq.Seq.len.? $ ?x1876 ?x55388)))
 (let (($x55627 (= ?x55625 ?x55626)))
 (let ((?x55622 (+ ?x54928 ?x55621)))
 (let (($x55623 (>= ?x55622 0)))
 (let (($x51478 (>= ?x51407 0)))
 (let ((?x51409 (mod ?x46946 ?x46948)))
 (let ((?x51412 (* (- 1) ?x51409)))
 (let ((?x51415 (+ ?x51407 ?x51412)))
 (let (($x51435 (>= ?x51415 0)))
 (let (($x51414 (= ?x51415 0)))
 (let (($x1010 (forall ((x Int) (y Int) )(! (= (+ (EucMod x y) (* (- 1) (mod x y))) 0) :pattern ( (EucMod x y) ) :qid prelude_eucmod))
 ))
 (let ((?x10457 (lambda ((x Int) (y Int) )(let (($x1007 (= (+ (EucMod x y) (* (- 1) (mod x y))) 0)))
 (refl (~ $x1007 $x1007))))
 ))
 (let (($x1003 (forall ((x Int) (y Int) )(! (let ((?x1000 (mod x y)))
 (let ((?x999 (EucMod x y)))
 (= ?x999 ?x1000))) :pattern ( (EucMod x y) ) :qid prelude_eucmod))
 ))
 (let ((?x1011 (lambda ((x Int) (y Int) )(let (($x1007 (= (+ (EucMod x y) (* (- 1) (mod x y))) 0)))
 (let ((?x1000 (mod x y)))
 (let ((?x999 (EucMod x y)))
 (let (($x1001 (= ?x999 ?x1000)))
 (rewrite (= $x1001 $x1007)))))))
 ))
 (let ((@x1015 (mp (asserted $x1003) (quant-intro (proof-bind ?x1011) (= $x1003 $x1010)) $x1010)))
 (let ((@x10461 (mp~ @x1015 (nnf-pos (proof-bind ?x10457) (~ $x1010 $x1010)) $x1010)))
 (let (($x51265 (not $x1010)))
 (let (($x51417 (or $x51265 $x51414)))
 (let (($x51406 (= (+ ?x51402 (* (- 1) (mod ?x46991 ?x46994))) 0)))
 (let (($x51419 (or $x51265 $x51406)))
 (let (($x51421 (= $x51419 $x51417)))
 (let ((@x51425 (trans (monotonicity (rewrite (= $x51406 $x51414)) $x51421) (rewrite (= $x51417 $x51417)) $x51421)))
 (let ((@x51426 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x51419) @x51425 $x51417)))
 (let ((@x55857 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51414) $x51435)) (unit-resolution @x51426 @x10461 $x51414) $x51435)))
 (let (($x51468 (>= ?x51409 0)))
 (let (($x51336 (= ?x46948 0)))
 (let (($x55181 (not $x51336)))
 (let ((@x55184 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x55181 $x51293)) @x51957 $x55181)))
 (let ((@x55860 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x51478 (not $x51468) (not $x51435))) (unit-resolution ((_ th-lemma arith) (or $x51336 $x51468)) @x55184 $x51468) @x55857 $x51478)))
 (let ((?x54976 (* (- 1) ?x54928)))
 (let ((?x54972 (+ ?x50837 ?x54976)))
 (let (($x54966 (<= ?x54972 0)))
 (let (($x54971 (= ?x50837 ?x54928)))
 (let ((@x55283 (trans* @x52470 @x55270 @x55280 @x55282 $x54971)))
 (let ((@x55294 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54971) $x54966)) @x55283 $x54966)))
 (let (($x52632 (not $x51250)))
 (let (($x52631 (not $x51535)))
 (let (($x52629 (not $x51543)))
 (let (($x51481 (not $x51478)))
 (let (($x55299 (not $x54966)))
 (let ((@x55866 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1 -1 1 -1) (or $x55623 $x55299 $x51481 $x52629 $x52631 $x52632 (not $x55672))) @x55855 @x52621 @x55858 @x55294 @x55860 @x52627 $x55623)))
 (let (($x55613 (>= ?x55612 0)))
 (let ((@x55452 ((_ th-lemma arith assign-bounds 1 1 1 1 1) (or $x55613 (not $x55671) (not $x48759) (not $x48878) $x48785 (not $x48840)))))
 (let (($x54772 (has_type ?x54713 INT)))
 (let ((@x54563 (mp @x55103 (symm (monotonicity @x55112 (= $x54772 $x52275)) (= $x52275 $x54772)) $x54772)))
 (let ((?x54960 (+ ?x49340 ?x54976)))
 (let (($x54934 (>= ?x54960 0)))
 (let ((?x51159 (* (- 1) ?x50843)))
 (let ((?x51160 (+ ?x49340 ?x51159)))
 (let (($x51164 (>= ?x51160 0)))
 (let (($x51158 (= ?x49340 ?x50843)))
 (let ((@x51197 (def-axiom (or $x51142 $x51108))))
 (let ((@x55239 (unit-resolution @x51197 @x51951 $x51108)))
 (let ((@x55244 (mp @x55239 (symm (commutativity (= $x51158 $x51108)) (= $x51108 $x51158)) $x51158)))
 (let ((@x55245 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51158) $x51164)) @x55244 $x51164)))
 (let ((?x51730 (Add ?x46948 ?x7412)))
 (let ((?x51733 (* (- 1) ?x51730)))
 (let ((?x51769 (+ ?x50843 ?x51733)))
 (let (($x51771 (>= ?x51769 0)))
 (let (($x51768 (= ?x50843 ?x51730)))
 (let ((@x55251 (symm (monotonicity @x52403 @x52465 (= ?x51730 ?x50843)) $x51768)))
 (let ((@x55252 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51768) $x51771)) @x55251 $x51771)))
 (let ((?x51741 (+ ?x7412 ?x46948 ?x51733)))
 (let (($x51766 (<= ?x51741 0)))
 (let (($x51722 (= ?x51741 0)))
 (let (($x51757 (or $x48868 $x51722)))
 (let (($x51729 (= (+ ?x7412 ?x46994 (* (- 1) (Add ?x46994 ?x7412))) 0)))
 (let (($x51759 (or $x48868 $x51729)))
 (let (($x51761 (= $x51759 $x51757)))
 (let ((@x51764 (trans (monotonicity (rewrite (= $x51729 $x51722)) $x51761) (rewrite (= $x51757 $x51757)) $x51761)))
 (let ((@x51765 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985) (uClip 64 ?x7411)) $x51759) @x51764 $x51757)))
 (let ((@x55256 (unit-resolution @x51765 @x10433 $x51722)))
 (let ((@x55257 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51722) $x51766)) @x55256 $x51766)))
 (let ((?x51487 (+ ?x46948 ?x51484)))
 (let (($x51486 (<= ?x51487 0)))
 (let (($x51513 (not $x51486)))
 (let (($x51489 (or $x51481 $x51486)))
 (let (($x51483 (not $x51489)))
 (let (($x52026 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. ?x46946 ?x46948)))
 (let (($x52073 (= $x51489 $x52026)))
 (let (($x52076 (not $x52073)))
 (let (($x16473 (forall ((x! Int) (m! Int) )(! (let (($x5894 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (let (($x1196 (<= (+ m! (* (- 1) (EucMod x! m!))) 0)))
 (let (($x14751 (or (not (>= (EucMod x! m!) 0)) $x1196)))
 (not (= $x14751 $x5894))))) :pattern ( (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!) ) :qid internal_ens__vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor._definition))
 ))
 (let (($x5908 (forall ((x! Int) (m! Int) )(! (let ((?x999 (EucMod x! m!)))
 (let (($x1188 (>= ?x999 0)))
 (let (($x1201 (and $x1188 (not (<= (+ m! (* (- 1) ?x999)) 0)))))
 (let (($x5894 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (= $x5894 $x1201))))) :pattern ( (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!) ) :qid internal_ens__vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor._definition))
 ))
 (let ((?x16474 (lambda ((x! Int) (m! Int) )(let (($x5894 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (let (($x1196 (<= (+ m! (* (- 1) (EucMod x! m!))) 0)))
 (let (($x14751 (or (not (>= (EucMod x! m!) 0)) $x1196)))
 (let (($x16465 (not (= $x14751 $x5894))))
 (let ((?x999 (EucMod x! m!)))
 (let (($x1188 (>= ?x999 0)))
 (let (($x1201 (and $x1188 (not $x1196))))
 (let (($x5906 (= $x5894 $x1201)))
 (let (($x16468 (= $x5906 $x16465)))
 (let ((@x14754 (rewrite (= $x1201 (not $x14751)))))
 (let ((@x16469 (trans (monotonicity @x14754 (= $x5906 (= $x5894 (not $x14751)))) (rewrite (= (= $x5894 (not $x14751)) $x16465)) $x16468)))
 (trans @x16469 (rewrite (= $x16465 $x16465)) $x16468)))))))))))))
 ))
 (let ((?x12704 (lambda ((x! Int) (m! Int) )(let ((?x999 (EucMod x! m!)))
 (let (($x1188 (>= ?x999 0)))
 (let (($x1201 (and $x1188 (not (<= (+ m! (* (- 1) ?x999)) 0)))))
 (let (($x5894 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (let (($x5906 (= $x5894 $x1201)))
 (refl (~ $x5906 $x5906))))))))
 ))
 (let (($x5899 (forall ((x! Int) (m! Int) )(! (let (($x1181 (and (<= 0 (EucMod x! m!)) (< (EucMod x! m!) m!))))
 (let (($x5894 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (= $x5894 $x1181))) :pattern ( (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!) ) :qid internal_ens__vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor._definition))
 ))
 (let ((?x5902 (lambda ((x! Int) (m! Int) )(let ((?x999 (EucMod x! m!)))
 (let (($x1188 (>= ?x999 0)))
 (let (($x1201 (and $x1188 (not (<= (+ m! (* (- 1) ?x999)) 0)))))
 (let (($x5894 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. x! m!)))
 (let (($x5906 (= $x5894 $x1201)))
 (let (($x1181 (and (<= 0 ?x999) (< ?x999 m!))))
 (let (($x5895 (= $x5894 $x1181)))
 (rewrite (= $x5895 $x5906))))))))))
 ))
 (let ((@x5904 (mp (asserted $x5899) (quant-intro (proof-bind ?x5902) (= $x5899 $x5908)) $x5908)))
 (let ((@x16478 (mp (mp~ @x5904 (nnf-pos (proof-bind ?x12704) (~ $x5908 $x5908)) $x5908) (quant-intro (proof-bind ?x16474) (= $x5908 $x16473)) $x16473)))
 (let (($x51965 (not $x16473)))
 (let (($x52083 (or $x51965 $x52076)))
 (let (($x52022 (ens%vstd!arithmetic.div_mod.lemma_mod_division_less_than_divisor. ?x46991 ?x46994)))
 (let (($x51471 (<= (+ ?x46994 (* (- 1) ?x51402)) 0)))
 (let (($x51472 (or (not (>= ?x51402 0)) $x51471)))
 (let (($x52023 (= $x51472 $x52022)))
 (let (($x52024 (not $x52023)))
 (let (($x52084 (or $x51965 $x52024)))
 (let (($x52086 (= $x52084 $x52083)))
 (let (($x52078 (= $x52024 $x52076)))
 (let ((@x52082 (trans (monotonicity (rewrite (= $x52023 $x52073)) $x52078) (rewrite (= $x52076 $x52076)) $x52078)))
 (let ((@x52091 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x52084) (trans (monotonicity @x52082 $x52086) (rewrite (= $x52083 $x52083)) $x52086) $x52083)))
 (let ((@x55263 (mp (unit-resolution (def-axiom (or $x47027 $x46733)) @x52339 $x46733) (symm (monotonicity @x52059 @x52034 (= $x52026 $x46733)) (= $x46733 $x52026)) $x52026)))
 (let ((@x52100 (def-axiom (or $x52073 $x51483 (not $x52026)))))
 (let ((@x51515 (def-axiom (or $x51489 $x51513))))
 (let ((@x55266 (unit-resolution @x51515 (unit-resolution @x52100 @x55263 (unit-resolution @x52091 @x16478 $x52076) $x51483) $x51513)))
 (let (($x54973 (>= ?x54972 0)))
 (let ((@x55284 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54971) $x54973)) @x55283 $x54973)))
 (let (($x52499 (not $x51251)))
 (let (($x52498 (not $x51534)))
 (let (($x52496 (not $x51542)))
 (let (($x55287 (not $x51766)))
 (let (($x55286 (not $x51771)))
 (let (($x55285 (not $x51164)))
 (let ((@x55290 ((_ th-lemma arith assign-bounds 1 1 1 1 1 1 1 1) (or $x54934 $x55285 $x55286 $x55287 $x51486 $x52496 $x52498 $x52499 (not $x54973)))))
 (let (($x49952 (has_type ?x7471 INT)))
 (let (($x54796 (has_type ?x50032 INT)))
 (let (($x54806 (not $x54796)))
 (let ((@x54808 (monotonicity (symm (monotonicity @x54801 (= $x54796 $x49952)) (= $x49952 $x54796)) (= (not $x49952) $x54806))))
 (let ((@x54811 (unit-resolution (unit-resolution ((_ quant-inst (uClip 64 ?x7411)) (or (not $x698) $x54796)) @x10335 $x54796) (mp (hypothesis (not $x49952)) @x54808 $x54806) false)))
 (let ((@x54812 (lemma @x54811 $x49952)))
 (let (($x47482 (has_type ?x46673 ?x1968)))
 (let ((?x47486 (%Poly%vstd!seq.Seq<u8.>. ?x46673)))
 (let ((?x52955 (Poly%vstd!seq.Seq<u8.>. ?x47486)))
 (let (($x52956 (has_type ?x52955 ?x1968)))
 (let (($x52970 (not $x52956)))
 (let (($x47487 (= pm! ?x47486)))
 (let (($x1966 (forall ((x vstd!seq.Seq<u8.>.) )(! (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x))) :pattern ( (Poly%vstd!seq.Seq<u8.>. x) ) :qid internal_vstd__seq__Seq<u8.>_box_axiom_definition))
 ))
 (let ((?x10781 (lambda ((x vstd!seq.Seq<u8.>.) )(let (($x1964 (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x)))))
 (refl (~ $x1964 $x1964))))
 ))
 (let ((@x10785 (mp~ (asserted $x1966) (nnf-pos (proof-bind ?x10781) (~ $x1966 $x1966)) $x1966)))
 (let (($x47497 (not $x1966)))
 (let (($x47498 (or $x47497 $x47487)))
 (let ((@x47499 ((_ quant-inst pm!) $x47498)))
 (let ((@x52965 (monotonicity (symm (unit-resolution @x47499 @x10785 $x47487) (= ?x47486 pm!)) (= ?x52955 ?x46673))))
 (let ((@x52972 (monotonicity (symm (monotonicity @x52965 (= $x52956 $x47482)) (= $x47482 $x52956)) (= (not $x47482) $x52970))))
 (let (($x1989 (forall ((x vstd!seq.Seq<u8.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (has_type ?x1962 ?x1968)))) :pattern ( (has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_has_type_always_definition))
 ))
 (let ((?x10795 (lambda ((x vstd!seq.Seq<u8.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (let (($x1987 (has_type ?x1962 ?x1968)))
 (refl (~ $x1987 $x1987)))))))
 ))
 (let ((@x10799 (mp~ (asserted $x1989) (nnf-pos (proof-bind ?x10795) (~ $x1989 $x1989)) $x1989)))
 (let ((@x52975 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x46673)) (or (not $x1989) $x52956)) @x10799 $x52956) (mp (hypothesis (not $x47482)) @x52972 $x52970) false)))
 (let ((@x52976 (lemma @x52975 $x47482)))
 (let (($x15875 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x15675 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x15674 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x14879 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x15715 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x15689 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x15679 (not $x4256)))
 (or $x15679 $x15689 $x271 $x15715 $x14879 $x15674 $x15675 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x47829 (= $x4641 $x1589)))
 (let ((@x47831 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x47829)) @x47707 (hypothesis (not $x47829)) false)))
 (let ((@x47843 (lemma @x47831 $x47829)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x15026 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x15025 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x15024 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x15023 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x15022 (not $x1590)))
 (let (($x15021 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x15020 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x15019 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x15018 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x15017 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x15016 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x15015 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x15014 (not $x1582)))
 (let (($x15027 (or $x15014 $x15015 $x15016 $x15017 $x15018 $x15019 $x15020 $x15021 $x15022 $x15023 $x15024 $x15025 $x15026)))
 (let (($x15028 (not $x15027)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x15091 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x15090 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x15089 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x15088 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x15087 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x15086 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x15085 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x15084 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x15083 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x15082 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x15081 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x15080 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x15079 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x15078 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x15077 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x15092 (or $x1598 $x1610 $x15077 $x1621 $x15078 $x15079 $x15080 $x1565 $x15081 $x1633 $x15082 $x15083 $x1576 $x15084 $x15085 $x15086 $x15087 $x15088 $x15089 $x1644 $x15090 $x15091)))
 (let (($x15093 (not $x15092)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x15096 (or $x1669 $x15093)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x15098 (mp @x1673 (rewrite (= $x1670 $x15096)) $x15096)))
 (let ((@x44792 (def-axiom (or $x15092 $x1581))))
 (let (($x15031 (or $x1598 $x15028)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x15033 (mp @x1602 (rewrite (= $x1599 $x15031)) $x15031)))
 (let ((@x55305 (unit-resolution @x15033 (unit-resolution @x44792 (unit-resolution @x15098 @x1650 $x15093) $x1581) $x15028)))
 (let ((@x44750 (def-axiom (or $x15027 $x1589))))
 (let ((@x47836 (def-axiom (or (not $x47829) $x4641 $x15021))))
 (let ((@x55308 (unit-resolution @x47836 (unit-resolution @x44750 @x55305 $x1589) (or (not $x47829) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x15926 (or $x4675 $x15875)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x12217 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x12240 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x12217) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x4233 (<= ?x1191 ?x264)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 $x4233)))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643)))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x4233 (<= ?x1191 ?x264)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 $x4233)))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664)))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x15928 (mp (mp (mp~ @x4681 @x12240 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x15926)) $x15926)))
 (let ((@x55310 (unit-resolution @x15928 (unit-resolution @x55308 @x47843 $x4641) $x15875)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x54890 (not $x54934)))
 (let (($x55624 (not $x55623)))
 (let (($x55620 (not $x55613)))
 (let (($x53653 (not $x174)))
 (let (($x54752 (not $x54772)))
 (let (($x49953 (not $x49952)))
 (let (($x47483 (not $x47482)))
 (let (($x54915 (not $x15875)))
 (let (($x55371 (or $x54915 $x47483 $x49953 $x54752 $x53653 $x55620 $x55624 $x54890 $x55627)))
 (let ((?x54518 (* (- 1) ?x49340)))
 (let ((?x54946 (+ ?x54928 ?x54518)))
 (let (($x54953 (<= ?x54946 0)))
 (let (($x54931 (not $x54953)))
 (let (($x55628 (or $x47483 $x49953 $x54752 $x53653 $x55620 $x55624 $x54931 $x55627)))
 (let (($x55377 (or $x54915 $x55628)))
 (let ((@x55383 (rewrite (= (or $x54915 (or $x47483 $x49953 $x54752 $x53653 $x55620 $x55624 $x54890 $x55627)) $x55371))))
 (let (($x55365 (or $x47483 $x49953 $x54752 $x53653 $x55620 $x55624 $x54890 $x55627)))
 (let (($x55367 (= $x55628 $x55365)))
 (let ((@x55370 (trans (monotonicity (rewrite (= $x54931 $x54890)) $x55367) (rewrite (= $x55365 $x55365)) $x55367)))
 (let ((@x55387 (trans (monotonicity @x55370 (= $x55377 (or $x54915 $x55365))) @x55383 (= $x55377 $x55371))))
 (let ((@x55390 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.contents_offset.?) (I ?x54712)) $x55377) @x55387 $x55371)))
 (let ((@x55899 (unit-resolution @x55390 @x175 @x55310 @x52976 @x54812 (unit-resolution @x55290 @x55284 @x55266 @x52476 @x55897 @x55257 @x55252 @x52491 @x55245 $x54934) (or $x54752 $x55620 $x55624 $x55627))))
 (let ((@x55867 (unit-resolution @x55899 @x54563 (unit-resolution @x55452 @x55490 @x55196 @x55171 @x55123 @x55174 $x55613) @x55866 $x55627)))
 (let ((@x55732 (symm (monotonicity (monotonicity @x55112 (= ?x55388 ?x50849)) (= ?x55625 ?x55518)) (= ?x55518 ?x55625))))
 (let ((@x55738 (trans* @x55732 @x55867 (symm @x55703 (= ?x55626 ?x55704)) (symm @x55667 (= ?x55704 ?x51407)) (= ?x55518 ?x51407))))
 (let ((@x55903 (symm (monotonicity @x55738 (= ?x55645 (Add ?x55415 ?x51407))) (= (Add ?x55415 ?x51407) ?x55645))))
 (let ((?x55483 (Add ?x55415 ?x51407)))
 (let (($x55482 (= ?x55483 ?x52190)))
 (let (($x55413 (ens%pmemlog!math_v.lemma_mod_wrapped_len. ?x46943 ?x46946 ?x46948)))
 (let (($x55568 (= $x55413 $x55482)))
 (let (($x9912 (forall ((x! Int) (y! Int) (d! Int) )(! (let ((?x9833 (Sub y! x!)))
 (let (($x9929 (ens%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (= $x9929 (= (Add (Sub d! (EucMod x! d!)) (EucMod y! d!)) ?x9833)))) :pattern ( (ens%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!) ) :qid internal_ens__pmemlog!math_v.lemma_mod_wrapped_len._definition))
 ))
 (let ((?x14497 (lambda ((x! Int) (y! Int) (d! Int) )(let ((?x9833 (Sub y! x!)))
 (let (($x9929 (ens%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (let (($x9915 (= $x9929 (= (Add (Sub d! (EucMod x! d!)) (EucMod y! d!)) ?x9833))))
 (refl (~ $x9915 $x9915))))))
 ))
 (let ((@x14501 (mp~ (asserted $x9912) (nnf-pos (proof-bind ?x14497) (~ $x9912 $x9912)) $x9912)))
 (let (($x55563 (not $x9912)))
 (let (($x55629 (or $x55563 $x55568)))
 (let (($x55402 (ens%pmemlog!math_v.lemma_mod_wrapped_len. ?x46987 ?x46991 ?x46994)))
 (let (($x55412 (= $x55402 (= (Add (Sub ?x46994 ?x51246) ?x51402) (Sub ?x46991 ?x46987)))))
 (let (($x55636 (or $x55563 $x55412)))
 (let (($x55813 (= $x55636 $x55629)))
 (let ((@x55777 (trans (monotonicity (rewrite (= $x55412 $x55568)) $x55813) (rewrite (= $x55629 $x55629)) $x55813)))
 (let ((@x52582 (hypothesis $x46949)))
 (let (($x52286 (req%pmemlog!math_v.lemma_mod_wrapped_len. ?x46943 ?x46946 ?x46948)))
 (let (($x52572 (not $x52286)))
 (let ((@x52593 (monotonicity (symm (monotonicity @x52354 @x52349 @x52344 (= $x52286 $x46768)) (= $x46768 $x52286)) (= (not $x46768) $x52572))))
 (let (($x47283 (not $x46768)))
 (let ((@x47299 (def-axiom (or $x46838 $x46924 $x46923))))
 (let ((@x52584 (unit-resolution @x47299 (unit-resolution (def-axiom (or $x46869 $x46925)) @x52582 $x46925) (hypothesis $x46896) $x46924)))
 (let ((@x47285 (def-axiom (or $x46892 $x47283))))
 (let (($x9939 (not %%global_location_label%%104)))
 (let (($x52218 (or $x9939 $x52198)))
 (let (($x52222 (not $x52218)))
 (let (($x52267 (not $x52180)))
 (let (($x9922 (not %%global_location_label%%103)))
 (let (($x52212 (or $x9922 $x52267)))
 (let (($x52210 (not $x52212)))
 (let (($x9903 (not %%global_location_label%%102)))
 (let (($x52265 (or $x9903 $x52155)))
 (let (($x52216 (not $x52265)))
 (let (($x9861 (not %%global_location_label%%101)))
 (let (($x52189 (or $x9861 $x51738)))
 (let (($x52260 (not $x52189)))
 (let (($x52290 (or $x52260 $x52216 $x52210 $x52222)))
 (let (($x52214 (= $x52290 $x52286)))
 (let (($x52211 (not $x52214)))
 (let (($x18637 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9896 (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9939 (not %%global_location_label%%104)))
 (let (($x9940 (or $x9939 $x9885)))
 (let (($x9922 (not %%global_location_label%%103)))
 (let (($x9923 (or $x9922 (not (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9903 (not %%global_location_label%%102)))
 (let (($x9904 (or $x9903 $x9850)))
 (let (($x18621 (or (not (or (not %%global_location_label%%101) (not (<= d! 0)))) (not $x9904) (not $x9923) (not $x9940))))
 (not (= $x18621 $x9896)))))))))))))) :pattern ( (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_wrapped_len._definition))
 ))
 (let (($x9946 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9939 (not %%global_location_label%%104)))
 (let (($x9940 (or $x9939 $x9885)))
 (let (($x9922 (not %%global_location_label%%103)))
 (let (($x9923 (or $x9922 (not (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9903 (not %%global_location_label%%102)))
 (let (($x9904 (or $x9903 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9861 (not %%global_location_label%%101)))
 (let (($x9841 (or $x9861 $x1155)))
 (let (($x9945 (and $x9841 $x9904 $x9923 $x9940)))
 (let (($x9896 (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (= $x9896 $x9945))))))))))))))))) :pattern ( (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_wrapped_len._definition))
 ))
 (let ((?x18638 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9896 (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9939 (not %%global_location_label%%104)))
 (let (($x9940 (or $x9939 $x9885)))
 (let (($x9922 (not %%global_location_label%%103)))
 (let (($x9923 (or $x9922 (not (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9903 (not %%global_location_label%%102)))
 (let (($x9904 (or $x9903 $x9850)))
 (let (($x18621 (or (not (or (not %%global_location_label%%101) (not (<= d! 0)))) (not $x9904) (not $x9923) (not $x9940))))
 (let (($x18629 (not (= $x18621 $x9896))))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9861 (not %%global_location_label%%101)))
 (let (($x9841 (or $x9861 $x1155)))
 (let (($x9945 (and $x9841 $x9904 $x9923 $x9940)))
 (let (($x9935 (= $x9896 $x9945)))
 (let (($x18632 (= $x9935 $x18629)))
 (let ((@x18627 (monotonicity (rewrite (= $x9945 (not $x18621))) (= $x9935 (= $x9896 (not $x18621))))))
 (trans (trans @x18627 (rewrite (= (= $x9896 (not $x18621)) $x18629)) $x18632) (rewrite (= $x18629 $x18629)) $x18632)))))))))))))))))))))))
 ))
 (let ((?x14490 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9939 (not %%global_location_label%%104)))
 (let (($x9940 (or $x9939 $x9885)))
 (let (($x9922 (not %%global_location_label%%103)))
 (let (($x9923 (or $x9922 (not (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9903 (not %%global_location_label%%102)))
 (let (($x9904 (or $x9903 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9861 (not %%global_location_label%%101)))
 (let (($x9841 (or $x9861 $x1155)))
 (let (($x9945 (and $x9841 $x9904 $x9923 $x9940)))
 (let (($x9896 (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (let (($x9935 (= $x9896 $x9945)))
 (refl (~ $x9935 $x9935))))))))))))))))))))
 ))
 (let (($x9854 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9873 (=> %%global_location_label%%103 (> (EucMod x! d!) (EucMod y! d!)))))
 (let (($x9851 (and (=> %%global_location_label%%101 (> d! 0)) (=> %%global_location_label%%102 (<= x! y!)) $x9873 (=> %%global_location_label%%104 (< (Sub y! x!) d!)))))
 (let (($x9896 (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (= $x9896 $x9851)))) :pattern ( (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_wrapped_len._definition))
 ))
 (let ((?x9948 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9939 (not %%global_location_label%%104)))
 (let (($x9940 (or $x9939 $x9885)))
 (let (($x9922 (not %%global_location_label%%103)))
 (let (($x9923 (or $x9922 (not (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9903 (not %%global_location_label%%102)))
 (let (($x9904 (or $x9903 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9861 (not %%global_location_label%%101)))
 (let (($x9841 (or $x9861 $x1155)))
 (let (($x9945 (and $x9841 $x9904 $x9923 $x9940)))
 (let (($x9896 (req%pmemlog!math_v.lemma_mod_wrapped_len. x! y! d!)))
 (let (($x9935 (= $x9896 $x9945)))
 (let (($x9873 (=> %%global_location_label%%103 (> (EucMod x! d!) (EucMod y! d!)))))
 (let (($x9851 (and (=> %%global_location_label%%101 (> d! 0)) (=> %%global_location_label%%102 (<= x! y!)) $x9873 (=> %%global_location_label%%104 (< (Sub y! x!) d!)))))
 (let (($x9852 (= $x9896 $x9851)))
 (rewrite (= $x9852 $x9935)))))))))))))))))))))))
 ))
 (let ((@x9928 (mp (asserted $x9854) (quant-intro (proof-bind ?x9948) (= $x9854 $x9946)) $x9946)))
 (let ((@x18642 (mp (mp~ @x9928 (nnf-pos (proof-bind ?x14490) (~ $x9946 $x9946)) $x9946) (quant-intro (proof-bind ?x18638) (= $x9946 $x18637)) $x18637)))
 (let (($x52410 (not $x18637)))
 (let (($x52411 (or $x52410 $x52211)))
 (let (($x52255 (req%pmemlog!math_v.lemma_mod_wrapped_len. ?x46987 ?x46991 ?x46994)))
 (let (($x52237 (or (not (or $x9861 $x51690)) (not (or $x9903 $x52117)) (not (or $x9922 (not (>= (+ ?x51402 (* (- 1) ?x51246)) 0)))) (not (or $x9939 $x52128)))))
 (let (($x52256 (= $x52237 $x52255)))
 (let (($x52259 (not $x52256)))
 (let (($x52334 (or $x52410 $x52259)))
 (let (($x52531 (= $x52334 $x52411)))
 (let (($x52266 (= $x52259 $x52211)))
 (let ((@x52426 (trans (monotonicity (rewrite (= $x52256 $x52214)) $x52266) (rewrite (= $x52211 $x52211)) $x52266)))
 (let ((@x52536 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x52334) (trans (monotonicity @x52426 $x52531) (rewrite (= $x52411 $x52411)) $x52531) $x52411)))
 (let (($x52569 (not $x52290)))
 (let ((?x51234 (Add ?x51075 ?x7412)))
 (let ((?x51235 (* (- 1) ?x51234)))
 (let ((?x51236 (+ ?x7412 ?x51075 ?x51235)))
 (let (($x51243 (>= ?x51236 0)))
 (let (($x51237 (= ?x51236 0)))
 (let (($x51240 (or $x48868 $x51237)))
 (let ((@x51241 ((_ quant-inst (EucMod ?x50830 ?x51074) (uClip 64 ?x7411)) $x51240)))
 (let ((@x52368 (unit-resolution @x51241 @x10433 $x51237)))
 (let ((@x52600 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51237) $x51243)) @x52368 $x51243)))
 (let ((?x51993 (* (- 1) ?x50833)))
 (let ((?x51994 (+ physical_head@ ?x51993)))
 (let (($x51995 (<= ?x51994 0)))
 (let (($x51992 (= physical_head@ ?x50833)))
 (let (($x52382 (= ?x46743 ?x50833)))
 (let ((@x52376 (monotonicity (trans* @x52340 @x51868 @x51943 (= log_size@ ?x50831)) (= ?x46742 ?x50832))))
 (let ((@x52380 (monotonicity (trans* @x52350 @x51890 @x52301 (= head@ ?x50828)) (= ?x46741 ?x50829))))
 (let ((@x47436 (def-axiom (or $x47027 $x46744))))
 (let ((@x52381 (unit-resolution @x47436 @x52339 $x46744)))
 (let ((@x52384 (trans* @x52381 (monotonicity @x52380 @x52376 $x52382) $x51992)))
 (let ((@x52602 ((_ th-lemma arith triangle-eq) (or (not $x51992) $x51995))))
 (let ((@x52603 (unit-resolution @x52602 @x52384 $x51995)))
 (let ((?x51989 (+ physical_tail@ ?x50838)))
 (let (($x51991 (>= ?x51989 0)))
 (let (($x51988 (= physical_tail@ ?x50837)))
 (let ((@x52395 (monotonicity (monotonicity (trans* @x52345 @x52042 @x52326 (= tail@ ?x50835)) (= ?x46746 ?x50836)) @x52376 (= ?x46747 ?x50837))))
 (let ((@x52396 (trans* (unit-resolution (def-axiom (or $x47027 $x46748)) @x52339 $x46748) @x52395 $x51988)))
 (let ((@x52606 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51988) $x51991)) @x52396 $x51991)))
 (let ((@x52432 (monotonicity (trans* @x52416 (symm @x52424 (= ?x51023 ?x51078)) (= ?x46946 ?x51078)) @x52415 (= ?x51407 ?x51079))))
 (let ((@x52433 (symm @x52432 $x51540)))
 (let ((@x52613 (unit-resolution @x52608 @x52433 $x51543)))
 (let ((?x51367 (* (- 1) ?x51255)))
 (let ((?x51537 (+ ?x51075 ?x51367)))
 (let (($x51538 (<= ?x51537 0)))
 (let ((@x52615 ((_ th-lemma arith triangle-eq) (or (not $x51536) $x51538))))
 (let ((@x52618 (unit-resolution @x52615 @x52455 $x51538)))
 (let ((?x51529 (+ ?x50833 ?x51235)))
 (let (($x51530 (<= ?x51529 0)))
 (let (($x51528 (= ?x50833 ?x51234)))
 (let ((@x52482 (monotonicity @x52465 (= ?x51234 (Add ?x51075 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x51076 (Add ?x51075 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x51077 (= ?x50833 ?x51076)))
 (let (($x51081 (or $x51080 $x51077)))
 (let ((@x51082 ((_ quant-inst (I ?x50828) (I ?x50831)) $x51081)))
 (let ((@x52480 (unit-resolution @x51082 @x52469 $x51077)))
 (let ((@x52485 (trans* @x52480 (symm @x52482 (= ?x51076 ?x51234)) $x51528)))
 (let ((@x52624 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51528) $x51530)) @x52485 $x51530)))
 (let ((@x47301 (def-axiom (or $x46869 $x46888))))
 (let ((@x52628 (unit-resolution @x47301 @x52582 $x46888)))
 (let (($x52636 (not $x51243)))
 (let (($x52635 (not $x51538)))
 (let (($x52634 (not $x51530)))
 (let (($x52633 (not $x51995)))
 (let (($x52630 (not $x51991)))
 (let ((@x52639 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 -1 -1 1 1 1 1 -1) (or $x52267 $x52629 $x46885 $x52630 $x52631 $x52632 $x52633 $x52634 $x52635 $x52636)) @x52628 @x52627 @x52624 @x52621 @x52618 @x52613 @x52606 @x52603 @x52600 $x52267)))
 (let ((?x51222 (* (- 1) ?x50828)))
 (let ((?x51223 (+ ?x46716 ?x51222)))
 (let (($x51224 (<= ?x51223 0)))
 (let ((@x52303 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x46716 ?x50828)) $x51224)) (trans* @x51890 @x52301 (= ?x46716 ?x50828)) $x51224)))
 (let ((?x51525 (+ ?x46687 ?x51524)))
 (let (($x51526 (<= ?x51525 0)))
 (let (($x51523 (= ?x46687 ?x46946)))
 (let (($x51017 (= ?x46969 ?x46946)))
 (let ((@x52310 (symm @x52038 $x51017)))
 (let ((@x52306 ((_ th-lemma arith triangle-eq) (or (not $x51523) $x51526))))
 (let ((@x52312 (unit-resolution @x52306 (trans* @x52044 @x52036 @x52035 @x52046 (symm @x52040 $x51015) @x52310 $x51523) $x51526)))
 (let ((?x51519 (* (- 1) ?x46943)))
 (let ((?x51520 (+ ?x46716 ?x51519)))
 (let (($x51522 (>= ?x51520 0)))
 (let (($x51518 (= ?x46716 ?x46943)))
 (let (($x50964 (= ?x46965 ?x46943)))
 (let ((@x52318 (symm @x51886 $x50964)))
 (let (($x50961 (= ?x46987 ?x46965)))
 (let ((@x52317 (symm @x51888 $x50961)))
 (let ((@x52320 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51518) $x51522)) (trans* @x51890 @x51892 @x51885 @x51884 @x51894 @x52317 @x52318 $x51518) $x51522)))
 (let ((?x51227 (+ ?x46687 ?x51138)))
 (let (($x51229 (>= ?x51227 0)))
 (let ((@x52327 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51226) $x51229)) @x52326 $x51229)))
 (let ((@x52330 (lemma ((_ th-lemma arith farkas 1 -1 -1 -1 1 1) @x52328 @x52327 @x52320 (hypothesis (not $x52155)) @x52312 @x52303 false) $x52155)))
 (let ((@x52642 (unit-resolution (def-axiom (or $x52569 $x52260 $x52216 $x52210 $x52222)) (unit-resolution (def-axiom (or $x52189 $x51293)) @x51957 $x52189) (unit-resolution (def-axiom (or $x52265 (not $x52155))) @x52330 $x52265) (unit-resolution (def-axiom (or $x52212 $x52180)) @x52639 $x52212) (unit-resolution (def-axiom (or $x52218 $x52195)) @x52522 $x52218) $x52569)))
 (let ((@x52645 (unit-resolution (unit-resolution (def-axiom (or $x52214 $x52290 $x52286)) @x52642 (or $x52214 $x52286)) (unit-resolution @x52536 @x18642 $x52211) $x52286)))
 (let ((@x52646 (unit-resolution @x52645 (mp (unit-resolution @x47285 @x52584 $x47283) @x52593 $x52572) false)))
 (let ((@x52648 (lemma @x52646 (or $x46869 $x46923))))
 (let ((@x47289 (def-axiom (or $x46896 $x46770))))
 (let ((@x55887 (mp (unit-resolution @x47289 (unit-resolution @x52648 @x52582 $x46923) $x46770) (symm (monotonicity @x52354 @x52349 @x52344 (= $x55413 $x46770)) (= $x46770 $x55413)) $x55413)))
 (let ((@x55888 (unit-resolution (def-axiom (or (not $x55568) (not $x55413) $x55482)) @x55887 (unit-resolution (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x55636) @x55777 $x55629) @x14501 $x55568) $x55482)))
 (let ((@x55904 (trans* (symm @x55888 (= ?x52190 ?x55483)) @x55903 $x55805)))
 (let ((?x55517 (vstd!seq.Seq.len.? $ ?x1876 ?x50845)))
 (let ((?x55519 (Add ?x55517 ?x55518)))
 (let ((?x55520 (nClip ?x55519)))
 (let ((?x55821 (* (- 1) ?x55520)))
 (let ((?x55812 (+ ?x46812 ?x55821)))
 (let (($x55790 (>= ?x55812 0)))
 (let (($x55823 (= ?x46812 ?x55520)))
 (let ((?x55509 (vstd!seq.Seq.add.? $ ?x1876 ?x50845 ?x50849)))
 (let ((?x55510 (vstd!seq.Seq.len.? $ ?x1876 ?x55509)))
 (let (($x55521 (= ?x55510 ?x55520)))
 (let (($x55499 (has_type ?x50845 ?x1968)))
 (let ((?x49341 (I ?x49340)))
 (let ((?x54744 (%I ?x50842)))
 (let ((?x54745 (I ?x54744)))
 (let ((?x55393 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x54745 ?x49341)))
 (let (($x55394 (has_type ?x55393 ?x1968)))
 (let (($x55974 (= $x55394 $x55499)))
 (let (($x54754 (= ?x50842 ?x54745)))
 (let (($x52273 (has_type ?x50842 INT)))
 (let ((?x52288 (I ?x51076)))
 (let (($x55050 (has_type ?x52288 INT)))
 (let (($x55062 (not $x55050)))
 (let ((@x55057 (monotonicity (symm @x52480 (= ?x51076 ?x50833)) (= ?x52288 ?x50842))))
 (let ((@x55064 (monotonicity (symm (monotonicity @x55057 (= $x55050 $x52273)) (= $x52273 $x55050)) (= (not $x52273) $x55062))))
 (let ((@x55067 (unit-resolution (unit-resolution ((_ quant-inst (Add ?x51075 pmemlog!logimpl_v.contents_offset.?)) (or (not $x698) $x55050)) @x10335 $x55050) (mp (hypothesis (not $x52273)) @x55064 $x55062) false)))
 (let ((@x55068 (lemma @x55067 $x52273)))
 (let (($x52274 (not $x52273)))
 (let (($x54716 (or $x54732 $x52274 $x54754)))
 (let ((@x54709 (mp ((_ quant-inst (I ?x50833)) (or $x54732 (or $x52274 $x54754))) (rewrite (= (or $x54732 (or $x52274 $x54754)) $x54716)) $x54716)))
 (let ((@x54839 (symm (unit-resolution @x54709 @x10216 @x55068 $x54754) (= ?x54745 ?x50842))))
 (let ((@x55969 (monotonicity @x54839 (symm (monotonicity @x55239 (= ?x50844 ?x49341)) (= ?x49341 ?x50844)) (= ?x55393 ?x50845))))
 (let (($x54760 (has_type ?x54745 INT)))
 (let ((@x55109 (mp @x55068 (symm (monotonicity @x54839 (= $x54760 $x52273)) (= $x52273 $x54760)) $x54760)))
 (let (($x49960 (has_type ?x49341 INT)))
 (let ((?x50030 (%I ?x49341)))
 (let ((?x54813 (I ?x50030)))
 (let (($x54814 (has_type ?x54813 INT)))
 (let (($x54827 (not $x54814)))
 (let (($x50031 (= ?x49340 ?x50030)))
 (let (($x50034 (or $x49974 $x50031)))
 (let ((@x50035 ((_ quant-inst (vstd!seq.Seq.len.? $ ?x1876 ?x46673)) $x50034)))
 (let ((@x54816 (unit-resolution @x50035 @x10195 $x50031)))
 (let ((@x54824 (monotonicity (monotonicity (symm @x54816 (= ?x50030 ?x49340)) (= ?x54813 ?x49341)) (= $x54814 $x49960))))
 (let ((@x54830 (mp (hypothesis (not $x49960)) (monotonicity (symm @x54824 (= $x49960 $x54814)) (= (not $x49960) $x54827)) $x54827)))
 (let ((@x54832 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x49341)) (or (not $x698) $x54814)) @x10335 $x54814) @x54830 false)))
 (let ((@x54833 (lemma @x54832 $x49960)))
 (let (($x15709 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x15689 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x15679 (not $x4256)))
 (or $x15679 $x15689 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x15710 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x15689 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x15679 (not $x4256)))
 (let (($x15704 (or $x15679 $x15689 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x15696 (monotonicity (rewrite (= $x4258 (not (or $x15679 $x15689 $x271)))) (= $x4266 (not (not (or $x15679 $x15689 $x271)))))))
 (let ((@x15700 (trans @x15696 (rewrite (= (not (not (or $x15679 $x15689 $x271))) (or $x15679 $x15689 $x271))) (= $x4266 (or $x15679 $x15689 $x271)))))
 (trans (monotonicity @x15700 (= $x4269 (or (or $x15679 $x15689 $x271) $x4261))) (rewrite (= (or (or $x15679 $x15689 $x271) $x4261) $x15704)) (= $x4269 $x15704))))))))))))))))))
 ))
 (let ((?x11985 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x15714 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x11985) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x15710) (= $x4272 $x15709)) $x15709)))
 (let (($x49961 (not $x49960)))
 (let (($x54761 (not $x54760)))
 (let (($x49906 (not $x15709)))
 (let (($x55404 (or $x49906 $x47483 $x54761 $x49961 $x55394)))
 (let ((@x55409 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x54744) (I ?x49340)) (or $x49906 (or $x47483 $x54761 $x49961 $x55394))) (rewrite (= (or $x49906 (or $x47483 $x54761 $x49961 $x55394)) $x55404)) $x55404)))
 (let ((@x55963 (unit-resolution (unit-resolution @x55409 @x15714 @x52976 @x54833 (or $x54761 $x55394)) @x55109 $x55394)))
 (let ((@x56001 (mp @x55963 (monotonicity @x55969 $x55974) $x55499)))
 (let (($x55495 (has_type ?x50849 ?x1968)))
 (let (($x55389 (has_type ?x55388 ?x1968)))
 (let (($x55920 (= $x55389 $x55495)))
 (let ((@x55915 (monotonicity @x55112 (= ?x55388 ?x50849))))
 (let (($x55395 (or $x49906 $x47483 $x49953 $x54752 $x55389)))
 (let ((@x55400 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.contents_offset.?) (I ?x54712)) (or $x49906 (or $x47483 $x49953 $x54752 $x55389))) (rewrite (= (or $x49906 (or $x47483 $x49953 $x54752 $x55389)) $x55395)) $x55395)))
 (let ((@x55913 (unit-resolution (unit-resolution @x55400 @x15714 @x52976 @x54812 (or $x54752 $x55389)) @x54563 $x55389)))
 (let ((@x55979 (mp @x55913 (monotonicity @x55915 $x55920) $x55495)))
 (let (($x16034 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x15840 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x15587 (not $x4101)))
 (or $x15587 $x15840 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4955 (fuel_bool fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x47874 (= $x4955 $x1592)))
 (let ((@x47876 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_len.) (or (not $x30) $x47874)) @x47707 (hypothesis (not $x47874)) false)))
 (let ((@x47888 (lemma @x47876 $x47874)))
 (let ((@x47881 (def-axiom (or (not $x47874) $x4955 $x15024))))
 (let ((@x55905 (unit-resolution @x47881 (unit-resolution (def-axiom (or $x15027 $x1592)) @x55305 $x1592) (or (not $x47874) $x4955))))
 (let (($x4985 (not $x4955)))
 (let (($x16039 (or $x4985 $x16034)))
 (let (($x4977 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4986 (or $x4985 $x4977)))
 (let ((?x12284 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (refl (~ $x4972 $x4972))))))))))))))))
 ))
 (let ((@x12289 (monotonicity (refl (~ $x4985 $x4985)) (nnf-pos (proof-bind ?x12284) (~ $x4977 $x4977)) (~ $x4986 $x4986))))
 (let (($x4963 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4959)))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4964 (=> $x4955 $x4963)))
 (let ((?x4978 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let (($x4961 (=> (and $x4526 $x3858) $x4959)))
 (let ((@x4971 (monotonicity (rewrite (= $x4960 (or $x4431 $x4959))) (= $x4961 (=> $x4526 (or $x4431 $x4959))))))
 (trans @x4971 (rewrite (= (=> $x4526 (or $x4431 $x4959)) $x4972)) (= $x4961 $x4972)))))))))))))))))))
 ))
 (let ((@x4984 (monotonicity (quant-intro (proof-bind ?x4978) (= $x4963 $x4977)) (= $x4964 (=> $x4955 $x4977)))))
 (let ((@x4991 (mp (asserted $x4964) (trans @x4984 (rewrite (= (=> $x4955 $x4977) $x4986)) (= $x4964 $x4986)) $x4986)))
 (let ((@x16041 (mp (mp (mp~ @x4991 @x12289 $x4986) (rewrite (= $x4986 $x4986)) $x4986) (rewrite (= $x4986 $x16039)) $x16039)))
 (let (($x55496 (not $x55495)))
 (let (($x55500 (not $x55499)))
 (let (($x55780 (not $x16034)))
 (let (($x55837 (or $x55780 $x55500 $x55496 $x53653 $x55521)))
 (let ((@x55844 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x50842 ?x50844) (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7471 ?x50848)) (or $x55780 (or $x55500 $x55496 $x53653 $x55521))) (rewrite (= (or $x55780 (or $x55500 $x55496 $x53653 $x55521)) $x55837)) $x55837)))
 (let ((@x56002 (unit-resolution @x55844 @x175 (unit-resolution @x16041 (unit-resolution @x55905 @x47888 $x4955) $x16034) @x55979 @x56001 $x55521)))
 (let (($x55497 (= ?x50849 ?x50851)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x10788 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x10792 (mp~ @x1986 (nnf-pos (proof-bind ?x10788) (~ $x1981 $x1981)) $x1981)))
 (let (($x53538 (not $x1981)))
 (let (($x55501 (or $x53538 $x55496 $x55497)))
 (let ((@x55506 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7471 ?x50848)) (or $x53538 (or $x55496 $x55497))) (rewrite (= (or $x53538 (or $x55496 $x55497)) $x55501)) $x55501)))
 (let (($x55507 (= ?x50845 ?x50847)))
 (let (($x55511 (or $x53538 $x55500 $x55507)))
 (let ((@x55516 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x50842 ?x50844)) (or $x53538 (or $x55500 $x55507))) (rewrite (= (or $x53538 (or $x55500 $x55507)) $x55511)) $x55511)))
 (let ((@x56045 (monotonicity (unit-resolution @x55516 @x10792 @x56001 $x55507) (unit-resolution @x55506 @x10792 @x55979 $x55497) (= ?x55509 ?x50852))))
 (let ((@x55772 (symm @x56045 (= ?x50852 ?x55509))))
 (let (($x50929 (= ?x50852 ?x50853)))
 (let (($x50930 (not $x50841)))
 (let ((@x56032 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1) (or $x50930 $x46885 $x52630 $x52633)) @x52606 @x52603 (or $x50930 $x46885))))
 (let ((@x50934 (def-axiom (or $x50841 $x50929))))
 (let ((@x55770 (symm (unit-resolution @x50934 (unit-resolution @x56032 @x52628 $x50930) $x50929) (= ?x50853 ?x50852))))
 (let (($x50926 (= ?x50853 ?x50855)))
 (let ((?x52753 (Sub ?x51079 ?x51075)))
 (let ((?x54899 (* (- 1) ?x52753)))
 (let ((?x54937 (+ ?x52190 ?x54899)))
 (let (($x54941 (>= ?x54937 0)))
 (let (($x54836 (= ?x52190 ?x52753)))
 (let ((@x54764 (symm (monotonicity @x52433 @x52455 (= ?x52753 (Sub ?x51407 ?x51255))) (= (Sub ?x51407 ?x51255) ?x52753))))
 (let ((?x54889 (Sub ?x51407 ?x51255)))
 (let (($x54599 (= ?x54889 ?x52190)))
 (let (($x52702 (ens%pmemlog!math_v.lemma_mod_difference_equal. ?x46943 ?x46946 ?x46948)))
 (let (($x54496 (= $x52702 $x54599)))
 (let (($x9894 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9877 (ens%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (= $x9877 (= (Sub (EucMod y! d!) (EucMod x! d!)) (Sub y! x!)))) :pattern ( (ens%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!) ) :qid internal_ens__pmemlog!math_v.lemma_mod_difference_equal._definition))
 ))
 (let ((?x14483 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9877 (ens%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (let (($x9890 (= $x9877 (= (Sub (EucMod y! d!) (EucMod x! d!)) (Sub y! x!)))))
 (refl (~ $x9890 $x9890)))))
 ))
 (let ((@x14487 (mp~ (asserted $x9894) (nnf-pos (proof-bind ?x14483) (~ $x9894 $x9894)) $x9894)))
 (let (($x54719 (not $x9894)))
 (let (($x54561 (or $x54719 $x54496)))
 (let (($x52111 (ens%pmemlog!math_v.lemma_mod_difference_equal. ?x46987 ?x46991 ?x46994)))
 (let (($x52701 (= $x52111 (= (Sub ?x51402 ?x51246) (Sub ?x46991 ?x46987)))))
 (let (($x54774 (or $x54719 $x52701)))
 (let (($x54791 (= $x54774 $x54561)))
 (let ((@x54920 (trans (monotonicity (rewrite (= $x52701 $x54496)) $x54791) (rewrite (= $x54561 $x54561)) $x54791)))
 (let ((@x52308 (hypothesis $x46980)))
 (let (($x52204 (req%pmemlog!math_v.lemma_mod_difference_equal. ?x46943 ?x46946 ?x46948)))
 (let (($x52284 (not $x52204)))
 (let ((@x52360 (monotonicity (symm (monotonicity @x52354 @x52349 @x52344 (= $x52204 $x46758)) (= $x46758 $x52204)) (= (not $x46758) $x52284))))
 (let (($x47258 (not $x46758)))
 (let ((@x47274 (def-axiom (or $x46850 $x46847 $x46848))))
 (let ((@x52332 (unit-resolution @x47274 (unit-resolution (def-axiom (or $x46855 $x46849)) @x52308 $x46849) (hypothesis $x46864) $x46847)))
 (let ((@x47260 (def-axiom (or $x46860 $x47258))))
 (let (($x9891 (not %%global_location_label%%100)))
 (let (($x52197 (or $x9891 $x52198)))
 (let (($x52199 (not $x52197)))
 (let (($x9870 (not %%global_location_label%%99)))
 (let (($x52185 (or $x9870 $x52180)))
 (let (($x52187 (not $x52185)))
 (let (($x9856 (not %%global_location_label%%98)))
 (let (($x52160 (or $x9856 $x52155)))
 (let (($x52162 (not $x52160)))
 (let (($x9844 (not %%global_location_label%%97)))
 (let (($x52135 (or $x9844 $x51738)))
 (let (($x52137 (not $x52135)))
 (let (($x52205 (or $x52137 $x52162 $x52187 $x52199)))
 (let (($x52107 (= $x52205 $x52204)))
 (let (($x52238 (not $x52107)))
 (let (($x18611 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9822 (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9891 (not %%global_location_label%%100)))
 (let (($x9892 (or $x9891 $x9885)))
 (let (($x9862 (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))
 (let (($x9870 (not %%global_location_label%%99)))
 (let (($x9871 (or $x9870 $x9862)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9856 (not %%global_location_label%%98)))
 (let (($x9857 (or $x9856 $x9850)))
 (let (($x18595 (or (not (or (not %%global_location_label%%97) (not (<= d! 0)))) (not $x9857) (not $x9871) (not $x9892))))
 (not (= $x18595 $x9822))))))))))))))) :pattern ( (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_difference_equal._definition))
 ))
 (let (($x9898 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9891 (not %%global_location_label%%100)))
 (let (($x9892 (or $x9891 $x9885)))
 (let (($x9862 (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))
 (let (($x9870 (not %%global_location_label%%99)))
 (let (($x9871 (or $x9870 $x9862)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9856 (not %%global_location_label%%98)))
 (let (($x9857 (or $x9856 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9844 (not %%global_location_label%%97)))
 (let (($x9845 (or $x9844 $x1155)))
 (let (($x9897 (and $x9845 $x9857 $x9871 $x9892)))
 (let (($x9822 (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (= $x9822 $x9897)))))))))))))))))) :pattern ( (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_difference_equal._definition))
 ))
 (let ((?x18612 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9822 (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9891 (not %%global_location_label%%100)))
 (let (($x9892 (or $x9891 $x9885)))
 (let (($x9862 (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))
 (let (($x9870 (not %%global_location_label%%99)))
 (let (($x9871 (or $x9870 $x9862)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9856 (not %%global_location_label%%98)))
 (let (($x9857 (or $x9856 $x9850)))
 (let (($x18595 (or (not (or (not %%global_location_label%%97) (not (<= d! 0)))) (not $x9857) (not $x9871) (not $x9892))))
 (let (($x18603 (not (= $x18595 $x9822))))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9844 (not %%global_location_label%%97)))
 (let (($x9845 (or $x9844 $x1155)))
 (let (($x9897 (and $x9845 $x9857 $x9871 $x9892)))
 (let (($x9878 (= $x9822 $x9897)))
 (let (($x18606 (= $x9878 $x18603)))
 (let ((@x18601 (monotonicity (rewrite (= $x9897 (not $x18595))) (= $x9878 (= $x9822 (not $x18595))))))
 (trans (trans @x18601 (rewrite (= (= $x9822 (not $x18595)) $x18603)) $x18606) (rewrite (= $x18603 $x18603)) $x18606))))))))))))))))))))))))
 ))
 (let ((?x14476 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9891 (not %%global_location_label%%100)))
 (let (($x9892 (or $x9891 $x9885)))
 (let (($x9862 (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))
 (let (($x9870 (not %%global_location_label%%99)))
 (let (($x9871 (or $x9870 $x9862)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9856 (not %%global_location_label%%98)))
 (let (($x9857 (or $x9856 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9844 (not %%global_location_label%%97)))
 (let (($x9845 (or $x9844 $x1155)))
 (let (($x9897 (and $x9845 $x9857 $x9871 $x9892)))
 (let (($x9822 (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (let (($x9878 (= $x9822 $x9897)))
 (refl (~ $x9878 $x9878)))))))))))))))))))))
 ))
 (let (($x9839 (forall ((x! Int) (y! Int) (d! Int) )(! (let (($x9831 (=> %%global_location_label%%99 (<= (EucMod x! d!) (EucMod y! d!)))))
 (let (($x9836 (and (=> %%global_location_label%%97 (> d! 0)) (=> %%global_location_label%%98 (<= x! y!)) $x9831 (=> %%global_location_label%%100 (< (Sub y! x!) d!)))))
 (let (($x9822 (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (= $x9822 $x9836)))) :pattern ( (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!) ) :qid internal_req__pmemlog!math_v.lemma_mod_difference_equal._definition))
 ))
 (let ((?x9900 (lambda ((x! Int) (y! Int) (d! Int) )(let (($x9885 (not (<= (+ d! (* (- 1) (Sub y! x!))) 0))))
 (let (($x9891 (not %%global_location_label%%100)))
 (let (($x9892 (or $x9891 $x9885)))
 (let (($x9862 (>= (+ (EucMod y! d!) (* (- 1) (EucMod x! d!))) 0)))
 (let (($x9870 (not %%global_location_label%%99)))
 (let (($x9871 (or $x9870 $x9862)))
 (let ((?x1399 (* (- 1) x!)))
 (let ((?x1400 (+ y! ?x1399)))
 (let (($x9850 (>= ?x1400 0)))
 (let (($x9856 (not %%global_location_label%%98)))
 (let (($x9857 (or $x9856 $x9850)))
 (let (($x1154 (<= d! 0)))
 (let (($x1155 (not $x1154)))
 (let (($x9844 (not %%global_location_label%%97)))
 (let (($x9845 (or $x9844 $x1155)))
 (let (($x9897 (and $x9845 $x9857 $x9871 $x9892)))
 (let (($x9822 (req%pmemlog!math_v.lemma_mod_difference_equal. x! y! d!)))
 (let (($x9878 (= $x9822 $x9897)))
 (let (($x9831 (=> %%global_location_label%%99 (<= (EucMod x! d!) (EucMod y! d!)))))
 (let (($x9836 (and (=> %%global_location_label%%97 (> d! 0)) (=> %%global_location_label%%98 (<= x! y!)) $x9831 (=> %%global_location_label%%100 (< (Sub y! x!) d!)))))
 (let (($x9837 (= $x9822 $x9836)))
 (rewrite (= $x9837 $x9878))))))))))))))))))))))))
 ))
 (let ((@x9876 (mp (asserted $x9839) (quant-intro (proof-bind ?x9900) (= $x9839 $x9898)) $x9898)))
 (let ((@x18616 (mp (mp~ @x9876 (nnf-pos (proof-bind ?x14476) (~ $x9898 $x9898)) $x9898) (quant-intro (proof-bind ?x18612) (= $x9898 $x18611)) $x18611)))
 (let (($x52245 (not $x18611)))
 (let (($x52246 (or $x52245 $x52238)))
 (let (($x52132 (req%pmemlog!math_v.lemma_mod_difference_equal. ?x46987 ?x46991 ?x46994)))
 (let (($x52131 (or (not (or $x9844 $x51690)) (not (or $x9856 $x52117)) (not (or $x9870 (>= (+ ?x51402 (* (- 1) ?x51246)) 0))) (not (or $x9891 $x52128)))))
 (let (($x52133 (= $x52131 $x52132)))
 (let (($x52134 (not $x52133)))
 (let (($x52247 (or $x52245 $x52134)))
 (let (($x52249 (= $x52247 $x52246)))
 (let (($x52240 (= $x52134 $x52238)))
 (let ((@x52244 (trans (monotonicity (rewrite (= $x52133 $x52107)) $x52240) (rewrite (= $x52238 $x52238)) $x52240)))
 (let ((@x52254 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x52247) (trans (monotonicity @x52244 $x52249) (rewrite (= $x52246 $x52246)) $x52249) $x52246)))
 (let (($x52282 (not $x52205)))
 (let (($x51242 (<= ?x51236 0)))
 (let ((@x52369 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51237) $x51242)) @x52368 $x51242)))
 (let (($x51996 (>= ?x51994 0)))
 (let ((@x52372 ((_ th-lemma arith triangle-eq) (or (not $x51992) $x51996))))
 (let ((@x52385 (unit-resolution @x52372 @x52384 $x51996)))
 (let (($x51990 (<= ?x51989 0)))
 (let ((@x52397 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51988) $x51990)) @x52396 $x51990)))
 (let ((@x52434 (unit-resolution @x52400 @x52433 $x51542)))
 (let (($x51539 (>= ?x51537 0)))
 (let ((@x52437 ((_ th-lemma arith triangle-eq) (or (not $x51536) $x51539))))
 (let ((@x52456 (unit-resolution @x52437 @x52455 $x51539)))
 (let (($x51531 (>= ?x51529 0)))
 (let ((@x52486 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51528) $x51531)) @x52485 $x51531)))
 (let ((@x47276 (def-axiom (or $x46855 $x46856))))
 (let ((@x52492 (unit-resolution @x47276 @x52308 $x46856)))
 (let ((@x52495 (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x46885 $x46851)) @x52492 $x46885)))
 (let (($x52503 (not $x51242)))
 (let (($x52502 (not $x51539)))
 (let (($x52501 (not $x51531)))
 (let (($x52500 (not $x51996)))
 (let (($x52497 (not $x51990)))
 (let ((@x52505 ((_ th-lemma arith assign-bounds 1 1 -1 -1 1 1 1 1 -1) (or $x52180 $x52496 $x46888 $x52497 $x52498 $x52499 $x52500 $x52501 $x52502 $x52503))))
 (let ((@x52506 (unit-resolution @x52505 @x52495 @x52491 @x52486 @x52476 @x52456 @x52434 @x52397 @x52385 @x52369 $x52180)))
 (let ((@x52524 (unit-resolution (def-axiom (or $x52282 $x52137 $x52162 $x52187 $x52199)) (unit-resolution (def-axiom (or $x52135 $x51293)) @x51957 $x52135) (unit-resolution (def-axiom (or $x52160 (not $x52155))) @x52330 $x52160) (unit-resolution (def-axiom (or $x52185 $x52267)) @x52506 $x52185) (unit-resolution (def-axiom (or $x52197 $x52195)) @x52522 $x52197) $x52282)))
 (let ((@x52527 (unit-resolution (unit-resolution (def-axiom (or $x52107 $x52205 $x52204)) @x52524 (or $x52107 $x52204)) (unit-resolution @x52254 @x18616 $x52238) $x52204)))
 (let ((@x52528 (unit-resolution @x52527 (mp (unit-resolution @x47260 @x52332 $x47258) @x52360 $x52284) false)))
 (let ((@x52530 (lemma @x52528 (or $x46855 $x46848))))
 (let ((@x47264 (def-axiom (or $x46864 $x46760))))
 (let ((@x54570 (mp (unit-resolution @x47264 (unit-resolution @x52530 @x52308 $x46848) $x46760) (symm (monotonicity @x52354 @x52349 @x52344 (= $x52702 $x46760)) (= $x46760 $x52702)) $x52702)))
 (let ((@x54578 (unit-resolution (def-axiom (or (not $x54496) (not $x52702) $x54599)) @x54570 (unit-resolution (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x54774) @x54920 $x54561) @x14487 $x54496) $x54599)))
 (let ((@x54765 (trans* (symm @x54578 (= ?x52190 ?x54889)) @x54764 $x54836)))
 (let ((?x54600 (* (- 1) ?x51076)))
 (let ((?x54952 (+ ?x50833 ?x54600)))
 (let (($x54981 (<= ?x54952 0)))
 (let ((@x54912 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51077) $x54981)) @x52480 $x54981)))
 (let ((?x54974 (Sub ?x51083 ?x51076)))
 (let ((?x54975 (+ ?x51076 ?x54968 ?x54974)))
 (let (($x54979 (<= ?x54975 0)))
 (let (($x54980 (= ?x54975 0)))
 (let ((@x55210 (unit-resolution ((_ quant-inst (Add ?x51079 pmemlog!logimpl_v.contents_offset.?) (Add ?x51075 pmemlog!logimpl_v.contents_offset.?)) (or $x47606 $x54980)) @x10440 $x54980)))
 (let ((?x54779 (* (- 1) ?x54974)))
 (let ((?x54766 (+ ?x46812 ?x54779)))
 (let (($x54778 (<= ?x54766 0)))
 (let (($x54776 (= ?x46812 ?x54974)))
 (let ((@x54595 (symm (monotonicity @x54839 (= (%I ?x54745) ?x54744)) (= ?x54744 (%I ?x54745)))))
 (let ((@x54747 (symm (monotonicity (symm @x55057 (= ?x50842 ?x52288)) (= ?x54744 (%I ?x52288))) (= (%I ?x52288) ?x54744))))
 (let ((?x52289 (%I ?x52288)))
 (let (($x52292 (= ?x51076 ?x52289)))
 (let (($x54710 (or $x49974 $x52292)))
 (let ((@x54762 ((_ quant-inst (Add ?x51075 pmemlog!logimpl_v.contents_offset.?)) $x54710)))
 (let ((@x54592 (unit-resolution @x54762 @x10195 $x52292)))
 (let ((@x55315 (trans* @x54592 @x54747 @x54595 (= ?x51076 (%I ?x54745)))))
 (let ((@x55327 (symm (monotonicity @x55317 @x55315 (= ?x54974 (Sub ?x54928 (%I ?x54745)))) (= (Sub ?x54928 (%I ?x54745)) ?x54974))))
 (let ((?x54949 (%I ?x54745)))
 (let ((?x54955 (Sub ?x54928 ?x54949)))
 (let ((?x54841 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x54745 ?x54713)))
 (let ((?x54954 (vstd!seq.Seq.len.? $ ?x1876 ?x54841)))
 (let (($x54895 (= ?x54954 ?x54955)))
 (let (($x54950 (>= ?x54949 0)))
 (let (($x51361 (>= ?x51255 0)))
 (let ((?x51257 (mod ?x46943 ?x46948)))
 (let ((?x51260 (* (- 1) ?x51257)))
 (let ((?x51263 (+ ?x51255 ?x51260)))
 (let (($x51284 (>= ?x51263 0)))
 (let (($x51262 (= ?x51263 0)))
 (let (($x51267 (or $x51265 $x51262)))
 (let (($x51254 (= (+ ?x51246 (* (- 1) (mod ?x46987 ?x46994))) 0)))
 (let (($x51266 (or $x51265 $x51254)))
 (let (($x51270 (= $x51266 $x51267)))
 (let ((@x51274 (trans (monotonicity (rewrite (= $x51254 $x51262)) $x51270) (rewrite (= $x51267 $x51267)) $x51270)))
 (let ((@x51275 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46985) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985)) $x51266) @x51274 $x51267)))
 (let ((@x55189 (unit-resolution @x51275 @x10461 $x51262)))
 (let (($x51340 (>= ?x51257 0)))
 (let ((@x55193 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x51361 (not $x51340) (not $x51284))) (unit-resolution ((_ th-lemma arith) (or $x51336 $x51340)) @x55184 $x51340) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51262) $x51284)) @x55189 $x51284) $x51361)))
 (let ((?x54929 (* (- 1) ?x54949)))
 (let ((?x54897 (+ ?x50833 ?x54929)))
 (let (($x54964 (<= ?x54897 0)))
 (let (($x54291 (= ?x50833 ?x54949)))
 (let ((@x55198 (trans* @x52480 @x54592 @x54747 @x54595 $x54291)))
 (let ((@x55199 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54291) $x54964)) @x55198 $x54964)))
 (let (($x51364 (not $x51361)))
 (let (($x55228 (not $x48840)))
 (let (($x55166 (not $x48878)))
 (let (($x55227 (not $x48759)))
 (let ((@x55226 ((_ th-lemma arith assign-bounds 1 1 1 1 1 1 1 1 1) (or $x54950 (not $x54964) $x55227 $x55166 $x48785 $x55228 $x52501 $x51364 $x52502 $x52503))))
 (let ((@x55235 (unit-resolution @x55226 @x55199 @x55196 @x55171 @x52369 @x55193 @x52486 @x52456 @x55174 @x55123 $x54950)))
 (let ((?x54943 (+ ?x54928 ?x54929)))
 (let (($x54944 (>= ?x54943 0)))
 (let (($x54965 (>= ?x54897 0)))
 (let ((@x55297 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54291) $x54965)) @x55198 $x54965)))
 (let ((@x55302 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1 -1) (or $x54944 (not $x54965) $x55299 $x46888 $x52497 $x52500)) @x52495 @x52385 @x52397 @x55297 @x55294 $x54944)))
 (let (($x54945 (not $x54944)))
 (let (($x54947 (not $x54950)))
 (let (($x54924 (or $x54915 $x47483 $x54761 $x54752 $x53653 $x54947 $x54945 $x54890 $x54895)))
 (let ((@x54930 (rewrite (= (or $x54915 (or $x47483 $x54761 $x54752 $x53653 $x54947 $x54945 $x54890 $x54895)) $x54924))))
 (let (($x54951 (or $x47483 $x54761 $x54752 $x53653 $x54947 $x54945 $x54890 $x54895)))
 (let (($x54900 (or $x54915 $x54951)))
 (let (($x54948 (or $x47483 $x54761 $x54752 $x53653 $x54947 $x54945 $x54931 $x54895)))
 (let (($x54925 (or $x54915 $x54948)))
 (let (($x54580 (= $x54948 $x54951)))
 (let ((@x54650 (trans (monotonicity (rewrite (= $x54931 $x54890)) $x54580) (rewrite (= $x54951 $x54951)) $x54580)))
 (let ((@x54497 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x54744) (I ?x54712)) $x54925) (trans (monotonicity @x54650 (= $x54925 $x54900)) @x54930 (= $x54925 $x54924)) $x54924)))
 (let ((@x55312 (unit-resolution @x54497 @x175 @x55310 @x52976 @x55109 @x54563 (or $x54947 $x54945 $x54890 $x54895))))
 (let ((@x55313 (unit-resolution @x55312 @x55302 (unit-resolution @x55290 @x55284 @x55266 @x52476 @x52434 @x55257 @x55252 @x55245 @x52491 $x54934) @x55235 $x54895)))
 (let (($x51037 (= ?x50856 ?x50858)))
 (let (($x51040 (or $x47497 $x51037)))
 (let ((@x51041 ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x50855)) $x51040)))
 (let ((@x55026 (symm (unit-resolution @x51041 @x10785 $x51037) (= ?x50858 ?x50856))))
 (let ((?x50942 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log ?x50862)))
 (let ((@x55024 (symm ((_ th-lemma datatype) (= ?x50858 ?x50942)) (= ?x50942 ?x50858))))
 (let ((?x51085 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x50863)))
 (let ((?x51095 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?capacity ?x51085)))
 (let ((?x51094 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log ?x51085)))
 (let ((?x51093 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head ?x51085)))
 (let ((?x51096 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x51093 ?x51094 ?x51095)))
 (let ((?x51100 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log ?x51096)))
 (let (($x51097 (= ?x51085 ?x51096)))
 (let ((@x52845 ((_ th-lemma datatype) $x51097)))
 (let (($x51086 (= ?x50862 ?x51085)))
 (let (($x2539 (forall ((x pmemlog!infinitelog_t.AbstractInfiniteLogState.) )(! (let ((?x2535 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x)))
 (= x (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x2535))) :pattern ( (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x) ) :qid internal_pmemlog__infinitelog_t__AbstractInfiniteLogState_box_axiom_definition))
 ))
 (let ((?x11054 (lambda ((x pmemlog!infinitelog_t.AbstractInfiniteLogState.) )(let ((?x2535 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x)))
 (let (($x2537 (= x (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x2535))))
 (refl (~ $x2537 $x2537)))))
 ))
 (let ((@x11058 (mp~ (asserted $x2539) (nnf-pos (proof-bind ?x11054) (~ $x2539 $x2539)) $x2539)))
 (let (($x47690 (not $x2539)))
 (let (($x51091 (or $x47690 $x51086)))
 (let ((@x51092 ((_ quant-inst (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x50830 ?x50858 ?x50861)) $x51091)))
 (let ((@x52844 (unit-resolution @x51092 @x11058 $x51086)))
 (let ((@x55022 (symm (monotonicity (trans* @x52844 @x52845 (= ?x50862 ?x51096)) (= ?x50942 ?x51100)) (= ?x51100 ?x50942))))
 (let ((?x47387 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?capacity ?x46805)))
 (let ((?x47386 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log ?x46805)))
 (let ((?x47385 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head ?x46805)))
 (let ((?x47388 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x47385 ?x47386 ?x47387)))
 (let ((?x47392 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log ?x47388)))
 (let (($x47389 (= ?x46805 ?x47388)))
 (let ((@x52852 ((_ th-lemma datatype) $x47389)))
 (let ((?x47671 (core!option.Option./Some/?0 ?x46803)))
 (let (($x47672 (= ?x46804 ?x47671)))
 (let (($x47669 ((_ is core!option.Option./Some ) ?x46803)))
 (let (($x52859 (= $x47669 true)))
 (let ((@x47464 (iff-true @x46680 (= $x46677 true))))
 (let (($x47674 (= ?x46674 ?x46803)))
 (let (($x2085 (forall ((x core!option.Option.) )(! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ( (Poly%core!option.Option. x) ) :qid internal_core__option__Option_box_axiom_definition))
 ))
 (let ((?x10865 (lambda ((x core!option.Option.) )(let (($x2083 (= x (%Poly%core!option.Option. (Poly%core!option.Option. x)))))
 (refl (~ $x2083 $x2083))))
 ))
 (let ((@x10869 (mp~ (asserted $x2085) (nnf-pos (proof-bind ?x10865) (~ $x2085 $x2085)) $x2085)))
 (let (($x47685 (or (not $x2085) $x47674)))
 (let ((@x47686 ((_ quant-inst (pmemlog!logimpl_v.impl&%0.recover.? ?x46673)) $x47685)))
 (let ((@x52855 (symm (unit-resolution @x47686 @x10869 $x47674) (= ?x46803 ?x46674))))
 (let ((@x52863 (mp (trans* (monotonicity @x52855 (= $x47669 $x46677)) @x47464 $x52859) (rewrite (= $x52859 $x47669)) $x47669)))
 (let (($x47670 (not $x47669)))
 (let (($x47673 (or $x47670 $x47672)))
 (let (($x2150 (forall ((V&. Dcr) (V& Type) (x core!option.Option.) )(! (let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2138 ((_ is core!option.Option./Some ) x)))
 (let (($x2144 (not $x2138)))
 (or $x2144 $x2133))))) :pattern ( (core!option.Option./Some/0 V&. V& x) ) :qid internal_core!option.Option./Some/0_accessor_definition))
 ))
 (let ((?x10893 (lambda ((V&. Dcr) (V& Type) (x core!option.Option.) )(let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2138 ((_ is core!option.Option./Some ) x)))
 (let (($x2144 (not $x2138)))
 (let (($x2145 (or $x2144 $x2133)))
 (refl (~ $x2145 $x2145))))))))
 ))
 (let (($x2136 (forall ((V&. Dcr) (V& Type) (x core!option.Option.) )(! (let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2130 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) x)))
 (=> $x2130 $x2133)))) :pattern ( (core!option.Option./Some/0 V&. V& x) ) :qid internal_core!option.Option./Some/0_accessor_definition))
 ))
 (let ((?x2151 (lambda ((V&. Dcr) (V& Type) (x core!option.Option.) )(let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2138 ((_ is core!option.Option./Some ) x)))
 (let (($x2144 (not $x2138)))
 (let (($x2145 (or $x2144 $x2133)))
 (let (($x2130 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) x)))
 (let (($x2134 (=> $x2130 $x2133)))
 (trans (monotonicity (rewrite (= $x2130 $x2138)) (= $x2134 (=> $x2138 $x2133))) (rewrite (= (=> $x2138 $x2133) $x2145)) (= $x2134 $x2145))))))))))
 ))
 (let ((@x2155 (mp (asserted $x2136) (quant-intro (proof-bind ?x2151) (= $x2136 $x2150)) $x2150)))
 (let ((@x10897 (mp~ @x2155 (nnf-pos (proof-bind ?x10893) (~ $x2150 $x2150)) $x2150)))
 (let (($x47676 (not $x2150)))
 (let (($x47677 (or $x47676 $x47670 $x47672)))
 (let ((@x47682 (mp ((_ quant-inst $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x46802)) (or $x47676 $x47673)) (rewrite (= (or $x47676 $x47673) $x47677)) $x47677)))
 (let ((@x52878 (symm (unit-resolution (unit-resolution @x47682 @x10897 $x47673) @x52863 $x47672) (= ?x47671 ?x46804))))
 (let (($x50872 (= ?x50864 ?x50865)))
 (let ((@x50950 (def-axiom (or (not $x50820) $x50872))))
 (let ((@x52869 (trans* (unit-resolution @x50950 @x51950 $x50872) (symm @x51778 (= ?x50865 ?x46674)) (= ?x50864 ?x46674))))
 (let ((@x52880 (trans* ((_ th-lemma datatype) (= ?x50863 (core!option.Option./Some/?0 ?x50864))) (monotonicity @x52869 (= (core!option.Option./Some/?0 ?x50864) ?x47477)) (symm (monotonicity @x52855 (= ?x47671 ?x47477)) (= ?x47477 ?x47671)) @x52878 (= ?x50863 ?x46804))))
 (let ((@x52882 (monotonicity @x52880 (= ?x51085 ?x46805))))
 (let ((@x52847 (symm @x52845 (= ?x51096 ?x51085))))
 (let ((@x55020 (symm (monotonicity (trans* @x52847 @x52882 @x52852 (= ?x51096 ?x47388)) (= ?x51100 ?x47392)) (= ?x47392 ?x51100))))
 (let (($x47393 (= ?x47386 ?x47392)))
 (let ((@x55011 ((_ th-lemma datatype) $x47393)))
 (let ((?x52683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/log ?x47388)))
 (let (($x52690 (= ?x52683 ?x47386)))
 (let (($x2570 (forall ((x pmemlog!infinitelog_t.AbstractInfiniteLogState.) )(! (let ((?x2567 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log x)))
 (let ((?x2566 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/log x)))
 (= ?x2566 ?x2567))) :pattern ( (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/log x) ) :qid internal_pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/log_accessor_definition))
 ))
 (let ((?x11075 (lambda ((x pmemlog!infinitelog_t.AbstractInfiniteLogState.) )(let ((?x2567 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log x)))
 (let ((?x2566 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/log x)))
 (let (($x2568 (= ?x2566 ?x2567)))
 (refl (~ $x2568 $x2568))))))
 ))
 (let ((@x11079 (mp~ (asserted $x2570) (nnf-pos (proof-bind ?x11075) (~ $x2570 $x2570)) $x2570)))
 (let (($x52694 (not $x2570)))
 (let (($x52704 (or $x52694 $x52690)))
 (let (($x52684 (= ?x52683 ?x47392)))
 (let (($x52709 (or $x52694 $x52684)))
 (let (($x52728 (= $x52709 $x52704)))
 (let ((@x52736 (trans (monotonicity (rewrite (= $x52684 $x52690)) $x52728) (rewrite (= $x52704 $x52704)) $x52728)))
 (let ((@x52739 (mp ((_ quant-inst (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x47385 ?x47386 ?x47387)) $x52709) @x52736 $x52704)))
 (let ((?x47675 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47388)))
 (let ((?x47683 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47675)))
 (let (($x47687 (= ?x47388 ?x47683)))
 (let (($x47691 (or $x47690 $x47687)))
 (let ((@x47692 ((_ quant-inst (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x47385 ?x47386 ?x47387)) $x47691)))
 (let ((@x52895 (symm (monotonicity (symm @x52852 (= ?x47388 ?x46805)) (= ?x47675 ?x46806)) (= ?x46806 ?x47675))))
 (let ((@x52901 (trans* (monotonicity @x52895 (= ?x46807 ?x47683)) (symm (unit-resolution @x47692 @x11058 $x47687) (= ?x47683 ?x47388)) (= ?x46807 ?x47388))))
 (let ((@x55028 (trans* (monotonicity @x52901 (= ?x46810 ?x52683)) (unit-resolution @x52739 @x11079 $x52690) @x55011 @x55020 @x55022 @x55024 @x55026 (= ?x46810 ?x50856))))
 (let ((@x55034 (monotonicity @x55028 (= ?x46811 ?x50857))))
 (let ((@x55036 (symm @x55034 (= ?x50857 ?x46811))))
 (let (($x52731 (= ?x50855 ?x50857)))
 (let (($x52729 (has_type ?x50855 ?x1968)))
 (let (($x50927 (= ?x50854 ?x50855)))
 (let (($x50935 (not $x50840)))
 (let ((@x55121 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1) (or $x50935 $x46851 $x52497 $x52500)) @x52397 @x52385 (or $x50935 $x46851))))
 (let ((@x50939 (def-axiom (or $x50840 $x50927))))
 (let ((@x54229 (unit-resolution @x50939 (unit-resolution @x55121 @x52492 $x50935) $x50927)))
 (let ((@x54512 (trans* (symm @x54229 (= ?x50855 ?x50854)) (symm (monotonicity @x54839 @x55112 (= ?x54841 ?x50854)) (= ?x50854 ?x54841)) (= ?x50855 ?x54841))))
 (let ((@x54757 (symm (monotonicity @x54512 (= $x52729 (has_type ?x54841 ?x1968))) (= (has_type ?x54841 ?x1968) $x52729))))
 (let (($x54842 (has_type ?x54841 ?x1968)))
 (let (($x54834 (or $x49906 $x47483 $x54761 $x54752 $x54842)))
 (let ((@x54721 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x54744) (I ?x54712)) (or $x49906 (or $x47483 $x54761 $x54752 $x54842))) (rewrite (= (or $x49906 (or $x47483 $x54761 $x54752 $x54842)) $x54834)) $x54834)))
 (let ((@x55118 (unit-resolution (unit-resolution @x54721 @x15714 @x52976 (or $x54761 $x54752 $x54842)) @x54563 @x55109 $x54842)))
 (let (($x52730 (not $x52729)))
 (let (($x52732 (or $x52730 $x52731)))
 (let (($x54932 (or $x53538 $x52730 $x52731)))
 (let ((@x54942 (mp ((_ quant-inst (ite $x50840 ?x50853 ?x50854)) (or $x53538 $x52732)) (rewrite (= (or $x53538 $x52732) $x54932)) $x54932)))
 (let ((@x54986 (unit-resolution @x54942 @x10792 $x52732)))
 (let ((@x55079 (monotonicity @x54839 @x55112 (= ?x54841 ?x50854))))
 (let ((@x55124 (trans* @x55079 @x54229 (unit-resolution @x54986 (mp @x55118 @x54757 $x52729) $x52731) @x55036 (= ?x54841 ?x46811))))
 (let ((@x55328 (trans* (symm (monotonicity @x55124 (= ?x54954 ?x46812)) (= ?x46812 ?x54954)) @x55313 @x55327 $x54776)))
 (let (($x54940 (<= ?x54937 0)))
 (let (($x54591 (>= ?x54766 0)))
 (let (($x54982 (>= ?x54952 0)))
 (let ((@x55209 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51077) $x54982)) @x52480 $x54982)))
 (let (($x54740 (>= ?x54975 0)))
 (let (($x55216 (not $x52793)))
 (let ((@x55217 (hypothesis $x55216)))
 (let ((?x52762 (* (- 1) ?x51079)))
 (let ((?x52754 (+ ?x51075 ?x52762 ?x52753)))
 (let (($x54935 (<= ?x52754 0)))
 (let (($x52733 (= ?x52754 0)))
 (let ((@x55218 (unit-resolution ((_ quant-inst (EucMod ?x51078 ?x51074) (EucMod ?x50830 ?x51074)) (or $x47606 $x52733)) @x10440 $x52733)))
 (let (($x52106 (<= ?x52270 0)))
 (let ((@x55229 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x52105) $x52106)) @x52517 $x52106)))
 (let ((@x55230 ((_ th-lemma arith farkas 1 1 -1 -1 1 1 -1 -1 -1 -1 1 1) @x55229 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x52733) $x54935)) @x55218 $x54935) @x55217 @x52621 @x52627 @x52624 @x52600 (hypothesis $x54591) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54980) $x54740)) @x55210 $x54740) @x55209 @x55205 (hypothesis $x54940) false)))
 (let ((@x55234 (lemma @x55230 (or $x52793 (not $x54591) (not $x54940)))))
 (let ((@x55336 (unit-resolution @x55234 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54776) $x54591)) @x55328 $x54591) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54836) $x54940)) @x54765 $x54940) $x52793)))
 (let (($x52740 (= ?x46689 ?x46812)))
 (let (($x55352 (not $x52740)))
 (let ((@x55354 (monotonicity (symm (commutativity (= $x52740 $x46813)) (= $x46813 $x52740)) (= $x47011 $x55352))))
 (let (($x52770 (= $x46844 true)))
 (let ((@x52771 (trans* (monotonicity (not-or-elim @x46870 $x46707) (= $x46844 $x46677)) @x47464 $x52770)))
 (let ((@x47374 (def-axiom (or $x46897 $x46920))))
 (let ((@x47384 (def-axiom (or $x47004 $x47001 $x47002))))
 (let ((@x52777 (unit-resolution @x47384 (unit-resolution @x47374 (mp @x52771 (rewrite (= $x52770 $x46844)) $x46844) $x46897) (or $x47004 $x47001))))
 (let ((@x52778 (unit-resolution @x52777 (unit-resolution (def-axiom (or $x47027 $x47003)) @x52339 $x47003) $x47001)))
 (let ((@x47370 (def-axiom (or $x46992 $x46988))))
 (let ((@x52750 (monotonicity (trans* @x52446 (symm @x52438 (= ?x50970 ?x46943)) (= ?x50830 ?x46943)) @x52745 $x51536)))
 (let ((@x52751 (unit-resolution @x52615 @x52750 $x51538)))
 (let ((@x52752 (unit-resolution @x52437 @x52750 $x51539)))
 (let ((@x52760 (monotonicity (symm @x52380 (= ?x50829 ?x46741)) (symm @x52376 (= ?x50832 ?x46742)) (= ?x50833 ?x46743))))
 (let ((@x52764 (trans* @x52381 (symm @x52760 $x52382) $x51992)))
 (let ((@x47368 (def-axiom (or $x46992 $x46982))))
 (let ((@x52779 (unit-resolution @x47368 @x52778 $x46982)))
 (let ((@x52780 (hypothesis %%switch_label%%1)))
 (let ((@x47266 (def-axiom (or $x46864 $x46789))))
 (let ((@x47356 (def-axiom (or $x46983 $x46980 $x46981))))
 (let ((@x52783 (unit-resolution @x47356 (unit-resolution @x52530 (unit-resolution @x47266 @x52780 $x46864) $x46855) @x52779 $x46981)))
 (let ((@x47346 (def-axiom (or $x46971 $x46842))))
 (let ((@x47342 (def-axiom (or $x46968 %%switch_label%%2 $x46789))))
 (let ((@x52786 (unit-resolution @x47342 (unit-resolution (def-axiom (or $x46971 $x46967)) @x52783 $x46967) @x52780 %%switch_label%%2)))
 (let ((@x47291 (def-axiom (or $x46896 $x46784))))
 (let ((@x47336 (def-axiom (or $x46843 $x46949 $x46956))))
 (let ((@x52789 (unit-resolution @x47336 (unit-resolution @x52648 (unit-resolution @x47291 @x52786 $x46896) $x46869) (unit-resolution @x47346 @x52783 $x46842) $x46956)))
 (let ((@x47326 (def-axiom (or $x46959 $x46885))))
 (let ((@x52794 ((_ th-lemma arith eq-propagate -1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 -1 -1) @x52613 @x52434 (unit-resolution (def-axiom (or $x46971 $x46851)) @x52783 $x46851) (unit-resolution @x47326 @x52789 $x46885) @x52606 @x52397 @x52621 @x52476 @x52491 @x52627 (unit-resolution @x52372 @x52764 $x51996) (unit-resolution @x52602 @x52764 $x51995) @x52486 @x52624 @x52752 @x52751 @x52600 @x52369 $x52579)))
 (let ((@x52700 (def-axiom (or $x52617 (not $x52579)))))
 (let (($x47308 (not $x46777)))
 (let ((@x47324 (def-axiom (or $x46955 $x46950 $x46953))))
 (let ((@x52799 (unit-resolution @x47324 (unit-resolution (def-axiom (or $x46959 $x46954)) @x52789 $x46954) (unit-resolution (def-axiom (or $x46918 $x46784)) @x52786 $x46918) $x46950)))
 (let ((@x47310 (def-axiom (or $x46914 $x47308))))
 (let ((@x52726 (def-axiom (or $x52663 $x52654 $x52661))))
 (let ((@x52808 (unit-resolution @x52726 (mp (unit-resolution @x47310 @x52799 $x47308) @x52806 $x52720) @x52796 $x52654)))
 (let ((@x52692 (def-axiom (or $x52567 (not $x52155)))))
 (let ((@x52810 (unit-resolution @x52692 @x52330 $x52567)))
 (let ((@x52686 (def-axiom (or $x52562 $x51293))))
 (let ((@x52809 (unit-resolution @x52686 @x51957 $x52562)))
 (let ((@x52719 (def-axiom (or $x52717 $x52564 $x52574 $x52609 $x52651))))
 (let ((@x52814 (unit-resolution (unit-resolution @x52719 @x52809 @x52810 @x52811 (or $x52717 $x52609)) @x52808 (unit-resolution @x52700 @x52794 $x52617) false)))
 (let ((@x52815 (lemma @x52814 $x46789)))
 (let ((@x47362 (def-axiom (or $x46989 %%switch_label%%1 $x46800))))
 (let ((@x47426 (def-axiom (or $x47022 %%switch_label%%0 $x47020))))
 (let ((@x55345 (unit-resolution @x47426 (unit-resolution @x47362 @x52815 (unit-resolution @x47370 @x52778 $x46988) $x46800) (unit-resolution (def-axiom (or $x47027 $x47021)) @x52339 $x47021) $x47020)))
 (let ((@x47418 (def-axiom (or $x47016 $x47012))))
 (let ((?x52824 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/head ?x47388)))
 (let (($x52828 (= ?x52824 ?x47385)))
 (let (($x2564 (forall ((x pmemlog!infinitelog_t.AbstractInfiniteLogState.) )(! (let ((?x2561 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head x)))
 (let ((?x2560 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/head x)))
 (= ?x2560 ?x2561))) :pattern ( (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/head x) ) :qid internal_pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/head_accessor_definition))
 ))
 (let ((?x11068 (lambda ((x pmemlog!infinitelog_t.AbstractInfiniteLogState.) )(let ((?x2561 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head x)))
 (let ((?x2560 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/head x)))
 (let (($x2562 (= ?x2560 ?x2561)))
 (refl (~ $x2562 $x2562))))))
 ))
 (let ((@x11072 (mp~ (asserted $x2564) (nnf-pos (proof-bind ?x11068) (~ $x2564 $x2564)) $x2564)))
 (let (($x52830 (not $x2564)))
 (let (($x52832 (or $x52830 $x52828)))
 (let ((?x47390 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head ?x47388)))
 (let (($x52825 (= ?x52824 ?x47390)))
 (let (($x52833 (or $x52830 $x52825)))
 (let (($x52835 (= $x52833 $x52832)))
 (let ((@x52839 (trans (monotonicity (rewrite (= $x52825 $x52828)) $x52835) (rewrite (= $x52832 $x52832)) $x52835)))
 (let ((@x52916 (symm (unit-resolution (mp ((_ quant-inst (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x47385 ?x47386 ?x47387)) $x52833) @x52839 $x52832) @x11072 $x52828) (= ?x47385 ?x52824))))
 (let ((?x51098 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head ?x51096)))
 (let ((@x52884 (symm @x52852 (= ?x47388 ?x46805))))
 (let ((@x52905 (monotonicity (trans* @x52884 (symm @x52882 (= ?x46805 ?x51085)) @x52845 (= ?x47388 ?x51096)) (= ?x47390 ?x51098))))
 (let ((?x50940 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?head ?x50862)))
 (let ((@x52907 (monotonicity (trans* @x52847 (symm @x52844 (= ?x51085 ?x50862)) (= ?x51096 ?x50862)) (= ?x51098 ?x50940))))
 (let ((@x52919 (trans* @x51892 @x51885 @x51884 @x51894 @x52317 @x52318 @x52438 @x52450 ((_ th-lemma datatype) (= ?x50830 ?x50940)) (symm @x52907 (= ?x50940 ?x51098)) (symm @x52905 (= ?x51098 ?x47390)) (symm ((_ th-lemma datatype) (= ?x47385 ?x47390)) (= ?x47390 ?x47385)) @x52916 (symm (monotonicity @x52901 (= ?x46808 ?x52824)) (= ?x52824 ?x46808)) $x46809)))
 (let ((@x52922 (lemma (unit-resolution (hypothesis $x47010) @x52919 false) $x46809)))
 (let ((@x47414 (def-axiom (or $x47013 $x47009 $x47010 $x47011))))
 (let ((@x55347 (unit-resolution (unit-resolution @x47414 @x46680 (or $x47013 $x47010 $x47011)) @x52922 (unit-resolution @x47418 @x55345 $x47012) $x47011)))
 (let ((@x55357 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x52740 $x55216 $x55337)) (mp @x55347 @x55354 $x55352) (or $x55216 $x55337))))
 (let (($x54939 (>= ?x52754 0)))
 (let ((@x55362 ((_ th-lemma arith farkas 1 1 -1 -1 1 1 -1 -1 -1 -1 1 1) @x52518 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x52733) $x54939)) @x55218 $x54939) (unit-resolution @x55357 @x55336 $x55337) @x52476 @x52491 @x52486 @x52369 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54776) $x54778)) @x55328 $x54778) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54980) $x54979)) @x55210 $x54979) @x54912 @x55076 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54836) $x54941)) @x54765 $x54941) false)))
 (let ((@x55363 (lemma @x55362 $x46855)))
 (let ((@x55934 (unit-resolution (unit-resolution @x47356 @x52779 $x46982) @x55363 $x46981)))
 (let ((@x47344 (def-axiom (or $x46971 $x46851))))
 (let ((@x55931 (unit-resolution @x47344 @x55934 $x46851)))
 (let ((@x55987 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1) (or $x50840 $x46856 $x52630 $x52633)) @x52606 @x52603 (or $x50840 $x46856))))
 (let ((@x50937 (def-axiom (or $x50935 $x50926))))
 (let ((@x56047 (symm (unit-resolution @x50937 (unit-resolution @x55987 @x55931 $x50840) $x50926) (= ?x50855 ?x50853))))
 (let (($x55833 (= ?x50857 ?x50855)))
 (let ((@x55828 (monotonicity (trans* @x56047 @x55770 @x55772 (= ?x50855 ?x55509)) (= $x52729 (has_type ?x55509 ?x1968)))))
 (let (($x55473 (has_type ?x55509 ?x1968)))
 (let (($x16020 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x15840 (not $x4525)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x15587 (not $x4101)))
 (or $x15587 $x15840 $x4941)))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let (($x4949 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4941)))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let ((?x16021 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x15840 (not $x4525)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x15587 (not $x4101)))
 (let (($x16015 (or $x15587 $x15840 $x4941)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (let ((@x16007 (monotonicity (rewrite (= $x4526 (not (or $x15587 $x15840)))) (= $x4568 (not (not (or $x15587 $x15840)))))))
 (let ((@x16011 (trans @x16007 (rewrite (= (not (not (or $x15587 $x15840))) (or $x15587 $x15840))) (= $x4568 (or $x15587 $x15840)))))
 (trans (monotonicity @x16011 (= $x4946 (or (or $x15587 $x15840) $x4941))) (rewrite (= (or (or $x15587 $x15840) $x4941) $x16015)) (= $x4946 $x16015))))))))))))))))
 ))
 (let ((?x12275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (refl (~ $x4946 $x4946)))))))))))
 ))
 (let (($x4944 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> $x4526 $x4941))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let ((?x4950 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (let (($x4942 (=> $x4526 $x4941)))
 (rewrite (= $x4942 $x4946))))))))))))
 ))
 (let ((@x4954 (mp (asserted $x4944) (quant-intro (proof-bind ?x4950) (= $x4944 $x4949)) $x4949)))
 (let ((@x16025 (mp (mp~ @x4954 (nnf-pos (proof-bind ?x12275) (~ $x4949 $x4949)) $x4949) (quant-intro (proof-bind ?x16021) (= $x4949 $x16020)) $x16020)))
 (let (($x55634 (not $x16020)))
 (let (($x55638 (or $x55634 $x55500 $x55496 $x55473)))
 (let ((@x55642 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x50842 ?x50844) (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7471 ?x50848)) (or $x55634 (or $x55500 $x55496 $x55473))) (rewrite (= (or $x55634 (or $x55500 $x55496 $x55473)) $x55638)) $x55638)))
 (let ((@x55829 (mp (unit-resolution @x55642 @x16025 @x55979 @x56001 $x55473) (symm @x55828 (= $x55473 $x52729)) $x52729)))
 (let ((@x56048 (trans* @x55034 (symm (unit-resolution @x54986 @x55829 $x52731) $x55833) @x56047 @x55770 @x55772 (= ?x46811 ?x55509))))
 (let ((@x56071 (trans* (monotonicity @x56048 (= ?x46812 ?x55510)) @x56002 $x55823)))
 (let (($x55810 (<= ?x55809 0)))
 (let ((?x55583 (* (- 1) ?x50030)))
 (let ((?x55584 (+ ?x49340 ?x55583)))
 (let (($x55658 (<= ?x55584 0)))
 (let ((@x55952 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50031) $x55658)) @x54816 $x55658)))
 (let ((?x55677 (Sub ?x50030 ?x51076)))
 (let ((?x55686 (* (- 1) ?x55677)))
 (let ((?x55687 (+ ?x50030 ?x54600 ?x55686)))
 (let (($x55702 (<= ?x55687 0)))
 (let (($x55688 (= ?x55687 0)))
 (let (($x55693 (or $x47606 $x55688)))
 (let ((?x55678 (+ ?x51076 ?x55583 ?x55677)))
 (let (($x55679 (= ?x55678 0)))
 (let (($x55694 (or $x47606 $x55679)))
 (let (($x55696 (= $x55694 $x55693)))
 (let ((@x55682 (rewrite (= ?x55678 (+ ?x55583 ?x51076 ?x55677)))))
 (let ((@x55692 (trans (monotonicity @x55682 (= $x55679 (= (+ ?x55583 ?x51076 ?x55677) 0))) (rewrite (= (= (+ ?x55583 ?x51076 ?x55677) 0) $x55688)) (= $x55679 $x55688))))
 (let ((@x55701 (mp ((_ quant-inst (%I ?x49341) (Add ?x51075 pmemlog!logimpl_v.contents_offset.?)) $x55694) (trans (monotonicity @x55692 $x55696) (rewrite (= $x55693 $x55693)) $x55696) $x55693)))
 (let ((@x55953 (unit-resolution @x55701 @x10440 $x55688)))
 (let ((@x55957 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55688) $x55702)) @x55953 $x55702)))
 (let ((?x55450 (+ ?x55517 ?x55686)))
 (let (($x55478 (>= ?x55450 0)))
 (let (($x55449 (= ?x55517 ?x55677)))
 (let ((@x56008 (symm (monotonicity @x55315 (= ?x55677 (Sub ?x50030 ?x54949))) (= (Sub ?x50030 ?x54949) ?x55677))))
 (let ((?x55574 (Sub ?x50030 ?x54949)))
 (let ((?x55573 (vstd!seq.Seq.len.? $ ?x1876 ?x55393)))
 (let (($x55575 (= ?x55573 ?x55574)))
 (let ((?x55561 (+ ?x50030 ?x54929)))
 (let (($x55562 (>= ?x55561 0)))
 (let (($x51294 (>= ?x46948 0)))
 (let ((?x51310 (ite $x51294 ?x46948 ?x51044)))
 (let ((?x51287 (* (- 1) ?x51310)))
 (let ((?x51723 (+ ?x46948 ?x51287)))
 (let (($x51725 (>= ?x51723 0)))
 (let (($x51308 (= ?x46948 ?x51310)))
 (let ((@x51312 (def-axiom (or (not $x51294) $x51308))))
 (let ((@x55941 (unit-resolution @x51312 (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x51294 $x51293)) @x51957 $x51294) $x51308)))
 (let ((@x55942 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51308) $x51725)) @x55941 $x51725)))
 (let ((?x51292 (+ ?x51257 ?x51287)))
 (let (($x51306 (<= ?x51292 (- 1))))
 (let ((@x55948 (unit-resolution ((_ th-lemma arith) (or $x51336 $x51306)) @x55184 $x51306)))
 (let (($x51283 (<= ?x51263 0)))
 (let ((@x55945 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51262) $x51283)) @x55189 $x51283)))
 (let (($x55298 (not $x54965)))
 (let (($x55992 (or $x55562 $x55298 (not $x55658) $x55285 $x55286 $x55287 (not $x51306) (not $x51283) (not $x51725) $x52634 $x52635 $x52636)))
 (let ((@x55993 ((_ th-lemma arith assign-bounds 1 1 1 1 1 1 1 1 1 1 1) $x55992)))
 (let ((@x56069 (unit-resolution @x55993 @x55952 @x55945 @x55948 @x52624 @x52618 @x55942 @x55257 @x55252 @x55297 @x52600 @x55245 $x55562)))
 (let (($x55585 (>= ?x55584 0)))
 (let ((@x55985 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50031) $x55585)) @x54816 $x55585)))
 (let ((@x55995 (unit-resolution @x55226 @x55199 @x55196 @x55171 @x52369 @x55193 @x52486 @x52456 @x55123 @x55174 $x54950)))
 (let (($x55590 (not $x55585)))
 (let (($x55569 (not $x55562)))
 (let (($x55599 (or $x54915 $x47483 $x54761 $x49961 $x53653 $x54947 $x55569 $x55590 $x55575)))
 (let ((?x55570 (+ ?x50030 ?x54518)))
 (let (($x55571 (<= ?x55570 0)))
 (let (($x55572 (not $x55571)))
 (let (($x55576 (or $x47483 $x54761 $x49961 $x53653 $x54947 $x55569 $x55572 $x55575)))
 (let (($x55600 (or $x54915 $x55576)))
 (let ((@x55606 (rewrite (= (or $x54915 (or $x47483 $x54761 $x49961 $x53653 $x54947 $x55569 $x55590 $x55575)) $x55599))))
 (let (($x55592 (or $x47483 $x54761 $x49961 $x53653 $x54947 $x55569 $x55590 $x55575)))
 (let (($x55594 (= $x55576 $x55592)))
 (let ((@x55598 (trans (monotonicity (rewrite (= $x55572 $x55590)) $x55594) (rewrite (= $x55592 $x55592)) $x55594)))
 (let ((@x55608 (trans (monotonicity @x55598 (= $x55600 (or $x54915 $x55592))) @x55606 (= $x55600 $x55599))))
 (let ((@x55609 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x54744) (I ?x49340)) $x55600) @x55608 $x55599)))
 (let ((@x56068 (unit-resolution @x55609 @x175 @x55310 @x52976 @x54833 @x55995 @x55985 (or $x54761 $x55569 $x55575))))
 (let ((@x56077 (trans* (symm (monotonicity @x55969 (= ?x55573 ?x55517)) (= ?x55517 ?x55573)) (unit-resolution @x56068 @x55109 @x56069 $x55575) @x56008 $x55449)))
 (let ((?x54790 (* (- 1) ?x55519)))
 (let ((?x54589 (+ ?x55517 ?x55518 ?x54790)))
 (let (($x54837 (<= ?x54589 0)))
 (let (($x54787 (= ?x54589 0)))
 (let (($x54840 (or $x48868 $x54787)))
 (let (($x54607 (= (+ ?x55518 ?x55517 ?x54790) 0)))
 (let (($x54777 (or $x48868 $x54607)))
 (let (($x54788 (= $x54777 $x54840)))
 (let ((@x54569 (trans (monotonicity (rewrite (= $x54607 $x54787)) $x54788) (rewrite (= $x54840 $x54840)) $x54788)))
 (let ((@x54838 (mp ((_ quant-inst (vstd!seq.Seq.len.? $ ?x1876 ?x50845) (vstd!seq.Seq.len.? $ ?x1876 ?x50849)) $x54777) @x54569 $x54840)))
 (let ((@x56082 (unit-resolution @x54838 @x10433 $x54787)))
 (let ((?x55822 (+ ?x55519 ?x55821)))
 (let (($x55774 (<= ?x55822 0)))
 (let (($x55534 (= ?x55519 ?x55520)))
 (let (($x55532 (>= ?x55519 0)))
 (let (($x55533 (not $x55532)))
 (let (($x55535 (or $x55533 $x55534)))
 (let (($x55536 (not $x55535)))
 (let (($x55537 (or (not (>= ?x55520 0)) $x55536)))
 (let (($x55538 (not $x55537)))
 (let (($x12235 (forall ((i Int) )(! (let (($x12229 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (not $x12229)) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let (($x534 (forall ((i Int) )(! (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (and $x533 $x541))))))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x14530 (lambda ((i Int) )(let (($x12229 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (let (($x12206 (not $x12229)))
 (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (rewrite (= $x546 $x12206))))))))))))
 ))
 (let ((?x10282 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (refl (~ $x546 $x546))))))))))
 ))
 (let (($x529 (forall ((i Int) )(! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x535 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (let (($x527 (and (<= 0 ?x522) (=> (<= 0 i) $x525))))
 (rewrite (= $x527 $x546)))))))))))
 ))
 (let ((@x542 (mp (asserted $x529) (quant-intro (proof-bind ?x535) (= $x529 $x534)) $x534)))
 (let ((@x14534 (mp (mp~ @x542 (nnf-pos (proof-bind ?x10282) (~ $x534 $x534)) $x534) (quant-intro (proof-bind ?x14530) (= $x534 $x12235)) $x12235)))
 (let ((@x56085 (unit-resolution (def-axiom (or $x55537 $x55535)) (unit-resolution ((_ quant-inst (Add ?x55517 ?x55518)) (or (not $x12235) $x55538)) @x14534 $x55538) $x55535)))
 (let (($x55663 (>= (+ (vstd!seq.Seq.len.? $ ?x1876 ?x50851) (* (- 1) ?x55518)) 0)))
 (let ((?x54916 (vstd!seq.Seq.len.? $ ?x1876 ?x50851)))
 (let (($x55659 (= ?x54916 ?x55518)))
 (let ((@x55922 (mp @x55913 (symm (monotonicity (symm @x55915 (= ?x50849 ?x55388)) (= $x55495 $x55389)) $x55920) $x55495)))
 (let ((@x55928 (monotonicity (unit-resolution (unit-resolution @x55506 @x10792 (or $x55496 $x55497)) @x55922 $x55497) (= ?x55518 ?x54916))))
 (let ((@x55929 (symm @x55928 $x55659)))
 (let (($x55726 (>= (+ (vstd!seq.Seq.len.? $ ?x1876 ?x50847) ?x55686) 0)))
 (let ((?x55075 (vstd!seq.Seq.len.? $ ?x1876 ?x50847)))
 (let (($x55723 (= ?x55075 ?x55677)))
 (let ((@x55994 (unit-resolution @x55993 @x55952 @x55945 @x55948 @x52624 @x52618 @x55942 @x55257 @x55252 @x55297 @x55245 @x52600 $x55562)))
 (let ((@x55997 (unit-resolution @x55609 @x175 @x55310 @x52976 @x54833 @x55995 @x55109 (or $x55569 $x55590 $x55575))))
 (let ((@x55976 (mp @x55963 (symm (monotonicity (symm @x55969 (= ?x50845 ?x55393)) (= $x55499 $x55394)) $x55974) $x55499)))
 (let ((@x55978 (unit-resolution (unit-resolution @x55516 @x10792 (or $x55500 $x55507)) @x55976 $x55507)))
 (let ((@x56006 (symm (monotonicity (trans* @x55969 @x55978 (= ?x55393 ?x50847)) (= ?x55573 ?x55075)) (= ?x55075 ?x55573))))
 (let ((@x56010 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55723) $x55726)) (trans* @x56006 (unit-resolution @x55997 @x55994 @x55985 $x55575) @x56008 $x55723) $x55726)))
 (let ((?x55646 (Add ?x55075 ?x54916)))
 (let ((?x55647 (* (- 1) ?x55646)))
 (let ((?x55648 (+ ?x54916 ?x55075 ?x55647)))
 (let (($x55654 (<= ?x55648 0)))
 (let (($x55649 (= ?x55648 0)))
 (let ((@x56015 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55649) $x55654)) (unit-resolution ((_ quant-inst (vstd!seq.Seq.len.? $ ?x1876 ?x50847) (vstd!seq.Seq.len.? $ ?x1876 ?x50851)) (or $x48868 $x55649)) @x10433 $x55649) $x55654)))
 (let (($x55676 (>= (+ ?x55519 ?x55647) 0)))
 (let (($x55673 (= ?x55519 ?x55646)))
 (let ((@x56023 (monotonicity (symm (monotonicity @x55978 (= ?x55517 ?x55075)) (= ?x55075 ?x55517)) @x55929 (= ?x55646 ?x55519))))
 (let ((@x56025 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55673) $x55676)) (symm @x56023 $x55673) $x55676)))
 (let (($x55610 (>= ?x55518 0)))
 (let (($x4084 (forall ((A&. Dcr) (A& Type) (self! Poly) )(! (let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4073 (>= ?x4066 0)))
 (or (not (has_type self! (TYPE%vstd!seq.Seq. A&. A&))) $x4073))) :pattern ( (vstd!seq.Seq.len.? A&. A& self!) ) :qid internal_vstd!seq.Seq.len.?_pre_post_definition))
 ))
 (let ((?x11915 (lambda ((A&. Dcr) (A& Type) (self! Poly) )(let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4073 (>= ?x4066 0)))
 (let (($x4079 (or (not (has_type self! (TYPE%vstd!seq.Seq. A&. A&))) $x4073)))
 (refl (~ $x4079 $x4079))))))
 ))
 (let (($x4070 (forall ((A&. Dcr) (A& Type) (self! Poly) )(! (let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4067 (<= 0 ?x4066)))
 (let (($x4065 (has_type self! (TYPE%vstd!seq.Seq. A&. A&))))
 (=> $x4065 $x4067)))) :pattern ( (vstd!seq.Seq.len.? A&. A& self!) ) :qid internal_vstd!seq.Seq.len.?_pre_post_definition))
 ))
 (let ((?x4085 (lambda ((A&. Dcr) (A& Type) (self! Poly) )(let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4073 (>= ?x4066 0)))
 (let (($x4079 (or (not (has_type self! (TYPE%vstd!seq.Seq. A&. A&))) $x4073)))
 (let (($x4067 (<= 0 ?x4066)))
 (let (($x4065 (has_type self! (TYPE%vstd!seq.Seq. A&. A&))))
 (let (($x4068 (=> $x4065 $x4067)))
 (trans (monotonicity (rewrite (= $x4067 $x4073)) (= $x4068 (=> $x4065 $x4073))) (rewrite (= (=> $x4065 $x4073) $x4079)) (= $x4068 $x4079)))))))))
 ))
 (let ((@x4089 (mp (asserted $x4070) (quant-intro (proof-bind ?x4085) (= $x4070 $x4084)) $x4084)))
 (let ((@x11919 (mp~ @x4089 (nnf-pos (proof-bind ?x11915) (~ $x4084 $x4084)) $x4084)))
 (let (($x50451 (not $x4084)))
 (let (($x55614 (or $x50451 $x55496 $x55610)))
 (let ((@x55619 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.subrange.? $ ?x1876 ?x46673 ?x7471 ?x50848)) (or $x50451 (or $x55496 $x55610))) (rewrite (= (or $x50451 (or $x55496 $x55610)) $x55614)) $x55614)))
 (let ((@x56028 ((_ th-lemma arith farkas 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) (unit-resolution @x55619 @x11919 @x55922 $x55610) (hypothesis $x55533) @x56025 @x56015 @x56010 @x55957 @x55952 @x55245 @x55252 @x55257 @x55948 @x55945 @x55942 @x52624 @x52618 @x52600 @x55209 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55659) $x55663)) @x55929 $x55663) false)))
 (let ((@x56029 (lemma @x56028 $x55532)))
 (let ((@x56088 (unit-resolution (unit-resolution (def-axiom (or $x55536 $x55533 $x55534)) @x56029 (or $x55536 $x55534)) @x56085 $x55534)))
 (let ((?x55710 (+ ?x55415 ?x55518 ?x55713)))
 (let (($x55754 (>= ?x55710 0)))
 (let (($x55711 (= ?x55710 0)))
 (let (($x55707 (or $x48868 $x55711)))
 (let (($x55709 (= (+ ?x55518 ?x55415 ?x55713) 0)))
 (let (($x55708 (or $x48868 $x55709)))
 (let (($x55717 (= $x55708 $x55707)))
 (let ((@x55751 (trans (monotonicity (rewrite (= $x55709 $x55711)) $x55717) (rewrite (= $x55707 $x55707)) $x55717)))
 (let ((@x56094 (unit-resolution (mp ((_ quant-inst (Sub ?x46948 ?x51255) (vstd!seq.Seq.len.? $ ?x1876 ?x50849)) $x55708) @x55751 $x55707) @x10433 $x55711)))
 (let ((?x55791 (+ ?x46948 (* (- 1) ?x51075) ?x55789)))
 (let (($x55804 (>= ?x55791 0)))
 (let (($x55792 (= ?x55791 0)))
 (let (($x55797 (or $x47606 $x55792)))
 (let ((?x55447 (Sub ?x46994 ?x51075)))
 (let ((?x51038 (* (- 1) ?x46994)))
 (let ((?x55448 (+ ?x51075 ?x51038 ?x55447)))
 (let (($x55453 (= ?x55448 0)))
 (let (($x55798 (or $x47606 $x55453)))
 (let (($x55776 (= $x55798 $x55797)))
 (let ((@x55457 (rewrite (= ?x55447 ?x55454))))
 (let ((@x51047 (rewrite (= ?x51038 ?x51044))))
 (let ((@x55749 (trans (monotonicity @x51047 @x55457 (= ?x55448 (+ ?x51075 ?x51044 ?x55454))) (rewrite (= (+ ?x51075 ?x51044 ?x55454) (+ ?x51044 ?x51075 ?x55454))) (= ?x55448 (+ ?x51044 ?x51075 ?x55454)))))
 (let ((@x55796 (trans (monotonicity @x55749 (= $x55453 (= (+ ?x51044 ?x51075 ?x55454) 0))) (rewrite (= (= (+ ?x51044 ?x51075 ?x55454) 0) $x55792)) (= $x55453 $x55792))))
 (let ((@x55802 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46985) (EucMod ?x50830 ?x51074)) $x55798) (trans (monotonicity @x55796 $x55776) (rewrite (= $x55797 $x55797)) $x55776) $x55797)))
 (let ((@x56099 (unit-resolution @x55802 @x10440 $x55792)))
 (let ((@x56104 ((_ th-lemma arith farkas -1 -1 1 1 1 -1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55792) $x55804)) @x56099 $x55804) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55711) $x55754)) @x56094 $x55754) (hypothesis $x55807) @x55229 @x52624 @x52600 (hypothesis $x55790) @x55217 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55534) $x55774)) @x56088 $x55774) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54787) $x54837)) @x56082 $x54837) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55449) $x55478)) @x56077 $x55478) @x55209 @x55957 @x55952 @x55245 @x55252 @x55257 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55787) $x55810)) @x56060 $x55810) false)))
 (let ((@x56108 (lemma @x56104 (or $x52793 (not $x55807) (not $x55790)))))
 (let ((@x56065 (unit-resolution @x56108 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55823) $x55790)) @x56071 $x55790) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55805) $x55807)) @x55904 $x55807) $x52793)))
 (let (($x55811 (<= ?x55812 0)))
 (let (($x51767 (>= ?x51741 0)))
 (let (($x51770 (<= ?x51769 0)))
 (let (($x51162 (<= ?x51160 0)))
 (let (($x55427 (>= ?x55687 0)))
 (let (($x55477 (<= ?x55450 0)))
 (let (($x55074 (>= ?x54589 0)))
 (let (($x55850 (>= ?x55822 0)))
 (let (($x55808 (>= ?x55806 0)))
 (let (($x55753 (<= ?x55710 0)))
 (let (($x55803 (<= ?x55791 0)))
 (let ((@x56142 ((_ th-lemma arith farkas -1 -1 1 1 1 -1 1 1 -1 -1 1 1 -1 -1 1 -1 -1 1) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55792) $x55803)) @x56099 $x55803) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55711) $x55753)) @x56094 $x55753) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55805) $x55808)) @x55904 $x55808) @x52518 @x52486 @x52369 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55534) $x55850)) @x56088 $x55850) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x54787) $x55074)) @x56082 $x55074) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55449) $x55477)) @x56077 $x55477) @x54912 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55688) $x55427)) @x55953 $x55427) @x55985 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51158) $x51162)) @x55244 $x51162) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51768) $x51770)) @x55251 $x51770) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51722) $x51767)) @x55256 $x51767) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55823) $x55811)) @x56071 $x55811) (unit-resolution @x55357 @x56065 $x55337) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55787) $x55769)) @x56060 $x55769) false)))
 (let ((@x56143 (lemma @x56142 $x46869)))
 (let ((@x56168 (unit-resolution (unit-resolution @x47336 (unit-resolution @x47346 @x55934 $x46842) $x46842) @x56143 $x46956)))
 (let ((@x56169 (unit-resolution @x47326 @x56168 $x46885)))
 (let ((@x56165 (unit-resolution @x52505 @x52491 @x52486 @x52476 @x52752 @x55897 @x52397 @x52385 @x52369 (or $x52180 $x46888))))
 (let (($x52695 (>= ?x52179 0)))
 (let ((@x56160 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 -1 -1 1 1 1 1 -1) (or $x52695 $x52629 $x46856 $x52630 $x52631 $x52632 $x52633 $x52634 $x52635 $x52636)) @x52627 @x52624 @x52621 @x52751 @x55858 @x52606 @x52603 @x52600 (or $x52695 $x46856))))
 (let ((@x56163 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x52579 $x52267 (not $x52695))) (unit-resolution @x56160 @x55931 $x52695) (or $x52579 $x52267))))
 (let ((@x56172 (unit-resolution @x52700 (unit-resolution @x56163 (unit-resolution @x56165 @x56169 $x52180) $x52579) $x52617)))
 (let ((@x56175 (unit-resolution @x52726 (unit-resolution @x52719 @x52809 @x52810 @x56172 @x52811 $x52717) (or $x52663 $x52661))))
 (let ((@x56177 (unit-resolution (unit-resolution @x56175 @x52796 $x52661) (mp (hypothesis $x47308) @x52806 $x52720) false)))
 (let ((@x56178 (lemma @x56177 $x46777)))
 (let ((@x56382 (unit-resolution @x47324 (unit-resolution (def-axiom (or $x46959 $x46954)) @x56168 $x46954) $x46954)))
 (let ((@x47314 (def-axiom (or $x46918 $x46779))))
 (let ((@x56384 (unit-resolution @x47314 (unit-resolution @x56382 (unit-resolution @x47310 @x56178 $x46914) $x46953) $x46779)))
 (let ((@x56194 (def-axiom (or (not $x56146) (not $x55890) $x55878))))
 (let ((@x56399 (unit-resolution @x56194 (mp @x56384 (symm @x56395 (= $x46779 $x55890)) $x55890) (unit-resolution @x56186 @x14515 $x56146) $x55878)))
 (let (($x52223 (>= ?x46812 0)))
 (let (($x52103 (has_type ?x46811 ?x1968)))
 (let ((?x54989 (Poly%vstd!seq.Seq<u8.>. ?x47386)))
 (let (($x54991 (has_type ?x54989 ?x1968)))
 (let (($x55043 (not $x54991)))
 (let ((@x55032 (monotonicity (trans* @x55011 @x55020 @x55022 @x55024 @x55026 (= ?x47386 ?x50856)) (= ?x54989 ?x50857))))
 (let ((@x55042 (symm (monotonicity (trans* @x55032 @x55036 (= ?x54989 ?x46811)) (= $x54991 $x52103)) (= $x52103 $x54991))))
 (let ((@x55046 (mp (hypothesis (not $x52103)) (monotonicity @x55042 (= (not $x52103) $x55043)) $x55043)))
 (let (($x52959 (not $x1989)))
 (let (($x54994 (or $x52959 $x54991)))
 (let ((?x54987 (Poly%vstd!seq.Seq<u8.>. ?x47392)))
 (let (($x54988 (has_type ?x54987 ?x1968)))
 (let (($x54996 (or $x52959 $x54988)))
 (let (($x54998 (= $x54996 $x54994)))
 (let ((@x55002 (trans (monotonicity (rewrite (= $x54988 $x54991)) $x54998) (rewrite (= $x54994 $x54994)) $x54998)))
 (let ((@x55048 (unit-resolution (unit-resolution (mp ((_ quant-inst (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState/?log ?x47388)) $x54996) @x55002 $x54994) @x10799 $x54991) @x55046 false)))
 (let ((@x55049 (lemma @x55048 $x52103)))
 (let (($x52104 (not $x52103)))
 (let (($x52224 (or $x52104 $x52223)))
 (let (($x52109 (or $x50451 $x52104 $x52223)))
 (let ((@x52114 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x46810)) (or $x50451 $x52224)) (rewrite (= (or $x50451 $x52224) $x52109)) $x52109)))
 (let ((?x47575 (Sub ?x46687 ?x46716)))
 (let ((?x47599 (* (- 1) ?x47575)))
 (let ((?x47689 (+ ?x46689 ?x47599)))
 (let (($x47704 (<= ?x47689 0)))
 (let (($x47688 (= ?x46689 ?x47575)))
 (let ((@x56410 (symm (monotonicity @x51890 (= ?x47575 ?x46689)) $x47688)))
 (let ((?x47598 (* (- 1) ?x46716)))
 (let ((?x47600 (+ ?x46687 ?x47598 ?x47599)))
 (let (($x47617 (>= ?x47600 0)))
 (let (($x47601 (= ?x47600 0)))
 (let (($x47607 (or $x47606 $x47601)))
 (let ((?x47574 (* (- 1) ?x46687)))
 (let ((?x47590 (+ ?x46716 ?x47574 ?x47575)))
 (let (($x47591 (= ?x47590 0)))
 (let (($x47608 (or $x47606 $x47591)))
 (let (($x47610 (= $x47608 $x47607)))
 (let ((@x47597 (monotonicity (rewrite (= ?x47590 (+ ?x47574 ?x46716 ?x47575))) (= $x47591 (= (+ ?x47574 ?x46716 ?x47575) 0)))))
 (let ((@x47605 (trans @x47597 (rewrite (= (= (+ ?x47574 ?x46716 ?x47575) 0) $x47601)) (= $x47591 $x47601))))
 (let ((@x47615 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x46686) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x46715)) $x47608) (trans (monotonicity @x47605 $x47610) (rewrite (= $x47607 $x47607)) $x47610) $x47607)))
 (let ((@x56415 (unit-resolution @x47615 @x10440 $x47601)))
 (let ((@x56418 (unit-resolution @x52306 (trans* @x52044 @x52036 @x52035 @x52046 @x56391 @x52310 $x51523) $x51526)))
 (let ((@x56419 ((_ th-lemma arith farkas -1 1 1 -1 1 1 1) @x56418 @x52320 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47601) $x47617)) @x56415 $x47617) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47688) $x47704)) @x56410 $x47704) (unit-resolution (unit-resolution @x52114 @x11919 $x52224) @x55049 $x52223) @x55217 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55878) $x56187)) @x56399 $x56187) false)))
 (let ((@x56420 (lemma @x56419 $x52793)))
 (let (($x55529 (<= ?x46812 0)))
 (let (($x55528 (= ?x46812 0)))
 (let ((?x55549 (vstd!seq.Seq.len.? $ ?x1876 ?x7133)))
 (let (($x55554 (= ?x55549 0)))
 (let (($x4384 (forall ((A&. Dcr) (A& Type) )(! (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (let (($x4380 (not $x3813)))
 (or $x4380 $x4374)))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) ) :qid user_vstd__seq__axiom_seq_empty_2))
 ))
 (let (($x4372 (fuel_bool fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x47754 (= $x4372 $x1584)))
 (let ((@x47756 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_empty.) (or (not $x30) $x47754)) @x47707 (hypothesis (not $x47754)) false)))
 (let ((@x47768 (lemma @x47756 $x47754)))
 (let ((@x47761 (def-axiom (or (not $x47754) $x4372 $x15016))))
 (let ((@x56219 (unit-resolution @x47761 (unit-resolution (def-axiom (or $x15027 $x1584)) @x55305 $x1584) (or (not $x47754) $x4372))))
 (let (($x4392 (not $x4372)))
 (let (($x4393 (or $x4392 $x4384)))
 (let ((?x12015 (lambda ((A&. Dcr) (A& Type) )(let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (let (($x4380 (not $x3813)))
 (let (($x4381 (or $x4380 $x4374)))
 (refl (~ $x4381 $x4381)))))))))
 ))
 (let ((@x12020 (monotonicity (refl (~ $x4392 $x4392)) (nnf-pos (proof-bind ?x12015) (~ $x4384 $x4384)) (~ $x4393 $x4393))))
 (let (($x4377 (forall ((A&. Dcr) (A& Type) )(! (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (=> $x3813 $x4374))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) ) :qid user_vstd__seq__axiom_seq_empty_2))
 ))
 (let (($x4378 (=> $x4372 $x4377)))
 (let ((?x4385 (lambda ((A&. Dcr) (A& Type) )(let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (let (($x4380 (not $x3813)))
 (let (($x4381 (or $x4380 $x4374)))
 (let (($x4375 (=> $x3813 $x4374)))
 (rewrite (= $x4375 $x4381))))))))))
 ))
 (let ((@x4391 (monotonicity (quant-intro (proof-bind ?x4385) (= $x4377 $x4384)) (= $x4378 (=> $x4372 $x4384)))))
 (let ((@x4398 (mp (asserted $x4378) (trans @x4391 (rewrite (= (=> $x4372 $x4384) $x4393)) (= $x4378 $x4393)) $x4393)))
 (let ((@x12024 (mp (mp~ @x4398 @x12020 $x4393) (rewrite (= $x4393 $x4393)) $x4393)))
 (let (($x55559 (not $x4384)))
 (let (($x55553 (or $x55559 $x53653 $x55554)))
 (let ((@x55633 (mp ((_ quant-inst $ (UINT 8)) (or $x55559 (or $x53653 $x55554))) (rewrite (= (or $x55559 (or $x53653 $x55554)) $x55553)) $x55553)))
 (let ((@x56222 (unit-resolution @x55633 @x175 (unit-resolution @x12024 (unit-resolution @x56219 @x47768 $x4372) $x4384) $x55554)))
 (let (($x50928 (= ?x7133 ?x50853)))
 (let ((@x56227 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 1) (or $x50841 $x46888 $x52497 $x52500)) @x52397 @x52385 (or $x50841 $x46888))))
 (let ((@x50932 (def-axiom (or $x50930 $x50928))))
 (let ((@x56232 (symm (unit-resolution @x50932 (unit-resolution @x56227 @x56169 $x50841) $x50928) (= ?x50853 ?x7133))))
 (let ((@x56223 (monotonicity (trans* @x56047 @x56232 (= ?x50855 ?x7133)) (= $x52729 (has_type ?x7133 ?x1968)))))
 (let (($x52537 (has_type ?x7133 ?x1968)))
 (let (($x4370 (forall ((A&. Dcr) (A& Type) )(! (let ((?x3809 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (has_type ?x4367 ?x3809))) :pattern ( (vstd!seq.Seq.empty.? A&. A&) ) :qid internal_vstd!seq.Seq.empty.?_pre_post_definition))
 ))
 (let ((?x12006 (lambda ((A&. Dcr) (A& Type) )(let ((?x3809 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let (($x4368 (has_type ?x4367 ?x3809)))
 (refl (~ $x4368 $x4368))))))
 ))
 (let ((@x12010 (mp~ (asserted $x4370) (nnf-pos (proof-bind ?x12006) (~ $x4370 $x4370)) $x4370)))
 (let (($x55557 (or (not $x4370) $x52537)))
 (let ((@x55555 ((_ quant-inst $ (UINT 8)) $x55557)))
 (let ((@x56260 (unit-resolution @x54986 (mp (unit-resolution @x55555 @x12010 $x52537) (symm @x56223 (= $x52537 $x52729)) $x52729) $x52731)))
 (let ((@x56268 (monotonicity (trans* @x55034 (symm @x56260 $x55833) @x56047 @x56232 (= ?x46811 ?x7133)) (= ?x46812 ?x55549))))
 (let ((@x56270 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55528) $x55529)) (trans* @x56268 @x56222 $x55528) $x55529)))
 (let (($x47705 (>= ?x47689 0)))
 (let (($x47616 (<= ?x47600 0)))
 ((_ th-lemma arith farkas 1 -1 1 -1 1 1 1) @x52303 @x52327 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47601) $x47616)) @x56415 $x47616) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47688) $x47705)) @x56410 $x47705) @x56270 (unit-resolution @x55357 @x56420 $x55337) @x52328 false))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

