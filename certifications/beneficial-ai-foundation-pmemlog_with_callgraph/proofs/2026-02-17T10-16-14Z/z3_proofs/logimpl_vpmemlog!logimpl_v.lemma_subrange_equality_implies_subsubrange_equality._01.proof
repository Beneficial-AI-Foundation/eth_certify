(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10642)
(:version "4.12.5")
unsat
((declare-fun m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17 () Poly)
(declare-fun k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 () Poly)
(declare-fun i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 (Poly Poly Type Dcr) Poly)
(declare-fun k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 (Int Int Poly Poly Type Dcr) Poly)
(proof
(let ((?x44794 (vstd!seq.Seq.subrange.? T&. T& s2! k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17)))
 (let ((?x44793 (vstd!seq.Seq.subrange.? T&. T& s1! k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17)))
 (let ((?x44566 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44795 (ext_eq false ?x44566 ?x44793 ?x44794)))
 (let (($x46939 (= ?x44793 ?x44794)))
 (let (($x46940 (= $x46939 $x44795)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x9234 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x9238 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x9234) (~ $x418 $x418)) $x418)))
 (let (($x46901 (or (not $x418) $x46940)))
 (let ((@x46943 ((_ quant-inst false (TYPE%vstd!seq.Seq. T&. T&) (vstd!seq.Seq.subrange.? T&. T& s1! k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17) (vstd!seq.Seq.subrange.? T&. T& s2! k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17)) $x46901)))
 (let ((?x44748 (%I m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17)))
 (let ((?x44721 (* (- 1) ?x44748)))
 (let ((?x44722 (+ j! ?x44721)))
 (let (($x44723 (>= ?x44722 0)))
 (let (($x44886 (not $x44723)))
 (let ((?x44782 (%I k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18)))
 (let ((?x44749 (* (- 1) ?x44782)))
 (let ((?x44787 (+ ?x44748 ?x44749)))
 (let (($x44788 (>= ?x44787 0)))
 (let (($x44885 (not $x44788)))
 (let ((?x44704 (+ i! ?x44749)))
 (let (($x44705 (<= ?x44704 0)))
 (let (($x44884 (not $x44705)))
 (let (($x44778 (has_type m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17 INT)))
 (let (($x44872 (not $x44778)))
 (let (($x44777 (has_type k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 INT)))
 (let (($x44871 (not $x44777)))
 (let (($x44807 (not %%location_label%%3)))
 (let (($x44866 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x44656 (= ?x44654 ?x44655)))
 (let (($x44747 (<= (+ (%I m$) (* (- 1) j!)) 0)))
 (let (($x44846 (not $x44747)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14297 (not $x4245)))
 (let (($x44743 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x44845 (not $x44743)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14312 (not $x4257)))
 (or $x14312 $x271 $x44845 $x14297 $x44846 $x44656)))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_42))
 ))
 (let (($x44890 (not $x44866)))
 (let (($x44891 (or $x44890 $x44807 $x44871 $x44872 $x44884 $x44885 $x44886 $x44795)))
 (let (($x44892 (not $x44891)))
 (let ((?x44637 (vstd!seq.Seq.subrange.? T&. T& s2! k@ m@)))
 (let ((?x44636 (vstd!seq.Seq.subrange.? T&. T& s1! k@ m@)))
 (let (($x44638 (ext_eq false ?x44566 ?x44636 ?x44637)))
 (let (($x44703 (not %%location_label%%2)))
 (let (($x44710 (not tmp%1)))
 (let (($x44711 (or $x44710 $x44703 $x44638)))
 (let (($x44733 (not $x44711)))
 (let (($x44699 (not %%location_label%%1)))
 (let (($x44700 (or $x44699 tmp%1)))
 (let (($x44731 (not $x44700)))
 (let (($x44734 (or $x44731 $x44733)))
 (let (($x44735 (not $x44734)))
 (let (($x44639 (= tmp%1 $x44638)))
 (let (($x44707 (not $x44639)))
 (let ((?x44629 (%I m@)))
 (let ((?x44683 (* (- 1) ?x44629)))
 (let ((?x44687 (+ j! ?x44683)))
 (let (($x44686 (>= ?x44687 0)))
 (let (($x44701 (not $x44686)))
 (let ((?x44628 (%I k@)))
 (let ((?x44684 (+ ?x44628 ?x44683)))
 (let (($x44685 (<= ?x44684 0)))
 (let (($x44717 (not $x44685)))
 (let ((?x44678 (* (- 1) ?x44628)))
 (let ((?x44679 (+ i! ?x44678)))
 (let (($x44680 (<= ?x44679 0)))
 (let (($x44697 (not $x44680)))
 (let (($x44627 (has_type m@ INT)))
 (let (($x44728 (not $x44627)))
 (let (($x44625 (has_type k@ INT)))
 (let (($x44737 (not $x44625)))
 (let (($x44826 (or $x44737 $x44728 $x44697 $x44717 $x44701 $x44707 $x44735)))
 (let (($x44831 (not $x44826)))
 (let ((@x47245 (hypothesis $x44831)))
 (let ((@x44998 (def-axiom (or $x44826 $x44734))))
 (let ((?x46835 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44637 ?x44636 T& T&.)))
 (let ((?x46836 (vstd!seq.Seq.index.? T&. T& ?x44637 ?x46835)))
 (let ((?x46850 (vstd!seq.Seq.index.? T&. T& ?x44636 ?x46835)))
 (let (($x46851 (= ?x46850 ?x46836)))
 (let ((?x46854 (vstd!seq.Seq.len.? T&. T& ?x44636)))
 (let ((?x46873 (* (- 1) ?x46854)))
 (let ((?x46852 (%I ?x46835)))
 (let ((?x46907 (+ ?x46852 ?x46873)))
 (let (($x46908 (>= ?x46907 0)))
 (let (($x46857 (>= ?x46852 0)))
 (let (($x46858 (not $x46857)))
 (let (($x46859 (has_type ?x46835 INT)))
 (let (($x46860 (not $x46859)))
 (let (($x46903 (or $x46860 $x46858 $x46908 $x46851)))
 (let (($x46960 (not $x46903)))
 (let ((?x46863 (vstd!seq.Seq.len.? T&. T& ?x44637)))
 (let (($x46864 (= ?x46854 ?x46863)))
 (let (($x46865 (not $x46864)))
 (let (($x46892 (or $x44638 $x46865 $x46960)))
 (let (($x46912 (not $x46892)))
 (let (($x46877 (forall ((i$ Poly) )(! (let ((?x44637 (vstd!seq.Seq.subrange.? T&. T& s2! k@ m@)))
 (let ((?x46870 (vstd!seq.Seq.index.? T&. T& ?x44637 i$)))
 (let ((?x44636 (vstd!seq.Seq.subrange.? T&. T& s1! k@ m@)))
 (let ((?x46868 (vstd!seq.Seq.index.? T&. T& ?x44636 i$)))
 (let (($x46875 (>= (+ (%I i$) (* (- 1) (vstd!seq.Seq.len.? T&. T& ?x44636))) 0)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x14198 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x14198 $x46875 (= ?x46868 ?x46870)))))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& (vstd!seq.Seq.subrange.? T&. T& s1! k@ m@) i$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& (vstd!seq.Seq.subrange.? T&. T& s2! k@ m@) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x45027 (not $x44638)))
 (let (($x46882 (not (or $x45027 (not (or $x46865 (not $x46877)))))))
 (let (($x46963 (or $x46882 $x46912)))
 (let (($x46910 (not $x46963)))
 (let (($x46886 (has_type ?x44637 ?x44566)))
 (let ((@x44986 (def-axiom (or $x44826 $x44625))))
 (let ((@x47281 (unit-resolution @x44986 @x47245 $x44625)))
 (let ((@x44988 (def-axiom (or $x44826 $x44627))))
 (let ((@x47276 (unit-resolution @x44988 @x47245 $x44627)))
 (let (($x44570 (has_type s2! ?x44566)))
 (let ((@x44571 (asserted $x44570)))
 (let (($x14332 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x14312 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x14302 (not $x4256)))
 (or $x14302 $x14312 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x14333 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x14312 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x14302 (not $x4256)))
 (let (($x14327 (or $x14302 $x14312 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x14319 (monotonicity (rewrite (= $x4258 (not (or $x14302 $x14312 $x271)))) (= $x4266 (not (not (or $x14302 $x14312 $x271)))))))
 (let ((@x14323 (trans @x14319 (rewrite (= (not (not (or $x14302 $x14312 $x271))) (or $x14302 $x14312 $x271))) (= $x4266 (or $x14302 $x14312 $x271)))))
 (trans (monotonicity @x14323 (= $x4269 (or (or $x14302 $x14312 $x271) $x4261))) (rewrite (= (or (or $x14302 $x14312 $x271) $x4261) $x14327)) (= $x4269 $x14327))))))))))))))))))
 ))
 (let ((?x10944 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x14337 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x10944) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x14333) (= $x4272 $x14332)) $x14332)))
 (let (($x44970 (not $x44570)))
 (let (($x44837 (not $x14332)))
 (let (($x46930 (or $x44837 $x44970 $x44737 $x44728 $x46886)))
 (let ((@x46934 (mp ((_ quant-inst T&. T& s2! k@ m@) (or $x44837 (or $x44970 $x44737 $x44728 $x46886))) (rewrite (= (or $x44837 (or $x44970 $x44737 $x44728 $x46886)) $x46930)) $x46930)))
 (let ((@x47313 (unit-resolution (unit-resolution @x46934 @x14337 @x44571 (or $x44737 $x44728 $x46886)) @x47276 @x47281 $x46886)))
 (let (($x46888 (has_type ?x44636 ?x44566)))
 (let (($x44567 (has_type s1! ?x44566)))
 (let ((@x44568 (asserted $x44567)))
 (let (($x44936 (not $x44567)))
 (let (($x46924 (or $x44837 $x44936 $x44737 $x44728 $x46888)))
 (let ((@x46929 (mp ((_ quant-inst T&. T& s1! k@ m@) (or $x44837 (or $x44936 $x44737 $x44728 $x46888))) (rewrite (= (or $x44837 (or $x44936 $x44737 $x44728 $x46888)) $x46924)) $x46924)))
 (let ((@x47283 (unit-resolution (unit-resolution @x46929 @x14337 @x44568 (or $x44737 $x44728 $x46888)) @x47276 @x47281 $x46888)))
 (let (($x44562 (sized T&.)))
 (let ((@x44563 (asserted $x44562)))
 (let (($x14542 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x11043 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x11055 (= (vstd!seq.Seq.index.? A&. A& s1! ?x11043) (vstd!seq.Seq.index.? A&. A& s2! ?x11043))))
 (let (($x11094 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x11043))) 0)))
 (let (($x11045 (not (has_type ?x11043 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x11040 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x14523 (not (or $x4527 $x11040 (not (or $x11045 (not (>= (%I ?x11043) 0)) $x11094 $x11055))))))
 (let (($x14494 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x14198 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x14198 $x4552 $x4534))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x11027 (not $x4527)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14463 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x14210 (not $x4101)))
 (or $x14210 $x14463 $x4431 (not (or (not (or $x11027 (not (or $x11040 (not $x14494))))) $x14523)))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4524 (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x45125 (= $x4524 $x1587)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x44560 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x8980 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x8986 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x8980) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x8990 (mp (mp~ @x37 @x8986 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x44860 (unit-resolution @x8990 @x44560 $x30)))
 (let ((@x45127 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_ext_equal.) (or (not $x30) $x45125)) @x44860 (hypothesis (not $x45125)) false)))
 (let ((@x45139 (lemma @x45127 $x45125)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x13649 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x13648 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x13647 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x13646 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x13645 (not $x1590)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x13644 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x13643 (not $x1588)))
 (let (($x13642 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x13641 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x13640 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x13639 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x13638 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x13637 (not $x1582)))
 (let (($x13650 (or $x13637 $x13638 $x13639 $x13640 $x13641 $x13642 $x13643 $x13644 $x13645 $x13646 $x13647 $x13648 $x13649)))
 (let (($x13651 (not $x13650)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x13714 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x13713 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x13712 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x13711 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x13710 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x13709 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x13708 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x13707 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x13706 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x13705 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x13704 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x13703 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x13702 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x13701 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x13700 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x13715 (or $x1598 $x1610 $x13700 $x1621 $x13701 $x13702 $x13703 $x1565 $x13704 $x1633 $x13705 $x13706 $x1576 $x13707 $x13708 $x13709 $x13710 $x13711 $x13712 $x1644 $x13713 $x13714)))
 (let (($x13716 (not $x13715)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x13719 (or $x1669 $x13716)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x13721 (mp @x1673 (rewrite (= $x1670 $x13719)) $x13719)))
 (let ((@x42734 (def-axiom (or $x13715 $x1581))))
 (let (($x13654 (or $x1598 $x13651)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x13656 (mp @x1602 (rewrite (= $x1599 $x13654)) $x13654)))
 (let ((@x47189 (unit-resolution @x13656 (unit-resolution @x42734 (unit-resolution @x13721 @x1650 $x13716) $x1581) $x13651)))
 (let ((@x42688 (def-axiom (or $x13650 $x1587))))
 (let ((@x45132 (def-axiom (or (not $x45125) $x4524 $x13642))))
 (let ((@x47247 (unit-resolution @x45132 (unit-resolution @x42688 @x47189 $x1587) (or (not $x45125) $x4524))))
 (let (($x4583 (not $x4524)))
 (let (($x14475 (or $x4583 $x14542)))
 (let (($x11108 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x11043 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x11055 (= (vstd!seq.Seq.index.? A&. A& s1! ?x11043) (vstd!seq.Seq.index.? A&. A& s2! ?x11043))))
 (let (($x11094 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x11043))) 0)))
 (let ((?x11046 (%I ?x11043)))
 (let (($x11047 (>= ?x11046 0)))
 (let (($x11045 (not (has_type ?x11043 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x11040 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x11027 (not $x4527)))
 (let (($x11066 (or $x11027 $x4548)))
 (let (($x11109 (and $x11066 (or $x4527 $x11040 (not (or $x11045 (not (and $x11047 (not $x11094))) $x11055))))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x11109)))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x11082 (or $x4583 $x11108)))
 (let (($x11073 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x11043 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x11055 (= (vstd!seq.Seq.index.? A&. A& s1! ?x11043) (vstd!seq.Seq.index.? A&. A& s2! ?x11043))))
 (let (($x11049 (>= (+ (%I ?x11043) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x11046 (%I ?x11043)))
 (let (($x11047 (>= ?x11046 0)))
 (let (($x11045 (not (has_type ?x11043 INT))))
 (let (($x11057 (not (or $x11045 (not (and $x11047 (not $x11049))) $x11055))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x11040 (not $x4529)))
 (let (($x11061 (or $x11040 $x11057)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x11027 (not $x4527)))
 (let (($x11066 (or $x11027 $x4548)))
 (let (($x11067 (and $x11066 (or $x4527 $x11061))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x11067)))))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x11078 (or $x4583 $x11073)))
 (let (($x4576 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4559))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4584 (or $x4583 $x4576)))
 (let ((?x11074 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x11043 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x11055 (= (vstd!seq.Seq.index.? A&. A& s1! ?x11043) (vstd!seq.Seq.index.? A&. A& s2! ?x11043))))
 (let (($x11049 (>= (+ (%I ?x11043) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x11046 (%I ?x11043)))
 (let (($x11047 (>= ?x11046 0)))
 (let (($x11045 (not (has_type ?x11043 INT))))
 (let (($x11057 (not (or $x11045 (not (and $x11047 (not $x11049))) $x11055))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x11040 (not $x4529)))
 (let (($x11061 (or $x11040 $x11057)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x11027 (not $x4527)))
 (let (($x11066 (or $x11027 $x4548)))
 (let (($x11067 (and $x11066 (or $x4527 $x11061))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x11070 (or $x4568 $x4431 $x11067)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let ((@x11042 (refl (~ $x11040 $x11040))))
 (let ((?x11034 (lambda ((i$ Poly) )(let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4569 (or $x271 $x4554 $x4534)))
 (refl (~ $x4569 $x4569))))))))))))))))
 ))
 (let ((@x11031 (refl (~ $x4529 $x4529))))
 (let ((@x11039 (monotonicity @x11031 (nnf-pos (proof-bind ?x11034) (~ $x4574 $x4574)) (~ $x4548 $x4548))))
 (let ((@x11069 (nnf-pos (refl (~ $x4527 $x4527)) (refl (~ $x11027 $x11027)) @x11039 (nnf-neg @x11042 (sk (~ (not $x4574) $x11057)) (~ (not $x4548) $x11061)) (~ $x4559 $x11067))))
 (let ((@x11024 (refl (~ $x4431 $x4431))))
 (let ((@x11022 (refl (~ $x4568 $x4568))))
 (monotonicity @x11022 @x11024 @x11069 (~ $x4570 $x11070))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x11080 (monotonicity (refl (~ $x4583 $x4583)) (nnf-pos (proof-bind ?x11074) (~ $x4576 $x11073)) (~ $x4584 $x11078))))
 (let (($x4545 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x3858 (sized A&.)))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4541))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4546 (=> $x4524 $x4545)))
 (let ((?x4577 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4543 (=> (and $x4526 $x3858) $x4541)))
 (let ((@x4564 (trans (monotonicity (rewrite (= $x4541 $x4559)) (= $x4542 (=> $x3858 $x4559))) (rewrite (= (=> $x3858 $x4559) (or $x4431 $x4559))) (= $x4542 (or $x4431 $x4559)))))
 (trans (monotonicity @x4564 (= $x4543 (=> $x4526 (or $x4431 $x4559)))) (rewrite (= (=> $x4526 (or $x4431 $x4559)) $x4570)) (= $x4543 $x4570)))))))))))))))))))))))
 ))
 (let ((@x4582 (monotonicity (quant-intro (proof-bind ?x4577) (= $x4545 $x4576)) (= $x4546 (=> $x4524 $x4576)))))
 (let ((@x4589 (mp (asserted $x4546) (trans @x4582 (rewrite (= (=> $x4524 $x4576) $x4584)) (= $x4546 $x4584)) $x4584)))
 (let ((@x14464 (mp (mp (mp~ @x4589 @x11080 $x11078) (rewrite (= $x11078 $x11082)) $x11082) (rewrite (= $x11082 $x14475)) $x14475)))
 (let (($x46885 (not $x44562)))
 (let (($x46887 (not $x46886)))
 (let (($x46889 (not $x46888)))
 (let (($x46900 (not $x14542)))
 (let (($x46911 (or $x46900 $x46889 $x46887 $x46885 $x46910)))
 (let (($x46866 (or $x44638 $x46865 (not (or $x46860 $x46858 (<= (+ ?x46854 (* (- 1) ?x46852)) 0) $x46851)))))
 (let (($x46884 (not (or $x46882 (not $x46866)))))
 (let (($x46890 (or $x46889 $x46887 $x46885 $x46884)))
 (let (($x46915 (or $x46900 $x46890)))
 (let (($x46921 (or $x46889 $x46887 $x46885 $x46910)))
 (let (($x46923 (= $x46890 $x46921)))
 (let ((@x46899 (trans (monotonicity (rewrite (= $x46884 $x46910)) $x46923) (rewrite (= $x46921 $x46921)) $x46923)))
 (let ((@x46896 (trans (monotonicity @x46899 (= $x46915 (or $x46900 $x46921))) (rewrite (= (or $x46900 $x46921) $x46911)) (= $x46915 $x46911))))
 (let ((@x47311 (unit-resolution (mp ((_ quant-inst T&. T& (vstd!seq.Seq.subrange.? T&. T& s1! k@ m@) (vstd!seq.Seq.subrange.? T&. T& s2! k@ m@)) $x46915) @x46896 $x46911) (unit-resolution @x14464 (unit-resolution @x47247 @x45139 $x4524) $x14542) @x44563 @x47283 @x47313 $x46910)))
 (let ((?x46768 (I ?x44629)))
 (let ((?x46986 (%I ?x46768)))
 (let ((?x47005 (* (- 1) ?x46986)))
 (let ((?x46817 (I ?x44628)))
 (let ((?x46983 (%I ?x46817)))
 (let ((?x47006 (+ ?x46983 ?x47005)))
 (let (($x47007 (<= ?x47006 0)))
 (let ((@x44992 (def-axiom (or $x44826 $x44685))))
 (let ((@x47315 (unit-resolution @x44992 @x47245 $x44685)))
 (let ((?x47100 (+ ?x44629 ?x47005)))
 (let (($x47101 (<= ?x47100 0)))
 (let (($x47099 (= ?x44629 ?x46986)))
 (let (($x46769 (= m@ ?x46768)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x9171 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x9175 (mp~ @x280 (nnf-pos (proof-bind ?x9171) (~ $x275 $x275)) $x275)))
 (let (($x46819 (not $x275)))
 (let (($x46820 (or $x46819 $x44728 $x46769)))
 (let ((@x46825 (mp ((_ quant-inst m@) (or $x46819 (or $x44728 $x46769))) (rewrite (= (or $x46819 (or $x44728 $x46769)) $x46820)) $x46820)))
 (let ((@x47145 ((_ th-lemma arith triangle-eq) (or (not $x47099) $x47101))))
 (let ((@x47322 (unit-resolution @x47145 (monotonicity (unit-resolution @x46825 @x9175 @x47276 $x46769) $x47099) $x47101)))
 (let ((?x46987 (* (- 1) ?x46983)))
 (let ((?x47096 (+ ?x44628 ?x46987)))
 (let (($x47098 (>= ?x47096 0)))
 (let (($x47095 (= ?x44628 ?x46983)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x9150 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x9154 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x9150) (~ $x237 $x237)) $x237)))
 (let (($x44856 (not $x237)))
 (let (($x46770 (or $x44856 $x47095)))
 (let ((@x46771 ((_ quant-inst (%I k@)) $x46770)))
 (let ((@x47475 (unit-resolution @x46771 @x9154 $x47095)))
 (let ((@x47156 ((_ th-lemma arith triangle-eq) (or (not $x47095) $x47098))))
 (let ((@x47114 (hypothesis $x44685)))
 (let ((@x47118 ((_ th-lemma arith farkas -1 1 -1 1) (hypothesis $x47098) (hypothesis $x47101) (hypothesis (not $x47007)) @x47114 false)))
 (let ((@x47122 (lemma @x47118 (or $x47007 (not $x47098) (not $x47101) $x44717))))
 (let ((@x47327 (unit-resolution @x47122 (unit-resolution @x47156 @x47475 $x47098) (or $x47007 (not $x47101) $x44717))))
 (let ((@x44990 (def-axiom (or $x44826 $x44680))))
 (let ((@x47359 (unit-resolution @x44990 @x47245 $x44680)))
 (let ((@x44994 (def-axiom (or $x44826 $x44686))))
 (let ((@x47381 (unit-resolution @x44994 @x47245 $x44686)))
 (let ((?x46996 (Sub ?x46986 ?x46983)))
 (let ((?x47419 (+ ?x46983 ?x47005 ?x46996)))
 (let (($x47426 (<= ?x47419 0)))
 (let (($x47420 (= ?x47419 0)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x9395 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x9399 (mp~ @x956 (nnf-pos (proof-bind ?x9395) (~ $x951 $x951)) $x951)))
 (let ((@x47502 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47420) $x47426)) (unit-resolution ((_ quant-inst (%I ?x46768) (%I ?x46817)) (or (not $x951) $x47420)) @x9399 $x47420) $x47426)))
 (let ((?x44615 (I j!)))
 (let ((?x44844 (%I ?x44615)))
 (let ((?x46538 (* (- 1) ?x44844)))
 (let ((?x46648 (+ j! ?x46538)))
 (let (($x46649 (<= ?x46648 0)))
 (let (($x44847 (= j! ?x44844)))
 (let (($x44857 (or $x44856 $x44847)))
 (let ((@x44858 ((_ quant-inst j!) $x44857)))
 (let ((@x46674 (unit-resolution @x44858 @x9154 $x44847)))
 (let ((@x46700 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44847) $x46649)) @x46674 $x46649)))
 (let ((@x47125 (hypothesis $x44686)))
 (let (($x47446 (<= (+ ?x44844 (* (- 1) (%I (I (%I (I (Add ?x46852 ?x46983))))))) 0)))
 (let ((?x47235 (Add ?x46852 ?x46983)))
 (let ((?x47236 (I ?x47235)))
 (let ((?x47302 (%I ?x47236)))
 (let ((?x47360 (I ?x47302)))
 (let ((?x47433 (vstd!seq.Seq.index.? T&. T& s2! ?x47360)))
 (let ((?x47432 (vstd!seq.Seq.index.? T&. T& s1! ?x47360)))
 (let (($x47434 (= ?x47432 ?x47433)))
 (let (($x47569 (not $x47434)))
 (let ((?x46994 (vstd!seq.Seq.subrange.? T&. T& s2! ?x46817 ?x46768)))
 (let ((?x47234 (vstd!seq.Seq.index.? T&. T& ?x46994 ?x46835)))
 (let ((@x47146 (hypothesis $x44627)))
 (let ((@x47147 (unit-resolution @x46825 @x9175 @x47146 $x46769)))
 (let ((@x47149 (symm @x47147 (= ?x46768 m@))))
 (let (($x46818 (= k@ ?x46817)))
 (let ((@x47157 (hypothesis $x44625)))
 (let (($x46829 (or $x46819 $x44737 $x46818)))
 (let ((@x46834 (mp ((_ quant-inst k@) (or $x46819 (or $x44737 $x46818))) (rewrite (= (or $x46819 (or $x44737 $x46818)) $x46829)) $x46829)))
 (let ((@x47160 (symm (unit-resolution @x46834 @x9175 @x47157 $x46818) (= ?x46817 k@))))
 (let ((@x47182 (monotonicity @x47160 @x47149 (= ?x46994 ?x44637))))
 (let ((?x47237 (vstd!seq.Seq.index.? T&. T& s2! ?x47236)))
 (let (($x47238 (= ?x47234 ?x47237)))
 (let (($x46973 (has_type ?x46817 INT)))
 (let ((@x47179 (mp @x47157 (symm (monotonicity @x47160 (= $x46973 $x44625)) (= $x44625 $x46973)) $x46973)))
 (let (($x46981 (has_type ?x46768 INT)))
 (let ((@x47174 (mp @x47146 (symm (monotonicity @x47149 (= $x46981 $x44627)) (= $x44627 $x46981)) $x46981)))
 (let ((?x47224 (* (- 1) ?x46996)))
 (let ((?x47225 (+ ?x46852 ?x47224)))
 (let (($x47233 (>= ?x47225 0)))
 (let (($x47530 (not $x47233)))
 (let ((?x47412 (+ ?x46854 ?x47224)))
 (let (($x47413 (<= ?x47412 0)))
 (let (($x47411 (= ?x46854 ?x46996)))
 (let ((?x47059 (vstd!seq.Seq.subrange.? T&. T& s1! ?x46817 ?x46768)))
 (let ((?x47060 (vstd!seq.Seq.len.? T&. T& ?x47059)))
 (let (($x47061 (= ?x47060 ?x46996)))
 (let ((?x44577 (vstd!seq.Seq.len.? T&. T& s1!)))
 (let ((?x47069 (+ ?x44577 ?x47005)))
 (let (($x47070 (>= ?x47069 0)))
 (let (($x47102 (>= ?x47100 0)))
 (let ((@x47184 ((_ th-lemma arith triangle-eq) (or (not $x47099) $x47102))))
 (let ((@x47513 (unit-resolution @x47184 (monotonicity @x47147 $x47099) $x47102)))
 (let ((?x44587 (* (- 1) ?x44577)))
 (let ((?x44588 (+ j! ?x44587)))
 (let (($x44581 (<= ?x44588 0)))
 (let ((?x44584 (* (- 1) j!)))
 (let ((?x44585 (+ i! ?x44584)))
 (let (($x44586 (<= ?x44585 0)))
 (let (($x44582 (>= i! 0)))
 (let (($x44596 (and $x44582 $x44586 $x44581)))
 (let (($x44589 (and $x44582 $x44586)))
 (let (($x44593 (and $x44589 $x44581)))
 (let (($x44578 (<= j! ?x44577)))
 (let (($x44576 (and (<= 0 i!) (<= i! j!))))
 (let (($x44579 (and $x44576 $x44578)))
 (let ((@x44595 (monotonicity (rewrite (= $x44576 $x44589)) (rewrite (= $x44578 $x44581)) (= $x44579 $x44593))))
 (let ((@x44601 (mp (asserted $x44579) (trans @x44595 (rewrite (= $x44593 $x44596)) (= $x44579 $x44596)) $x44596)))
 (let ((@x44604 (and-elim @x44601 $x44581)))
 (let ((@x47518 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x47070 (not $x44581) $x44701 (not $x47102))) @x44604 (or $x47070 $x44701 (not $x47102)))))
 (let ((@x47519 (unit-resolution @x47518 @x47513 @x47125 $x47070)))
 (let ((@x47511 (hypothesis $x47007)))
 (let (($x46984 (>= ?x46983 0)))
 (let ((@x47107 (hypothesis $x44680)))
 (let (($x47097 (<= ?x47096 0)))
 (let ((@x47167 ((_ th-lemma arith triangle-eq) (or (not $x47095) $x47097))))
 (let ((@x47476 (unit-resolution @x47167 @x47475 $x47097)))
 (let ((@x44602 (and-elim @x44601 $x44582)))
 (let ((@x47113 (lemma ((_ th-lemma arith farkas -1 1 1 1) @x44602 (hypothesis (not $x46984)) (hypothesis $x47097) @x47107 false) (or $x46984 (not $x47097) $x44697))))
 (let ((@x47510 (unit-resolution (unit-resolution @x47113 @x47476 (or $x46984 $x44697)) @x47107 $x46984)))
 (let (($x14498 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x14298 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14297 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x13502 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x14338 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x14312 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x14302 (not $x4256)))
 (or $x14302 $x14312 $x271 $x14338 $x13502 $x14297 $x14298 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x45155 (= $x4641 $x1589)))
 (let ((@x45157 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x45155)) @x44860 (hypothesis (not $x45155)) false)))
 (let ((@x45169 (lemma @x45157 $x45155)))
 (let ((@x45162 (def-axiom (or (not $x45155) $x4641 $x13644))))
 (let ((@x47192 (unit-resolution @x45162 (unit-resolution (def-axiom (or $x13650 $x1589)) @x47189 $x1589) (or (not $x45155) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x14549 (or $x4675 $x14498)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x11176 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x11199 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x11176) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x4233 (<= ?x1191 ?x264)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 $x4233)))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643)))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x4233 (<= ?x1191 ?x264)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 $x4233)))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664)))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x14551 (mp (mp (mp~ @x4681 @x11199 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x14549)) $x14549)))
 (let ((@x47194 (unit-resolution @x14551 (unit-resolution @x47192 @x45169 $x4641) $x14498)))
 (let (($x47075 (not $x47070)))
 (let (($x47012 (not $x47007)))
 (let (($x46985 (not $x46984)))
 (let (($x46982 (not $x46981)))
 (let (($x46974 (not $x46973)))
 (let (($x47036 (not $x14498)))
 (let (($x47084 (or $x47036 $x44936 $x46974 $x46982 $x46885 $x46985 $x47012 $x47075 $x47061)))
 (let ((?x47050 (+ ?x46986 ?x44587)))
 (let (($x47051 (<= ?x47050 0)))
 (let (($x47058 (not $x47051)))
 (let ((?x46988 (+ ?x46986 ?x46987)))
 (let (($x46989 (>= ?x46988 0)))
 (let (($x46990 (not $x46989)))
 (let (($x47062 (or $x44936 $x46974 $x46982 $x46885 $x46985 $x46990 $x47058 $x47061)))
 (let (($x47085 (or $x47036 $x47062)))
 (let ((@x47091 (rewrite (= (or $x47036 (or $x44936 $x46974 $x46982 $x46885 $x46985 $x47012 $x47075 $x47061)) $x47084))))
 (let (($x47077 (or $x44936 $x46974 $x46982 $x46885 $x46985 $x47012 $x47075 $x47061)))
 (let (($x47079 (= $x47062 $x47077)))
 (let ((@x47083 (trans (monotonicity (rewrite (= $x46990 $x47012)) (rewrite (= $x47058 $x47075)) $x47079) (rewrite (= $x47077 $x47077)) $x47079)))
 (let ((@x47093 (trans (monotonicity @x47083 (= $x47085 (or $x47036 $x47077))) @x47091 (= $x47085 $x47084))))
 (let ((@x47094 (mp ((_ quant-inst T&. T& s1! (I ?x44628) (I ?x44629)) $x47085) @x47093 $x47084)))
 (let ((@x47521 (unit-resolution @x47094 @x47194 @x44563 @x44568 @x47510 @x47511 @x47519 (or $x46974 $x46982 $x47061))))
 (let ((@x47205 (monotonicity @x47160 @x47149 (= ?x47059 ?x44636))))
 (let ((@x47207 (monotonicity @x47205 (= ?x47060 ?x46854))))
 (let ((@x47527 (trans* (symm @x47207 (= ?x46854 ?x47060)) (unit-resolution @x47521 @x47174 @x47179 $x47061) $x47411)))
 (let ((@x47528 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47411) $x47413)) @x47527 $x47413)))
 (let (($x47055 (not $x46908)))
 (let ((@x47503 (hypothesis $x46960)))
 (let ((@x47052 (def-axiom (or $x46903 $x47055))))
 (let ((@x47529 (unit-resolution @x47052 @x47503 $x47055)))
 (let ((@x47534 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1) (or $x47530 (not $x47413) $x46908)) @x47529 @x47528 $x47530)))
 (let ((@x47054 (def-axiom (or $x46903 $x46857))))
 (let ((@x47542 (unit-resolution @x47054 @x47503 $x46857)))
 (let ((@x46980 (def-axiom (or $x46903 $x46859))))
 (let ((@x47541 (unit-resolution @x46980 @x47503 $x46859)))
 (let ((?x44605 (vstd!seq.Seq.len.? T&. T& s2!)))
 (let ((?x47021 (+ ?x44605 ?x47005)))
 (let (($x47022 (>= ?x47021 0)))
 (let ((?x44608 (* (- 1) ?x44605)))
 (let ((?x44609 (+ j! ?x44608)))
 (let (($x44610 (<= ?x44609 0)))
 (let ((@x44613 (mp (asserted (<= j! ?x44605)) (rewrite (= (<= j! ?x44605) $x44610)) $x44610)))
 (let ((@x47129 (lemma ((_ th-lemma arith farkas -1 -1 1 1) @x47125 (hypothesis $x47102) (hypothesis (not $x47022)) @x44613 false) (or $x47022 $x44701 (not $x47102)))))
 (let (($x14568 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x14198 (not $x821)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4686 (sized A&.)))
 (let (($x14518 (not $x4686)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k! INT)))
 (let (($x14312 (not $x4257)))
 (let (($x4684 (has_type j! INT)))
 (let (($x14558 (not $x4684)))
 (or (not (has_type s! (TYPE%vstd!seq.Seq. A&. A&))) $x14558 $x14312 $x271 $x14518 (not (>= (%I j!) 0)) (not (<= (+ (%I j!) (* (- 1) (%I k!))) 0)) (not $x4711) $x14198 $x4741 $x4703)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4682 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x45170 (= $x4682 $x1590)))
 (let ((@x45172 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_index.) (or (not $x30) $x45170)) @x44860 (hypothesis (not $x45170)) false)))
 (let ((@x45184 (lemma @x45172 $x45170)))
 (let ((@x45177 (def-axiom (or (not $x45170) $x4682 $x13645))))
 (let ((@x47537 (unit-resolution @x45177 (unit-resolution (def-axiom (or $x13650 $x1590)) @x47189 $x1590) (or (not $x45170) $x4682))))
 (let (($x4749 (not $x4682)))
 (let (($x14573 (or $x4749 $x14568)))
 (let (($x4774 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (or (not $x4685) $x4759 $x4703)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4779 (or $x4749 $x4774)))
 (let ((?x11208 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (refl (~ $x4769 $x4769)))))))))))))))))))))))
 ))
 (let ((@x11213 (monotonicity (refl (~ $x4749 $x4749)) (nnf-pos (proof-bind ?x11208) (~ $x4774 $x4774)) (~ $x4779 $x4779))))
 (let (($x4707 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) (%I j!))))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let ((?x1186 (%I j!)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4686 (sized A&.)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (=> (and $x4685 $x4697) $x4703))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4708 (=> $x4682 $x4707)))
 (let ((?x4775 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) ?x1186)))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x4705 (=> (and $x4685 $x4697) $x4703)))
 (let ((@x4734 (rewrite (= (and $x4686 (and $x4710 $x4714 $x4711)) (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4723 (monotonicity (rewrite (= $x4689 (and $x4710 $x4714))) (rewrite (= $x4691 $x4711)) (= $x4692 (and (and $x4710 $x4714) $x4711)))))
 (let ((@x4728 (trans @x4723 (rewrite (= (and (and $x4710 $x4714) $x4711) (and $x4710 $x4714 $x4711))) (= $x4692 (and $x4710 $x4714 $x4711)))))
 (let ((@x4736 (trans (monotonicity @x4728 (= $x4693 (and $x4686 (and $x4710 $x4714 $x4711)))) @x4734 (= $x4693 (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4742 (monotonicity @x4736 (rewrite (= $x4696 (and $x821 $x4746))) (= $x4697 (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746))))))
 (let ((@x4755 (trans @x4742 (rewrite (= (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746)) $x4745)) (= $x4697 $x4745))))
 (let ((@x4764 (trans (monotonicity @x4755 (= $x4704 (=> $x4745 $x4703))) (rewrite (= (=> $x4745 $x4703) (or $x4759 $x4703))) (= $x4704 (or $x4759 $x4703)))))
 (trans (monotonicity @x4764 (= $x4705 (=> $x4685 (or $x4759 $x4703)))) (rewrite (= (=> $x4685 (or $x4759 $x4703)) $x4769)) (= $x4705 $x4769))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4747 (monotonicity (quant-intro (proof-bind ?x4775) (= $x4707 $x4774)) (= $x4708 (=> $x4682 $x4774)))))
 (let ((@x4784 (mp (asserted $x4708) (trans @x4747 (rewrite (= (=> $x4682 $x4774) $x4779)) (= $x4708 $x4779)) $x4779)))
 (let ((@x14575 (mp (mp (mp~ @x4784 @x11213 $x4779) (rewrite (= $x4779 $x4779)) $x4779) (rewrite (= $x4779 $x14573)) $x14573)))
 (let ((@x47539 (unit-resolution @x14575 (unit-resolution @x47537 @x45184 $x4682) $x14568)))
 (let (($x47027 (not $x47022)))
 (let (($x47264 (not $x14568)))
 (let (($x47262 (or $x47264 $x44970 $x46974 $x46982 $x46860 $x46885 $x46985 $x47012 $x47027 $x46858 $x47233 $x47238)))
 (let ((?x46991 (+ ?x46986 ?x44608)))
 (let (($x46992 (<= ?x46991 0)))
 (let (($x46993 (not $x46992)))
 (let (($x47239 (or $x44970 $x46974 $x46982 $x46860 $x46885 $x46985 $x47012 $x46993 $x46858 $x47233 $x47238)))
 (let (($x47265 (or $x47264 $x47239)))
 (let (($x47243 (or $x44970 $x46974 $x46982 $x46860 $x46885 $x46985 $x47012 $x47027 $x46858 $x47233 $x47238)))
 (let (($x47267 (or $x47264 $x47243)))
 (let (($x47244 (= $x47239 $x47243)))
 (let ((@x47263 (trans (monotonicity (rewrite (= $x46993 $x47027)) $x47244) (rewrite (= $x47243 $x47243)) $x47244)))
 (let ((@x47273 (trans (monotonicity @x47263 (= $x47265 $x47267)) (rewrite (= $x47267 $x47262)) (= $x47265 $x47262))))
 (let ((@x47544 (unit-resolution (mp ((_ quant-inst T&. T& s2! (I ?x44628) (I ?x44629) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44637 ?x44636 T& T&.)) $x47265) @x47273 $x47262) @x47539 @x44563 @x44571 @x47510 @x47511 (unit-resolution @x47129 @x47513 @x47125 $x47022) @x47541 @x47542 (or $x46974 $x46982 $x47233 $x47238))))
 (let (($x47368 (= ?x47360 ?x47236)))
 (let (($x46778 (= ?x47236 ?x47360)))
 (let (($x47300 (has_type ?x47236 INT)))
 (let (($x47361 (has_type ?x47360 INT)))
 (let (($x47374 (not $x47361)))
 (let (($x47372 (= $x47300 $x47361)))
 (let (($x47370 (= $x47361 $x47300)))
 (let (($x47345 (= ?x47235 ?x47302)))
 (let (($x47348 (or $x44856 $x47345)))
 (let ((@x47349 ((_ quant-inst (Add ?x46852 ?x46983)) $x47348)))
 (let ((@x47363 (unit-resolution @x47349 @x9154 $x47345)))
 (let ((@x47373 (symm (monotonicity (monotonicity (symm @x47363 (= ?x47302 ?x47235)) $x47368) $x47370) $x47372)))
 (let ((@x47377 (mp (hypothesis (not $x47300)) (monotonicity @x47373 (= (not $x47300) $x47374)) $x47374)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x9290 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x9294 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x9290) (~ $x698 $x698)) $x698)))
 (let ((@x47379 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x47236)) (or (not $x698) $x47361)) @x9294 $x47361) @x47377 false)))
 (let ((@x47380 (lemma @x47379 $x47300)))
 (let (($x47301 (not $x47300)))
 (let (($x46772 (or $x46819 $x47301 $x46778)))
 (let ((@x46815 (mp ((_ quant-inst (I ?x47235)) (or $x46819 (or $x47301 $x46778))) (rewrite (= (or $x46819 (or $x47301 $x46778)) $x46772)) $x46772)))
 (let ((@x47482 (symm (unit-resolution @x46815 @x9175 @x47380 $x46778) $x47368)))
 (let ((@x47553 (trans* (monotonicity @x47482 (= ?x47433 ?x47237)) (symm (unit-resolution @x47544 @x47534 @x47174 @x47179 $x47238) (= ?x47237 ?x47234)) (monotonicity @x47182 (= ?x47234 ?x46836)) (= ?x47433 ?x46836))))
 (let ((@x47562 (monotonicity @x47205 (= (vstd!seq.Seq.index.? T&. T& ?x47059 ?x46835) ?x46850))))
 (let ((?x47260 (vstd!seq.Seq.index.? T&. T& ?x47059 ?x46835)))
 (let ((?x47261 (vstd!seq.Seq.index.? T&. T& s1! ?x47236)))
 (let (($x47268 (= ?x47260 ?x47261)))
 (let (($x47292 (or $x47264 $x44936 $x46974 $x46982 $x46860 $x46885 $x46985 $x47012 $x47075 $x46858 $x47233 $x47268)))
 (let (($x47269 (or $x44936 $x46974 $x46982 $x46860 $x46885 $x46985 $x47012 $x47058 $x46858 $x47233 $x47268)))
 (let (($x47295 (or $x47264 $x47269)))
 (let (($x47275 (or $x44936 $x46974 $x46982 $x46860 $x46885 $x46985 $x47012 $x47075 $x46858 $x47233 $x47268)))
 (let (($x47297 (or $x47264 $x47275)))
 (let (($x47279 (= $x47269 $x47275)))
 (let ((@x47294 (trans (monotonicity (rewrite (= $x47058 $x47075)) $x47279) (rewrite (= $x47275 $x47275)) $x47279)))
 (let ((@x47323 (trans (monotonicity @x47294 (= $x47295 $x47297)) (rewrite (= $x47297 $x47292)) (= $x47295 $x47292))))
 (let ((@x47555 (unit-resolution (mp ((_ quant-inst T&. T& s1! (I ?x44628) (I ?x44629) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44637 ?x44636 T& T&.)) $x47295) @x47323 $x47292) @x47539 @x44563 @x44568 @x47510 @x47511 @x47519 @x47541 @x47542 (or $x46974 $x46982 $x47233 $x47268))))
 (let ((@x47564 (trans* (monotonicity @x47482 (= ?x47432 ?x47261)) (symm (unit-resolution @x47555 @x47534 @x47174 @x47179 $x47268) (= ?x47261 ?x47260)) @x47562 (= ?x47432 ?x46850))))
 (let ((@x47571 (monotonicity (symm (monotonicity @x47564 @x47553 (= $x47434 $x46851)) (= $x46851 $x47434)) (= (not $x46851) $x47569))))
 (let ((@x47572 (mp (unit-resolution (def-axiom (or $x46903 (not $x46851))) @x47503 (not $x46851)) @x47571 $x47569)))
 (let ((?x47421 (%I ?x47360)))
 (let ((?x47442 (* (- 1) ?x47421)))
 (let ((?x44614 (I i!)))
 (let ((?x44854 (%I ?x44614)))
 (let ((?x47443 (+ ?x44854 ?x47442)))
 (let (($x47444 (<= ?x47443 0)))
 (let ((?x46506 (* (- 1) ?x44854)))
 (let ((?x46645 (+ i! ?x46506)))
 (let (($x46495 (>= ?x46645 0)))
 (let (($x44855 (= i! ?x44854)))
 (let (($x44862 (or $x44856 $x44855)))
 (let ((@x44863 ((_ quant-inst i!) $x44862)))
 (let ((@x46653 (unit-resolution @x44863 @x9154 $x44855)))
 (let ((@x46696 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44855) $x46495)) @x46653 $x46495)))
 (let ((?x47472 (+ ?x47235 ?x47442)))
 (let (($x47473 (<= ?x47472 0)))
 (let (($x47471 (= ?x47235 ?x47421)))
 (let ((@x47487 (trans* @x47363 (symm (monotonicity @x47482 (= ?x47421 ?x47302)) (= ?x47302 ?x47421)) $x47471)))
 (let ((?x46774 (* (- 1) ?x47235)))
 (let ((?x46841 (+ ?x46852 ?x46983 ?x46774)))
 (let (($x46917 (<= ?x46841 0)))
 (let (($x46844 (= ?x46841 0)))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x9388 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x9392 (mp~ @x925 (nnf-pos (proof-bind ?x9388) (~ $x920 $x920)) $x920)))
 (let (($x46194 (not $x920)))
 (let (($x46842 (or $x46194 $x46844)))
 (let (($x46840 (= (+ ?x46983 ?x46852 ?x46774) 0)))
 (let (($x46843 (or $x46194 $x46840)))
 (let (($x46848 (= $x46843 $x46842)))
 (let ((@x46839 (trans (monotonicity (rewrite (= $x46840 $x46844)) $x46848) (rewrite (= $x46842 $x46842)) $x46848)))
 (let ((@x46916 (mp ((_ quant-inst (%I ?x46835) (%I ?x46817)) $x46843) @x46839 $x46842)))
 (let ((@x47492 (unit-resolution @x46916 @x9392 $x46844)))
 (let ((@x47495 ((_ th-lemma arith farkas 1 -1 1 1 -1 -1 1) @x47107 (hypothesis $x46857) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46844) $x46917)) @x47492 $x46917) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47471) $x47473)) @x47487 $x47473) (hypothesis (not $x47444)) @x46696 @x47476 false)))
 (let ((@x47497 (lemma @x47495 (or $x47444 $x44697 $x46858))))
 (let (($x47449 (not $x47444)))
 (let (($x47454 (or $x47374 $x47449 $x47446 $x47434)))
 (let (($x46762 (forall ((k$ Poly) )(! (let ((?x46753 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x46751 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (>= (+ (%I k$) (* (- 1) (%I (I i!)))) 0)) (>= (+ (%I k$) (* (- 1) (%I (I j!)))) 0) (= ?x46751 ?x46753)))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x46748 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! ?x44854 ?x44844)))
 (let (($x46763 (not $x46748)))
 (let (($x46764 (or $x46763 $x46762)))
 (let ((?x46602 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 ?x44844 ?x44854 s2! s1! T& T&.)))
 (let ((?x46609 (vstd!seq.Seq.index.? T&. T& s2! ?x46602)))
 (let ((?x46612 (vstd!seq.Seq.index.? T&. T& s1! ?x46602)))
 (let (($x46497 (= ?x46612 ?x46609)))
 (let ((?x46498 (%I ?x46602)))
 (let ((?x46594 (* (- 1) ?x46498)))
 (let ((?x46647 (+ ?x44844 ?x46594)))
 (let (($x46611 (<= ?x46647 0)))
 (let ((?x46603 (+ ?x44854 ?x46594)))
 (let (($x46604 (<= ?x46603 0)))
 (let (($x46500 (not $x46604)))
 (let (($x46621 (has_type ?x46602 INT)))
 (let (($x46745 (not $x46621)))
 (let (($x46746 (or $x46745 $x46500 $x46611 $x46497)))
 (let (($x46747 (not $x46746)))
 (let (($x46749 (or $x46748 $x46747)))
 (let (($x46750 (not $x46749)))
 (let (($x46765 (not $x46764)))
 (let (($x46766 (or $x46765 $x46750)))
 (let (($x46767 (not $x46766)))
 (let (($x16601 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let ((?x13028 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 j! i! s2! s1! T& T&.)))
 (let (($x13041 (= (vstd!seq.Seq.index.? T&. T& s1! ?x13028) (vstd!seq.Seq.index.? T&. T& s2! ?x13028))))
 (let (($x13080 (<= (+ j! (* (- 1) (%I ?x13028))) 0)))
 (let (($x13030 (not (has_type ?x13028 INT))))
 (let (($x16602 (not (or $x13030 (not (<= (+ i! (* (- 1) (%I ?x13028))) 0)) $x13080 $x13041))))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x16583 (or $x8863 $x16602)))
 (let (($x16574 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let (($x8886 (>= (+ (%I k$) (* (- 1) j!)) 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (>= (+ (%I k$) (* (- 1) i!)) 0)) $x8886 $x8898))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13019 (not $x8863)))
 (let (($x16579 (or $x13019 $x16574)))
 (not (or (not $x16579) (not $x16583))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let (($x13064 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let ((?x13028 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 j! i! s2! s1! T& T&.)))
 (let (($x13041 (= (vstd!seq.Seq.index.? T&. T& s1! ?x13028) (vstd!seq.Seq.index.? T&. T& s2! ?x13028))))
 (let (($x13068 (<= (+ i! (* (- 1) (%I ?x13028))) 0)))
 (let (($x13030 (not (has_type ?x13028 INT))))
 (let (($x13074 (or $x13030 (not (and $x13068 (not (<= (+ j! (* (- 1) (%I ?x13028))) 0)))) $x13041)))
 (let (($x13088 (not $x13074)))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x13060 (or $x8863 $x13088)))
 (let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13019 (not $x8863)))
 (let (($x13048 (or $x13019 $x8928)))
 (and $x13048 $x13060)))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let ((?x16604 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let ((?x13028 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 j! i! s2! s1! T& T&.)))
 (let (($x13041 (= (vstd!seq.Seq.index.? T&. T& s1! ?x13028) (vstd!seq.Seq.index.? T&. T& s2! ?x13028))))
 (let (($x13080 (<= (+ j! (* (- 1) (%I ?x13028))) 0)))
 (let (($x13030 (not (has_type ?x13028 INT))))
 (let (($x16602 (not (or $x13030 (not (<= (+ i! (* (- 1) (%I ?x13028))) 0)) $x13080 $x13041))))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x16583 (or $x8863 $x16602)))
 (let (($x16574 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let (($x8886 (>= (+ (%I k$) (* (- 1) j!)) 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (>= (+ (%I k$) (* (- 1) i!)) 0)) $x8886 $x8898))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13019 (not $x8863)))
 (let (($x16579 (or $x13019 $x16574)))
 (let (($x16595 (not (or (not $x16579) (not $x16583)))))
 (let (($x13074 (or $x13030 (not (and (<= (+ i! (* (- 1) (%I ?x13028))) 0) (not $x13080))) $x13041)))
 (let (($x13088 (not $x13074)))
 (let (($x13060 (or $x8863 $x13088)))
 (let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13048 (or $x13019 $x8928)))
 (let (($x13072 (and $x13048 $x13060)))
 (let (($x16584 (= $x13060 $x16583)))
 (let ((@x16588 (trans (monotonicity (rewrite (= $x13088 $x16602)) $x16584) (rewrite (= $x16583 $x16583)) $x16584)))
 (trans (monotonicity (rewrite (= $x13048 $x16579)) @x16588 (= $x13072 (and $x16579 $x16583))) (rewrite (= (and $x16579 $x16583) $x16595)) (= $x13072 $x16595))))))))))))))))))))))
 ))
 (let (($x13052 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let ((?x13028 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 j! i! s2! s1! T& T&.)))
 (let (($x13041 (= (vstd!seq.Seq.index.? T&. T& s1! ?x13028) (vstd!seq.Seq.index.? T&. T& s2! ?x13028))))
 (let (($x13037 (and (>= (+ (%I ?x13028) (* (- 1) i!)) 0) (not (>= (+ (%I ?x13028) (* (- 1) j!)) 0)))))
 (let (($x13030 (not (has_type ?x13028 INT))))
 (let (($x13043 (not (or $x13030 (not $x13037) $x13041))))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13019 (not $x8863)))
 (let (($x13048 (or $x13019 $x8928)))
 (and $x13048 (or $x8863 $x13043))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let ((?x13065 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let ((?x13028 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 j! i! s2! s1! T& T&.)))
 (let (($x13041 (= (vstd!seq.Seq.index.? T&. T& s1! ?x13028) (vstd!seq.Seq.index.? T&. T& s2! ?x13028))))
 (let (($x13068 (<= (+ i! (* (- 1) (%I ?x13028))) 0)))
 (let (($x13030 (not (has_type ?x13028 INT))))
 (let (($x13074 (or $x13030 (not (and $x13068 (not (<= (+ j! (* (- 1) (%I ?x13028))) 0)))) $x13041)))
 (let (($x13088 (not $x13074)))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x13060 (or $x8863 $x13088)))
 (let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13019 (not $x8863)))
 (let (($x13048 (or $x13019 $x8928)))
 (let (($x13072 (and $x13048 $x13060)))
 (let (($x13037 (and (>= (+ (%I ?x13028) (* (- 1) i!)) 0) (not (>= (+ (%I ?x13028) (* (- 1) j!)) 0)))))
 (let (($x13043 (not (or $x13030 (not $x13037) $x13041))))
 (let (($x13049 (and $x13048 (or $x8863 $x13043))))
 (rewrite (= $x13049 $x13072))))))))))))))))))
 ))
 (let (($x8915 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (= $x8863 $x8928))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let ((?x13053 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let ((?x13028 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37!14 j! i! s2! s1! T& T&.)))
 (let (($x13041 (= (vstd!seq.Seq.index.? T&. T& s1! ?x13028) (vstd!seq.Seq.index.? T&. T& s2! ?x13028))))
 (let (($x13037 (and (>= (+ (%I ?x13028) (* (- 1) i!)) 0) (not (>= (+ (%I ?x13028) (* (- 1) j!)) 0)))))
 (let (($x13030 (not (has_type ?x13028 INT))))
 (let (($x13043 (not (or $x13030 (not $x13037) $x13041))))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x13019 (not $x8863)))
 (let (($x13048 (or $x13019 $x8928)))
 (let (($x13049 (and $x13048 (or $x8863 $x13043))))
 (let (($x8880 (= $x8863 $x8928)))
 (let ((?x13024 (lambda ((k$ Poly) )(let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (let (($x8923 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))
 (refl (~ $x8923 $x8923)))))))))))))
 ))
 (nnf-pos (refl (~ $x8863 $x8863)) (refl (~ $x13019 $x13019)) (nnf-pos (proof-bind ?x13024) (~ $x8928 $x8928)) (sk (~ (not $x8928) $x13043)) (~ $x8880 $x13049)))))))))))))))
 ))
 (let (($x8873 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8870 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let (($x263 (has_type k$ INT)))
 (=> (and $x263 (and (<= i! (%I k$)) (< (%I k$) j!))) $x8898))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (= $x8863 $x8870))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let ((?x8917 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8928 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let ((?x1399 (* (- 1) i!)))
 (let ((?x264 (%I k$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8876 (>= ?x8878 0)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 (not (and $x8876 (not (>= (+ ?x264 (* (- 1) j!)) 0)))) $x8898)))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x8863 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8880 (= $x8863 $x8928)))
 (let (($x8870 (forall ((k$ Poly) )(! (let ((?x8895 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x8281 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x8898 (= ?x8281 ?x8895)))
 (let (($x263 (has_type k$ INT)))
 (=> (and $x263 (and (<= i! (%I k$)) (< (%I k$) j!))) $x8898))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_37))
 ))
 (let (($x8871 (= $x8863 $x8870)))
 (rewrite (= $x8871 $x8880))))))))
 ))
 (let ((@x8877 (mp (asserted $x8873) (quant-intro (proof-bind ?x8917) (= $x8873 $x8915)) $x8915)))
 (let ((@x13076 (mp (mp~ @x8877 (nnf-pos (proof-bind ?x13053) (~ $x8915 $x13052)) $x13052) (quant-intro (proof-bind ?x13065) (= $x13052 $x13064)) $x13064)))
 (let ((@x16555 (mp @x13076 (quant-intro (proof-bind ?x16604) (= $x13064 $x16601)) $x16601)))
 (let (($x46777 (or (not $x16601) $x46767)))
 (let ((@x46779 ((_ quant-inst T&. T& s1! s2! (%I ?x44614) (%I ?x44615)) $x46777)))
 (let ((@x46807 (def-axiom (or $x46766 $x46764))))
 (let (($x44623 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let ((@x46678 (symm @x46674 (= ?x44844 j!))))
 (let ((@x46658 (symm @x46653 (= ?x44854 i!))))
 (let (($x44897 (or $x44831 $x44892)))
 (let (($x44909 (not $x44897)))
 (let (($x44752 (not $x44623)))
 (let (($x44887 (or $x44752 $x44909)))
 (let (($x44888 (not $x44887)))
 (let (($x44621 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x44674 (not %%location_label%%0)))
 (let (($x44675 (or $x44674 $x44621)))
 (let ((?x46522 (I ?x44844)))
 (let ((?x46521 (I ?x44854)))
 (let ((?x46524 (vstd!seq.Seq.subrange.? T&. T& s2! ?x46521 ?x46522)))
 (let ((?x46523 (vstd!seq.Seq.subrange.? T&. T& s1! ?x46521 ?x46522)))
 (let (($x46525 (= ?x46523 ?x46524)))
 (let (($x8902 (not %%global_location_label%%53)))
 (let (($x46526 (or $x8902 $x46525)))
 (let (($x46527 (not $x46526)))
 (let ((?x46562 (+ ?x44605 ?x46538)))
 (let (($x46563 (>= ?x46562 0)))
 (let (($x8896 (not %%global_location_label%%52)))
 (let (($x46568 (or $x8896 $x46563)))
 (let (($x46570 (not $x46568)))
 (let ((?x46539 (+ ?x44577 ?x46538)))
 (let (($x46540 (>= ?x46539 0)))
 (let (($x46545 (not $x46540)))
 (let ((?x46507 (+ ?x44844 ?x46506)))
 (let (($x46508 (>= ?x46507 0)))
 (let (($x46509 (not $x46508)))
 (let (($x46489 (>= ?x44854 0)))
 (let (($x46462 (not $x46489)))
 (let (($x46547 (or $x46462 $x46509 $x46545)))
 (let (($x46546 (not $x46547)))
 (let (($x8882 (not %%global_location_label%%51)))
 (let (($x46549 (or $x8882 $x46546)))
 (let (($x46550 (not $x46549)))
 (let (($x46573 (or $x46550 $x46570 $x46527)))
 (let (($x46529 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! ?x44854 ?x44844)))
 (let (($x46620 (= $x46573 $x46529)))
 (let (($x46610 (not $x46620)))
 (let (($x16550 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8843 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8902 (not %%global_location_label%%53)))
 (let (($x8903 (or $x8902 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8896 (not %%global_location_label%%52)))
 (let (($x8897 (or $x8896 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x15306 (not $x6227)))
 (let (($x1122 (>= i! 0)))
 (let (($x13313 (not $x1122)))
 (let (($x16520 (not (or $x13313 $x15306 (not $x8865)))))
 (let (($x8882 (not %%global_location_label%%51)))
 (let (($x16523 (or $x8882 $x16520)))
 (let (($x16532 (or (not $x16523) (not $x8897) (not $x8903))))
 (not (= $x16532 $x8843)))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_req__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let (($x8907 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8902 (not %%global_location_label%%53)))
 (let (($x8903 (or $x8902 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8896 (not %%global_location_label%%52)))
 (let (($x8897 (or $x8896 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8882 (not %%global_location_label%%51)))
 (let (($x8883 (or $x8882 $x8874)))
 (let (($x8906 (and $x8883 $x8897 $x8903)))
 (let (($x8843 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (= $x8843 $x8906))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_req__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let ((?x16551 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8843 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8902 (not %%global_location_label%%53)))
 (let (($x8903 (or $x8902 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8896 (not %%global_location_label%%52)))
 (let (($x8897 (or $x8896 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x15306 (not $x6227)))
 (let (($x1122 (>= i! 0)))
 (let (($x13313 (not $x1122)))
 (let (($x16520 (not (or $x13313 $x15306 (not $x8865)))))
 (let (($x8882 (not %%global_location_label%%51)))
 (let (($x16523 (or $x8882 $x16520)))
 (let (($x16532 (or (not $x16523) (not $x8897) (not $x8903))))
 (let (($x16542 (not (= $x16532 $x8843))))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8883 (or $x8882 $x8874)))
 (let (($x8906 (and $x8883 $x8897 $x8903)))
 (let (($x8904 (= $x8843 $x8906)))
 (let (($x16545 (= $x8904 $x16542)))
 (let ((@x16537 (trans (monotonicity (rewrite (= $x8883 $x16523)) (= $x8906 (and $x16523 $x8897 $x8903))) (rewrite (= (and $x16523 $x8897 $x8903) (not $x16532))) (= $x8906 (not $x16532)))))
 (let ((@x16546 (trans (monotonicity @x16537 (= $x8904 (= $x8843 (not $x16532)))) (rewrite (= (= $x8843 (not $x16532)) $x16542)) $x16545)))
 (trans @x16546 (rewrite (= $x16542 $x16542)) $x16545))))))))))))))))))))))))))
 ))
 (let ((?x13012 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8902 (not %%global_location_label%%53)))
 (let (($x8903 (or $x8902 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8896 (not %%global_location_label%%52)))
 (let (($x8897 (or $x8896 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8882 (not %%global_location_label%%51)))
 (let (($x8883 (or $x8882 $x8874)))
 (let (($x8906 (and $x8883 $x8897 $x8903)))
 (let (($x8843 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8904 (= $x8843 $x8906)))
 (refl (~ $x8904 $x8904))))))))))))))))))
 ))
 (let (($x8860 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let ((?x8849 (vstd!seq.Seq.len.? T&. T& s2!)))
 (let (($x8850 (<= j! ?x8849)))
 (let (($x1116 (<= 0 i!)))
 (let (($x6215 (and $x1116 (<= i! j!))))
 (let (($x8846 (and $x6215 (<= j! (vstd!seq.Seq.len.? T&. T& s1!)))))
 (let (($x8857 (and (=> %%global_location_label%%51 $x8846) (=> %%global_location_label%%52 $x8850) (=> %%global_location_label%%53 $x8855))))
 (let (($x8843 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (= $x8843 $x8857))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!) ) :qid internal_req__pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality._definition))
 ))
 (let ((?x8909 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8902 (not %%global_location_label%%53)))
 (let (($x8903 (or $x8902 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8896 (not %%global_location_label%%52)))
 (let (($x8897 (or $x8896 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8882 (not %%global_location_label%%51)))
 (let (($x8883 (or $x8882 $x8874)))
 (let (($x8906 (and $x8883 $x8897 $x8903)))
 (let (($x8843 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_index_equality. T&. T& s1! s2! i! j!)))
 (let (($x8904 (= $x8843 $x8906)))
 (let ((?x8849 (vstd!seq.Seq.len.? T&. T& s2!)))
 (let (($x8850 (<= j! ?x8849)))
 (let (($x1116 (<= 0 i!)))
 (let (($x6215 (and $x1116 (<= i! j!))))
 (let (($x8846 (and $x6215 (<= j! (vstd!seq.Seq.len.? T&. T& s1!)))))
 (let (($x8857 (and (=> %%global_location_label%%51 $x8846) (=> %%global_location_label%%52 $x8850) (=> %%global_location_label%%53 $x8855))))
 (let (($x8858 (= $x8843 $x8857)))
 (rewrite (= $x8858 $x8904)))))))))))))))))))))))))
 ))
 (let ((@x8862 (mp (asserted $x8860) (quant-intro (proof-bind ?x8909) (= $x8860 $x8907)) $x8907)))
 (let ((@x16521 (mp (mp~ @x8862 (nnf-pos (proof-bind ?x13012) (~ $x8907 $x8907)) $x8907) (quant-intro (proof-bind ?x16551) (= $x8907 $x16550)) $x16550)))
 (let (($x46628 (not $x16550)))
 (let (($x46630 (or $x46628 $x46610)))
 (let ((?x46517 (+ ?x44844 ?x44608)))
 (let (($x46518 (<= ?x46517 0)))
 (let (($x46519 (or $x8896 $x46518)))
 (let (($x46520 (not $x46519)))
 (let (($x46514 (not (or $x46462 $x46509 (not (<= (+ ?x44844 ?x44587) 0))))))
 (let (($x46515 (or $x8882 $x46514)))
 (let (($x46516 (not $x46515)))
 (let (($x46528 (or $x46516 $x46520 $x46527)))
 (let (($x46530 (= $x46528 $x46529)))
 (let (($x46531 (not $x46530)))
 (let (($x46631 (or $x46628 $x46531)))
 (let (($x46622 (= $x46631 $x46630)))
 (let (($x46614 (= $x46531 $x46610)))
 (let ((@x46618 (trans (monotonicity (rewrite (= $x46530 $x46620)) $x46614) (rewrite (= $x46610 $x46610)) $x46614)))
 (let ((@x46639 (mp ((_ quant-inst T&. T& s1! s2! (%I ?x44614) (%I ?x44615)) $x46631) (trans (monotonicity @x46618 $x46622) (rewrite (= $x46630 $x46630)) $x46622) $x46630)))
 (let (($x46598 (not $x46529)))
 (let ((@x46719 (monotonicity (symm (monotonicity @x46658 @x46678 (= $x46529 $x44621)) (= $x44621 $x46529)) (= (not $x44621) $x46598))))
 (let ((@x46606 (def-axiom (or $x46620 $x46573 $x46529))))
 (let ((@x46721 (unit-resolution @x46606 (mp (hypothesis (not $x44621)) @x46719 $x46598) (unit-resolution @x46639 @x16521 $x46610) $x46573)))
 (let ((@x46680 (monotonicity @x46678 (= ?x46522 ?x44615))))
 (let ((@x46660 (monotonicity @x46658 (= ?x46521 ?x44614))))
 (let ((@x46725 (monotonicity @x46660 @x46680 (= ?x46524 (vstd!seq.Seq.subrange.? T&. T& s2! ?x44614 ?x44615)))))
 (let ((@x46727 (symm @x46725 (= (vstd!seq.Seq.subrange.? T&. T& s2! ?x44614 ?x44615) ?x46524))))
 (let ((?x44617 (vstd!seq.Seq.subrange.? T&. T& s2! ?x44614 ?x44615)))
 (let ((?x44616 (vstd!seq.Seq.subrange.? T&. T& s1! ?x44614 ?x44615)))
 (let (($x44618 (= ?x44616 ?x44617)))
 (let ((@x44619 (asserted $x44618)))
 (let ((@x46586 (def-axiom (or $x46526 (not $x46525)))))
 (let ((@x46729 (unit-resolution @x46586 (trans* (monotonicity @x46660 @x46680 (= ?x46523 ?x44616)) @x44619 @x46727 $x46525) $x46526)))
 (let (($x46505 (>= ?x46648 0)))
 (let ((@x46706 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44847) $x46505)) @x46674 $x46505)))
 (let ((@x46711 (lemma ((_ th-lemma arith farkas -1 1 1) @x46706 (hypothesis (not $x46563)) @x44613 false) $x46563)))
 (let ((@x46601 (def-axiom (or $x46568 (not $x46563)))))
 (let ((@x46708 (lemma ((_ th-lemma arith farkas -1 1 1) @x46706 (hypothesis $x46545) @x44604 false) $x46540)))
 (let ((@x46702 (lemma ((_ th-lemma arith farkas 1 -1 1 1) @x46700 @x46696 (hypothesis $x46509) (and-elim @x44601 $x44586) false) $x46508)))
 (let (($x46646 (<= ?x46645 0)))
 (let ((@x46737 (unit-resolution ((_ th-lemma arith assign-bounds -1 1) (or $x46489 (not $x44582) (not $x46646))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44855) $x46646)) @x46653 $x46646) @x44602 $x46489)))
 (let ((@x46582 (def-axiom (or $x46546 $x46462 $x46509 $x46545))))
 (let ((@x46583 (def-axiom (or $x46549 $x46547))))
 (let ((@x46597 (def-axiom (or (not $x46573) $x46550 $x46570 $x46527))))
 (let ((@x46742 (unit-resolution @x46597 (unit-resolution @x46583 (unit-resolution @x46582 @x46737 @x46702 @x46708 $x46546) $x46549) (unit-resolution @x46601 @x46711 $x46568) (or (not $x46573) $x46527))))
 (let ((@x46744 (lemma (unit-resolution @x46742 @x46729 @x46721 false) $x44621)))
 (let ((@x45025 (def-axiom (or $x44675 (not $x44621)))))
 (let (($x44763 (not $x44675)))
 (let (($x44896 (or $x44763 $x44888)))
 (let (($x44942 (or $x44886 $x44795)))
 (let (($x44941 (or $x44884 $x44885)))
 (let (($x44944 (or $x44941 $x44942)))
 (let (($x44873 (or $x44871 $x44872)))
 (let (($x44929 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x44656 (= ?x44654 ?x44655)))
 (let (($x44747 (<= (+ (%I m$) (* (- 1) j!)) 0)))
 (let (($x44846 (not $x44747)))
 (let (($x44924 (or $x44846 $x44656)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14297 (not $x4245)))
 (let (($x44743 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x44845 (not $x44743)))
 (let (($x44922 (or $x44845 $x14297)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14312 (not $x4257)))
 (let (($x44833 (or $x14312 $x271)))
 (let (($x44925 (or $x44833 $x44922)))
 (or $x44925 $x44924)))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_42))
 ))
 (let (($x44934 (not $x44929)))
 (let (($x44940 (or $x44934 $x44807)))
 (let (($x44943 (or $x44940 $x44873)))
 (let (($x44893 (not (or $x44731 (not (or (or $x44710 $x44703) $x44638))))))
 (let (($x44912 (or $x44701 $x44707)))
 (let (($x44914 (or $x44912 $x44893)))
 (let (($x44911 (or $x44697 $x44717)))
 (let (($x44910 (or $x44737 $x44728)))
 (let (($x44913 (or $x44910 $x44911)))
 (let (($x44915 (or $x44913 $x44914)))
 (let (($x44920 (not $x44915)))
 (let (($x44938 (or $x44763 (not (or $x44752 (not (or $x44920 (not (or $x44943 $x44944)))))))))
 (let (($x44780 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x44656 (= ?x44654 ?x44655)))
 (let (($x44747 (<= (+ (%I m$) (* (- 1) j!)) 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x44743 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x44766 (not (and $x44743 $x4245 $x44747))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 $x44766 $x44656)))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_42))
 ))
 (let (($x44715 (and $x44780 %%location_label%%3 (not (or (not (and $x44777 $x44778)) (not (and $x44705 $x44788 $x44723)) $x44795)))))
 (let (($x44738 (or $x44737 $x44728 (not (and $x44680 $x44685 $x44686)) $x44707 (and $x44700 $x44711))))
 (let (($x44757 (not $x44738)))
 (let (($x44698 (or $x44763 (and $x44623 (or $x44757 $x44715)))))
 (let ((?x44789 (+ ?x44748 ?x44584)))
 (let (($x44790 (<= ?x44789 0)))
 (let ((?x44744 (* (- 1) i!)))
 (let ((?x44783 (+ ?x44782 ?x44744)))
 (let (($x44784 (>= ?x44783 0)))
 (let (($x44781 (not (and $x44777 $x44778))))
 (let (($x44798 (not (or $x44781 (not (and $x44784 $x44788 $x44790)) $x44795))))
 (let (($x44803 (and $x44780 %%location_label%%3 $x44798)))
 (let (($x44786 (or $x44757 $x44803)))
 (let (($x44810 (and $x44623 $x44786)))
 (let (($x44814 (or $x44763 $x44810)))
 (let (($x44801 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let ((?x44566 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44663 (ext_eq false ?x44566 ?x44654 ?x44655)))
 (let (($x44747 (<= (+ (%I m$) (* (- 1) j!)) 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x44743 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x44766 (not (and $x44743 $x4245 $x44747))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 $x44766 $x44663))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41))
 ))
 (let (($x44816 (not $x44780)))
 (let (($x44817 (or $x44816 $x44807 $x44801)))
 (let (($x44822 (and $x44738 $x44817)))
 (let (($x44754 (or $x44752 $x44822)))
 (let (($x44823 (not (and $x44675 $x44754))))
 (let ((?x44764 (lambda ((k$ Poly) (m$ Poly) )(let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x44656 (= ?x44654 ?x44655)))
 (let (($x44747 (<= (+ (%I m$) (* (- 1) j!)) 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x44743 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x44766 (not (and $x44743 $x4245 $x44747))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (let (($x44775 (or $x6681 $x44766 $x44656)))
 (refl (~ $x44775 $x44775)))))))))))))))))))
 ))
 (let ((@x44771 (nnf-neg (nnf-pos (proof-bind ?x44764) (~ $x44780 $x44780)) (~ (not $x44816) $x44780))))
 (let ((@x44785 (nnf-neg @x44771 (refl (~ %%location_label%%3 %%location_label%%3)) (sk (~ (not $x44801) $x44798)) (~ (not $x44817) $x44803))))
 (let ((@x44813 (nnf-neg (refl (~ $x44623 $x44623)) (nnf-neg (refl (~ $x44757 $x44757)) @x44785 (~ (not $x44822) $x44786)) (~ (not $x44754) $x44810))))
 (let (($x44666 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let ((?x44566 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44663 (ext_eq false ?x44566 ?x44654 ?x44655)))
 (let (($x44653 (and (and (<= i! (%I k$)) (<= (%I k$) (%I m$))) (<= (%I m$) j!))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (=> (and $x6619 $x44653) $x44663))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41))
 ))
 (let (($x44661 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x44655 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x44654 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x44656 (= ?x44654 ?x44655)))
 (let (($x44653 (and (and (<= i! (%I k$)) (<= (%I k$) (%I m$))) (<= (%I m$) j!))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (=> (and $x6619 $x44653) $x44656)))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_42))
 ))
 (let (($x44645 (and (=> %%location_label%%1 tmp%1) (=> (and tmp%1 %%location_label%%2) $x44638))))
 (let (($x44647 (=> (and (and (and (<= i! ?x44628) (<= ?x44628 ?x44629)) (<= ?x44629 j!)) $x44639) $x44645)))
 (let (($x44669 (and (=> (and $x44625 $x44627 (and (and (<= i! ?x44628) (<= ?x44628 ?x44629)) (<= ?x44629 j!)) $x44639) $x44645) (=> (and $x44661 %%location_label%%3) $x44666))))
 (let (($x44672 (not (and (=> %%location_label%%0 $x44621) (=> $x44623 $x44669)))))
 (let ((@x44819 (mp~ (mp (asserted $x44672) (rewrite (= $x44672 $x44823)) $x44823) (nnf-neg (refl (~ $x44763 $x44763)) @x44813 (~ $x44823 $x44814)) $x44814)))
 (let ((@x44898 (mp (mp @x44819 (rewrite (= $x44814 $x44698)) $x44698) (rewrite (= $x44698 $x44896)) $x44896)))
 (let ((@x45030 (mp (mp @x44898 (rewrite (= $x44896 $x44938)) $x44938) (rewrite (= $x44938 $x44896)) $x44896)))
 (let ((@x47578 (unit-resolution @x45030 (unit-resolution @x45025 @x46744 $x44675) $x44888)))
 (let ((@x44829 (def-axiom (or $x44887 $x44623))))
 (let ((@x47584 (mp (unit-resolution @x44829 @x47578 $x44623) (symm (monotonicity @x46658 @x46678 (= $x46748 $x44623)) (= $x44623 $x46748)) $x46748)))
 (let ((@x46787 (def-axiom (or $x46765 $x46763 $x46762))))
 (let ((@x47587 (unit-resolution @x46787 @x47584 (unit-resolution @x46807 (unit-resolution @x46779 @x16555 $x46767) $x46764) $x46762)))
 (let (($x46783 (not $x46762)))
 (let (($x47460 (or $x46783 $x47374 $x47449 $x47446 $x47434)))
 (let ((?x47430 (+ ?x47421 ?x46538)))
 (let (($x47431 (>= ?x47430 0)))
 (let (($x47429 (not (>= (+ ?x47421 ?x46506) 0))))
 (let (($x47435 (or $x47374 $x47429 $x47431 $x47434)))
 (let (($x47461 (or $x46783 $x47435)))
 (let (($x47455 (= $x47435 $x47454)))
 (let ((@x47441 (monotonicity (rewrite (= ?x47430 (+ ?x46538 ?x47421))) (= $x47431 (>= (+ ?x46538 ?x47421) 0)))))
 (let ((@x47453 (trans @x47441 (rewrite (= (>= (+ ?x46538 ?x47421) 0) $x47446)) (= $x47431 $x47446))))
 (let ((@x47459 (trans (monotonicity (rewrite (= $x47429 $x47449)) @x47453 $x47455) (rewrite (= $x47454 $x47454)) $x47455)))
 (let ((@x47469 (trans (monotonicity @x47459 (= $x47461 (or $x46783 $x47454))) (rewrite (= (or $x46783 $x47454) $x47460)) (= $x47461 $x47460))))
 (let ((@x47589 (unit-resolution (unit-resolution (mp ((_ quant-inst (I ?x47302)) $x47461) @x47469 $x47460) @x47587 $x47454) (unit-resolution @x47497 @x47542 @x47107 $x47444) (mp @x47380 (symm (monotonicity @x47482 $x47370) $x47372) $x47361) @x47572 $x47446)))
 (let (($x47474 (>= ?x47472 0)))
 (let (($x46918 (>= ?x46841 0)))
 (let ((@x47596 ((_ th-lemma arith farkas -1 1 1 -1 -1 1 -1 1 1) @x47513 @x47528 @x47529 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46844) $x46918)) @x47492 $x46918) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47471) $x47474)) @x47487 $x47474) @x47589 @x47125 @x46700 @x47502 false)))
 (let ((@x47598 (lemma @x47596 (or $x46903 $x44701 $x44697 $x47012 $x44728 $x44737))))
 (let ((@x47290 (unit-resolution @x47598 @x47381 @x47359 (unit-resolution @x47327 @x47322 @x47315 $x47007) @x47276 @x47281 $x46903)))
 (let ((@x47152 (symm (monotonicity @x47149 (= ?x46986 ?x44629)) $x47099)))
 (let ((@x47163 (symm (monotonicity @x47160 (= ?x46983 ?x44628)) $x47095)))
 (let ((@x47165 (unit-resolution @x47122 (unit-resolution @x47156 @x47163 $x47098) (unit-resolution @x47145 @x47152 $x47101) @x47114 $x47007)))
 (let ((@x47169 (unit-resolution @x47113 (unit-resolution @x47167 @x47163 $x47097) @x47107 $x46984)))
 (let (($x47212 (not $x47061)))
 (let ((?x46995 (vstd!seq.Seq.len.? T&. T& ?x46994)))
 (let (($x46997 (= ?x46995 ?x46996)))
 (let (($x47037 (or $x47036 $x44970 $x46974 $x46982 $x46885 $x46985 $x47012 $x47027 $x46997)))
 (let ((@x47044 (rewrite (= (or $x47036 (or $x44970 $x46974 $x46982 $x46885 $x46985 $x47012 $x47027 $x46997)) $x47037))))
 (let (($x47029 (or $x44970 $x46974 $x46982 $x46885 $x46985 $x47012 $x47027 $x46997)))
 (let (($x47040 (or $x47036 $x47029)))
 (let (($x46998 (or $x44970 $x46974 $x46982 $x46885 $x46985 $x46990 $x46993 $x46997)))
 (let (($x47038 (or $x47036 $x46998)))
 (let (($x47031 (= $x46998 $x47029)))
 (let ((@x47035 (trans (monotonicity (rewrite (= $x46990 $x47012)) (rewrite (= $x46993 $x47027)) $x47031) (rewrite (= $x47029 $x47029)) $x47031)))
 (let ((@x47047 (mp ((_ quant-inst T&. T& s2! (I ?x44628) (I ?x44629)) $x47038) (trans (monotonicity @x47035 (= $x47038 $x47040)) @x47044 (= $x47038 $x47037)) $x47037)))
 (let ((@x47196 (unit-resolution @x47047 @x47194 @x44563 @x44571 (or $x46974 $x46982 $x46985 $x47012 $x47027 $x46997))))
 (let ((@x47197 (unit-resolution @x47196 (unit-resolution @x47129 (unit-resolution @x47184 @x47152 $x47102) @x47125 $x47022) @x47179 @x47174 @x47169 @x47165 $x46997)))
 (let ((@x47203 (trans* (symm @x47197 (= ?x46996 ?x46995)) (monotonicity @x47182 (= ?x46995 ?x46863)) (= ?x46996 ?x46863))))
 (let ((@x47214 (monotonicity (symm (monotonicity @x47207 @x47203 (= $x47061 $x46864)) (= $x46864 $x47061)) (= $x46865 $x47212))))
 (let ((@x47217 (unit-resolution @x47094 @x47194 @x44563 @x44568 (or $x46974 $x46982 $x46985 $x47012 $x47075 $x47061))))
 (let ((@x47218 (unit-resolution @x47217 (mp (hypothesis $x46865) @x47214 $x47212) @x47179 @x47174 @x47169 @x47165 $x47075)))
 (let ((@x47185 (unit-resolution @x47184 @x47152 $x47102)))
 (let ((@x47221 (lemma ((_ th-lemma arith farkas 1 -1 -1 1) @x44604 @x47125 @x47185 @x47218 false) (or $x46864 $x44701 $x44717 $x44697 $x44728 $x44737))))
 (let ((@x47357 (unit-resolution (def-axiom (or $x46912 $x44638 $x46865 $x46960)) (unit-resolution @x47221 @x47281 @x47315 @x47359 @x47276 @x47381 $x46864) (or $x46912 $x44638 $x46960))))
 (let ((@x47352 (unit-resolution @x47357 @x47290 (unit-resolution (def-axiom (or $x46963 $x46892)) @x47311 $x46892) $x44638)))
 (let ((@x45019 (def-axiom (or $x44711 $x45027))))
 (let ((@x45029 (def-axiom (or $x44707 tmp%1 $x45027))))
 (let ((@x47383 (unit-resolution @x45029 @x47352 (unit-resolution (def-axiom (or $x44826 $x44639)) @x47245 $x44639) tmp%1)))
 (let ((@x45011 (def-axiom (or $x44700 $x44710))))
 (let ((@x44960 (def-axiom (or $x44735 $x44731 $x44733))))
 (let ((@x47358 (unit-resolution @x44960 (unit-resolution @x45011 @x47383 $x44700) (unit-resolution @x45019 @x47352 $x44711) (unit-resolution @x44998 @x47245 $x44734) false)))
 (let ((@x47385 (lemma @x47358 $x44826)))
 (let ((@x44827 (def-axiom (or $x44909 $x44831 $x44892))))
 (let ((@x47785 (unit-resolution @x44827 (unit-resolution (def-axiom (or $x44887 $x44897)) @x47578 $x44897) $x44897)))
 (let ((@x47786 (unit-resolution @x47785 @x47385 $x44892)))
 (let ((@x44821 (def-axiom (or $x44891 $x44723))))
 (let (($x47680 (or $x44890 $x44871 $x44872 $x44884 $x44885 $x44886 $x46939)))
 (let (($x47673 (or $x44871 $x44872 $x44884 $x44885 $x44886 $x46939)))
 (let (($x47683 (or $x44890 $x47673)))
 (let (($x47648 (not $x44790)))
 (let (($x47647 (not $x44784)))
 (let (($x47649 (or $x44871 $x44872 $x47647 $x44885 $x47648 $x46939)))
 (let (($x47681 (or $x44890 $x47649)))
 (let (($x47675 (= $x47649 $x47673)))
 (let ((@x47679 (trans (monotonicity (rewrite (= $x47647 $x44884)) (rewrite (= $x47648 $x44886)) $x47675) (rewrite (= $x47673 $x47673)) $x47675)))
 (let ((@x47689 (trans (monotonicity @x47679 (= $x47681 $x47683)) (rewrite (= $x47683 $x47680)) (= $x47681 $x47680))))
 (let ((@x47690 (mp ((_ quant-inst k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!18 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_41!17) $x47681) @x47689 $x47680)))
 (let ((@x47793 (unit-resolution @x47690 (unit-resolution (def-axiom (or $x44891 $x44866)) @x47786 $x44866) (unit-resolution (def-axiom (or $x44891 $x44777)) @x47786 $x44777) (unit-resolution (def-axiom (or $x44891 $x44778)) @x47786 $x44778) (unit-resolution (def-axiom (or $x44891 $x44705)) @x47786 $x44705) (unit-resolution (def-axiom (or $x44891 $x44788)) @x47786 $x44788) (unit-resolution @x44821 @x47786 $x44723) $x46939)))
 (let ((@x46949 (def-axiom (or (not $x46940) (not $x46939) $x44795))))
 (let ((@x47796 (unit-resolution @x46949 (unit-resolution (def-axiom (or $x44891 (not $x44795))) @x47786 (not $x44795)) (or (not $x46940) (not $x46939)))))
 (unit-resolution @x47796 @x47793 (unit-resolution @x46943 @x9238 $x46940) false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

