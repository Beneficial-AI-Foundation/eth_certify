(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10739)
(:version "4.12.5")
unsat
((declare-fun m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23 () Poly)
(declare-fun k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 () Poly)
(declare-fun s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27 () Poly)
(declare-fun s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28 () Poly)
(declare-fun j$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!25 () Poly)
(declare-fun i$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!26 () Poly)
(declare-fun m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 (Int Int Poly Poly Type Dcr) Poly)
(declare-fun k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 (Int Int Poly Poly Type Dcr) Poly)
(proof
(let ((?x45067 (vstd!seq.Seq.subrange.? T&. T& s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27 k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23)))
 (let ((?x45066 (vstd!seq.Seq.subrange.? T&. T& s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28 k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x45068 (ext_eq false ?x44765 ?x45066 ?x45067)))
 (let (($x46736 (= ?x45066 ?x45067)))
 (let (($x46739 (= $x46736 $x45068)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x9283 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x9287 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x9283) (~ $x418 $x418)) $x418)))
 (let (($x46884 (not $x418)))
 (let (($x46745 (or $x46884 $x46739)))
 (let ((@x46746 ((_ quant-inst false (TYPE%vstd!seq.Seq. T&. T&) (vstd!seq.Seq.subrange.? T&. T& s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28 k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23) (vstd!seq.Seq.subrange.? T&. T& s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27 k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23)) $x46745)))
 (let ((?x45054 (%I m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23)))
 (let ((?x44873 (* (- 1) ?x45054)))
 (let ((?x45035 (%I j$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!25)))
 (let ((?x44888 (+ ?x45035 ?x44873)))
 (let (($x44889 (>= ?x44888 0)))
 (let (($x44978 (not $x44889)))
 (let ((?x45051 (%I k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24)))
 (let ((?x44874 (+ ?x45051 ?x44873)))
 (let (($x44875 (<= ?x44874 0)))
 (let (($x44977 (not $x44875)))
 (let ((?x45056 (* (- 1) ?x45051)))
 (let ((?x45034 (%I i$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!26)))
 (let ((?x44858 (+ ?x45034 ?x45056)))
 (let (($x44859 (<= ?x44858 0)))
 (let (($x44975 (not $x44859)))
 (let ((?x45049 (vstd!seq.Seq.subrange.? T&. T& s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27 i$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!26 j$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!25)))
 (let ((?x45048 (vstd!seq.Seq.subrange.? T&. T& s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28 i$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!26 j$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!25)))
 (let (($x45050 (= ?x45048 ?x45049)))
 (let (($x44974 (not $x45050)))
 (let ((?x45043 (vstd!seq.Seq.len.? T&. T& s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27)))
 (let ((?x45044 (* (- 1) ?x45043)))
 (let ((?x45045 (+ ?x45035 ?x45044)))
 (let (($x45046 (<= ?x45045 0)))
 (let (($x44973 (not $x45046)))
 (let ((?x45039 (vstd!seq.Seq.len.? T&. T& s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28)))
 (let ((?x45040 (* (- 1) ?x45039)))
 (let ((?x45041 (+ ?x45035 ?x45040)))
 (let (($x45042 (<= ?x45041 0)))
 (let (($x44972 (not $x45042)))
 (let ((?x45059 (* (- 1) ?x45035)))
 (let ((?x45029 (+ ?x45034 ?x45059)))
 (let (($x45030 (<= ?x45029 0)))
 (let (($x44971 (not $x45030)))
 (let (($x45033 (>= ?x45034 0)))
 (let (($x44970 (not $x45033)))
 (let (($x45026 (has_type m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23 INT)))
 (let (($x44956 (not $x45026)))
 (let (($x45025 (has_type k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 INT)))
 (let (($x44955 (not $x45025)))
 (let (($x45024 (has_type j$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!25 INT)))
 (let (($x44954 (not $x45024)))
 (let (($x45023 (has_type i$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!26 INT)))
 (let (($x44953 (not $x45023)))
 (let (($x45022 (has_type s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27 ?x44765)))
 (let (($x44952 (not $x45022)))
 (let (($x45021 (has_type s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28 ?x44765)))
 (let (($x44951 (not $x45021)))
 (let (($x45028 (not %%location_label%%2)))
 (let (($x44945 (forall ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(! (let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let (($x44834 (= ?x44832 ?x44833)))
 (let ((?x264 (%I m$)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I j$)))))
 (let (($x9050 (<= ?x4483 0)))
 (let (($x16785 (not $x9050)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14442 (not $x4245)))
 (let ((?x4792 (%I i$)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x4854 (>= ?x4855 0)))
 (let (($x14739 (not $x4854)))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let (($x44917 (not $x44829)))
 (let (($x45008 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s2$))) 0)))
 (let (($x44916 (not $x45008)))
 (let (($x44995 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s1$))) 0)))
 (let (($x44914 (not $x44995)))
 (let (($x4827 (>= (+ (%I j$) ?x4828) 0)))
 (let (($x14737 (not $x4827)))
 (let (($x4825 (>= ?x4792 0)))
 (let (($x14736 (not $x4825)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14457 (not $x4257)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x14703 (not $x4684)))
 (let (($x4789 (has_type i$ INT)))
 (let (($x14723 (not $x4789)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x45096 (not $x44819)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44992 (not $x44818)))
 (or $x44992 $x45096 $x14723 $x14703 $x14457 $x271 $x14736 $x14737 $x44914 $x44916 $x44917 $x14739 $x14442 $x16785 $x44834))))))))))))))))))))))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_45))
 ))
 (let (($x44982 (not $x44945)))
 (let (($x44983 (or $x44982 $x45028 $x44951 $x44952 $x44953 $x44954 $x44955 $x44956 $x44970 $x44971 $x44972 $x44973 $x44974 $x44975 $x44977 $x44978 $x45068)))
 (let (($x44984 (not $x44983)))
 (let ((?x44806 (vstd!seq.Seq.subrange.? T&. T& s2@ k@ m@)))
 (let ((?x44805 (vstd!seq.Seq.subrange.? T&. T& s1@ k@ m@)))
 (let (($x44807 (ext_eq false ?x44765 ?x44805 ?x44806)))
 (let (($x44924 (not %%location_label%%1)))
 (let ((?x44778 (%I j@)))
 (let ((?x44777 (%I i@)))
 (let (($x44803 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1@ s2@ ?x44777 ?x44778)))
 (let (($x44931 (not $x44803)))
 (let (($x44932 (or $x44931 $x44924 $x44807)))
 (let (($x44879 (not $x44932)))
 (let (($x44801 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1@ s2@ ?x44777 ?x44778)))
 (let (($x44920 (not %%location_label%%0)))
 (let (($x44921 (or $x44920 $x44801)))
 (let (($x44877 (not $x44921)))
 (let (($x44880 (or $x44877 $x44879)))
 (let (($x45100 (not $x44880)))
 (let ((?x44793 (%I m@)))
 (let ((?x44896 (* (- 1) ?x44793)))
 (let ((?x44900 (+ ?x44778 ?x44896)))
 (let (($x44899 (>= ?x44900 0)))
 (let (($x45088 (not $x44899)))
 (let ((?x44792 (%I k@)))
 (let ((?x44897 (+ ?x44792 ?x44896)))
 (let (($x44898 (<= ?x44897 0)))
 (let (($x45085 (not $x44898)))
 (let ((?x44891 (* (- 1) ?x44792)))
 (let ((?x44892 (+ ?x44777 ?x44891)))
 (let (($x44893 (<= ?x44892 0)))
 (let (($x44878 (not $x44893)))
 (let ((?x44789 (vstd!seq.Seq.subrange.? T&. T& s2@ i@ j@)))
 (let ((?x44788 (vstd!seq.Seq.subrange.? T&. T& s1@ i@ j@)))
 (let (($x44790 (= ?x44788 ?x44789)))
 (let (($x44887 (not $x44790)))
 (let ((?x44785 (vstd!seq.Seq.len.? T&. T& s2@)))
 (let ((?x44870 (* (- 1) ?x44785)))
 (let ((?x44871 (+ ?x44778 ?x44870)))
 (let (($x44872 (<= ?x44871 0)))
 (let (($x44884 (not $x44872)))
 (let ((?x44782 (vstd!seq.Seq.len.? T&. T& s1@)))
 (let ((?x44856 (* (- 1) ?x44782)))
 (let ((?x44857 (+ ?x44778 ?x44856)))
 (let (($x44850 (<= ?x44857 0)))
 (let (($x44886 (not $x44850)))
 (let ((?x44853 (* (- 1) ?x44778)))
 (let ((?x44854 (+ ?x44777 ?x44853)))
 (let (($x44855 (<= ?x44854 0)))
 (let (($x44907 (not $x44855)))
 (let (($x44851 (>= ?x44777 0)))
 (let (($x44865 (not $x44851)))
 (let (($x44776 (has_type m@ INT)))
 (let (($x44939 (not $x44776)))
 (let (($x44774 (has_type k@ INT)))
 (let (($x44949 (not $x44774)))
 (let (($x44772 (has_type j@ INT)))
 (let (($x44958 (not $x44772)))
 (let (($x44770 (has_type i@ INT)))
 (let (($x44967 (not $x44770)))
 (let (($x44768 (has_type s2@ ?x44765)))
 (let (($x44976 (not $x44768)))
 (let (($x44766 (has_type s1@ ?x44765)))
 (let (($x44985 (not $x44766)))
 (let (($x44852 (or $x44985 $x44976 $x44967 $x44958 $x44949 $x44939 $x44865 $x44907 $x44886 $x44884 $x44887 $x44878 $x45085 $x45088 $x45100)))
 (let (($x45095 (not $x44852)))
 (let ((@x47198 (hypothesis $x45095)))
 (let ((@x45083 (def-axiom (or $x44852 $x44899))))
 (let (($x47171 (not (>= (+ ?x44778 (* (- 1) (%I (I ?x44793)))) 0))))
 (let ((?x46670 (I ?x44793)))
 (let ((?x46688 (I ?x44792)))
 (let ((?x47008 (vstd!seq.Seq.subrange.? T&. T& s2@ ?x46688 ?x46670)))
 (let ((?x47011 (vstd!seq.Seq.subrange.? T&. T& s1@ ?x46688 ?x46670)))
 (let (($x47136 (= ?x47011 ?x47008)))
 (let (($x47242 (not $x47136)))
 (let (($x46643 (= m@ ?x46670)))
 (let ((@x45224 (def-axiom (or $x44852 $x44776))))
 (let ((@x47226 (unit-resolution @x45224 @x47198 $x44776)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x9220 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x9224 (mp~ @x280 (nnf-pos (proof-bind ?x9220) (~ $x275 $x275)) $x275)))
 (let (($x46832 (not $x275)))
 (let (($x46833 (or $x46832 $x44939 $x46643)))
 (let ((@x46839 (mp ((_ quant-inst m@) (or $x46832 (or $x44939 $x46643))) (rewrite (= (or $x46832 (or $x44939 $x46643)) $x46833)) $x46833)))
 (let ((@x47229 (symm (unit-resolution @x46839 @x9224 @x47226 $x46643) (= ?x46670 m@))))
 (let (($x46689 (= k@ ?x46688)))
 (let ((@x45222 (def-axiom (or $x44852 $x44774))))
 (let ((@x47230 (unit-resolution @x45222 @x47198 $x44774)))
 (let (($x46840 (or $x46832 $x44949 $x46689)))
 (let ((@x46845 (mp ((_ quant-inst k@) (or $x46832 (or $x44949 $x46689))) (rewrite (= (or $x46832 (or $x44949 $x46689)) $x46840)) $x46840)))
 (let ((@x47233 (symm (unit-resolution @x46845 @x9224 @x47230 $x46689) (= ?x46688 k@))))
 (let ((@x47239 (monotonicity (monotonicity @x47233 @x47229 (= ?x47011 ?x44805)) (monotonicity @x47233 @x47229 (= ?x47008 ?x44806)) (= $x47136 (= ?x44805 ?x44806)))))
 (let ((@x47244 (monotonicity (symm @x47239 (= (= ?x44805 ?x44806) $x47136)) (= (not (= ?x44805 ?x44806)) $x47242))))
 (let (($x46732 (= ?x44805 ?x44806)))
 (let (($x46890 (not $x46732)))
 (let (($x46735 (= $x46732 $x44807)))
 (let (($x45195 (not $x44807)))
 (let ((?x46698 (I ?x44778)))
 (let ((?x46707 (I ?x44777)))
 (let ((?x46759 (vstd!seq.Seq.subrange.? T&. T& s2@ ?x46707 ?x46698)))
 (let ((?x46758 (vstd!seq.Seq.subrange.? T&. T& s1@ ?x46707 ?x46698)))
 (let (($x46760 (= ?x46758 ?x46759)))
 (let (($x8963 (not %%global_location_label%%56)))
 (let (($x46761 (or $x8963 $x46760)))
 (let (($x46762 (not $x46761)))
 (let (($x8957 (not %%global_location_label%%55)))
 (let (($x46756 (or $x8957 $x44872)))
 (let (($x46757 (not $x46756)))
 (let (($x46777 (or $x44865 $x44907 $x44886)))
 (let (($x46780 (not $x46777)))
 (let (($x8946 (not %%global_location_label%%54)))
 (let (($x46779 (or $x8946 $x46780)))
 (let (($x46783 (not $x46779)))
 (let (($x46787 (or $x46783 $x46757 $x46762)))
 (let (($x46720 (not $x46787)))
 (let ((@x46683 (def-axiom (or $x46780 $x44865 $x44907 $x44886))))
 (let ((@x47205 (unit-resolution @x46683 (unit-resolution (def-axiom (or $x44852 $x44855)) @x47198 $x44855) (unit-resolution (def-axiom (or $x44852 $x44850)) @x47198 $x44850) (unit-resolution (def-axiom (or $x44852 $x44851)) @x47198 $x44851) $x46780)))
 (let ((@x46675 (def-axiom (or $x46779 $x46777))))
 (let ((@x46695 (def-axiom (or $x46756 $x44884))))
 (let ((@x47208 (unit-resolution @x46695 (unit-resolution (def-axiom (or $x44852 $x44872)) @x47198 $x44872) $x46756)))
 (let (($x46699 (= j@ ?x46698)))
 (let (($x46846 (or $x46832 $x44958 $x46699)))
 (let ((@x46849 (mp ((_ quant-inst j@) (or $x46832 (or $x44958 $x46699))) (rewrite (= (or $x46832 (or $x44958 $x46699)) $x46846)) $x46846)))
 (let ((@x47211 (unit-resolution @x46849 @x9224 (unit-resolution (def-axiom (or $x44852 $x44772)) @x47198 $x44772) $x46699)))
 (let (($x46708 (= i@ ?x46707)))
 (let (($x46850 (or $x46832 $x44967 $x46708)))
 (let ((@x46855 (mp ((_ quant-inst i@) (or $x46832 (or $x44967 $x46708))) (rewrite (= (or $x46832 (or $x44967 $x46708)) $x46850)) $x46850)))
 (let ((@x47213 (unit-resolution @x46855 @x9224 (unit-resolution (def-axiom (or $x44852 $x44770)) @x47198 $x44770) $x46708)))
 (let ((@x46859 (symm (hypothesis $x46699) (= ?x46698 j@))))
 (let ((@x46862 (symm (hypothesis $x46708) (= ?x46707 i@))))
 (let ((@x46870 (trans* (monotonicity @x46862 @x46859 (= ?x46758 ?x44788)) (hypothesis $x44790) (symm (monotonicity @x46862 @x46859 (= ?x46759 ?x44789)) (= ?x44789 ?x46759)) $x46760)))
 (let ((@x46876 (lemma (unit-resolution (hypothesis (not $x46760)) @x46870 false) (or $x46760 $x44887 (not $x46699) (not $x46708)))))
 (let ((@x47214 (unit-resolution @x46876 @x47213 @x47211 (unit-resolution (def-axiom (or $x44852 $x44790)) @x47198 $x44790) $x46760)))
 (let ((@x46704 (def-axiom (or $x46761 (not $x46760)))))
 (let ((@x46721 (def-axiom (or $x46720 $x46783 $x46757 $x46762))))
 (let ((@x47216 (unit-resolution @x46721 (unit-resolution @x46704 @x47214 $x46761) @x47208 (unit-resolution @x46675 @x47205 $x46779) $x46720)))
 (let (($x46813 (= $x46787 $x44801)))
 (let (($x46815 (not $x46813)))
 (let (($x16762 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8879 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8963 (not %%global_location_label%%56)))
 (let (($x8964 (or $x8963 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8957 (not %%global_location_label%%55)))
 (let (($x8958 (or $x8957 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x15451 (not $x6227)))
 (let (($x1122 (>= i! 0)))
 (let (($x13458 (not $x1122)))
 (let (($x16665 (not (or $x13458 $x15451 (not $x8865)))))
 (let (($x8946 (not %%global_location_label%%54)))
 (let (($x16703 (or $x8946 $x16665)))
 (let (($x16712 (or (not $x16703) (not $x8958) (not $x8964))))
 (not (= $x16712 $x8879)))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_req__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let (($x8968 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8963 (not %%global_location_label%%56)))
 (let (($x8964 (or $x8963 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8957 (not %%global_location_label%%55)))
 (let (($x8958 (or $x8957 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8946 (not %%global_location_label%%54)))
 (let (($x8947 (or $x8946 $x8874)))
 (let (($x8967 (and $x8947 $x8958 $x8964)))
 (let (($x8879 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (= $x8879 $x8967))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_req__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let ((?x16763 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8879 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8963 (not %%global_location_label%%56)))
 (let (($x8964 (or $x8963 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8957 (not %%global_location_label%%55)))
 (let (($x8958 (or $x8957 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x15451 (not $x6227)))
 (let (($x1122 (>= i! 0)))
 (let (($x13458 (not $x1122)))
 (let (($x16665 (not (or $x13458 $x15451 (not $x8865)))))
 (let (($x8946 (not %%global_location_label%%54)))
 (let (($x16703 (or $x8946 $x16665)))
 (let (($x16712 (or (not $x16703) (not $x8958) (not $x8964))))
 (let (($x16754 (not (= $x16712 $x8879))))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8947 (or $x8946 $x8874)))
 (let (($x8967 (and $x8947 $x8958 $x8964)))
 (let (($x8965 (= $x8879 $x8967)))
 (let (($x16757 (= $x8965 $x16754)))
 (let ((@x16718 (trans (monotonicity (rewrite (= $x8947 $x16703)) (= $x8967 (and $x16703 $x8958 $x8964))) (rewrite (= (and $x16703 $x8958 $x8964) (not $x16712))) (= $x8967 (not $x16712)))))
 (let ((@x16758 (trans (monotonicity @x16718 (= $x8965 (= $x8879 (not $x16712)))) (rewrite (= (= $x8879 (not $x16712)) $x16754)) $x16757)))
 (trans @x16758 (rewrite (= $x16754 $x16754)) $x16757))))))))))))))))))))))))))
 ))
 (let ((?x13112 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8963 (not %%global_location_label%%56)))
 (let (($x8964 (or $x8963 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8957 (not %%global_location_label%%55)))
 (let (($x8958 (or $x8957 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8946 (not %%global_location_label%%54)))
 (let (($x8947 (or $x8946 $x8874)))
 (let (($x8967 (and $x8947 $x8958 $x8964)))
 (let (($x8879 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8965 (= $x8879 $x8967)))
 (refl (~ $x8965 $x8965))))))))))))))))))
 ))
 (let (($x8927 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let ((?x8849 (vstd!seq.Seq.len.? T&. T& s2!)))
 (let (($x8850 (<= j! ?x8849)))
 (let (($x1116 (<= 0 i!)))
 (let (($x6215 (and $x1116 (<= i! j!))))
 (let (($x8846 (and $x6215 (<= j! (vstd!seq.Seq.len.? T&. T& s1!)))))
 (let (($x8924 (and (=> %%global_location_label%%54 $x8846) (=> %%global_location_label%%55 $x8850) (=> %%global_location_label%%56 $x8855))))
 (let (($x8879 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (= $x8879 $x8924))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_req__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let ((?x8970 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8855 (= (vstd!seq.Seq.subrange.? T&. T& s1! (I i!) (I j!)) (vstd!seq.Seq.subrange.? T&. T& s2! (I i!) (I j!)))))
 (let (($x8963 (not %%global_location_label%%56)))
 (let (($x8964 (or $x8963 $x8855)))
 (let (($x8890 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s2!))) 0)))
 (let (($x8957 (not %%global_location_label%%55)))
 (let (($x8958 (or $x8957 $x8890)))
 (let (($x8865 (<= (+ j! (* (- 1) (vstd!seq.Seq.len.? T&. T& s1!))) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x8874 (and $x1122 $x6227 $x8865)))
 (let (($x8946 (not %%global_location_label%%54)))
 (let (($x8947 (or $x8946 $x8874)))
 (let (($x8967 (and $x8947 $x8958 $x8964)))
 (let (($x8879 (req%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8965 (= $x8879 $x8967)))
 (let ((?x8849 (vstd!seq.Seq.len.? T&. T& s2!)))
 (let (($x8850 (<= j! ?x8849)))
 (let (($x1116 (<= 0 i!)))
 (let (($x6215 (and $x1116 (<= i! j!))))
 (let (($x8846 (and $x6215 (<= j! (vstd!seq.Seq.len.? T&. T& s1!)))))
 (let (($x8924 (and (=> %%global_location_label%%54 $x8846) (=> %%global_location_label%%55 $x8850) (=> %%global_location_label%%56 $x8855))))
 (let (($x8925 (= $x8879 $x8924)))
 (rewrite (= $x8925 $x8965)))))))))))))))))))))))))
 ))
 (let ((@x8930 (mp (asserted $x8927) (quant-intro (proof-bind ?x8970) (= $x8927 $x8968)) $x8968)))
 (let ((@x16701 (mp (mp~ @x8930 (nnf-pos (proof-bind ?x13112) (~ $x8968 $x8968)) $x8968) (quant-intro (proof-bind ?x16763) (= $x8968 $x16762)) $x16762)))
 (let (($x46822 (not $x16762)))
 (let (($x46823 (or $x46822 $x46815)))
 (let (($x46753 (not (or $x44865 (not (>= (+ ?x44778 (* (- 1) ?x44777)) 0)) $x44886))))
 (let (($x46754 (or $x8946 $x46753)))
 (let (($x46755 (not $x46754)))
 (let (($x46763 (or $x46755 $x46757 $x46762)))
 (let (($x46764 (= $x46763 $x44801)))
 (let (($x46765 (not $x46764)))
 (let (($x46824 (or $x46822 $x46765)))
 (let (($x46826 (= $x46824 $x46823)))
 (let (($x46817 (= $x46765 $x46815)))
 (let ((@x46821 (trans (monotonicity (rewrite (= $x46764 $x46813)) $x46817) (rewrite (= $x46815 $x46815)) $x46817)))
 (let ((@x46831 (mp ((_ quant-inst T&. T& s1@ s2@ (%I i@) (%I j@)) $x46824) (trans (monotonicity @x46821 $x46826) (rewrite (= $x46823 $x46823)) $x46826) $x46823)))
 (let ((@x46879 (lemma (unit-resolution @x46831 @x16701 (hypothesis $x46813) false) $x46815)))
 (let ((@x46727 (def-axiom (or $x46813 $x46787 $x44801))))
 (let ((@x45185 (def-axiom (or $x44921 (not $x44801)))))
 (let ((@x47220 (unit-resolution @x45185 (unit-resolution (unit-resolution @x46727 @x46879 (or $x46787 $x44801)) @x47216 $x44801) $x44921)))
 (let ((@x45210 (def-axiom (or $x45100 $x44877 $x44879))))
 (let ((@x47221 (unit-resolution @x45210 @x47220 (unit-resolution (def-axiom (or $x44852 $x44880)) @x47198 $x44880) $x44879)))
 (let ((@x45197 (def-axiom (or $x44932 $x45195))))
 (let ((@x47224 (unit-resolution (def-axiom (or (not $x46735) $x46890 $x44807)) (unit-resolution @x45197 @x47221 $x45195) (or (not $x46735) $x46890))))
 (let ((@x47225 (unit-resolution @x47224 (unit-resolution ((_ quant-inst false (TYPE%vstd!seq.Seq. T&. T&) (vstd!seq.Seq.subrange.? T&. T& s1@ k@ m@) (vstd!seq.Seq.subrange.? T&. T& s2@ k@ m@)) (or $x46884 $x46735)) @x9287 $x46735) $x46890)))
 (let ((?x47124 (%I ?x46688)))
 (let ((?x47129 (* (- 1) ?x47124)))
 (let ((?x47144 (+ ?x44777 ?x47129)))
 (let (($x47145 (<= ?x47144 0)))
 (let ((?x47175 (+ ?x44792 ?x47129)))
 (let (($x47176 (<= ?x47175 0)))
 (let (($x47173 (= ?x44792 ?x47124)))
 (let ((@x47252 (symm (monotonicity @x47233 (= ?x47124 ?x44792)) $x47173)))
 (let ((@x47185 ((_ th-lemma arith farkas 1 -1 1) (hypothesis $x47176) (hypothesis (not $x47145)) (hypothesis $x44893) false)))
 (let ((@x47188 (lemma @x47185 (or $x47145 (not $x47176) $x44878))))
 (let ((@x47254 (unit-resolution @x47188 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47173) $x47176)) @x47252 $x47176) (unit-resolution (def-axiom (or $x44852 $x44893)) @x47198 $x44893) $x47145)))
 (let ((?x47128 (%I ?x46670)))
 (let ((?x47146 (* (- 1) ?x47128)))
 (let ((?x47147 (+ ?x47124 ?x47146)))
 (let (($x47148 (<= ?x47147 0)))
 (let ((?x47179 (+ ?x44793 ?x47146)))
 (let (($x47180 (<= ?x47179 0)))
 (let (($x47178 (= ?x44793 ?x47128)))
 (let ((@x47261 (symm (monotonicity @x47229 (= ?x47128 ?x44793)) $x47178)))
 (let (($x47177 (>= ?x47175 0)))
 (let ((@x47193 ((_ th-lemma arith farkas -1 1 -1 1) (hypothesis $x47177) (hypothesis $x47180) (hypothesis (not $x47148)) (hypothesis $x44898) false)))
 (let ((@x47197 (lemma @x47193 (or $x47148 (not $x47177) (not $x47180) $x45085))))
 (let ((@x47266 (unit-resolution @x47197 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47173) $x47177)) @x47252 $x47177) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47178) $x47180)) @x47261 $x47180) (unit-resolution (def-axiom (or $x44852 $x44898)) @x47198 $x44898) $x47148)))
 (let (($x47064 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x47054 (vstd!seq.Seq.subrange.? T&. T& s2@ k$ m$)))
 (let ((?x47052 (vstd!seq.Seq.subrange.? T&. T& s1@ k$ m$)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14442 (not $x4245)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14457 (not $x4257)))
 (or $x14457 $x271 (not (>= (+ ?x1191 (* (- 1) (%I i@))) 0)) $x14442 (not (<= (+ ?x264 (* (- 1) (%I j@))) 0)) (= ?x47052 ?x47054)))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1@ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2@ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x47065 (or $x44931 $x47064)))
 (let ((?x47020 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 ?x44778 ?x44777 s2@ s1@ T& T&.)))
 (let ((?x47021 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 ?x44778 ?x44777 s2@ s1@ T& T&.)))
 (let (($x47030 (= (vstd!seq.Seq.subrange.? T&. T& s1@ ?x47021 ?x47020) (vstd!seq.Seq.subrange.? T&. T& s2@ ?x47021 ?x47020))))
 (let (($x47035 (not (>= (+ ?x44778 (* (- 1) (%I ?x47020))) 0))))
 (let (($x47043 (not (<= (+ ?x44777 (* (- 1) (%I ?x47021))) 0))))
 (let (($x47045 (not (has_type ?x47020 INT))))
 (let (($x47047 (not (has_type ?x47021 INT))))
 (let (($x47073 (or $x47047 $x47045 $x47043 (not (>= (+ (%I ?x47020) (* (- 1) (%I ?x47021))) 0)) $x47035 $x47030)))
 (let (($x47066 (not $x47065)))
 (let (($x47082 (or $x47066 (not (or $x44803 (not $x47073))))))
 (let (($x47083 (not $x47082)))
 (let (($x16840 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let ((?x13145 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 j! i! s2! s1! T& T&.)))
 (let ((?x13146 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 j! i! s2! s1! T& T&.)))
 (let (($x13164 (= (vstd!seq.Seq.subrange.? T&. T& s1! ?x13146 ?x13145) (vstd!seq.Seq.subrange.? T&. T& s2! ?x13146 ?x13145))))
 (let (($x16836 (or (not (has_type ?x13146 INT)) (not (has_type ?x13145 INT)) (not (<= (+ i! (* (- 1) (%I ?x13146))) 0)) (not (<= (+ (%I ?x13146) (* (- 1) (%I ?x13145))) 0)) (not (>= (+ j! (* (- 1) (%I ?x13145))) 0)) $x13164)))
 (let (($x16841 (not $x16836)))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x16822 (or $x8931 $x16841)))
 (let (($x16798 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14442 (not $x4245)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14457 (not $x4257)))
 (or $x14457 $x271 (not (>= (+ ?x1191 (* (- 1) i!)) 0)) $x14442 (not (<= (+ ?x264 (* (- 1) j!)) 0)) $x8938)))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13133 (not $x8931)))
 (let (($x16803 (or $x13133 $x16798)))
 (not (or (not $x16803) (not $x16822))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let (($x13216 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let ((?x13145 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 j! i! s2! s1! T& T&.)))
 (let ((?x13146 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 j! i! s2! s1! T& T&.)))
 (let (($x13164 (= (vstd!seq.Seq.subrange.? T&. T& s1! ?x13146 ?x13145) (vstd!seq.Seq.subrange.? T&. T& s2! ?x13146 ?x13145))))
 (let (($x13215 (>= (+ j! (* (- 1) (%I ?x13145))) 0)))
 (let (($x13203 (<= (+ (%I ?x13146) (* (- 1) (%I ?x13145))) 0)))
 (let (($x13190 (<= (+ i! (* (- 1) (%I ?x13146))) 0)))
 (let (($x13150 (not (and (has_type ?x13146 INT) (has_type ?x13145 INT)))))
 (let (($x13209 (not (or $x13150 (not (and $x13190 $x13203 $x13215)) $x13164))))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x13210 (or $x8931 $x13209)))
 (let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13133 (not $x8931)))
 (let (($x13171 (or $x13133 $x8999)))
 (and $x13171 $x13210)))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let ((?x16843 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let ((?x13145 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 j! i! s2! s1! T& T&.)))
 (let ((?x13146 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 j! i! s2! s1! T& T&.)))
 (let (($x13164 (= (vstd!seq.Seq.subrange.? T&. T& s1! ?x13146 ?x13145) (vstd!seq.Seq.subrange.? T&. T& s2! ?x13146 ?x13145))))
 (let (($x16836 (or (not (has_type ?x13146 INT)) (not (has_type ?x13145 INT)) (not (<= (+ i! (* (- 1) (%I ?x13146))) 0)) (not (<= (+ (%I ?x13146) (* (- 1) (%I ?x13145))) 0)) (not (>= (+ j! (* (- 1) (%I ?x13145))) 0)) $x13164)))
 (let (($x16841 (not $x16836)))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x16822 (or $x8931 $x16841)))
 (let (($x16798 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x264 (%I m$)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14442 (not $x4245)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14457 (not $x4257)))
 (or $x14457 $x271 (not (>= (+ ?x1191 (* (- 1) i!)) 0)) $x14442 (not (<= (+ ?x264 (* (- 1) j!)) 0)) $x8938)))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13133 (not $x8931)))
 (let (($x16803 (or $x13133 $x16798)))
 (let (($x16834 (not (or (not $x16803) (not $x16822)))))
 (let (($x13215 (>= (+ j! (* (- 1) (%I ?x13145))) 0)))
 (let (($x13203 (<= (+ (%I ?x13146) (* (- 1) (%I ?x13145))) 0)))
 (let (($x13190 (<= (+ i! (* (- 1) (%I ?x13146))) 0)))
 (let (($x13150 (not (and (has_type ?x13146 INT) (has_type ?x13145 INT)))))
 (let (($x13209 (not (or $x13150 (not (and $x13190 $x13203 $x13215)) $x13164))))
 (let (($x13210 (or $x8931 $x13209)))
 (let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13171 (or $x13133 $x8999)))
 (let (($x13196 (and $x13171 $x13210)))
 (let (($x16823 (= $x13210 $x16822)))
 (let ((@x16827 (trans (monotonicity (rewrite (= $x13209 $x16841)) $x16823) (rewrite (= $x16822 $x16822)) $x16823)))
 (trans (monotonicity (rewrite (= $x13171 $x16803)) @x16827 (= $x13196 (and $x16803 $x16822))) (rewrite (= (and $x16803 $x16822) $x16834)) (= $x13196 $x16834)))))))))))))))))))))))))
 ))
 (let (($x13175 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let ((?x13145 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 j! i! s2! s1! T& T&.)))
 (let ((?x13146 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 j! i! s2! s1! T& T&.)))
 (let (($x13164 (= (vstd!seq.Seq.subrange.? T&. T& s1! ?x13146 ?x13145) (vstd!seq.Seq.subrange.? T&. T& s2! ?x13146 ?x13145))))
 (let (($x13160 (and (>= (+ (%I ?x13146) (* (- 1) i!)) 0) (>= (+ (%I ?x13145) (* (- 1) (%I ?x13146))) 0) (<= (+ (%I ?x13145) (* (- 1) j!)) 0))))
 (let (($x13150 (not (and (has_type ?x13146 INT) (has_type ?x13145 INT)))))
 (let (($x13166 (not (or $x13150 (not $x13160) $x13164))))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13133 (not $x8931)))
 (let (($x13171 (or $x13133 $x8999)))
 (and $x13171 (or $x8931 $x13166)))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let ((?x13217 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let ((?x13145 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 j! i! s2! s1! T& T&.)))
 (let ((?x13146 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 j! i! s2! s1! T& T&.)))
 (let (($x13164 (= (vstd!seq.Seq.subrange.? T&. T& s1! ?x13146 ?x13145) (vstd!seq.Seq.subrange.? T&. T& s2! ?x13146 ?x13145))))
 (let (($x13215 (>= (+ j! (* (- 1) (%I ?x13145))) 0)))
 (let (($x13203 (<= (+ (%I ?x13146) (* (- 1) (%I ?x13145))) 0)))
 (let (($x13190 (<= (+ i! (* (- 1) (%I ?x13146))) 0)))
 (let (($x13150 (not (and (has_type ?x13146 INT) (has_type ?x13145 INT)))))
 (let (($x13209 (not (or $x13150 (not (and $x13190 $x13203 $x13215)) $x13164))))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x13210 (or $x8931 $x13209)))
 (let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13133 (not $x8931)))
 (let (($x13171 (or $x13133 $x8999)))
 (let (($x13196 (and $x13171 $x13210)))
 (let (($x13160 (and (>= (+ (%I ?x13146) (* (- 1) i!)) 0) (>= (+ (%I ?x13145) (* (- 1) (%I ?x13146))) 0) (<= (+ (%I ?x13145) (* (- 1) j!)) 0))))
 (let (($x13166 (not (or $x13150 (not $x13160) $x13164))))
 (let (($x13172 (and $x13171 (or $x8931 $x13166))))
 (rewrite (= $x13172 $x13196))))))))))))))))))))
 ))
 (let (($x8969 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (= $x8931 $x8999))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let ((?x13176 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let ((?x13145 (m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!15 j! i! s2! s1! T& T&.)))
 (let ((?x13146 (k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40!16 j! i! s2! s1! T& T&.)))
 (let (($x13164 (= (vstd!seq.Seq.subrange.? T&. T& s1! ?x13146 ?x13145) (vstd!seq.Seq.subrange.? T&. T& s2! ?x13146 ?x13145))))
 (let (($x13160 (and (>= (+ (%I ?x13146) (* (- 1) i!)) 0) (>= (+ (%I ?x13145) (* (- 1) (%I ?x13146))) 0) (<= (+ (%I ?x13145) (* (- 1) j!)) 0))))
 (let (($x13150 (not (and (has_type ?x13146 INT) (has_type ?x13145 INT)))))
 (let (($x13166 (not (or $x13150 (not $x13160) $x13164))))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x13133 (not $x8931)))
 (let (($x13171 (or $x13133 $x8999)))
 (let (($x13172 (and $x13171 (or $x8931 $x13166))))
 (let (($x8950 (= $x8931 $x8999)))
 (let ((?x13141 (lambda ((k$ Poly) (m$ Poly) )(let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (let (($x8994 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938)))
 (refl (~ $x8994 $x8994))))))))))))))))))))
 ))
 (nnf-pos (refl (~ $x8931 $x8931)) (refl (~ $x13133 $x13133)) (nnf-pos (proof-bind ?x13141) (~ $x8999 $x8999)) (sk (~ (not $x8999) $x13166)) (~ $x8950 $x13172))))))))))))))))
 ))
 (let (($x8961 (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(! (let (($x8952 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let (($x8932 (and (and (<= i! (%I k$)) (<= (%I k$) (%I m$))) (<= (%I m$) j!))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (=> (and $x6619 $x8932) $x8938)))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (= $x8931 $x8952))) :pattern ( (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality._definition))
 ))
 (let ((?x8971 (lambda ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (i! Int) (j! Int) )(let (($x8999 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let ((?x1399 (* (- 1) j!)))
 (let ((?x264 (%I m$)))
 (let ((?x8878 (+ ?x264 ?x1399)))
 (let (($x8948 (<= ?x8878 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x8943 (>= (+ ?x1191 (* (- 1) i!)) 0)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (let (($x6681 (not $x6619)))
 (or $x6681 (not (and $x8943 $x4245 $x8948)) $x8938))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x8931 (ens%pmemlog!logimpl_v.lemma_subrange_equality_implies_subsubrange_equality. T&. T& s1! s2! i! j!)))
 (let (($x8950 (= $x8931 $x8999)))
 (let (($x8952 (forall ((k$ Poly) (m$ Poly) )(! (let ((?x8937 (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$)))
 (let ((?x8935 (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$)))
 (let (($x8938 (= ?x8935 ?x8937)))
 (let (($x8932 (and (and (<= i! (%I k$)) (<= (%I k$) (%I m$))) (<= (%I m$) j!))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x6619 (and $x4257 $x263)))
 (=> (and $x6619 $x8932) $x8938)))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1! k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2! k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_40))
 ))
 (let (($x8953 (= $x8931 $x8952)))
 (rewrite (= $x8953 $x8950))))))))
 ))
 (let ((@x8974 (mp (asserted $x8961) (quant-intro (proof-bind ?x8971) (= $x8961 $x8969)) $x8969)))
 (let ((@x13223 (mp (mp~ @x8974 (nnf-pos (proof-bind ?x13176) (~ $x8969 $x13175)) $x13175) (quant-intro (proof-bind ?x13217) (= $x13175 $x13216)) $x13216)))
 (let ((@x16702 (mp @x13223 (quant-intro (proof-bind ?x16843) (= $x13216 $x16840)) $x16840)))
 (let (($x47084 (not $x16840)))
 (let (($x47074 (or $x47084 $x47083)))
 (let (($x47048 (or $x47047 $x47045 $x47043 (not (<= (+ (%I ?x47021) (* (- 1) (%I ?x47020))) 0)) $x47035 $x47030)))
 (let (($x47068 (not (or $x47066 (not (or $x44803 (not $x47048)))))))
 (let (($x47069 (or $x47084 $x47068)))
 (let (($x47072 (= $x47069 $x47074)))
 (let ((@x47077 (trans (monotonicity (rewrite (= $x47068 $x47083)) $x47072) (rewrite (= $x47074 $x47074)) $x47072)))
 (let ((@x47278 (unit-resolution (def-axiom (or $x47082 $x47065)) (unit-resolution (mp ((_ quant-inst T&. T& s1@ s2@ (%I i@) (%I j@)) $x47069) @x47077 $x47074) @x16702 $x47083) $x47065)))
 (let ((@x47281 (unit-resolution (def-axiom (or $x47066 $x44931 $x47064)) (unit-resolution (def-axiom (or $x44932 $x44803)) @x47221 $x44803) (or $x47066 $x47064))))
 (let (($x47006 (has_type ?x46670 INT)))
 (let ((@x47276 (mp @x47226 (symm (monotonicity @x47229 (= $x47006 $x44776)) (= $x44776 $x47006)) $x47006)))
 (let (($x47004 (has_type ?x46688 INT)))
 (let ((@x47271 (mp @x47230 (symm (monotonicity @x47233 (= $x47004 $x44774)) (= $x44774 $x47004)) $x47004)))
 (let (($x47156 (not $x47148)))
 (let (($x47150 (not $x47145)))
 (let (($x47007 (not $x47006)))
 (let (($x47005 (not $x47004)))
 (let (($x47092 (not $x47064)))
 (let (($x47172 (or $x47092 $x47005 $x47007 $x47150 $x47156 $x47171 $x47136)))
 (let ((?x47130 (+ ?x47128 ?x47129)))
 (let (($x47131 (>= ?x47130 0)))
 (let (($x47132 (not $x47131)))
 (let (($x47137 (or $x47005 $x47007 (not (>= (+ ?x47124 (* (- 1) ?x44777)) 0)) $x47132 (not (<= (+ ?x47128 ?x44853) 0)) $x47136)))
 (let (($x47174 (or $x47092 $x47137)))
 (let ((@x47163 (monotonicity (rewrite (= $x47137 (or $x47005 $x47007 $x47150 $x47156 $x47171 $x47136))) (= $x47174 (or $x47092 (or $x47005 $x47007 $x47150 $x47156 $x47171 $x47136))))))
 (let ((@x47169 (trans @x47163 (rewrite (= (or $x47092 (or $x47005 $x47007 $x47150 $x47156 $x47171 $x47136)) $x47172)) (= $x47174 $x47172))))
 (let ((@x47284 (unit-resolution (mp ((_ quant-inst (I ?x44792) (I ?x44793)) $x47174) @x47169 $x47172) @x47271 @x47276 (unit-resolution @x47281 @x47278 $x47064) (or $x47150 $x47156 $x47171 $x47136))))
 (let (($x47181 (>= ?x47179 0)))
 (let ((@x47289 ((_ th-lemma arith farkas 1 -1 1) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47178) $x47181)) @x47261 $x47181) (unit-resolution @x47284 @x47266 @x47254 (mp @x47225 @x47244 $x47242) $x47171) (unit-resolution @x45083 @x47198 $x44899) false)))
 (let ((@x47290 (lemma @x47289 $x44852)))
 (let (($x45110 (or $x45095 $x44984)))
 (let (($x45175 (or $x44977 $x44978)))
 (let (($x45174 (or $x44974 $x44975)))
 (let (($x45179 (or $x45174 $x45175)))
 (let (($x45173 (or $x44972 $x44973)))
 (let (($x45172 (or $x44970 $x44971)))
 (let (($x45178 (or $x45172 $x45173)))
 (let (($x45181 (or $x45178 $x45179)))
 (let (($x45171 (or $x44955 $x44956)))
 (let (($x45170 (or $x44953 $x44954)))
 (let (($x45177 (or $x45170 $x45171)))
 (let (($x45169 (or $x44951 $x44952)))
 (let (($x45157 (forall ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(! (let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let (($x44834 (= ?x44832 ?x44833)))
 (let ((?x264 (%I m$)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I j$)))))
 (let (($x9050 (<= ?x4483 0)))
 (let (($x16785 (not $x9050)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x14442 (not $x4245)))
 (let (($x45147 (or $x14442 $x16785)))
 (let (($x45151 (or $x45147 $x44834)))
 (let ((?x4792 (%I i$)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x4854 (>= ?x4855 0)))
 (let (($x14739 (not $x4854)))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let (($x44917 (not $x44829)))
 (let (($x45146 (or $x44917 $x14739)))
 (let (($x45008 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s2$))) 0)))
 (let (($x44916 (not $x45008)))
 (let (($x44995 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s1$))) 0)))
 (let (($x44914 (not $x44995)))
 (let (($x45145 (or $x44914 $x44916)))
 (let (($x45150 (or $x45145 $x45146)))
 (let (($x45153 (or $x45150 $x45151)))
 (let (($x4827 (>= (+ (%I j$) ?x4828) 0)))
 (let (($x14737 (not $x4827)))
 (let (($x4825 (>= ?x4792 0)))
 (let (($x14736 (not $x4825)))
 (let (($x45144 (or $x14736 $x14737)))
 (let (($x263 (has_type m$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x14457 (not $x4257)))
 (let (($x45143 (or $x14457 $x271)))
 (let (($x45149 (or $x45143 $x45144)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x14703 (not $x4684)))
 (let (($x4789 (has_type i$ INT)))
 (let (($x14723 (not $x4789)))
 (let (($x45142 (or $x14723 $x14703)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x45096 (not $x44819)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44992 (not $x44818)))
 (let (($x45140 (or $x44992 $x45096)))
 (let (($x45148 (or $x45140 $x45142)))
 (let (($x45152 (or $x45148 $x45149)))
 (or $x45152 $x45153)))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_45))
 ))
 (let (($x45162 (not $x45157)))
 (let (($x45168 (or $x45162 $x45028)))
 (let (($x45176 (or $x45168 $x45169)))
 (let (($x45180 (or $x45176 $x45177)))
 (let (($x45182 (or $x45180 $x45181)))
 (let (($x44981 (not (or $x44877 (not (or (or $x44931 $x44924) $x44807))))))
 (let (($x45126 (or $x45085 $x45088)))
 (let (($x45130 (or $x45126 $x44981)))
 (let (($x45125 (or $x44887 $x44878)))
 (let (($x45124 (or $x44886 $x44884)))
 (let (($x45129 (or $x45124 $x45125)))
 (let (($x45132 (or $x45129 $x45130)))
 (let (($x45122 (or $x44865 $x44907)))
 (let (($x45119 (or $x44949 $x44939)))
 (let (($x45128 (or $x45119 $x45122)))
 (let (($x45118 (or $x44967 $x44958)))
 (let (($x45117 (or $x44985 $x44976)))
 (let (($x45127 (or $x45117 $x45118)))
 (let (($x45131 (or $x45127 $x45128)))
 (let (($x45133 (or $x45131 $x45132)))
 (let (($x45138 (not $x45133)))
 (let (($x45163 (or $x45138 (not (or $x45182 $x45068)))))
 (let (($x45032 (not (and $x45021 $x45022 $x45023 $x45024 $x45025 $x45026))))
 (let (($x44882 (not (or $x45032 (not (and $x45033 $x45030 $x45042 $x45046 $x45050 $x44859 $x44875 $x44889)) $x45068))))
 (let (($x45070 (forall ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(! (let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let (($x44834 (= ?x44832 ?x44833)))
 (let ((?x264 (%I m$)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I j$)))))
 (let (($x9050 (<= ?x4483 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let ((?x4792 (%I i$)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x4854 (>= ?x4855 0)))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let (($x45008 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s2$))) 0)))
 (let (($x44995 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s1$))) 0)))
 (let (($x4827 (>= (+ (%I j$) ?x4828) 0)))
 (let (($x4825 (>= ?x4792 0)))
 (let (($x45055 (not (and $x4825 $x4827 $x44995 $x45008 $x44829 $x4854 $x4245 $x9050))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x4789 (has_type i$ INT)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44820 (and $x44818 $x44819 $x4789 $x4684 $x4257 $x263)))
 (let (($x45064 (not $x44820)))
 (or $x45064 $x45055 $x44834)))))))))))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_45))
 ))
 (let (($x44986 (or $x44985 $x44976 $x44967 $x44958 $x44949 $x44939 (not (and $x44851 $x44855 $x44850 $x44872 $x44790 $x44893 $x44898 $x44899)) (and $x44921 $x44932))))
 (let (($x45111 (not $x44986)))
 (let (($x44901 (or $x45111 (and $x45070 %%location_label%%2 $x44882))))
 (let ((?x45060 (+ ?x45054 ?x45059)))
 (let (($x45061 (<= ?x45060 0)))
 (let ((?x45057 (+ ?x45054 ?x45056)))
 (let (($x45058 (>= ?x45057 0)))
 (let ((?x45036 (* (- 1) ?x45034)))
 (let ((?x45052 (+ ?x45051 ?x45036)))
 (let (($x45053 (>= ?x45052 0)))
 (let ((?x45037 (+ ?x45035 ?x45036)))
 (let (($x45038 (>= ?x45037 0)))
 (let (($x45071 (not (or $x45032 (not (and $x45033 $x45038 $x45042 $x45046 $x45050 $x45053 $x45058 $x45061)) $x45068))))
 (let (($x45075 (and $x45070 %%location_label%%2 $x45071)))
 (let (($x45079 (or $x45111 $x45075)))
 (let (($x45091 (forall ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(! (let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44841 (ext_eq false ?x44765 ?x44832 ?x44833)))
 (let ((?x264 (%I m$)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I j$)))))
 (let (($x9050 (<= ?x4483 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let ((?x4792 (%I i$)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x4854 (>= ?x4855 0)))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let (($x45008 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s2$))) 0)))
 (let (($x44995 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s1$))) 0)))
 (let (($x4827 (>= (+ (%I j$) ?x4828) 0)))
 (let (($x4825 (>= ?x4792 0)))
 (let (($x45055 (not (and $x4825 $x4827 $x44995 $x45008 $x44829 $x4854 $x4245 $x9050))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x4789 (has_type i$ INT)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44820 (and $x44818 $x44819 $x4789 $x4684 $x4257 $x263)))
 (let (($x45064 (not $x44820)))
 (or $x45064 $x45055 $x44841)))))))))))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44))
 ))
 (let (($x45102 (not $x45070)))
 (let (($x45103 (or $x45102 $x45028 $x45091)))
 (let (($x44996 (not (and $x44986 $x45103))))
 (let ((?x45003 (lambda ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let (($x44834 (= ?x44832 ?x44833)))
 (let ((?x264 (%I m$)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I j$)))))
 (let (($x9050 (<= ?x4483 0)))
 (let ((?x1191 (%I k$)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let ((?x4792 (%I i$)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x4854 (>= ?x4855 0)))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let (($x45008 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s2$))) 0)))
 (let (($x44995 (<= (+ (%I j$) (* (- 1) (vstd!seq.Seq.len.? T&. T& s1$))) 0)))
 (let (($x4827 (>= (+ (%I j$) ?x4828) 0)))
 (let (($x4825 (>= ?x4792 0)))
 (let (($x45055 (not (and $x4825 $x4827 $x44995 $x45008 $x44829 $x4854 $x4245 $x9050))))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x4789 (has_type i$ INT)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44820 (and $x44818 $x44819 $x4789 $x4684 $x4257 $x263)))
 (let (($x45064 (not $x44820)))
 (let (($x45065 (or $x45064 $x45055 $x44834)))
 (refl (~ $x45065 $x45065)))))))))))))))))))))))))))))))))))
 ))
 (let ((@x45012 (nnf-neg (nnf-pos (proof-bind ?x45003) (~ $x45070 $x45070)) (~ (not $x45102) $x45070))))
 (let ((@x45078 (nnf-neg @x45012 (refl (~ %%location_label%%2 %%location_label%%2)) (sk (~ (not $x45091) $x45071)) (~ (not $x45103) $x45075))))
 (let (($x44844 (forall ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(! (let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44841 (ext_eq false ?x44765 ?x44832 ?x44833)))
 (let (($x8995 (and (and (<= (%I i$) (%I k$)) (<= (%I k$) (%I m$))) (<= (%I m$) (%I j$)))))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let ((?x4792 (%I i$)))
 (let (($x4793 (<= 0 ?x4792)))
 (let (($x4795 (and $x4793 (<= ?x4792 (%I j$)))))
 (let (($x44826 (and (and $x4795 (<= (%I j$) (vstd!seq.Seq.len.? T&. T& s1$))) (<= (%I j$) (vstd!seq.Seq.len.? T&. T& s2$)))))
 (let (($x44831 (and (and $x44826 $x44829) $x8995)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x4789 (has_type i$ INT)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44820 (and $x44818 $x44819 $x4789 $x4684 $x4257 $x263)))
 (=> (and $x44820 $x44831) $x44841))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44))
 ))
 (let (($x44839 (forall ((s1$ Poly) (s2$ Poly) (i$ Poly) (j$ Poly) (k$ Poly) (m$ Poly) )(! (let ((?x44833 (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$)))
 (let ((?x44832 (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$)))
 (let (($x44834 (= ?x44832 ?x44833)))
 (let (($x8995 (and (and (<= (%I i$) (%I k$)) (<= (%I k$) (%I m$))) (<= (%I m$) (%I j$)))))
 (let ((?x44828 (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$)))
 (let ((?x44827 (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$)))
 (let (($x44829 (= ?x44827 ?x44828)))
 (let ((?x4792 (%I i$)))
 (let (($x4793 (<= 0 ?x4792)))
 (let (($x4795 (and $x4793 (<= ?x4792 (%I j$)))))
 (let (($x44826 (and (and $x4795 (<= (%I j$) (vstd!seq.Seq.len.? T&. T& s1$))) (<= (%I j$) (vstd!seq.Seq.len.? T&. T& s2$)))))
 (let (($x44831 (and (and $x44826 $x44829) $x8995)))
 (let (($x263 (has_type m$ INT)))
 (let (($x4257 (has_type k$ INT)))
 (let (($x4684 (has_type j$ INT)))
 (let (($x4789 (has_type i$ INT)))
 (let ((?x44765 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44819 (has_type s2$ ?x44765)))
 (let (($x44818 (has_type s1$ ?x44765)))
 (let (($x44820 (and $x44818 $x44819 $x4789 $x4684 $x4257 $x263)))
 (=> (and $x44820 $x44831) $x44834))))))))))))))))))))) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s1$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s2$ k$ m$) ) :pattern ( (vstd!seq.Seq.subrange.? T&. T& s2$ i$ j$) (vstd!seq.Seq.subrange.? T&. T& s1$ k$ m$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_45))
 ))
 (let (($x44810 (and (=> %%location_label%%0 $x44801) (=> (and $x44803 %%location_label%%1) $x44807))))
 (let (($x44787 (and (and (and (<= 0 ?x44777) (<= ?x44777 ?x44778)) (<= ?x44778 ?x44782)) (<= ?x44778 ?x44785))))
 (let (($x44799 (and (and $x44787 $x44790) (and (and (<= ?x44777 ?x44792) (<= ?x44792 ?x44793)) (<= ?x44793 ?x44778)))))
 (let (($x44817 (=> (and $x44766 $x44768 $x44770 $x44772 $x44774 $x44776 $x44799) $x44810)))
 (let (($x44848 (not (and $x44817 (=> (and $x44839 %%location_label%%2) $x44844)))))
 (let ((@x45082 (mp~ (mp (asserted $x44848) (rewrite (= $x44848 $x44996)) $x44996) (nnf-neg (refl (~ $x45111 $x45111)) @x45078 (~ $x44996 $x45079)) $x45079)))
 (let ((@x45115 (mp (mp @x45082 (rewrite (= $x45079 $x44901)) $x44901) (rewrite (= $x44901 $x45110)) $x45110)))
 (let ((@x45352 (mp (mp @x45115 (rewrite (= $x45110 $x45163)) $x45163) (rewrite (= $x45163 $x45110)) $x45110)))
 (let ((@x47506 (unit-resolution @x45352 @x47290 $x44984)))
 (let ((@x45357 (def-axiom (or $x44983 $x44889))))
 (let (($x47403 (or $x44982 $x44951 $x44952 $x44953 $x44954 $x44955 $x44956 $x44970 $x44971 $x44972 $x44973 $x44974 $x44975 $x44977 $x44978 $x46736)))
 (let (($x47359 (not $x45061)))
 (let (($x47101 (not $x45058)))
 (let (($x47358 (not $x45053)))
 (let (($x47357 (not $x45038)))
 (let (($x47360 (or $x44951 $x44952 $x44953 $x44954 $x44955 $x44956 $x44970 $x47357 $x44972 $x44973 $x44974 $x47358 $x47101 $x47359 $x46736)))
 (let (($x47404 (or $x44982 $x47360)))
 (let (($x47396 (or $x44951 $x44952 $x44953 $x44954 $x44955 $x44956 $x44970 $x44971 $x44972 $x44973 $x44974 $x44975 $x44977 $x44978 $x46736)))
 (let (($x47406 (or $x44982 $x47396)))
 (let (($x47398 (= $x47360 $x47396)))
 (let ((@x47397 (rewrite (= $x47359 $x44978))))
 (let ((@x47298 (rewrite (= $x47101 $x44977))))
 (let ((@x47385 (rewrite (= $x47358 $x44975))))
 (let ((@x47373 (rewrite (= $x47357 $x44971))))
 (let ((@x47402 (trans (monotonicity @x47373 @x47385 @x47298 @x47397 $x47398) (rewrite (= $x47396 $x47396)) $x47398)))
 (let ((@x47412 (trans (monotonicity @x47402 (= $x47404 $x47406)) (rewrite (= $x47406 $x47403)) (= $x47404 $x47403))))
 (let ((@x47413 (mp ((_ quant-inst s1$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!28 s2$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!27 i$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!26 j$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!25 k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!24 m$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_subsubrange_equality_forall_44!23) $x47404) @x47412 $x47403)))
 (let ((@x47528 (unit-resolution @x47413 (unit-resolution (def-axiom (or $x44983 $x44945)) @x47506 $x44945) (unit-resolution (def-axiom (or $x44983 $x45021)) @x47506 $x45021) (unit-resolution (def-axiom (or $x44983 $x45022)) @x47506 $x45022) (unit-resolution (def-axiom (or $x44983 $x45023)) @x47506 $x45023) (unit-resolution (def-axiom (or $x44983 $x45024)) @x47506 $x45024) (unit-resolution (def-axiom (or $x44983 $x45025)) @x47506 $x45025) (unit-resolution (def-axiom (or $x44983 $x45026)) @x47506 $x45026) (unit-resolution (def-axiom (or $x44983 $x45033)) @x47506 $x45033) (unit-resolution (def-axiom (or $x44983 $x45030)) @x47506 $x45030) (unit-resolution (def-axiom (or $x44983 $x45042)) @x47506 $x45042) (unit-resolution (def-axiom (or $x44983 $x45046)) @x47506 $x45046) (unit-resolution (def-axiom (or $x44983 $x45050)) @x47506 $x45050) (unit-resolution (def-axiom (or $x44983 $x44859)) @x47506 $x44859) (unit-resolution (def-axiom (or $x44983 $x44875)) @x47506 $x44875) (unit-resolution @x45357 @x47506 $x44889) $x46736)))
 (let ((@x46738 (def-axiom (or (not $x46739) (not $x46736) $x45068))))
 (let ((@x47531 (unit-resolution @x46738 (unit-resolution (def-axiom (or $x44983 (not $x45068))) @x47506 (not $x45068)) (or (not $x46739) (not $x46736)))))
 (unit-resolution @x47531 @x47528 (unit-resolution @x46746 @x9287 $x46739) false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

