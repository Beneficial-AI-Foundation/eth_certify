(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10388)
(:version "4.12.5")
unsat
((declare-fun i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 (Poly Poly Type Dcr) Poly)
(declare-fun s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 () Poly)
(declare-fun x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 () Poly)
(proof
(let ((?x44026 (Poly%pmemlog!logimpl_v.PersistentHeader. header!)))
 (let ((?x44031 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x44026)))
 (let ((?x44032 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x44031)))
 (let ((?x44096 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44032)))
 (let ((?x44940 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44096)))
 (let ((?x44948 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44940)))
 (let (($x49431 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44948 ?x44948)))
 (let (($x50087 (not $x49431)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x44082 (Poly%alloc!vec.Vec<u8./allocator_global%.>. out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44083 (vstd!view.View.view.? $ ?x1878 ?x44082)))
 (let ((?x44093 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44083 ?x7834 ?x7835)))
 (let ((?x44094 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x44093)))
 (let ((?x44095 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44094)))
 (let (($x44097 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44095 ?x44096)))
 (let (($x44419 (not $x44097)))
 (let (($x44949 (= ?x44096 ?x44948)))
 (let (($x44492 (has_type ?x44096 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x44027 (has_type ?x44026 TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((@x44028 (asserted $x44027)))
 (let (($x2697 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (or $x2627 $x2689))))))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_invariant_definition))
 ))
 (let ((?x9927 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2694 (or $x2627 $x2689)))
 (refl (~ $x2694 $x2694))))))))))
 ))
 (let (($x2692 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (=> $x2619 $x2689)))))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_invariant_definition))
 ))
 (let ((?x2698 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2694 (or $x2627 $x2689)))
 (let (($x2690 (=> $x2619 $x2689)))
 (rewrite (= $x2690 $x2694)))))))))))
 ))
 (let ((@x2702 (mp (asserted $x2692) (quant-intro (proof-bind ?x2698) (= $x2692 $x2697)) $x2697)))
 (let ((@x9931 (mp~ @x2702 (nnf-pos (proof-bind ?x9927) (~ $x2697 $x2697)) $x2697)))
 (let (($x44491 (not $x44027)))
 (let (($x44496 (not $x2697)))
 (let (($x44497 (or $x44496 $x44491 $x44492)))
 (let ((@x44502 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeader. header!)) (or $x44496 (or $x44491 $x44492))) (rewrite (= (or $x44496 (or $x44491 $x44492)) $x44497)) $x44497)))
 (let (($x2743 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2734 (= x (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2732))))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (or $x2739 $x2734))))) :pattern ( (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_unbox_axiom_definition))
 ))
 (let ((?x9948 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2734 (= x (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2732))))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2740 (or $x2739 $x2734)))
 (refl (~ $x2740 $x2740))))))))
 ))
 (let (($x2737 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2734 (= x (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2732))))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (=> $x2731 $x2734)))) :pattern ( (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_unbox_axiom_definition))
 ))
 (let ((?x2744 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2734 (= x (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2732))))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2740 (or $x2739 $x2734)))
 (let (($x2735 (=> $x2731 $x2734)))
 (rewrite (= $x2735 $x2740)))))))))
 ))
 (let ((@x2748 (mp (asserted $x2737) (quant-intro (proof-bind ?x2744) (= $x2737 $x2743)) $x2743)))
 (let ((@x9952 (mp~ @x2748 (nnf-pos (proof-bind ?x9948) (~ $x2743 $x2743)) $x2743)))
 (let (($x44939 (not $x44492)))
 (let (($x44953 (not $x2743)))
 (let (($x44954 (or $x44953 $x44939 $x44949)))
 (let ((@x44959 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44032)) (or $x44953 (or $x44939 $x44949))) (rewrite (= (or $x44953 (or $x44939 $x44949)) $x44954)) $x44954)))
 (let ((@x50074 (symm (unit-resolution @x44959 @x9952 (unit-resolution @x44502 @x9931 @x44028 $x44492) $x44949) (= ?x44948 ?x44096))))
 (let ((?x44323 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x44032)))
 (let ((?x44322 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x44032)))
 (let ((?x44321 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44032)))
 (let ((?x44324 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44321 ?x44322 ?x44323)))
 (let (($x44325 (= ?x44032 ?x44324)))
 (let ((@x48469 ((_ th-lemma datatype) $x44325)))
 (let ((@x48471 (symm @x48469 (= ?x44324 ?x44032))))
 (let ((?x44042 (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@0)))
 (let ((?x44043 (vstd!view.View.view.? $ ?x1878 ?x44042)))
 (let ((?x44650 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x44043)))
 (let (($x44651 (= ?x44324 ?x44650)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x44653 (vstd!seq.Seq.len.? $ ?x1876 ?x44043)))
 (let (($x44654 (= ?x44653 ?x8522)))
 (let (($x44655 (not $x44654)))
 (let (($x44652 (not $x44651)))
 (let (($x44656 (or $x44652 $x44655)))
 (let (($x44686 (not $x44656)))
 (let (($x44657 (ens%pmemlog!logimpl_v.metadata_to_bytes. ?x44324 metadata_bytes@0)))
 (let (($x44658 (= $x44656 $x44657)))
 (let (($x44659 (not $x44658)))
 (let (($x16104 (forall ((metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) (out! alloc!vec.Vec<u8./allocator_global%.>.) )(! (let (($x8776 (ens%pmemlog!logimpl_v.metadata_to_bytes. metadata! out!)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x8779 (= ?x6205 ?x8522)))
 (let (($x16088 (or (not (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6200))) (not $x8779))))
 (not (= $x16088 $x8776))))))))))) :pattern ( (ens%pmemlog!logimpl_v.metadata_to_bytes. metadata! out!) ) :qid internal_ens__pmemlog!logimpl_v.metadata_to_bytes._definition))
 ))
 (let (($x8783 (forall ((metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) (out! alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x8779 (= ?x6205 ?x8522)))
 (let (($x8778 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6200))))
 (let (($x8780 (and $x8778 $x8779)))
 (let (($x8776 (ens%pmemlog!logimpl_v.metadata_to_bytes. metadata! out!)))
 (= $x8776 $x8780))))))))))) :pattern ( (ens%pmemlog!logimpl_v.metadata_to_bytes. metadata! out!) ) :qid internal_ens__pmemlog!logimpl_v.metadata_to_bytes._definition))
 ))
 (let ((?x16105 (lambda ((metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) (out! alloc!vec.Vec<u8./allocator_global%.>.) )(let (($x8776 (ens%pmemlog!logimpl_v.metadata_to_bytes. metadata! out!)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x8779 (= ?x6205 ?x8522)))
 (let (($x16088 (or (not (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6200))) (not $x8779))))
 (let (($x16096 (not (= $x16088 $x8776))))
 (let (($x8778 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6200))))
 (let (($x8780 (and $x8778 $x8779)))
 (let (($x8781 (= $x8776 $x8780)))
 (let (($x16099 (= $x8781 $x16096)))
 (let ((@x16094 (monotonicity (rewrite (= $x8780 (not $x16088))) (= $x8781 (= $x8776 (not $x16088))))))
 (trans (trans @x16094 (rewrite (= (= $x8776 (not $x16088)) $x16096)) $x16099) (rewrite (= $x16096 $x16096)) $x16099)))))))))))))))))
 ))
 (let ((?x12807 (lambda ((metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) (out! alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x8779 (= ?x6205 ?x8522)))
 (let (($x8778 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6200))))
 (let (($x8780 (and $x8778 $x8779)))
 (let (($x8776 (ens%pmemlog!logimpl_v.metadata_to_bytes. metadata! out!)))
 (let (($x8781 (= $x8776 $x8780)))
 (refl (~ $x8781 $x8781))))))))))))))
 ))
 (let ((@x16109 (mp (mp~ (asserted $x8783) (nnf-pos (proof-bind ?x12807) (~ $x8783 $x8783)) $x8783) (quant-intro (proof-bind ?x16105) (= $x8783 $x16104)) $x16104)))
 (let (($x44669 (or (not $x16104) $x44659)))
 (let ((@x44670 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44321 ?x44322 ?x44323) metadata_bytes@0) $x44669)))
 (let (($x44035 (ens%pmemlog!logimpl_v.metadata_to_bytes. tmp%1 metadata_bytes@0)))
 (let (($x44033 (= tmp%1 ?x44032)))
 (let ((?x44100 (vstd!seq.Seq.len.? $ ?x1876 ?x44083)))
 (let (($x44101 (= ?x44100 pmemlog!logimpl_v.header_size.?)))
 (let (($x44148 (not %%location_label%%5)))
 (let (($x44149 (or $x44148 $x44101)))
 (let (($x44144 (not %%location_label%%4)))
 (let (($x44145 (or $x44144 $x44097)))
 (let ((?x44037 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x44031)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x44088 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44083 ?x7829 ?x7831)))
 (let ((?x44089 (vstd!bytes.spec_u64_from_le_bytes.? ?x44088)))
 (let (($x44090 (= ?x44089 ?x44037)))
 (let (($x44140 (not %%location_label%%3)))
 (let (($x44141 (or $x44140 $x44090)))
 (let ((?x44084 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x44083)))
 (let (($x44085 (= header! ?x44084)))
 (let (($x44136 (not %%location_label%%2)))
 (let (($x44137 (or $x44136 $x44085)))
 (let (($x44080 (= out! crc_bytes@1)))
 (let (($x44170 (not $x44080)))
 (let (($x44179 (not tmp%4)))
 (let (($x44132 (not %%location_label%%1)))
 (let (($x44133 (or $x44132 tmp%4)))
 (let ((?x44060 (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1)))
 (let ((?x44066 (vstd!view.View.view.? $ ?x1878 ?x44060)))
 (let ((?x44074 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7834 ?x7835)))
 (let ((?x44073 (Poly%vstd!seq.Seq<u8.>. old_metadata_bytes@1)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x44075 (ext_eq false ?x1968 ?x44073 ?x44074)))
 (let (($x44076 (= tmp%4 $x44075)))
 (let (($x44143 (not $x44076)))
 (let (($x44157 (not tmp%3)))
 (let (($x44158 (or $x44157 $x44143 (and $x44133 (or $x44179 $x44170 (and $x44137 $x44141 $x44145 $x44149))))))
 (let (($x44128 (not %%location_label%%0)))
 (let (($x44129 (or $x44128 tmp%3)))
 (let (($x44164 (and $x44129 $x44158)))
 (let ((?x44067 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7829 ?x7831)))
 (let ((?x44065 (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1)))
 (let (($x44068 (ext_eq false ?x1968 ?x44065 ?x44067)))
 (let (($x44069 (= tmp%3 $x44068)))
 (let (($x44139 (not $x44069)))
 (let ((?x44062 (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@1)))
 (let ((?x44051 (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@0)))
 (let (($x44063 (ens%alloc!vec.impl&%1.append. $ ?x1876 $ ALLOCATOR_GLOBAL ?x44051 ?x44060 ?x44042 ?x44062)))
 (let (($x44169 (not $x44063)))
 (let ((?x44052 (vstd!view.View.view.? $ ?x1878 ?x44051)))
 (let ((?x44053 (%Poly%vstd!seq.Seq<u8.>. ?x44052)))
 (let (($x44054 (= verus_tmp$1@1 ?x44053)))
 (let (($x44029 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. 0)))
 (let (($x44156 (not $x44029)))
 (let (($x44272 (or $x44156 (not $x44033) (not $x44035) (not (= tmp%2 ?x44037)) (not (ens%vstd!bytes.u64_to_le_bytes. tmp%2 crc_bytes@0)) (not (= verus_tmp@1 (%Poly%vstd!seq.Seq<u8.>. ?x44043))) (not (= verus_tmp_old_metadata_bytes@ verus_tmp@1)) (not (= old_metadata_bytes@1 verus_tmp_old_metadata_bytes@)) (not $x44054) (not (= verus_tmp_old_crc_bytes@ verus_tmp$1@1)) (not (= old_crc_bytes@1 verus_tmp_old_crc_bytes@)) $x44169 $x44139 $x44164)))
 (let (($x44277 (not $x44272)))
 (let (($x44104 (and (=> %%location_label%%3 $x44090) (and (=> %%location_label%%4 $x44097) (=> %%location_label%%5 $x44101)))))
 (let (($x44108 (and (=> %%location_label%%1 tmp%4) (=> (and tmp%4 $x44080) (and (=> %%location_label%%2 $x44085) $x44104)))))
 (let (($x44112 (=> $x44069 (and (=> %%location_label%%0 tmp%3) (=> (and tmp%3 $x44076) $x44108)))))
 (let (($x44058 (= old_crc_bytes@1 verus_tmp_old_crc_bytes@)))
 (let (($x44056 (= verus_tmp_old_crc_bytes@ verus_tmp$1@1)))
 (let (($x44049 (= old_metadata_bytes@1 verus_tmp_old_metadata_bytes@)))
 (let (($x44047 (= verus_tmp_old_metadata_bytes@ verus_tmp@1)))
 (let (($x44119 (=> (and $x44047 $x44049 $x44054 $x44056 $x44058 $x44063 $x44029 $x44069) (and (=> %%location_label%%0 tmp%3) (=> (and tmp%3 $x44076) $x44108)))))
 (let ((?x44044 (%Poly%vstd!seq.Seq<u8.>. ?x44043)))
 (let (($x44045 (= verus_tmp@1 ?x44044)))
 (let (($x44040 (ens%vstd!bytes.u64_to_le_bytes. tmp%2 crc_bytes@0)))
 (let (($x44038 (= tmp%2 ?x44037)))
 (let (($x44126 (not (=> (and $x44029 $x44033 $x44035 $x44038 $x44040 $x44045 $x44047 $x44049 $x44054 $x44056 $x44058 $x44063 $x44029 $x44069) (and (=> %%location_label%%0 tmp%3) (=> (and tmp%3 $x44076) $x44108))))))
 (let ((@x44165 (mp (asserted $x44126) (rewrite (= $x44126 $x44277)) $x44277)))
 (let ((@x44186 (not-or-elim @x44165 $x44033)))
 (let ((@x44470 (symm @x44186 (= ?x44032 tmp%1))))
 (let ((@x48477 (symm (monotonicity (trans* @x48471 @x44470 (= ?x44324 tmp%1)) (= $x44657 $x44035)) (= $x44035 $x44657))))
 (let ((@x44188 (not-or-elim @x44165 $x44035)))
 (let ((@x44697 (def-axiom (or $x44658 $x44686 (not $x44657)))))
 (let ((@x48480 (unit-resolution @x44697 (mp @x44188 @x48477 $x44657) (unit-resolution @x44670 @x16109 $x44659) $x44686)))
 (let ((@x44683 (def-axiom (or $x44656 $x44651))))
 (let ((@x49979 (unit-resolution @x44683 @x48480 $x44651)))
 (let ((?x47246 (Poly%vstd!seq.Seq<u8.>. ?x44044)))
 (let (($x47247 (= ?x44043 ?x47246)))
 (let (($x45081 (has_type ?x44043 ?x1968)))
 (let ((?x44723 (proj%vstd!view.View./V $ ?x1878)))
 (let (($x45086 (= ?x44723 ?x1968)))
 (let (($x3993 (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. T&. T&)))
 (let ((?x3983 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let ((?x3989 (proj%vstd!view.View./V $ ?x3983)))
 (= ?x3989 ?x3990)))) :pattern ( (proj%vstd!view.View./V $ (TYPE%alloc!vec.Vec. T&. T& A&. A&)) ) :qid internal_proj__vstd!view.View./V_assoc_type_impl_false_definition))
 ))
 (let ((?x10648 (lambda ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) )(let ((?x3990 (TYPE%vstd!seq.Seq. T&. T&)))
 (let ((?x3983 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let ((?x3989 (proj%vstd!view.View./V $ ?x3983)))
 (let (($x3991 (= ?x3989 ?x3990)))
 (refl (~ $x3991 $x3991)))))))
 ))
 (let ((@x10652 (mp~ (asserted $x3993) (nnf-pos (proof-bind ?x10648) (~ $x3993 $x3993)) $x3993)))
 (let (($x45096 (or (not $x3993) $x45086)))
 (let ((@x45097 ((_ quant-inst $ (UINT 8) $ ALLOCATOR_GLOBAL) $x45096)))
 (let ((@x48484 (unit-resolution @x45097 @x10652 $x45086)))
 (let (($x44725 (has_type ?x44043 ?x44723)))
 (let (($x44722 (has_type ?x44042 ?x1878)))
 (let ((?x44777 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44042)))
 (let ((?x47240 (Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44777)))
 (let (($x47213 (has_type ?x47240 ?x1878)))
 (let (($x47270 (not $x47213)))
 (let (($x44778 (= metadata_bytes@0 ?x44777)))
 (let (($x1874 (forall ((x alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (= x (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x1870))) :pattern ( (Poly%alloc!vec.Vec<u8./allocator_global%.>. x) ) :qid internal_alloc__vec__Vec<u8./allocator_global__.>_box_axiom_definition))
 ))
 (let ((?x9500 (lambda ((x alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (let (($x1872 (= x (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x1870))))
 (refl (~ $x1872 $x1872)))))
 ))
 (let ((@x9504 (mp~ (asserted $x1874) (nnf-pos (proof-bind ?x9500) (~ $x1874 $x1874)) $x1874)))
 (let (($x44787 (not $x1874)))
 (let (($x44788 (or $x44787 $x44778)))
 (let ((@x44789 ((_ quant-inst metadata_bytes@0) $x44788)))
 (let ((@x47265 (monotonicity (symm (unit-resolution @x44789 @x9504 $x44778) (= ?x44777 metadata_bytes@0)) (= ?x47240 ?x44042))))
 (let ((@x47272 (monotonicity (symm (monotonicity @x47265 (= $x47213 $x44722)) (= $x44722 $x47213)) (= (not $x44722) $x47270))))
 (let (($x1899 (forall ((x alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (has_type ?x1870 ?x1878)))) :pattern ( (has_type (Poly%alloc!vec.Vec<u8./allocator_global%.>. x) (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL)) ) :qid internal_alloc__vec__Vec<u8./allocator_global__.>_has_type_always_definition))
 ))
 (let ((?x9514 (lambda ((x alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (let (($x1897 (has_type ?x1870 ?x1878)))
 (refl (~ $x1897 $x1897)))))))
 ))
 (let ((@x9518 (mp~ (asserted $x1899) (nnf-pos (proof-bind ?x9514) (~ $x1899 $x1899)) $x1899)))
 (let ((@x47275 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44042)) (or (not $x1899) $x47213)) @x9518 $x47213) (mp (hypothesis (not $x44722)) @x47272 $x47270) false)))
 (let ((@x47276 (lemma @x47275 $x44722)))
 (let (($x44724 (not $x44722)))
 (let (($x44726 (or $x44724 $x44725)))
 (let (($x5331 (forall ((Self%&. Dcr) (Self%& Type) (self! Poly) )(! (let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (or $x2120 $x5323))))) :pattern ( (vstd!view.View.view.? Self%&. Self%& self!) ) :qid internal_vstd!view.View.view.?_pre_post_definition))
 ))
 (let ((?x11222 (lambda ((Self%&. Dcr) (Self%& Type) (self! Poly) )(let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (let (($x5328 (or $x2120 $x5323)))
 (refl (~ $x5328 $x5328))))))))
 ))
 (let (($x5326 (forall ((Self%&. Dcr) (Self%& Type) (self! Poly) )(! (let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (=> $x92 $x5323)))) :pattern ( (vstd!view.View.view.? Self%&. Self%& self!) ) :qid internal_vstd!view.View.view.?_pre_post_definition))
 ))
 (let ((?x5332 (lambda ((Self%&. Dcr) (Self%& Type) (self! Poly) )(let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (let (($x5328 (or $x2120 $x5323)))
 (let (($x5324 (=> $x92 $x5323)))
 (rewrite (= $x5324 $x5328)))))))))
 ))
 (let ((@x5336 (mp (asserted $x5326) (quant-intro (proof-bind ?x5332) (= $x5326 $x5331)) $x5331)))
 (let ((@x11226 (mp~ @x5336 (nnf-pos (proof-bind ?x11222) (~ $x5331 $x5331)) $x5331)))
 (let (($x44748 (not $x5331)))
 (let (($x44749 (or $x44748 $x44724 $x44725)))
 (let ((@x44754 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@0)) (or $x44748 $x44726)) (rewrite (= (or $x44748 $x44726) $x44749)) $x44749)))
 (let ((@x48487 (mp (unit-resolution (unit-resolution @x44754 @x11226 $x44726) @x47276 $x44725) (monotonicity @x48484 (= $x44725 $x45081)) $x45081)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x9570 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x9574 (mp~ @x1986 (nnf-pos (proof-bind ?x9570) (~ $x1981 $x1981)) $x1981)))
 (let (($x45082 (not $x45081)))
 (let (($x45125 (not $x1981)))
 (let (($x47251 (or $x45125 $x45082 $x47247)))
 (let ((@x47229 (mp ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x44042)) (or $x45125 (or $x45082 $x47247))) (rewrite (= (or $x45125 (or $x45082 $x47247)) $x47251)) $x47251)))
 (let ((@x48490 (symm (unit-resolution @x47229 @x9574 @x48487 $x47247) (= ?x47246 ?x44043))))
 (let (($x48715 (= ?x47246 ?x44074)))
 (let (($x48720 (ext_eq false ?x1968 ?x47246 ?x44074)))
 (let ((?x48722 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44074 ?x47246 ?x1876 $)))
 (let ((?x48717 (vstd!seq.Seq.index.? $ ?x1876 ?x44074 ?x48722)))
 (let ((?x48741 (vstd!seq.Seq.index.? $ ?x1876 ?x47246 ?x48722)))
 (let (($x48779 (= ?x48741 ?x48717)))
 (let ((?x48777 (%I ?x48722)))
 (let ((?x48778 (* (- 1) ?x48777)))
 (let ((?x48363 (vstd!seq.Seq.len.? $ ?x1876 ?x47246)))
 (let ((?x48780 (+ ?x48363 ?x48778)))
 (let (($x48781 (<= ?x48780 0)))
 (let (($x48782 (>= ?x48777 0)))
 (let (($x48832 (not $x48782)))
 (let (($x48834 (has_type ?x48722 INT)))
 (let (($x48835 (not $x48834)))
 (let (($x48833 (or $x48835 $x48832 $x48781 $x48779)))
 (let ((?x49338 (I ?x48777)))
 (let (($x49339 (= ?x48722 ?x49338)))
 (let (($x48836 (not $x48833)))
 (let ((@x49862 (hypothesis $x48836)))
 (let ((@x49073 (def-axiom (or $x48833 $x48834))))
 (let ((@x49863 (unit-resolution @x49073 @x49862 $x48834)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x8994 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x8998 (mp~ @x280 (nnf-pos (proof-bind ?x8994) (~ $x275 $x275)) $x275)))
 (let (($x48392 (not $x275)))
 (let (($x49397 (or $x48392 $x48835 $x49339)))
 (let ((@x49441 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44074 ?x47246 ?x1876 $)) (or $x48392 (or $x48835 $x49339))) (rewrite (= (or $x48392 (or $x48835 $x49339)) $x49397)) $x49397)))
 (let ((?x45346 (vstd!seq.Seq.len.? $ ?x1876 ?x44065)))
 (let ((?x44886 (%I ?x7831)))
 (let ((?x49325 (Add ?x48777 ?x44886)))
 (let ((?x49326 (I ?x49325)))
 (let ((?x49537 (%I ?x49326)))
 (let ((?x49643 (I ?x49537)))
 (let ((?x49453 (%I ?x49643)))
 (let ((?x49568 (Sub ?x49453 ?x45346)))
 (let ((?x49569 (I ?x49568)))
 (let ((?x49570 (vstd!seq.Seq.index.? $ ?x1876 ?x47246 ?x49569)))
 (let ((?x48361 (vstd!seq.Seq.add.? $ ?x1876 ?x44065 ?x47246)))
 (let ((?x49502 (vstd!seq.Seq.index.? $ ?x1876 ?x48361 ?x49643)))
 (let (($x49565 (= ?x49502 ?x49570)))
 (let ((?x49510 (* (- 1) ?x49453)))
 (let ((?x49511 (+ ?x45346 ?x49510)))
 (let (($x49512 (<= ?x49511 0)))
 (let ((?x49552 (* (- 1) ?x49537)))
 (let ((?x49513 (+ ?x49453 ?x49552)))
 (let (($x49637 (>= ?x49513 0)))
 (let (($x49636 (= ?x49453 ?x49537)))
 (let (($x49651 (= ?x49643 ?x49326)))
 (let (($x49217 (= ?x49326 ?x49643)))
 (let (($x49535 (has_type ?x49326 INT)))
 (let (($x49644 (has_type ?x49643 INT)))
 (let (($x49657 (not $x49644)))
 (let (($x49655 (= $x49535 $x49644)))
 (let (($x49653 (= $x49644 $x49535)))
 (let (($x49617 (= ?x49325 ?x49537)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x8973 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x8977 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x8973) (~ $x237 $x237)) $x237)))
 (let (($x44893 (not $x237)))
 (let (($x49620 (or $x44893 $x49617)))
 (let ((@x49621 ((_ quant-inst (Add ?x48777 ?x44886)) $x49620)))
 (let ((@x49646 (unit-resolution @x49621 @x8977 $x49617)))
 (let ((@x49656 (symm (monotonicity (monotonicity (symm @x49646 (= ?x49537 ?x49325)) $x49651) $x49653) $x49655)))
 (let ((@x49660 (mp (hypothesis (not $x49535)) (monotonicity @x49656 (= (not $x49535) $x49657)) $x49657)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x9113 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x9117 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x9113) (~ $x698 $x698)) $x698)))
 (let ((@x49662 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x49326)) (or (not $x698) $x49644)) @x9117 $x49644) @x49660 false)))
 (let ((@x49663 (lemma @x49662 $x49535)))
 (let (($x49536 (not $x49535)))
 (let (($x49252 (or $x48392 $x49536 $x49217)))
 (let ((@x49314 (mp ((_ quant-inst (I ?x49325)) (or $x48392 (or $x49536 $x49217))) (rewrite (= (or $x48392 (or $x49536 $x49217)) $x49252)) $x49252)))
 (let ((@x49779 (symm (unit-resolution @x49314 @x8998 @x49663 $x49217) $x49651)))
 (let ((@x49780 (monotonicity @x49779 $x49636)))
 (let ((?x44713 (vstd!seq.Seq.len.? $ ?x1876 ?x44052)))
 (let (($x45226 (<= ?x44713 8)))
 (let (($x44714 (= ?x44713 8)))
 (let (($x44715 (not $x44714)))
 (let ((?x44709 (I ?x44037)))
 (let ((?x44710 (vstd!bytes.spec_u64_to_le_bytes.? ?x44709)))
 (let (($x44711 (= ?x44053 ?x44710)))
 (let (($x44712 (not $x44711)))
 (let (($x44716 (or $x44712 $x44715)))
 (let (($x44735 (not $x44716)))
 (let (($x44717 (ens%vstd!bytes.u64_to_le_bytes. ?x44037 crc_bytes@0)))
 (let (($x44718 (= $x44716 $x44717)))
 (let (($x44719 (not $x44718)))
 (let (($x14966 (forall ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(! (let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x14950 (or (not $x6204) (not $x6206))))
 (not (= $x14950 $x6199)))))))))))))) :pattern ( (ens%vstd!bytes.u64_to_le_bytes. x! s!) ) :qid internal_ens__vstd!bytes.u64_to_le_bytes._definition))
 ))
 (let (($x6210 (forall ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x6207 (and $x6204 $x6206)))
 (let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (= $x6199 $x6207))))))))))))) :pattern ( (ens%vstd!bytes.u64_to_le_bytes. x! s!) ) :qid internal_ens__vstd!bytes.u64_to_le_bytes._definition))
 ))
 (let ((?x14967 (lambda ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x14950 (or (not $x6204) (not $x6206))))
 (let (($x14958 (not (= $x14950 $x6199))))
 (let (($x6207 (and $x6204 $x6206)))
 (let (($x6208 (= $x6199 $x6207)))
 (let (($x14961 (= $x6208 $x14958)))
 (let ((@x14956 (monotonicity (rewrite (= $x6207 (not $x14950))) (= $x6208 (= $x6199 (not $x14950))))))
 (trans (trans @x14956 (rewrite (= (= $x6199 (not $x14950)) $x14958)) $x14961) (rewrite (= $x14958 $x14958)) $x14961)))))))))))))))))))
 ))
 (let ((?x11695 (lambda ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x6207 (and $x6204 $x6206)))
 (let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (let (($x6208 (= $x6199 $x6207)))
 (refl (~ $x6208 $x6208))))))))))))))))
 ))
 (let ((@x14971 (mp (mp~ (asserted $x6210) (nnf-pos (proof-bind ?x11695) (~ $x6210 $x6210)) $x6210) (quant-intro (proof-bind ?x14967) (= $x6210 $x14966)) $x14966)))
 (let (($x44729 (or (not $x14966) $x44719)))
 (let ((@x44730 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x44031) crc_bytes@0) $x44729)))
 (let ((@x44138 (not-or-elim @x44165 $x44038)))
 (let ((@x44474 (symm @x44138 (= ?x44037 tmp%2))))
 (let ((@x44142 (not-or-elim @x44165 $x44040)))
 (let ((@x48501 (mp @x44142 (symm (monotonicity @x44474 (= $x44717 $x44040)) (= $x44040 $x44717)) $x44717)))
 (let ((@x44746 (def-axiom (or $x44718 $x44735 (not $x44717)))))
 (let ((@x48503 (unit-resolution @x44746 @x48501 (unit-resolution @x44730 @x14971 $x44719) $x44735)))
 (let ((@x44734 (def-axiom (or $x44716 $x44714))))
 (let ((@x48504 (unit-resolution @x44734 @x48503 $x44714)))
 (let ((@x48930 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x44715 $x45226)) @x48504 $x45226)))
 (let ((?x49618 (Add ?x48777 8)))
 (let ((?x49619 (* (- 1) ?x49618)))
 (let ((?x49342 (+ ?x49325 ?x49619)))
 (let (($x49343 (>= ?x49342 0)))
 (let (($x49341 (= ?x49325 ?x49618)))
 (let (($x44887 (= ?x7830 ?x44886)))
 (let (($x44894 (or $x44893 $x44887)))
 (let ((@x44895 ((_ quant-inst (Add pmemlog!logimpl_v.header_crc_offset.? 8)) $x44894)))
 (let ((@x48346 (unit-resolution @x44895 @x8977 $x44887)))
 (let ((?x44904 (* (- 1) ?x7830)))
 (let ((?x44910 (+ pmemlog!logimpl_v.header_crc_offset.? ?x44904)))
 (let (($x44924 (<= ?x44910 (- 8))))
 (let (($x44911 (= ?x44910 (- 8))))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x9211 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x9215 (mp~ @x925 (nnf-pos (proof-bind ?x9211) (~ $x920 $x920)) $x920)))
 (let (($x44914 (not $x920)))
 (let (($x44915 (or $x44914 $x44911)))
 (let (($x44908 (= (+ 8 pmemlog!logimpl_v.header_crc_offset.? ?x44904) 0)))
 (let (($x44916 (or $x44914 $x44908)))
 (let (($x44918 (= $x44916 $x44915)))
 (let ((@x44922 (trans (monotonicity (rewrite (= $x44908 $x44911)) $x44918) (rewrite (= $x44915 $x44915)) $x44918)))
 (let ((@x44923 (mp ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.? 8) $x44916) @x44922 $x44915)))
 (let ((@x47466 (unit-resolution @x44923 @x9215 $x44911)))
 (let ((@x47467 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44911) $x44924)) @x47466 $x44924)))
 (let (($x44925 (>= ?x44910 (- 8))))
 (let ((@x47470 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44911) $x44925)) @x47466 $x44925)))
 (let (($x46248 (<= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7263 (= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7261 (fuel_bool fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x7259 (fuel_bool_default fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x46219 (= $x7261 $x7259)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x44024 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x8807 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x8812 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x8807) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x8816 (mp (mp~ @x37 @x8812 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x45233 (unit-resolution @x8816 @x44024 $x30)))
 (let ((@x46249 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_crc_offset.) (or (not $x30) $x46219)) @x45233 (hypothesis (not $x46219)) false)))
 (let ((@x46262 (lemma @x46249 $x46219)))
 (let ((@x7260 (asserted $x7259)))
 (let ((@x46240 (def-axiom (or (not $x46219) $x7261 (not $x7259)))))
 (let ((@x47441 (unit-resolution (unit-resolution @x46240 @x7260 (or (not $x46219) $x7261)) @x46262 $x7261)))
 (let (($x7266 (not $x7261)))
 (let (($x7267 (or $x7266 $x7263)))
 (let ((@x7270 (mp (asserted (=> $x7261 $x7263)) (rewrite (= (=> $x7261 $x7263) $x7267)) $x7267)))
 (let ((@x47442 (unit-resolution @x7270 @x47441 $x7263)))
 (let ((@x47474 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7263) $x46248)) @x47442 $x46248)))
 (let (($x43659 (>= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let ((?x43672 (* (- 1) pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x441 (uHi 64)))
 (let ((?x43673 (+ ?x441 ?x43672)))
 (let (($x43674 (<= ?x43673 0)))
 (let (($x43660 (not $x43659)))
 (let (($x43679 (or $x43660 $x43674)))
 (let (($x43705 (not $x43679)))
 (let (($x7271 (uInv 64 pmemlog!logimpl_v.header_crc_offset.?)))
 (let (($x43681 (= $x43679 $x7271)))
 (let (($x43684 (not $x43681)))
 (let (($x12949 (forall ((bits Int) (i Int) )(! (let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12824 (or $x540 $x578)))
 (not (= $x12824 $x648))))))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let (($x669 (forall ((bits Int) (i Int) )(! (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x584)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x12950 (lambda ((bits Int) (i Int) )(let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12824 (or $x540 $x578)))
 (let (($x12941 (not (= $x12824 $x648))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x667 (= $x648 $x584)))
 (let (($x12944 (= $x667 $x12941)))
 (let ((@x12827 (rewrite (= $x584 (not $x12824)))))
 (let ((@x12945 (trans (monotonicity @x12827 (= $x667 (= $x648 (not $x12824)))) (rewrite (= (= $x648 (not $x12824)) $x12941)) $x12944)))
 (trans @x12945 (rewrite (= $x12941 $x12941)) $x12944)))))))))))))
 ))
 (let ((?x9092 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (refl (~ $x667 $x667)))))))
 ))
 (let (($x660 (forall ((bits Int) (i Int) )(! (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x548)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x674 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x658 (= $x648 $x548)))
 (rewrite (= $x658 $x667))))))))))
 ))
 (let ((@x640 (mp (asserted $x660) (quant-intro (proof-bind ?x674) (= $x660 $x669)) $x669)))
 (let ((@x12954 (mp (mp~ @x640 (nnf-pos (proof-bind ?x9092) (~ $x669 $x669)) $x669) (quant-intro (proof-bind ?x12950) (= $x669 $x12949)) $x12949)))
 (let (($x43342 (not $x12949)))
 (let (($x43691 (or $x43342 $x43684)))
 (let ((?x43311 (* (- 1) ?x441)))
 (let ((?x43661 (+ pmemlog!logimpl_v.header_crc_offset.? ?x43311)))
 (let (($x43662 (>= ?x43661 0)))
 (let (($x43663 (or $x43660 $x43662)))
 (let (($x43664 (= $x43663 $x7271)))
 (let (($x43665 (not $x43664)))
 (let (($x43692 (or $x43342 $x43665)))
 (let (($x43694 (= $x43692 $x43691)))
 (let (($x43686 (= $x43665 $x43684)))
 (let ((@x43690 (trans (monotonicity (rewrite (= $x43664 $x43681)) $x43686) (rewrite (= $x43684 $x43684)) $x43686)))
 (let ((@x43699 (mp ((_ quant-inst 64 pmemlog!logimpl_v.header_crc_offset.?) $x43692) (trans (monotonicity @x43690 $x43694) (rewrite (= $x43691 $x43691)) $x43694) $x43691)))
 (let ((@x7272 (asserted $x7271)))
 (let ((@x43716 (def-axiom (or $x43681 $x43705 (not $x7271)))))
 (let ((@x47478 (unit-resolution (unit-resolution @x43716 @x7272 (or $x43681 $x43705)) (unit-resolution @x43699 @x12954 $x43684) $x43705)))
 (let ((@x43701 (def-axiom (or $x43679 $x43659))))
 (let ((@x47479 (unit-resolution @x43701 @x47478 $x43659)))
 (let ((@x47481 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x47479 @x47474 @x47470 @x47467 (= ?x7830 8))))
 (let ((@x47483 (symm @x47481 (= 8 ?x7830))))
 (let ((@x49769 (symm (monotonicity (trans* @x47483 @x48346 (= 8 ?x44886)) (= ?x49618 ?x49325)) $x49341)))
 (let ((@x49870 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49341) $x49343)) @x49769 $x49343)))
 (let ((?x49624 (+ ?x48777 ?x49619)))
 (let (($x49337 (<= ?x49624 (- 8))))
 (let (($x49218 (= ?x49624 (- 8))))
 (let (($x49317 (or $x44914 $x49218)))
 (let (($x49623 (= (+ 8 ?x48777 ?x49619) 0)))
 (let (($x49320 (or $x44914 $x49623)))
 (let (($x49322 (= $x49320 $x49317)))
 (let ((@x49335 (trans (monotonicity (rewrite (= $x49623 $x49218)) $x49322) (rewrite (= $x49317 $x49317)) $x49322)))
 (let ((@x49336 (mp ((_ quant-inst (%I ?x48722) 8) $x49320) @x49335 $x49317)))
 (let ((@x49760 (unit-resolution @x49336 @x9215 $x49218)))
 (let ((@x49873 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49218) $x49337)) @x49760 $x49337)))
 (let ((?x49096 (+ ?x49325 ?x49552)))
 (let (($x49216 (<= ?x49096 0)))
 (let ((?x45365 (* (- 1) ?x45346)))
 (let ((?x47281 (+ ?x44713 ?x45365)))
 (let (($x47277 (>= ?x47281 0)))
 (let (($x47280 (= ?x44713 ?x45346)))
 (let ((@x44146 (not-or-elim @x44165 $x44058)))
 (let ((@x48506 (symm @x44146 (= verus_tmp_old_crc_bytes@ old_crc_bytes@1))))
 (let ((@x44151 (not-or-elim @x44165 $x44056)))
 (let ((@x44484 (symm @x44151 (= verus_tmp$1@1 verus_tmp_old_crc_bytes@))))
 (let ((@x44150 (not-or-elim @x44165 $x44054)))
 (let ((@x44482 (symm @x44150 (= ?x44053 verus_tmp$1@1))))
 (let ((@x48517 (symm (unit-resolution (def-axiom (or $x44716 $x44711)) @x48503 $x44711) (= ?x44710 ?x44053))))
 (let ((@x48521 (monotonicity (trans* @x48517 @x44482 @x44484 @x48506 (= ?x44710 old_crc_bytes@1)) (= (Poly%vstd!seq.Seq<u8.>. ?x44710) ?x44065))))
 (let ((@x48531 (symm @x48521 (= ?x44065 (Poly%vstd!seq.Seq<u8.>. ?x44710)))))
 (let ((@x48533 (monotonicity @x48531 (= ?x45346 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44710))))))
 (let ((@x48925 (symm @x48533 (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44710)) ?x45346))))
 (let ((?x44877 (Poly%vstd!seq.Seq<u8.>. ?x44053)))
 (let (($x47278 (= ?x44052 ?x44877)))
 (let (($x45102 (has_type ?x44052 ?x1968)))
 (let (($x44755 (has_type ?x44052 ?x44723)))
 (let (($x44727 (has_type ?x44051 ?x1878)))
 (let ((?x44785 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44051)))
 (let ((?x47249 (Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44785)))
 (let (($x47250 (has_type ?x47249 ?x1878)))
 (let (($x47300 (not $x47250)))
 (let (($x44786 (= crc_bytes@0 ?x44785)))
 (let (($x44792 (or $x44787 $x44786)))
 (let ((@x44793 ((_ quant-inst crc_bytes@0) $x44792)))
 (let ((@x47295 (monotonicity (symm (unit-resolution @x44793 @x9504 $x44786) (= ?x44785 crc_bytes@0)) (= ?x47249 ?x44051))))
 (let ((@x47302 (monotonicity (symm (monotonicity @x47295 (= $x47250 $x44727)) (= $x44727 $x47250)) (= (not $x44727) $x47300))))
 (let ((@x47305 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44051)) (or (not $x1899) $x47250)) @x9518 $x47250) (mp (hypothesis (not $x44727)) @x47302 $x47300) false)))
 (let ((@x47306 (lemma @x47305 $x44727)))
 (let (($x44747 (not $x44727)))
 (let (($x44756 (or $x44747 $x44755)))
 (let (($x44759 (or $x44748 $x44747 $x44755)))
 (let ((@x44764 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@0)) (or $x44748 $x44756)) (rewrite (= (or $x44748 $x44756) $x44759)) $x44759)))
 (let ((@x48513 (mp (unit-resolution (unit-resolution @x44764 @x11226 $x44756) @x47306 $x44755) (monotonicity @x48484 (= $x44755 $x45102)) $x45102)))
 (let (($x45103 (not $x45102)))
 (let (($x47282 (or $x45125 $x45103 $x47278)))
 (let ((@x47287 (mp ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x44051)) (or $x45125 (or $x45103 $x47278))) (rewrite (= (or $x45125 (or $x45103 $x47278)) $x47282)) $x47282)))
 (let ((@x48527 (symm (unit-resolution @x47287 @x9574 @x48513 $x47278) (= ?x44877 ?x44052))))
 (let ((@x48523 (monotonicity (trans* @x44482 @x44484 @x48506 (= ?x44053 old_crc_bytes@1)) (= ?x44877 ?x44065))))
 (let ((@x48525 (symm @x48523 (= ?x44065 ?x44877))))
 (let ((@x48535 (monotonicity (trans* @x48521 @x48525 @x48527 (= (Poly%vstd!seq.Seq<u8.>. ?x44710) ?x44052)) (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44710)) ?x44713))))
 (let ((@x48923 (symm @x48535 (= ?x44713 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44710))))))
 (let ((@x48927 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47280) $x47277)) (trans* @x48923 @x48925 $x47280) $x47277)))
 (let ((@x49075 (def-axiom (or $x48833 $x48782))))
 (let ((@x49877 (unit-resolution @x49075 @x49862 $x48782)))
 (let (($x49883 (not $x49337)))
 (let (($x49882 (not $x49343)))
 (let (($x49884 (or $x49512 (not $x45226) (not $x47277) (not $x49637) (not $x49216) $x49882 $x48832 $x49883)))
 (let ((@x49886 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 1 -1 1 1 -1) $x49884) @x49877 @x48927 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49617) $x49216)) @x49646 $x49216) @x49873 @x49870 @x48930 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49636) $x49637)) @x49780 $x49637) $x49512)))
 (let ((?x48364 (Add ?x45346 ?x48363)))
 (let ((?x48365 (nClip ?x48364)))
 (let ((?x49601 (+ ?x48365 ?x49510)))
 (let (($x49602 (<= ?x49601 0)))
 (let (($x49784 (not $x49602)))
 (let (($x49076 (not $x48781)))
 (let ((@x49078 (def-axiom (or $x48833 $x49076))))
 (let ((@x49890 (unit-resolution @x49078 @x49862 $x49076)))
 (let ((@x49515 (hypothesis $x49076)))
 (let (($x49638 (>= ?x49624 (- 8))))
 (let ((@x49761 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49218) $x49638)) @x49760 $x49638)))
 (let (($x49340 (<= ?x49342 0)))
 (let ((@x49770 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49341) $x49340)) @x49769 $x49340)))
 (let (($x49318 (>= ?x49096 0)))
 (let (($x49514 (<= ?x49513 0)))
 (let ((?x48389 (* (- 1) ?x48365)))
 (let ((?x48390 (+ ?x48364 ?x48389)))
 (let (($x48391 (<= ?x48390 0)))
 (let (($x48379 (= ?x48364 ?x48365)))
 (let (($x48377 (>= ?x48364 0)))
 (let (($x48378 (not $x48377)))
 (let (($x48380 (or $x48378 $x48379)))
 (let (($x48381 (not $x48380)))
 (let (($x48368 (>= ?x48365 0)))
 (let (($x48369 (not $x48368)))
 (let (($x48382 (or $x48369 $x48381)))
 (let (($x48383 (not $x48382)))
 (let (($x11017 (forall ((i Int) )(! (let (($x11011 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (not $x11011)) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let (($x534 (forall ((i Int) )(! (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (and $x533 $x541))))))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x12819 (lambda ((i Int) )(let (($x11011 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (let (($x10988 (not $x11011)))
 (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (rewrite (= $x546 $x10988))))))))))))
 ))
 (let ((?x9064 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (refl (~ $x546 $x546))))))))))
 ))
 (let (($x529 (forall ((i Int) )(! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x535 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (let (($x527 (and (<= 0 ?x522) (=> (<= 0 i) $x525))))
 (rewrite (= $x527 $x546)))))))))))
 ))
 (let ((@x542 (mp (asserted $x529) (quant-intro (proof-bind ?x535) (= $x529 $x534)) $x534)))
 (let ((@x12823 (mp (mp~ @x542 (nnf-pos (proof-bind ?x9064) (~ $x534 $x534)) $x534) (quant-intro (proof-bind ?x12819) (= $x534 $x11017)) $x11017)))
 (let (($x48387 (or (not $x11017) $x48383)))
 (let ((@x48388 ((_ quant-inst (Add ?x45346 ?x48363)) $x48387)))
 (let ((@x48403 (def-axiom (or $x48382 $x48380))))
 (let (($x48434 (>= ?x48364 32)))
 (let (($x48432 (= ?x48364 32)))
 (let ((?x48384 (Add 8 24)))
 (let (($x48415 (= ?x48384 32)))
 (let (($x48419 (or $x44914 $x48415)))
 (let ((?x48385 (* (- 1) ?x48384)))
 (let ((?x48406 (+ 24 8 ?x48385)))
 (let (($x48407 (= ?x48406 0)))
 (let (($x48420 (or $x44914 $x48407)))
 (let (($x48422 (= $x48420 $x48419)))
 (let ((@x48410 (rewrite (= ?x48406 (+ 32 ?x48385)))))
 (let ((@x48418 (trans (monotonicity @x48410 (= $x48407 (= (+ 32 ?x48385) 0))) (rewrite (= (= (+ 32 ?x48385) 0) $x48415)) (= $x48407 $x48415))))
 (let ((@x48427 (mp ((_ quant-inst 8 24) $x48420) (trans (monotonicity @x48418 $x48422) (rewrite (= $x48419 $x48419)) $x48422) $x48419)))
 (let ((@x48441 (unit-resolution @x48427 @x9215 $x48415)))
 (let (($x48495 (= ?x48363 24)))
 (let ((?x44896 (%I ?x7835)))
 (let ((?x45136 (Sub ?x44896 8)))
 (let ((?x45146 (* (- 1) ?x45136)))
 (let ((?x45147 (+ ?x44896 ?x45146)))
 (let (($x45160 (<= ?x45147 8)))
 (let (($x45145 (= ?x45147 8)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x9218 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x9222 (mp~ @x956 (nnf-pos (proof-bind ?x9218) (~ $x951 $x951)) $x951)))
 (let (($x45150 (not $x951)))
 (let (($x45151 (or $x45150 $x45145)))
 (let (($x45144 (= (+ 8 (* (- 1) ?x44896) ?x45136) 0)))
 (let (($x45152 (or $x45150 $x45144)))
 (let (($x45154 (= $x45152 $x45151)))
 (let ((@x45158 (trans (monotonicity (rewrite (= $x45144 $x45145)) $x45154) (rewrite (= $x45151 $x45151)) $x45154)))
 (let ((@x45159 (mp ((_ quant-inst (%I ?x7835) 8) $x45152) @x45158 $x45151)))
 (let ((@x48445 (unit-resolution @x45159 @x9222 $x45145)))
 (let ((@x48446 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45145) $x45160)) @x48445 $x45160)))
 (let (($x45161 (>= ?x45147 8)))
 (let ((?x45135 (* (- 1) ?x44896)))
 (let ((?x45223 (+ pmemlog!logimpl_v.header_size.? ?x45135)))
 (let (($x45224 (<= ?x45223 0)))
 (let (($x44897 (= pmemlog!logimpl_v.header_size.? ?x44896)))
 (let (($x44902 (or $x44893 $x44897)))
 (let ((@x44903 ((_ quant-inst pmemlog!logimpl_v.header_size.?) $x44902)))
 (let ((@x48453 (unit-resolution @x44903 @x8977 $x44897)))
 (let ((@x48454 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44897) $x45224)) @x48453 $x45224)))
 (let (($x45225 (>= ?x45223 0)))
 (let ((@x48457 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44897) $x45225)) @x48453 $x45225)))
 (let (($x46319 (<= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7320 (= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7318 (fuel_bool fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x7316 (fuel_bool_default fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x46290 (= $x7318 $x7316)))
 (let ((@x46320 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_size.) (or (not $x30) $x46290)) @x45233 (hypothesis (not $x46290)) false)))
 (let ((@x46333 (lemma @x46320 $x46290)))
 (let ((@x7317 (asserted $x7316)))
 (let ((@x46311 (def-axiom (or (not $x46290) $x7318 (not $x7316)))))
 (let ((@x47688 (unit-resolution (unit-resolution @x46311 @x7317 (or (not $x46290) $x7318)) @x46333 $x7318)))
 (let (($x7323 (not $x7318)))
 (let (($x7324 (or $x7323 $x7320)))
 (let ((@x7327 (mp (asserted (=> $x7318 $x7320)) (rewrite (= (=> $x7318 $x7320) $x7324)) $x7324)))
 (let ((@x47689 (unit-resolution @x7327 @x47688 $x7320)))
 (let ((@x48461 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x46319)) @x47689 $x46319)))
 (let (($x46307 (>= pmemlog!logimpl_v.header_size.? 32)))
 (let ((@x48464 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x46307)) @x47689 $x46307)))
 (let ((@x48466 ((_ th-lemma arith eq-propagate -1 -1 1 1 1 1) @x48464 @x48461 @x48457 @x48454 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45145) $x45161)) @x48445 $x45161) @x48446 (= ?x45136 24))))
 (let ((@x48494 (monotonicity @x48453 (= ?x8522 ?x45136))))
 (let ((@x44685 (def-axiom (or $x44656 $x44654))))
 (let ((@x48481 (unit-resolution @x44685 @x48480 $x44654)))
 (let ((@x48492 (monotonicity @x48490 (= ?x48363 ?x44653))))
 (let ((@x48496 (trans* @x48492 @x48481 @x48494 @x48466 $x48495)))
 (let ((@x48539 (monotonicity (trans* @x48533 @x48535 @x48504 (= ?x45346 8)) @x48496 (= ?x48364 ?x48384))))
 (let ((@x48541 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48432) $x48434)) (trans* @x48539 @x48441 $x48432) $x48434)))
 (let ((@x48399 (def-axiom (or $x48381 $x48378 $x48379))))
 (let ((@x48546 (unit-resolution @x48399 (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x48434) $x48377)) @x48541 $x48377) (unit-resolution @x48403 (unit-resolution @x48388 @x12823 $x48383) $x48380) $x48379)))
 (let ((@x48549 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48379) $x48391)) @x48546 $x48391)))
 (let (($x49008 (<= ?x48363 24)))
 (let ((@x49530 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48495) $x49008)) @x48496 $x49008)))
 (let ((@x49783 ((_ th-lemma arith farkas -1 -1 1 -1 -1 1 -1 1 1) @x49530 (hypothesis $x49602) @x48541 @x48549 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49636) $x49514)) @x49780 $x49514) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49617) $x49318)) @x49646 $x49318) @x49770 @x49761 @x49515 false)))
 (let ((@x49786 (lemma @x49783 (or $x49784 $x48781))))
 (let (($x48353 (has_type ?x47246 ?x1968)))
 (let ((@x48557 (mp @x48487 (symm (monotonicity @x48490 (= $x48353 $x45081)) (= $x45081 $x48353)) $x48353)))
 (let (($x45379 (has_type ?x44065 ?x1968)))
 (let ((@x48571 (symm (monotonicity (trans* @x48525 @x48527 (= ?x44065 ?x44052)) (= $x45379 $x45102)) (= $x45102 $x45379))))
 (let ((@x48572 (mp @x48513 @x48571 $x45379)))
 (let (($x14391 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x4282 (sized A&.)))
 (let (($x14004 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x14332 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x13968 (not $x4256)))
 (or $x13968 $x14332 $x271 $x14004 $x4555 $x5071 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5048 (fuel_bool fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x45538 (= $x5048 $x1594)))
 (let ((@x45540 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index2.) (or (not $x30) $x45538)) @x45233 (hypothesis (not $x45538)) false)))
 (let ((@x45552 (lemma @x45540 $x45538)))
 (let (($x13315 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x13314 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x13313 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x13312 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x13311 (not $x1590)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x13310 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x13309 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x13308 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x13307 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x13306 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x13305 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x13304 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x13303 (not $x1582)))
 (let (($x13316 (or $x13303 $x13304 $x13305 $x13306 $x13307 $x13308 $x13309 $x13310 $x13311 $x13312 $x13313 $x13314 $x13315)))
 (let (($x13317 (not $x13316)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x13380 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x13379 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x13378 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x13377 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x13376 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x13375 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x13374 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x13373 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x13372 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x13371 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x13370 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x13369 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x13368 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x13367 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x13366 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x13381 (or $x1598 $x1610 $x13366 $x1621 $x13367 $x13368 $x13369 $x1565 $x13370 $x1633 $x13371 $x13372 $x1576 $x13373 $x13374 $x13375 $x13376 $x13377 $x13378 $x1644 $x13379 $x13380)))
 (let (($x13382 (not $x13381)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x13385 (or $x1669 $x13382)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x13387 (mp @x1673 (rewrite (= $x1670 $x13385)) $x13385)))
 (let ((@x42210 (def-axiom (or $x13381 $x1581))))
 (let (($x13320 (or $x1598 $x13317)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x13322 (mp @x1602 (rewrite (= $x1599 $x13320)) $x13320)))
 (let ((@x48560 (unit-resolution @x13322 (unit-resolution @x42210 (unit-resolution @x13387 @x1650 $x13382) $x1581) $x13317)))
 (let ((@x42178 (def-axiom (or $x13316 $x1594))))
 (let ((@x45545 (def-axiom (or (not $x45538) $x5048 $x13315))))
 (let ((@x49894 (unit-resolution @x45545 (unit-resolution @x42178 @x48560 $x1594) (or (not $x45538) $x5048))))
 (let (($x5079 (not $x5048)))
 (let (($x14396 (or $x5079 $x14391)))
 (let (($x5101 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5087 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5106 (or $x5079 $x5101)))
 (let ((?x11094 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (refl (~ $x5096 $x5096)))))))))))))))))))))))
 ))
 (let ((@x11099 (monotonicity (refl (~ $x5079 $x5079)) (nnf-pos (proof-bind ?x11094) (~ $x5101 $x5101)) (~ $x5106 $x5106))))
 (let (($x5062 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x4282 (sized A&.)))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x5055) $x5059)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5063 (=> $x5048 $x5062)))
 (let ((?x5102 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x5061 (=> (and $x4994 $x5055) $x5059)))
 (let ((@x5072 (monotonicity (rewrite (= $x5054 (and $x4552 $x5076))) (= $x5055 (and $x4282 (and $x4552 $x5076))))))
 (let ((@x5083 (trans @x5072 (rewrite (= (and $x4282 (and $x4552 $x5076)) $x5075)) (= $x5055 $x5075))))
 (let ((@x5092 (trans (monotonicity @x5083 (= $x5060 (=> $x5075 $x5059))) (rewrite (= (=> $x5075 $x5059) (or $x5087 $x5059))) (= $x5060 (or $x5087 $x5059)))))
 (trans (monotonicity @x5092 (= $x5061 (=> $x4994 (or $x5087 $x5059)))) (rewrite (= (=> $x4994 (or $x5087 $x5059)) $x5096)) (= $x5061 $x5096))))))))))))))))))))))))))))))
 ))
 (let ((@x5077 (monotonicity (quant-intro (proof-bind ?x5102) (= $x5062 $x5101)) (= $x5063 (=> $x5048 $x5101)))))
 (let ((@x5111 (mp (asserted $x5063) (trans @x5077 (rewrite (= (=> $x5048 $x5101) $x5106)) (= $x5063 $x5106)) $x5106)))
 (let ((@x14398 (mp (mp (mp~ @x5111 @x11099 $x5106) (rewrite (= $x5106 $x5106)) $x5106) (rewrite (= $x5106 $x14396)) $x14396)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x49572 (not $x49512)))
 (let (($x45377 (not $x174)))
 (let (($x48354 (not $x48353)))
 (let (($x45380 (not $x45379)))
 (let (($x49616 (not $x14391)))
 (let (($x49629 (or $x49616 $x45380 $x48354 $x49657 $x45377 $x49572 $x49602 $x49565)))
 (let ((?x49563 (+ ?x49453 ?x48389)))
 (let (($x49564 (>= ?x49563 0)))
 (let ((?x49500 (+ ?x49453 ?x45365)))
 (let (($x49501 (>= ?x49500 0)))
 (let (($x49562 (not $x49501)))
 (let (($x49571 (or $x45380 $x48354 $x49657 $x45377 $x49562 $x49564 $x49565)))
 (let (($x49630 (or $x49616 $x49571)))
 (let ((@x49632 (rewrite (= (or $x49616 (or $x45380 $x48354 $x49657 $x45377 $x49572 $x49602 $x49565)) $x49629))))
 (let (($x49611 (or $x45380 $x48354 $x49657 $x45377 $x49572 $x49602 $x49565)))
 (let (($x49606 (= $x49571 $x49611)))
 (let ((@x49600 (monotonicity (rewrite (= ?x49563 (+ ?x48389 ?x49453))) (= $x49564 (>= (+ ?x48389 ?x49453) 0)))))
 (let ((@x49610 (trans @x49600 (rewrite (= (>= (+ ?x48389 ?x49453) 0) $x49602)) (= $x49564 $x49602))))
 (let ((@x49575 (rewrite (= $x49562 $x49572))))
 (let ((@x49628 (monotonicity (trans (monotonicity @x49575 @x49610 $x49606) (rewrite (= $x49611 $x49611)) $x49606) (= $x49630 (or $x49616 $x49611)))))
 (let ((@x49898 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1) (Poly%vstd!seq.Seq<u8.>. ?x44044) (I ?x49537)) $x49630) (trans @x49628 @x49632 (= $x49630 $x49629)) $x49629) @x175 (unit-resolution @x14398 (unit-resolution @x49894 @x45552 $x5048) $x14391) @x48572 @x48557 (or $x49657 $x49572 $x49602 $x49565))))
 (let ((@x49899 (unit-resolution @x49898 (unit-resolution @x49786 @x49890 $x49784) (mp @x49663 (symm (monotonicity @x49779 $x49653) $x49655) $x49644) @x49886 $x49565)))
 (let ((?x44806 (vstd!seq.Seq.add.? $ ?x1876 ?x44052 ?x44043)))
 (let ((?x49327 (vstd!seq.Seq.index.? $ ?x1876 ?x44806 ?x49326)))
 (let ((?x49016 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44806 ?x7831 ?x7835)))
 (let ((?x49324 (vstd!seq.Seq.index.? $ ?x1876 ?x49016 ?x48722)))
 (let (($x49328 (= ?x49324 ?x49327)))
 (let ((?x49226 (Sub ?x44896 ?x44886)))
 (let ((?x49315 (* (- 1) ?x49226)))
 (let ((?x49316 (+ ?x48777 ?x49315)))
 (let (($x49323 (>= ?x49316 0)))
 (let (($x49532 (not $x49323)))
 (let ((?x45229 (+ ?x44653 ?x45146)))
 (let (($x45231 (>= ?x45229 0)))
 (let ((@x49520 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x44653 ?x45136)) $x45231)) (trans* @x48481 @x48494 (= ?x44653 ?x45136)) $x45231)))
 (let ((?x49348 (+ ?x44653 ?x49315)))
 (let (($x49355 (<= ?x49348 0)))
 (let (($x49347 (= ?x44653 ?x49226)))
 (let ((@x48623 (trans* (symm @x48346 (= ?x44886 ?x7830)) @x47481 (= ?x44886 8))))
 (let ((@x49299 (monotonicity (symm @x48453 (= ?x44896 pmemlog!logimpl_v.header_size.?)) @x48623 (= ?x49226 ?x8522))))
 (let ((@x49301 (symm @x49299 (= ?x8522 ?x49226))))
 (let ((@x49525 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49347) $x49355)) (trans* @x48481 @x49301 $x49347) $x49355)))
 (let ((@x49531 ((_ th-lemma arith farkas -1 1 -1 1 1 -1 -1 1) @x49530 (hypothesis $x49323) @x49525 @x49520 @x48464 @x48454 @x48446 @x49515 false)))
 (let ((@x49534 (lemma @x49531 (or $x49532 $x48781))))
 (let (($x49211 (>= ?x44886 0)))
 (let ((?x48329 (* (- 1) ?x44886)))
 (let ((?x48330 (+ ?x7830 ?x48329)))
 (let (($x48331 (<= ?x48330 0)))
 (let ((@x48347 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44887) $x48331)) @x48346 $x48331)))
 (let ((@x49271 (lemma ((_ th-lemma arith farkas 1 1 1 1) @x48347 @x47479 @x47467 (hypothesis (not $x49211)) false) $x49211)))
 (let ((?x48309 (vstd!seq.Seq.len.? $ ?x1876 ?x44806)))
 (let ((?x48310 (* (- 1) ?x48309)))
 (let ((?x49222 (+ ?x44896 ?x48310)))
 (let (($x49223 (<= ?x49222 0)))
 (let ((?x48429 (+ ?x48309 ?x48389)))
 (let (($x48431 (>= ?x48429 0)))
 (let (($x48428 (= ?x48309 ?x48365)))
 (let ((?x48362 (vstd!seq.Seq.len.? $ ?x1876 ?x48361)))
 (let (($x48366 (= ?x48362 ?x48365)))
 (let (($x14323 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14129 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x13876 (not $x4101)))
 (or $x13876 $x14129 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4955 (fuel_bool fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x45508 (= $x4955 $x1592)))
 (let ((@x45510 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_len.) (or (not $x30) $x45508)) @x45233 (hypothesis (not $x45508)) false)))
 (let ((@x45522 (lemma @x45510 $x45508)))
 (let ((@x45515 (def-axiom (or (not $x45508) $x4955 $x13313))))
 (let ((@x48563 (unit-resolution @x45515 (unit-resolution (def-axiom (or $x13316 $x1592)) @x48560 $x1592) (or (not $x45508) $x4955))))
 (let (($x4985 (not $x4955)))
 (let (($x14328 (or $x4985 $x14323)))
 (let (($x4977 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4986 (or $x4985 $x4977)))
 (let ((?x11066 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (refl (~ $x4972 $x4972))))))))))))))))
 ))
 (let ((@x11071 (monotonicity (refl (~ $x4985 $x4985)) (nnf-pos (proof-bind ?x11066) (~ $x4977 $x4977)) (~ $x4986 $x4986))))
 (let (($x4963 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4959)))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4964 (=> $x4955 $x4963)))
 (let ((?x4978 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let (($x4961 (=> (and $x4526 $x3858) $x4959)))
 (let ((@x4971 (monotonicity (rewrite (= $x4960 (or $x4431 $x4959))) (= $x4961 (=> $x4526 (or $x4431 $x4959))))))
 (trans @x4971 (rewrite (= (=> $x4526 (or $x4431 $x4959)) $x4972)) (= $x4961 $x4972)))))))))))))))))))
 ))
 (let ((@x4984 (monotonicity (quant-intro (proof-bind ?x4978) (= $x4963 $x4977)) (= $x4964 (=> $x4955 $x4977)))))
 (let ((@x4991 (mp (asserted $x4964) (trans @x4984 (rewrite (= (=> $x4955 $x4977) $x4986)) (= $x4964 $x4986)) $x4986)))
 (let ((@x14330 (mp (mp (mp~ @x4991 @x11071 $x4986) (rewrite (= $x4986 $x4986)) $x4986) (rewrite (= $x4986 $x14328)) $x14328)))
 (let (($x48370 (not $x14323)))
 (let (($x48371 (or $x48370 $x45380 $x48354 $x45377 $x48366)))
 (let ((@x48376 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1) (Poly%vstd!seq.Seq<u8.>. ?x44044)) (or $x48370 (or $x45380 $x48354 $x45377 $x48366))) (rewrite (= (or $x48370 (or $x45380 $x48354 $x45377 $x48366)) $x48371)) $x48371)))
 (let ((@x48574 (unit-resolution @x48376 @x175 (unit-resolution @x14330 (unit-resolution @x48563 @x45522 $x4955) $x14323) @x48572 (or $x48354 $x48366))))
 (let ((@x48575 (unit-resolution @x48574 @x48557 $x48366)))
 (let ((@x48567 (trans* @x48525 @x48527 (= ?x44065 ?x44052))))
 (let ((@x48577 (monotonicity @x48567 @x48490 (= ?x48361 ?x44806))))
 (let ((@x48581 (monotonicity (symm @x48577 (= ?x44806 ?x48361)) (= ?x48309 ?x48362))))
 (let ((@x48583 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48428) $x48431)) (trans* @x48581 @x48575 $x48428) $x48431)))
 (let ((@x49279 ((_ th-lemma arith assign-bounds -1 1 1 1 -1) (or $x49223 (not $x46319) (not $x45225) (not $x48431) (not $x48434) (not $x48391)))))
 (let ((@x49280 (unit-resolution @x49279 @x48461 @x48549 @x48583 @x48541 @x48457 $x49223)))
 (let ((?x49235 (+ ?x44886 ?x45135)))
 (let (($x49236 (<= ?x49235 0)))
 (let (($x48284 (>= ?x48330 0)))
 (let ((@x48586 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44887) $x48284)) @x48346 $x48284)))
 (let ((@x49272 ((_ th-lemma arith assign-bounds 1 1 1 1 1) (or $x49236 (not $x48284) (not $x46248) (not $x44925) (not $x46307) (not $x45224)))))
 (let ((@x49273 (unit-resolution @x49272 @x48454 @x47474 @x48464 @x48586 @x47470 $x49236)))
 (let (($x45110 (has_type ?x44806 ?x1968)))
 (let (($x44807 (= ?x44066 ?x44806)))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x44809 (vstd!view.View.view.? $ ?x1878 ?x44062)))
 (let (($x44810 (= ?x44809 ?x7133)))
 (let (($x44811 (not $x44810)))
 (let (($x44808 (not $x44807)))
 (let (($x44802 (has_type ?x44062 ?x1878)))
 (let (($x44803 (not $x44802)))
 (let (($x44757 (has_type ?x44060 ?x1878)))
 (let (($x44758 (not $x44757)))
 (let (($x44812 (or $x44758 $x44803 $x44808 $x44811)))
 (let (($x44834 (not $x44812)))
 (let (($x44813 (= $x44812 $x44063)))
 (let (($x44814 (not $x44813)))
 (let (($x14850 (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(! (let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x14834 (or (not (has_type vec! ?x6064)) (not (has_type other! ?x6064)) (not $x6071) (not $x6074))))
 (not (= $x14834 $x6063)))))))) :pattern ( (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!) ) :qid internal_ens__alloc!vec.impl&__1.append._definition))
 ))
 (let (($x6078 (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(! (let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x6066 (has_type other! ?x6064)))
 (let (($x6065 (has_type vec! ?x6064)))
 (let (($x6075 (and $x6065 $x6066 $x6071 $x6074)))
 (let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (= $x6063 $x6075))))))))) :pattern ( (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!) ) :qid internal_ens__alloc!vec.impl&__1.append._definition))
 ))
 (let ((?x14851 (lambda ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x14834 (or (not (has_type vec! ?x6064)) (not (has_type other! ?x6064)) (not $x6071) (not $x6074))))
 (let (($x14842 (not (= $x14834 $x6063))))
 (let (($x6066 (has_type other! ?x6064)))
 (let (($x6065 (has_type vec! ?x6064)))
 (let (($x6075 (and $x6065 $x6066 $x6071 $x6074)))
 (let (($x6076 (= $x6063 $x6075)))
 (let (($x14845 (= $x6076 $x14842)))
 (let ((@x14840 (monotonicity (rewrite (= $x6075 (not $x14834))) (= $x6076 (= $x6063 (not $x14834))))))
 (trans (trans @x14840 (rewrite (= (= $x6063 (not $x14834)) $x14842)) $x14845) (rewrite (= $x14842 $x14842)) $x14845)))))))))))))))
 ))
 (let ((?x11577 (lambda ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x6066 (has_type other! ?x6064)))
 (let (($x6065 (has_type vec! ?x6064)))
 (let (($x6075 (and $x6065 $x6066 $x6071 $x6074)))
 (let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (let (($x6076 (= $x6063 $x6075)))
 (refl (~ $x6076 $x6076))))))))))))
 ))
 (let ((@x14855 (mp (mp~ (asserted $x6078) (nnf-pos (proof-bind ?x11577) (~ $x6078 $x6078)) $x6078) (quant-intro (proof-bind ?x14851) (= $x6078 $x14850)) $x14850)))
 (let (($x44824 (or (not $x14850) $x44814)))
 (let ((@x44825 ((_ quant-inst $ (UINT 8) $ ALLOCATOR_GLOBAL (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@0) (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1) (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@0) (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@1)) $x44824)))
 (let ((@x44154 (not-or-elim @x44165 $x44063)))
 (let ((@x44844 (def-axiom (or $x44813 $x44834 $x44169))))
 (let ((@x48633 (unit-resolution (unit-resolution @x44844 @x44154 (or $x44813 $x44834)) (unit-resolution @x44825 @x14855 $x44814) $x44834)))
 (let ((@x44831 (def-axiom (or $x44812 $x44807))))
 (let ((@x48636 (unit-resolution @x44831 @x48633 $x44807)))
 (let ((@x48638 (symm @x48636 (= ?x44806 ?x44066))))
 (let ((@x48644 (symm (monotonicity @x48638 (= $x45110 (has_type ?x44066 ?x1968))) (= (has_type ?x44066 ?x1968) $x45110))))
 (let ((@x48640 (monotonicity @x48484 (= (has_type ?x44066 ?x44723) (has_type ?x44066 ?x1968)))))
 (let (($x44765 (has_type ?x44066 ?x44723)))
 (let (($x44766 (or $x44758 $x44765)))
 (let (($x44769 (or $x44748 $x44758 $x44765)))
 (let ((@x44774 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1)) (or $x44748 $x44766)) (rewrite (= (or $x44748 $x44766) $x44769)) $x44769)))
 (let ((@x48635 (unit-resolution (unit-resolution @x44774 @x11226 $x44766) (unit-resolution (def-axiom (or $x44812 $x44757)) @x48633 $x44757) $x44765)))
 (let ((@x48647 (mp @x48635 (trans* @x48640 @x48644 (= $x44765 $x45110)) $x45110)))
 (let (($x44873 (has_type ?x7835 INT)))
 (let ((?x47663 (I 32)))
 (let (($x47664 (has_type ?x47663 INT)))
 (let (($x47698 (not $x47664)))
 (let ((@x47691 (symm @x47689 (= 32 pmemlog!logimpl_v.header_size.?))))
 (let ((@x47697 (symm (monotonicity (monotonicity @x47691 (= ?x47663 ?x7835)) (= $x47664 $x44873)) (= $x44873 $x47664))))
 (let ((@x47701 (mp (hypothesis (not $x44873)) (monotonicity @x47697 (= (not $x44873) $x47698)) $x47698)))
 (let ((@x47703 (unit-resolution (unit-resolution ((_ quant-inst 32) (or (not $x698) $x47664)) @x9117 $x47664) @x47701 false)))
 (let ((@x47704 (lemma @x47703 $x44873)))
 (let (($x44858 (has_type ?x7831 INT)))
 (let ((?x47426 (I 8)))
 (let (($x47427 (has_type ?x47426 INT)))
 (let (($x47490 (not $x47427)))
 (let ((@x47489 (symm (monotonicity (monotonicity @x47483 (= ?x47426 ?x7831)) (= $x47427 $x44858)) (= $x44858 $x47427))))
 (let ((@x47493 (mp (hypothesis (not $x44858)) (monotonicity @x47489 (= (not $x44858) $x47490)) $x47490)))
 (let ((@x47495 (unit-resolution (unit-resolution ((_ quant-inst 8) (or (not $x698) $x47427)) @x9117 $x47427) @x47493 false)))
 (let ((@x47496 (lemma @x47495 $x44858)))
 (let (($x14234 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13864 (not $x821)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4686 (sized A&.)))
 (let (($x14184 (not $x4686)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k! INT)))
 (let (($x13978 (not $x4257)))
 (let (($x4684 (has_type j! INT)))
 (let (($x14224 (not $x4684)))
 (or (not (has_type s! (TYPE%vstd!seq.Seq. A&. A&))) $x14224 $x13978 $x271 $x14184 (not (>= (%I j!) 0)) (not (<= (+ (%I j!) (* (- 1) (%I k!))) 0)) (not $x4711) $x13864 $x4741 $x4703)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4682 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x45478 (= $x4682 $x1590)))
 (let ((@x45480 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_index.) (or (not $x30) $x45478)) @x45233 (hypothesis (not $x45478)) false)))
 (let ((@x45492 (lemma @x45480 $x45478)))
 (let ((@x45485 (def-axiom (or (not $x45478) $x4682 $x13311))))
 (let ((@x49167 (unit-resolution @x45485 (unit-resolution (def-axiom (or $x13316 $x1590)) @x48560 $x1590) (or (not $x45478) $x4682))))
 (let (($x4749 (not $x4682)))
 (let (($x14239 (or $x4749 $x14234)))
 (let (($x4774 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (or (not $x4685) $x4759 $x4703)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4779 (or $x4749 $x4774)))
 (let ((?x11031 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (refl (~ $x4769 $x4769)))))))))))))))))))))))
 ))
 (let ((@x11036 (monotonicity (refl (~ $x4749 $x4749)) (nnf-pos (proof-bind ?x11031) (~ $x4774 $x4774)) (~ $x4779 $x4779))))
 (let (($x4707 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) (%I j!))))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let ((?x1186 (%I j!)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4686 (sized A&.)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (=> (and $x4685 $x4697) $x4703))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4708 (=> $x4682 $x4707)))
 (let ((?x4775 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) ?x1186)))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x4705 (=> (and $x4685 $x4697) $x4703)))
 (let ((@x4734 (rewrite (= (and $x4686 (and $x4710 $x4714 $x4711)) (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4723 (monotonicity (rewrite (= $x4689 (and $x4710 $x4714))) (rewrite (= $x4691 $x4711)) (= $x4692 (and (and $x4710 $x4714) $x4711)))))
 (let ((@x4728 (trans @x4723 (rewrite (= (and (and $x4710 $x4714) $x4711) (and $x4710 $x4714 $x4711))) (= $x4692 (and $x4710 $x4714 $x4711)))))
 (let ((@x4736 (trans (monotonicity @x4728 (= $x4693 (and $x4686 (and $x4710 $x4714 $x4711)))) @x4734 (= $x4693 (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4742 (monotonicity @x4736 (rewrite (= $x4696 (and $x821 $x4746))) (= $x4697 (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746))))))
 (let ((@x4755 (trans @x4742 (rewrite (= (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746)) $x4745)) (= $x4697 $x4745))))
 (let ((@x4764 (trans (monotonicity @x4755 (= $x4704 (=> $x4745 $x4703))) (rewrite (= (=> $x4745 $x4703) (or $x4759 $x4703))) (= $x4704 (or $x4759 $x4703)))))
 (trans (monotonicity @x4764 (= $x4705 (=> $x4685 (or $x4759 $x4703)))) (rewrite (= (=> $x4685 (or $x4759 $x4703)) $x4769)) (= $x4705 $x4769))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4747 (monotonicity (quant-intro (proof-bind ?x4775) (= $x4707 $x4774)) (= $x4708 (=> $x4682 $x4774)))))
 (let ((@x4784 (mp (asserted $x4708) (trans @x4747 (rewrite (= (=> $x4682 $x4774) $x4779)) (= $x4708 $x4779)) $x4779)))
 (let ((@x14241 (mp (mp (mp~ @x4784 @x11036 $x4779) (rewrite (= $x4779 $x4779)) $x4779) (rewrite (= $x4779 $x14239)) $x14239)))
 (let ((@x49169 (unit-resolution @x14241 (unit-resolution @x49167 @x45492 $x4682) $x14234)))
 (let (($x49224 (not $x49223)))
 (let (($x49241 (not $x49236)))
 (let (($x49212 (not $x49211)))
 (let (($x44874 (not $x44873)))
 (let (($x44859 (not $x44858)))
 (let (($x45123 (not $x45110)))
 (let (($x48756 (not $x14234)))
 (let (($x49378 (or $x48756 $x45123 $x44859 $x44874 $x48835 $x45377 $x49212 $x49241 $x49224 $x48832 $x49323 $x49328)))
 (let (($x49329 (or $x45123 $x44859 $x44874 $x48835 $x45377 $x49212 $x49241 $x49224 $x48832 $x49323 $x49328)))
 (let (($x49379 (or $x48756 $x49329)))
 (let ((@x49387 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44052 ?x44043) (I ?x7830) (I pmemlog!logimpl_v.header_size.?) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44074 ?x47246 ?x1876 $)) $x49379) (rewrite (= $x49379 $x49378)) $x49378)))
 (let ((@x49901 (unit-resolution @x49387 @x175 @x49169 @x47496 @x47704 @x48647 @x49863 @x49877 @x49273 @x49280 @x49271 (unit-resolution @x49534 @x49890 $x49532) $x49328)))
 (let ((?x49790 (Sub ?x49325 8)))
 (let (($x49811 (= ?x48777 ?x49790)))
 (let ((?x49796 (* (- 1) ?x49790)))
 (let ((?x49812 (+ ?x48777 ?x49796)))
 (let (($x49813 (<= ?x49812 0)))
 (let ((?x49797 (+ ?x49325 ?x49796)))
 (let (($x49809 (<= ?x49797 8)))
 (let (($x49795 (= ?x49797 8)))
 (let (($x49800 (or $x45150 $x49795)))
 (let (($x49794 (= (+ 8 (* (- 1) ?x49325) ?x49790) 0)))
 (let (($x49801 (or $x45150 $x49794)))
 (let (($x49803 (= $x49801 $x49800)))
 (let ((@x49807 (trans (monotonicity (rewrite (= $x49794 $x49795)) $x49803) (rewrite (= $x49800 $x49800)) $x49803)))
 (let ((@x49907 (unit-resolution (mp ((_ quant-inst (Add ?x48777 ?x44886) 8) $x49801) @x49807 $x49800) @x9222 $x49795)))
 (let ((@x49924 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x49813 $x49882 $x49883 (not $x49809))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49795) $x49809)) @x49907 $x49809) @x49870 @x49873 $x49813)))
 (let (($x49814 (>= ?x49812 0)))
 (let (($x49810 (>= ?x49797 8)))
 (let ((@x49917 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x49814 (not $x49340) (not $x49638) (not $x49810))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49795) $x49810)) @x49907 $x49810) @x49770 @x49761 $x49814)))
 (let ((@x49925 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x49811 (not $x49813) (not $x49814))) @x49917 @x49924 $x49811)))
 (let (($x7277 (= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let (($x7275 (fuel_bool fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x7273 (fuel_bool_default fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x46236 (= $x7275 $x7273)))
 (let ((@x46266 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_head_offset.) (or (not $x30) $x46236)) @x45233 (hypothesis (not $x46236)) false)))
 (let ((@x46279 (lemma @x46266 $x46236)))
 (let ((@x7274 (asserted $x7273)))
 (let ((@x46257 (def-axiom (or (not $x46236) $x7275 (not $x7273)))))
 (let ((@x49284 (unit-resolution (unit-resolution @x46257 @x7274 (or (not $x46236) $x7275)) @x46279 $x7275)))
 (let (($x7280 (not $x7275)))
 (let (($x7281 (or $x7280 $x7277)))
 (let ((@x7284 (mp (asserted (=> $x7275 $x7277)) (rewrite (= (=> $x7275 $x7277) $x7281)) $x7281)))
 (let ((@x49287 (trans* (unit-resolution @x7284 @x49284 $x7277) @x47483 (= pmemlog!logimpl_v.header_head_offset.? ?x7830))))
 (let ((@x49293 (monotonicity @x48638 (symm (monotonicity @x49287 (= ?x7834 ?x7831)) (= ?x7831 ?x7834)) (= ?x49016 ?x44074))))
 (let ((@x49295 (symm @x49293 (= ?x44074 ?x49016))))
 (let ((@x49827 (monotonicity (trans* @x49646 (symm @x49780 (= ?x49537 ?x49453)) (= ?x49325 ?x49453)) (trans* (symm @x48504 (= 8 ?x44713)) @x48923 @x48925 (= 8 ?x45346)) (= ?x49790 ?x49568))))
 (let ((@x49833 (trans* (symm @x49827 (= ?x49568 ?x49790)) (symm (hypothesis $x49811) (= ?x49790 ?x48777)) (= ?x49568 ?x48777))))
 (let ((@x49840 (trans* (hypothesis $x49339) (symm (monotonicity @x49833 (= ?x49569 ?x49338)) (= ?x49338 ?x49569)) (= ?x48722 ?x49569))))
 (let ((@x49853 (trans* (monotonicity @x49840 (= ?x48741 ?x49570)) (symm (hypothesis $x49565) (= ?x49570 ?x49502)) (monotonicity @x48577 @x49779 (= ?x49502 ?x49327)) (symm (hypothesis $x49328) (= ?x49327 ?x49324)) (symm (monotonicity @x49295 (= ?x48717 ?x49324)) (= ?x49324 ?x48717)) $x48779)))
 (let ((@x49861 (lemma (unit-resolution (hypothesis (not $x48779)) @x49853 false) (or (not $x49811) $x48779 (not $x49328) (not $x49565) (not $x49339)))))
 (let ((@x49926 (unit-resolution @x49861 @x49925 (unit-resolution (def-axiom (or $x48833 (not $x48779))) @x49862 (not $x48779)) @x49901 @x49899 (unit-resolution @x49441 @x8998 @x49863 $x49339) false)))
 (let ((@x49927 (lemma @x49926 $x48833)))
 (let ((?x48837 (vstd!seq.Seq.len.? $ ?x1876 ?x44074)))
 (let (($x48838 (= ?x48363 ?x48837)))
 (let (($x48839 (not $x48838)))
 (let (($x48816 (or $x48720 $x48839 $x48836)))
 (let (($x48840 (not $x48816)))
 (let (($x48824 (forall ((i$ Poly) )(! (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x44060 (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44066 (vstd!view.View.view.? $ ?x1878 ?x44060)))
 (let ((?x44074 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7834 ?x7835)))
 (let ((?x48842 (vstd!seq.Seq.index.? $ ?x1876 ?x44074 i$)))
 (let ((?x44042 (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@0)))
 (let ((?x44043 (vstd!view.View.view.? $ ?x1878 ?x44042)))
 (let ((?x44044 (%Poly%vstd!seq.Seq<u8.>. ?x44043)))
 (let ((?x47246 (Poly%vstd!seq.Seq<u8.>. ?x44044)))
 (let ((?x48813 (vstd!seq.Seq.index.? $ ?x1876 ?x47246 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13864 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13864 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x47246))) 0) (= ?x48813 ?x48842)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. metadata_bytes@0)))) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1)) (I pmemlog!logimpl_v.header_head_offset.?) (I pmemlog!logimpl_v.header_size.?)) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x48815 (not $x48824)))
 (let (($x48817 (or $x48839 $x48815)))
 (let (($x48825 (not $x48817)))
 (let (($x48726 (not $x48720)))
 (let (($x48818 (or $x48726 $x48825)))
 (let (($x48819 (not $x48818)))
 (let (($x48820 (or $x48819 $x48840)))
 (let (($x49002 (not $x48820)))
 (let (($x49004 (has_type ?x44074 ?x1968)))
 (let (($x49067 (has_type ?x49016 ?x1968)))
 (let (($x13998 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x13978 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x13968 (not $x4256)))
 (or $x13968 $x13978 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x13999 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x13978 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x13968 (not $x4256)))
 (let (($x13993 (or $x13968 $x13978 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x13985 (monotonicity (rewrite (= $x4258 (not (or $x13968 $x13978 $x271)))) (= $x4266 (not (not (or $x13968 $x13978 $x271)))))))
 (let ((@x13989 (trans @x13985 (rewrite (= (not (not (or $x13968 $x13978 $x271))) (or $x13968 $x13978 $x271))) (= $x4266 (or $x13968 $x13978 $x271)))))
 (trans (monotonicity @x13989 (= $x4269 (or (or $x13968 $x13978 $x271) $x4261))) (rewrite (= (or (or $x13968 $x13978 $x271) $x4261) $x13993)) (= $x4269 $x13993))))))))))))))))))
 ))
 (let ((?x10767 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x14003 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x10767) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x13999) (= $x4272 $x13998)) $x13998)))
 (let (($x44864 (not $x13998)))
 (let (($x49000 (or $x44864 $x45123 $x44859 $x44874 $x49067)))
 (let ((@x49106 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44052 ?x44043) (I ?x7830) (I pmemlog!logimpl_v.header_size.?)) (or $x44864 (or $x45123 $x44859 $x44874 $x49067))) (rewrite (= (or $x44864 (or $x45123 $x44859 $x44874 $x49067)) $x49000)) $x49000)))
 (let ((@x49745 (mp (unit-resolution @x49106 @x14003 @x47496 @x47704 @x48647 $x49067) (monotonicity @x49293 (= $x49067 $x49004)) $x49004)))
 (let (($x14208 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10866 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10878 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10866) (vstd!seq.Seq.index.? A&. A& s2! ?x10866))))
 (let (($x10917 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x10866))) 0)))
 (let (($x10868 (not (has_type ?x10866 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10863 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x14189 (not (or $x4527 $x10863 (not (or $x10868 (not (>= (%I ?x10866) 0)) $x10917 $x10878))))))
 (let (($x14160 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13864 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13864 $x4552 $x4534))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x10850 (not $x4527)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14129 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x13876 (not $x4101)))
 (or $x13876 $x14129 $x4431 (not (or (not (or $x10850 (not (or $x10863 (not $x14160))))) $x14189)))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4524 (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x45325 (= $x4524 $x1587)))
 (let ((@x45327 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_ext_equal.) (or (not $x30) $x45325)) @x45233 (hypothesis (not $x45325)) false)))
 (let ((@x45339 (lemma @x45327 $x45325)))
 (let ((@x45332 (def-axiom (or (not $x45325) $x4524 $x13308))))
 (let ((@x49677 (unit-resolution @x45332 (unit-resolution (def-axiom (or $x13316 $x1587)) @x48560 $x1587) (or (not $x45325) $x4524))))
 (let (($x4583 (not $x4524)))
 (let (($x14141 (or $x4583 $x14208)))
 (let (($x10931 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10866 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10878 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10866) (vstd!seq.Seq.index.? A&. A& s2! ?x10866))))
 (let (($x10917 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x10866))) 0)))
 (let ((?x10869 (%I ?x10866)))
 (let (($x10870 (>= ?x10869 0)))
 (let (($x10868 (not (has_type ?x10866 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10863 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10850 (not $x4527)))
 (let (($x10889 (or $x10850 $x4548)))
 (let (($x10932 (and $x10889 (or $x4527 $x10863 (not (or $x10868 (not (and $x10870 (not $x10917))) $x10878))))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x10932)))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x10905 (or $x4583 $x10931)))
 (let (($x10896 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10866 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10878 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10866) (vstd!seq.Seq.index.? A&. A& s2! ?x10866))))
 (let (($x10872 (>= (+ (%I ?x10866) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x10869 (%I ?x10866)))
 (let (($x10870 (>= ?x10869 0)))
 (let (($x10868 (not (has_type ?x10866 INT))))
 (let (($x10880 (not (or $x10868 (not (and $x10870 (not $x10872))) $x10878))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10863 (not $x4529)))
 (let (($x10884 (or $x10863 $x10880)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10850 (not $x4527)))
 (let (($x10889 (or $x10850 $x4548)))
 (let (($x10890 (and $x10889 (or $x4527 $x10884))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x10890)))))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x10901 (or $x4583 $x10896)))
 (let (($x4576 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4559))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4584 (or $x4583 $x4576)))
 (let ((?x10897 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x10866 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10878 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10866) (vstd!seq.Seq.index.? A&. A& s2! ?x10866))))
 (let (($x10872 (>= (+ (%I ?x10866) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x10869 (%I ?x10866)))
 (let (($x10870 (>= ?x10869 0)))
 (let (($x10868 (not (has_type ?x10866 INT))))
 (let (($x10880 (not (or $x10868 (not (and $x10870 (not $x10872))) $x10878))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10863 (not $x4529)))
 (let (($x10884 (or $x10863 $x10880)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10850 (not $x4527)))
 (let (($x10889 (or $x10850 $x4548)))
 (let (($x10890 (and $x10889 (or $x4527 $x10884))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x10893 (or $x4568 $x4431 $x10890)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let ((@x10865 (refl (~ $x10863 $x10863))))
 (let ((?x10857 (lambda ((i$ Poly) )(let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4569 (or $x271 $x4554 $x4534)))
 (refl (~ $x4569 $x4569))))))))))))))))
 ))
 (let ((@x10854 (refl (~ $x4529 $x4529))))
 (let ((@x10862 (monotonicity @x10854 (nnf-pos (proof-bind ?x10857) (~ $x4574 $x4574)) (~ $x4548 $x4548))))
 (let ((@x10892 (nnf-pos (refl (~ $x4527 $x4527)) (refl (~ $x10850 $x10850)) @x10862 (nnf-neg @x10865 (sk (~ (not $x4574) $x10880)) (~ (not $x4548) $x10884)) (~ $x4559 $x10890))))
 (let ((@x10847 (refl (~ $x4431 $x4431))))
 (let ((@x10845 (refl (~ $x4568 $x4568))))
 (monotonicity @x10845 @x10847 @x10892 (~ $x4570 $x10893))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x10903 (monotonicity (refl (~ $x4583 $x4583)) (nnf-pos (proof-bind ?x10897) (~ $x4576 $x10896)) (~ $x4584 $x10901))))
 (let (($x4545 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x3858 (sized A&.)))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4541))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4546 (=> $x4524 $x4545)))
 (let ((?x4577 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4543 (=> (and $x4526 $x3858) $x4541)))
 (let ((@x4564 (trans (monotonicity (rewrite (= $x4541 $x4559)) (= $x4542 (=> $x3858 $x4559))) (rewrite (= (=> $x3858 $x4559) (or $x4431 $x4559))) (= $x4542 (or $x4431 $x4559)))))
 (trans (monotonicity @x4564 (= $x4543 (=> $x4526 (or $x4431 $x4559)))) (rewrite (= (=> $x4526 (or $x4431 $x4559)) $x4570)) (= $x4543 $x4570)))))))))))))))))))))))
 ))
 (let ((@x4582 (monotonicity (quant-intro (proof-bind ?x4577) (= $x4545 $x4576)) (= $x4546 (=> $x4524 $x4576)))))
 (let ((@x4589 (mp (asserted $x4546) (trans @x4582 (rewrite (= (=> $x4524 $x4576) $x4584)) (= $x4546 $x4584)) $x4584)))
 (let ((@x14130 (mp (mp (mp~ @x4589 @x10903 $x10901) (rewrite (= $x10901 $x10905)) $x10905) (rewrite (= $x10905 $x14141)) $x14141)))
 (let ((@x49679 (unit-resolution @x14130 (unit-resolution @x49677 @x45339 $x4524) $x14208)))
 (let (($x49005 (not $x49004)))
 (let (($x45388 (not $x14208)))
 (let (($x49001 (or $x45388 $x48354 $x49005 $x45377 $x49002)))
 (let ((@x49007 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x44044) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7834 ?x7835)) (or $x45388 (or $x48354 $x49005 $x45377 $x49002))) (rewrite (= (or $x45388 (or $x48354 $x49005 $x45377 $x49002)) $x49001)) $x49001)))
 (let ((@x49746 (unit-resolution (unit-resolution @x49007 @x175 @x49679 @x48557 (or $x49005 $x49002)) @x49745 $x49002)))
 (let ((@x49041 (def-axiom (or $x48820 $x48816))))
 (let ((@x49305 (symm (monotonicity @x49295 (= ?x48837 (vstd!seq.Seq.len.? $ ?x1876 ?x49016))) (= (vstd!seq.Seq.len.? $ ?x1876 ?x49016) ?x48837))))
 (let ((?x49225 (vstd!seq.Seq.len.? $ ?x1876 ?x49016)))
 (let (($x49227 (= ?x49225 ?x49226)))
 (let (($x14164 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x13964 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x13963 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x13168 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x14004 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x13978 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x13968 (not $x4256)))
 (or $x13968 $x13978 $x271 $x14004 $x13168 $x13963 $x13964 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x45463 (= $x4641 $x1589)))
 (let ((@x45465 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x45463)) @x45233 (hypothesis (not $x45463)) false)))
 (let ((@x45477 (lemma @x45465 $x45463)))
 (let ((@x45470 (def-axiom (or (not $x45463) $x4641 $x13310))))
 (let ((@x48626 (unit-resolution @x45470 (unit-resolution (def-axiom (or $x13316 $x1589)) @x48560 $x1589) (or (not $x45463) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x14215 (or $x4675 $x14164)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x10999 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x11022 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x10999) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x14217 (mp (mp (mp~ @x4681 @x11022 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x14215)) $x14215)))
 (let ((@x48628 (unit-resolution @x14217 (unit-resolution @x48626 @x45477 $x4641) $x14164)))
 (let (($x48404 (not $x14164)))
 (let (($x49248 (or $x48404 $x45123 $x44859 $x44874 $x45377 $x49212 $x49241 $x49224 $x49227)))
 (let ((?x49219 (+ ?x44896 ?x48329)))
 (let (($x49220 (>= ?x49219 0)))
 (let (($x49221 (not $x49220)))
 (let (($x49228 (or $x45123 $x44859 $x44874 $x45377 $x49212 $x49221 $x49224 $x49227)))
 (let (($x49249 (or $x48404 $x49228)))
 (let ((@x49257 (rewrite (= (or $x48404 (or $x45123 $x44859 $x44874 $x45377 $x49212 $x49241 $x49224 $x49227)) $x49248))))
 (let (($x49091 (or $x45123 $x44859 $x44874 $x45377 $x49212 $x49241 $x49224 $x49227)))
 (let (($x49092 (= $x49228 $x49091)))
 (let ((@x49247 (trans (monotonicity (rewrite (= $x49221 $x49241)) $x49092) (rewrite (= $x49091 $x49091)) $x49092)))
 (let ((@x49259 (trans (monotonicity @x49247 (= $x49249 (or $x48404 $x49091))) @x49257 (= $x49249 $x49248))))
 (let ((@x49281 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44052 ?x44043) (I ?x7830) (I pmemlog!logimpl_v.header_size.?)) $x49249) @x49259 $x49248) @x175 @x48628 @x47496 @x47704 @x48647 @x49273 @x49280 @x49271 $x49227)))
 (let ((@x49308 (unit-resolution (hypothesis $x48839) (trans* @x48492 @x48481 @x49301 (symm @x49281 (= ?x49226 ?x49225)) @x49305 $x48838) false)))
 (let ((@x49309 (lemma @x49308 $x48838)))
 (let ((@x48850 (def-axiom (or $x48840 $x48720 $x48839 $x48836))))
 (let ((@x49724 (unit-resolution @x48850 @x49309 (unit-resolution @x49041 @x49746 $x48816) (or $x48720 $x48836))))
 (let ((@x49748 (unit-resolution @x49724 @x49927 $x48720)))
 (let (($x48721 (= $x48715 $x48720)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x9057 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x9061 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x9057) (~ $x418 $x418)) $x418)))
 (let (($x44821 (not $x418)))
 (let (($x48723 (or $x44821 $x48721)))
 (let ((@x48724 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. ?x44044) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7834 ?x7835)) $x48723)))
 (let ((@x48713 (def-axiom (or (not $x48721) $x48715 $x48726))))
 (let ((@x49983 (unit-resolution (unit-resolution @x48713 (unit-resolution @x48724 @x9061 $x48721) (or $x48715 $x48726)) @x49748 $x48715)))
 (let (($x44182 (not $x44149)))
 (let (($x44178 (not $x44145)))
 (let (($x44177 (not $x44141)))
 (let (($x44176 (not $x44137)))
 (let (($x44183 (or $x44176 $x44177 $x44178 $x44182)))
 (let (($x44184 (not $x44183)))
 (let (($x44187 (or $x44179 $x44170 $x44184)))
 (let (($x44194 (not $x44187)))
 (let ((@x44152 (not-or-elim @x44165 $x44045)))
 (let ((@x44153 (not-or-elim @x44165 $x44047)))
 (let ((@x44155 (not-or-elim @x44165 $x44049)))
 (let ((@x49752 (monotonicity (trans* @x44155 @x44153 @x44152 (= old_metadata_bytes@1 ?x44044)) (= ?x44073 ?x47246))))
 (let ((@x49732 (mp @x49748 (monotonicity (symm @x49752 (= ?x47246 ?x44073)) (= $x48720 $x44075)) $x44075)))
 (let (($x44193 (not $x44133)))
 (let (($x44195 (or $x44193 $x44194)))
 (let (($x44196 (not $x44195)))
 (let (($x44202 (or $x44157 $x44143 $x44196)))
 (let (($x44134 (not $x44202)))
 (let ((?x45340 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44067 ?x44065 ?x1876 $)))
 (let ((?x45341 (vstd!seq.Seq.index.? $ ?x1876 ?x44067 ?x45340)))
 (let ((?x45342 (vstd!seq.Seq.index.? $ ?x1876 ?x44065 ?x45340)))
 (let (($x45343 (= ?x45342 ?x45341)))
 (let ((?x45344 (%I ?x45340)))
 (let ((?x45398 (+ ?x45344 ?x45365)))
 (let (($x45399 (>= ?x45398 0)))
 (let (($x45349 (>= ?x45344 0)))
 (let (($x45350 (not $x45349)))
 (let (($x45351 (has_type ?x45340 INT)))
 (let (($x45352 (not $x45351)))
 (let (($x45404 (or $x45352 $x45350 $x45399 $x45343)))
 (let (($x45426 (not $x45399)))
 (let (($x45410 (not $x45404)))
 (let ((@x49143 (hypothesis $x45410)))
 (let ((@x45428 (def-axiom (or $x45404 $x45426))))
 (let ((@x49144 (unit-resolution @x45428 @x49143 $x45426)))
 (let (($x48898 (<= (+ ?x45346 (* (- 1) (%I (I (%I (I (Add ?x45344 (%I ?x7829)))))))) 0)))
 (let ((?x44891 (%I ?x7829)))
 (let ((?x48693 (Add ?x45344 ?x44891)))
 (let ((?x48694 (I ?x48693)))
 (let ((?x48937 (%I ?x48694)))
 (let ((?x49044 (I ?x48937)))
 (let ((?x48827 (vstd!seq.Seq.index.? $ ?x1876 ?x44065 ?x49044)))
 (let ((?x48826 (vstd!seq.Seq.index.? $ ?x1876 ?x48361 ?x49044)))
 (let (($x48828 (= ?x48826 ?x48827)))
 (let (($x49190 (not $x48828)))
 (let ((?x48730 (I ?x45344)))
 (let (($x48731 (= ?x45340 ?x48730)))
 (let ((@x45423 (def-axiom (or $x45404 $x45351))))
 (let ((@x49153 (unit-resolution @x45423 @x49143 $x45351)))
 (let (($x48787 (or $x48392 $x45352 $x48731)))
 (let ((@x48791 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44067 ?x44065 ?x1876 $)) (or $x48392 (or $x45352 $x48731))) (rewrite (= (or $x48392 (or $x45352 $x48731)) $x48787)) $x48787)))
 (let (($x49018 (= ?x48693 ?x48937)))
 (let (($x49021 (or $x44893 $x49018)))
 (let ((@x49022 ((_ quant-inst (Add ?x45344 ?x44891)) $x49021)))
 (let ((@x49047 (unit-resolution @x49022 @x8977 $x49018)))
 (let (($x44892 (= pmemlog!logimpl_v.header_crc_offset.? ?x44891)))
 (let (($x44898 (or $x44893 $x44892)))
 (let ((@x44899 ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.?) $x44898)))
 (let ((@x48341 (unit-resolution @x44899 @x8977 $x44892)))
 (let ((@x47444 (symm @x47442 (= 0 pmemlog!logimpl_v.header_crc_offset.?))))
 (let ((@x49133 (monotonicity (trans* @x47444 @x48341 (= 0 ?x44891)) (= (Add ?x45344 0) ?x48693))))
 (let ((?x49019 (Add ?x45344 0)))
 (let ((?x49020 (* (- 1) ?x49019)))
 (let ((?x48324 (+ ?x45344 ?x49020)))
 (let (($x48710 (<= ?x48324 0)))
 (let (($x48683 (= ?x48324 0)))
 (let (($x48322 (or $x44914 $x48683)))
 (let (($x49024 (= (+ 0 ?x45344 ?x49020) 0)))
 (let (($x48681 (or $x44914 $x49024)))
 (let (($x48686 (= $x48681 $x48322)))
 (let ((@x48719 (trans (monotonicity (rewrite (= $x49024 $x48683)) $x48686) (rewrite (= $x48322 $x48322)) $x48686)))
 (let ((@x48708 (mp ((_ quant-inst (%I ?x45340) 0) $x48681) @x48719 $x48322)))
 (let ((@x49121 (unit-resolution @x48708 @x9215 $x48683)))
 (let ((@x49122 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48683) $x48710)) @x49121 $x48710)))
 (let (($x48709 (>= ?x48324 0)))
 (let ((@x49148 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48683) $x48709)) @x49121 $x48709)))
 (let ((@x49156 (monotonicity (trans* ((_ th-lemma arith eq-propagate 1 1) @x49148 @x49122 (= ?x45344 ?x49019)) @x49133 @x49047 (= ?x45344 ?x48937)) (= ?x48730 ?x49044))))
 (let ((@x49162 (trans* (symm @x49156 (= ?x49044 ?x48730)) (symm (unit-resolution @x48791 @x8998 @x49153 $x48731) (= ?x48730 ?x45340)) (= ?x49044 ?x45340))))
 (let ((?x48314 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44806 ?x7829 ?x7831)))
 (let ((?x48692 (vstd!seq.Seq.index.? $ ?x1876 ?x48314 ?x45340)))
 (let ((@x48657 (monotonicity @x48638 (= ?x48314 ?x44067))))
 (let ((?x48695 (vstd!seq.Seq.index.? $ ?x1876 ?x44806 ?x48694)))
 (let (($x48696 (= ?x48692 ?x48695)))
 (let ((?x48316 (Sub ?x44886 ?x44891)))
 (let ((?x48689 (* (- 1) ?x48316)))
 (let ((?x48690 (+ ?x45344 ?x48689)))
 (let (($x48691 (>= ?x48690 0)))
 (let (($x48932 (not $x48691)))
 (let (($x48748 (>= ?x48316 8)))
 (let (($x48739 (= ?x48316 8)))
 (let ((?x45355 (vstd!seq.Seq.len.? $ ?x1876 ?x44067)))
 (let (($x45356 (= ?x45346 ?x45355)))
 (let ((?x48315 (vstd!seq.Seq.len.? $ ?x1876 ?x48314)))
 (let (($x48670 (= ?x48315 ?x45355)))
 (let (($x48317 (= ?x48315 ?x48316)))
 (let ((?x48311 (+ ?x44886 ?x48310)))
 (let (($x48312 (<= ?x48311 0)))
 (let ((@x48587 ((_ th-lemma arith farkas 1 1 1 1 1 1 1) @x48586 @x47474 @x47470 @x48583 @x48541 @x48549 (hypothesis (not $x48312)) false)))
 (let ((@x48588 (lemma @x48587 $x48312)))
 (let ((?x48305 (* (- 1) ?x44891)))
 (let ((?x48306 (+ ?x44886 ?x48305)))
 (let (($x48307 (>= ?x48306 0)))
 (let ((?x48319 (+ pmemlog!logimpl_v.header_crc_offset.? ?x48305)))
 (let (($x48328 (>= ?x48319 0)))
 (let ((@x48349 ((_ th-lemma arith farkas 1 1 1 1) (hypothesis (not $x48307)) @x48347 @x47467 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44892) $x48328)) @x48341 $x48328) false)))
 (let ((@x48350 (lemma @x48349 $x48307)))
 (let (($x48297 (>= ?x44891 0)))
 (let (($x48320 (<= ?x48319 0)))
 (let ((@x48654 (unit-resolution ((_ th-lemma arith assign-bounds -1 1) (or $x48297 $x43660 (not $x48320))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44892) $x48320)) @x48341 $x48320) @x47479 $x48297)))
 (let (($x44856 (has_type ?x7829 INT)))
 (let ((?x7131 (I 0)))
 (let (($x47390 (has_type ?x7131 INT)))
 (let (($x47451 (not $x47390)))
 (let ((@x47450 (symm (monotonicity (monotonicity @x47444 (= ?x7131 ?x7829)) (= $x47390 $x44856)) (= $x44856 $x47390))))
 (let ((@x47454 (mp (hypothesis (not $x44856)) (monotonicity @x47450 (= (not $x44856) $x47451)) $x47451)))
 (let ((@x47456 (unit-resolution (unit-resolution ((_ quant-inst 0) (or (not $x698) $x47390)) @x9117 $x47390) @x47454 false)))
 (let ((@x47457 (lemma @x47456 $x44856)))
 (let (($x48313 (not $x48312)))
 (let (($x48308 (not $x48307)))
 (let (($x48298 (not $x48297)))
 (let (($x44857 (not $x44856)))
 (let (($x48405 (or $x48404 $x45123 $x44857 $x44859 $x45377 $x48298 $x48308 $x48313 $x48317)))
 (let ((@x48336 (rewrite (= (or $x48404 (or $x45123 $x44857 $x44859 $x45377 $x48298 $x48308 $x48313 $x48317)) $x48405))))
 (let ((@x48337 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44052 ?x44043) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830)) (or $x48404 (or $x45123 $x44857 $x44859 $x45377 $x48298 $x48308 $x48313 $x48317))) @x48336 $x48405)))
 (let ((@x48669 (symm (unit-resolution @x48337 @x175 @x48628 @x47457 @x47496 @x48647 @x48654 @x48350 @x48588 $x48317) (= ?x48316 ?x48315))))
 (let ((@x48619 (trans* (symm @x48341 (= ?x44891 pmemlog!logimpl_v.header_crc_offset.?)) @x47442 (= ?x44891 0))))
 (let ((@x48667 (symm (monotonicity @x48623 @x48619 (= ?x48316 (Sub 8 0))) (= (Sub 8 0) ?x48316))))
 (let ((?x48467 (Sub 8 0)))
 (let (($x48601 (= ?x48467 8)))
 (let (($x48606 (or $x45150 $x48601)))
 (let ((?x46596 (* (- 1) 8)))
 (let ((?x48468 (+ 0 ?x46596 ?x48467)))
 (let (($x48589 (= ?x48468 0)))
 (let (($x48607 (or $x45150 $x48589)))
 (let (($x48609 (= $x48607 $x48606)))
 (let ((@x48597 (trans (monotonicity (rewrite (= ?x46596 (- 8))) (= ?x48468 (+ 0 (- 8) ?x48467))) (rewrite (= (+ 0 (- 8) ?x48467) (+ (- 8) ?x48467))) (= ?x48468 (+ (- 8) ?x48467)))))
 (let ((@x48605 (trans (monotonicity @x48597 (= $x48589 (= (+ (- 8) ?x48467) 0))) (rewrite (= (= (+ (- 8) ?x48467) 0) $x48601)) (= $x48589 $x48601))))
 (let ((@x48614 (mp ((_ quant-inst 8 0) $x48607) (trans (monotonicity @x48605 $x48609) (rewrite (= $x48606 $x48606)) $x48609) $x48606)))
 (let ((@x48672 (trans* @x48533 @x48535 @x48504 (symm (unit-resolution @x48614 @x9222 $x48601) (= 8 ?x48467)) @x48667 @x48669 (symm (monotonicity (symm @x48657 (= ?x44067 ?x48314)) (= ?x45355 ?x48315)) $x48670) $x45356)))
 (let ((@x48675 (lemma (unit-resolution (hypothesis (not $x45356)) @x48672 false) $x45356)))
 (let ((@x48917 (trans* @x48669 (monotonicity @x48657 $x48670) (symm @x48675 (= ?x45355 ?x45346)) @x48533 @x48535 @x48504 $x48739)))
 (let ((@x48931 ((_ th-lemma arith farkas 1 -1 -1 -1 1) @x48930 @x48927 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48739) $x48748)) @x48917 $x48748) (hypothesis $x48691) (hypothesis $x45426) false)))
 (let ((@x48934 (lemma @x48931 (or $x48932 $x45399))))
 (let ((@x45425 (def-axiom (or $x45404 $x45349))))
 (let ((@x49170 (unit-resolution @x45425 @x49143 $x45349)))
 (let (($x48758 (or $x48756 $x45123 $x44857 $x44859 $x45352 $x45377 $x48298 $x48308 $x48313 $x45350 $x48691 $x48696)))
 (let ((?x48679 (+ ?x44891 ?x48329)))
 (let (($x48680 (<= ?x48679 0)))
 (let (($x48688 (not $x48680)))
 (let (($x48697 (or $x45123 $x44857 $x44859 $x45352 $x45377 $x48298 $x48688 $x48313 $x45350 $x48691 $x48696)))
 (let (($x48759 (or $x48756 $x48697)))
 (let (($x48712 (or $x45123 $x44857 $x44859 $x45352 $x45377 $x48298 $x48308 $x48313 $x45350 $x48691 $x48696)))
 (let (($x48760 (or $x48756 $x48712)))
 (let (($x48744 (= $x48697 $x48712)))
 (let ((@x48747 (trans (monotonicity (rewrite (= $x48688 $x48308)) $x48744) (rewrite (= $x48712 $x48712)) $x48744)))
 (let ((@x48767 (trans (monotonicity @x48747 (= $x48759 $x48760)) (rewrite (= $x48760 $x48758)) (= $x48759 $x48758))))
 (let ((@x48770 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44052 ?x44043) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44067 ?x44065 ?x1876 $)) $x48759) @x48767 $x48758)))
 (let ((@x49172 (unit-resolution @x48770 @x175 @x49169 @x47457 @x47496 @x48647 @x49153 @x49170 @x48654 @x48350 @x48588 (unit-resolution @x48934 @x49144 $x48932) $x48696)))
 (let (($x49052 (= ?x49044 ?x48694)))
 (let (($x48400 (= ?x48694 ?x49044)))
 (let (($x48935 (has_type ?x48694 INT)))
 (let (($x49045 (has_type ?x49044 INT)))
 (let (($x49058 (not $x49045)))
 (let (($x49056 (= $x48935 $x49045)))
 (let (($x49054 (= $x49045 $x48935)))
 (let ((@x49057 (symm (monotonicity (monotonicity (symm @x49047 (= ?x48937 ?x48693)) $x49052) $x49054) $x49056)))
 (let ((@x49061 (mp (hypothesis (not $x48935)) (monotonicity @x49057 (= (not $x48935) $x49058)) $x49058)))
 (let ((@x49063 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x48694)) (or (not $x698) $x49045)) @x9117 $x49045) @x49061 false)))
 (let ((@x49064 (lemma @x49063 $x48935)))
 (let (($x48936 (not $x48935)))
 (let (($x48430 (or $x48392 $x48936 $x48400)))
 (let ((@x48393 (mp ((_ quant-inst (I ?x48693)) (or $x48392 (or $x48936 $x48400))) (rewrite (= (or $x48392 (or $x48936 $x48400)) $x48430)) $x48430)))
 (let ((@x49129 (symm (unit-resolution @x48393 @x8998 @x49064 $x48400) $x49052)))
 (let ((@x49180 (trans* (monotonicity @x48577 @x49129 (= ?x48826 ?x48695)) (symm @x49172 (= ?x48695 ?x48692)) (monotonicity @x48657 (= ?x48692 ?x45341)) (= ?x48826 ?x45341))))
 (let ((@x49183 (monotonicity @x49180 (monotonicity @x49162 (= ?x48827 ?x45342)) (= $x48828 (= ?x45341 ?x45342)))))
 (let ((@x49189 (symm (trans @x49183 (commutativity (= (= ?x45341 ?x45342) $x45343)) (= $x48828 $x45343)) (= $x45343 $x48828))))
 (let ((@x49193 (mp (unit-resolution (def-axiom (or $x45404 (not $x45343))) @x49143 (not $x45343)) (monotonicity @x49189 (= (not $x45343) $x49190)) $x49190)))
 (let ((?x48771 (%I ?x49044)))
 (let (($x48772 (>= ?x48771 0)))
 (let ((?x49027 (+ ?x48771 ?x49020)))
 (let (($x49025 (>= ?x49027 0)))
 (let (($x49017 (= ?x48771 ?x49019)))
 (let ((@x49051 (symm @x49047 (= ?x48937 ?x48693))))
 (let ((@x49136 (trans* (monotonicity @x49129 (= ?x48771 ?x48937)) @x49051 (symm @x49133 (= ?x48693 ?x49019)) $x49017)))
 (let ((@x49140 ((_ th-lemma arith farkas -1 1 -1 1) (hypothesis $x45349) (hypothesis (not $x48772)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49017) $x49025)) @x49136 $x49025) @x49122 false)))
 (let ((@x49142 (lemma @x49140 (or $x48772 $x45350))))
 (let (($x14363 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13864 (not $x821)))
 (let (($x4282 (sized A&.)))
 (let (($x14004 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x14332 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x13968 (not $x4256)))
 (or $x13968 $x14332 $x271 $x14004 $x13864 $x4552 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x4992 (fuel_bool fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x45523 (= $x4992 $x1593)))
 (let ((@x45525 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index1.) (or (not $x30) $x45523)) @x45233 (hypothesis (not $x45523)) false)))
 (let ((@x45537 (lemma @x45525 $x45523)))
 (let ((@x45530 (def-axiom (or (not $x45523) $x4992 $x13314))))
 (let ((@x49200 (unit-resolution @x45530 (unit-resolution (def-axiom (or $x13316 $x1593)) @x48560 $x1593) (or (not $x45523) $x4992))))
 (let (($x5013 (not $x4992)))
 (let (($x14368 (or $x5013 $x14363)))
 (let (($x5037 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5022 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5042 (or $x5013 $x5037)))
 (let ((?x11080 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (refl (~ $x5032 $x5032)))))))))))))))))))))
 ))
 (let ((@x11085 (monotonicity (refl (~ $x5013 $x5013)) (nnf-pos (proof-bind ?x11080) (~ $x5037 $x5037)) (~ $x5042 $x5042))))
 (let (($x5002 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4282 (sized A&.)))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x4995) $x4998))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5003 (=> $x4992 $x5002)))
 (let ((?x5038 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x5000 (=> (and $x4994 $x4995) $x4998)))
 (let ((@x5009 (monotonicity (rewrite (= $x4531 (and $x821 $x4555))) (= $x4995 (and $x4282 (and $x821 $x4555))))))
 (let ((@x5018 (trans @x5009 (rewrite (= (and $x4282 (and $x821 $x4555)) $x5010)) (= $x4995 $x5010))))
 (let ((@x5027 (trans (monotonicity @x5018 (= $x4999 (=> $x5010 $x4998))) (rewrite (= (=> $x5010 $x4998) (or $x5022 $x4998))) (= $x4999 (or $x5022 $x4998)))))
 (trans (monotonicity @x5027 (= $x5000 (=> $x4994 (or $x5022 $x4998)))) (rewrite (= (=> $x4994 (or $x5022 $x4998)) $x5032)) (= $x5000 $x5032)))))))))))))))))))))))))))))
 ))
 (let ((@x5011 (monotonicity (quant-intro (proof-bind ?x5038) (= $x5002 $x5037)) (= $x5003 (=> $x4992 $x5037)))))
 (let ((@x5047 (mp (asserted $x5003) (trans @x5011 (rewrite (= (=> $x4992 $x5037) $x5042)) (= $x5003 $x5042)) $x5042)))
 (let ((@x14370 (mp (mp (mp~ @x5047 @x11085 $x5042) (rewrite (= $x5042 $x5042)) $x5042) (rewrite (= $x5042 $x14368)) $x14368)))
 (let (($x48821 (not $x48772)))
 (let (($x48907 (not $x14363)))
 (let (($x48908 (or $x48907 $x45380 $x48354 $x49058 $x45377 $x48821 $x48898 $x48828)))
 (let ((?x48822 (+ ?x48771 ?x45365)))
 (let (($x48823 (>= ?x48822 0)))
 (let (($x48829 (or $x45380 $x48354 $x49058 $x45377 $x48821 $x48823 $x48828)))
 (let (($x48884 (or $x48907 $x48829)))
 (let ((@x48880 (rewrite (= (or $x48907 (or $x45380 $x48354 $x49058 $x45377 $x48821 $x48898 $x48828)) $x48908))))
 (let (($x48901 (or $x45380 $x48354 $x49058 $x45377 $x48821 $x48898 $x48828)))
 (let (($x48902 (= $x48829 $x48901)))
 (let ((@x48892 (rewrite (= ?x48822 (+ ?x45365 ?x48771)))))
 (let ((@x48900 (trans (monotonicity @x48892 (= $x48823 (>= (+ ?x45365 ?x48771) 0))) (rewrite (= (>= (+ ?x45365 ?x48771) 0) $x48898)) (= $x48823 $x48898))))
 (let ((@x48878 (monotonicity (trans (monotonicity @x48900 $x48902) (rewrite (= $x48901 $x48901)) $x48902) (= $x48884 (or $x48907 $x48901)))))
 (let ((@x49204 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1) (Poly%vstd!seq.Seq<u8.>. ?x44044) (I ?x48937)) $x48884) (trans @x48878 @x48880 (= $x48884 $x48908)) $x48908) @x175 (unit-resolution @x14370 (unit-resolution @x49200 @x45537 $x4992) $x14363) @x48572 @x48557 (or $x49058 $x48821 $x48898 $x48828))))
 (let ((@x49205 (unit-resolution @x49204 (unit-resolution @x49142 @x49170 $x48772) (mp @x49064 (symm (monotonicity @x49129 $x49054) $x49056) $x49045) @x49193 $x48898)))
 (let (($x49030 (<= ?x49027 0)))
 (let ((@x49209 ((_ th-lemma arith farkas -1 1 1 1) @x49148 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49017) $x49030)) @x49136 $x49030) @x49205 @x49144 false)))
 (let ((@x49210 (lemma @x49209 $x45404)))
 (let (($x45357 (not $x45356)))
 (let (($x45392 (or $x44068 $x45357 $x45410)))
 (let (($x45400 (not $x45392)))
 (let (($x45369 (forall ((i$ Poly) )(! (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x44060 (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44066 (vstd!view.View.view.? $ ?x1878 ?x44060)))
 (let ((?x44067 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7829 ?x7831)))
 (let ((?x45362 (vstd!seq.Seq.index.? $ ?x1876 ?x44067 i$)))
 (let ((?x44065 (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1)))
 (let ((?x45360 (vstd!seq.Seq.index.? $ ?x1876 ?x44065 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13864 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13864 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x44065))) 0) (= ?x45360 ?x45362)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. crc_bytes@1)) (I pmemlog!logimpl_v.header_crc_offset.?) (I (Add pmemlog!logimpl_v.header_crc_offset.? 8))) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x45370 (not $x45369)))
 (let (($x45371 (or $x45357 $x45370)))
 (let (($x45372 (not $x45371)))
 (let (($x44332 (not $x44068)))
 (let (($x45373 (or $x44332 $x45372)))
 (let (($x45374 (not $x45373)))
 (let (($x45411 (or $x45374 $x45400)))
 (let (($x45397 (not $x45411)))
 (let (($x44860 (has_type ?x44067 ?x1968)))
 (let (($x44818 (has_type ?x44066 ?x1968)))
 (let (($x44820 (not $x44818)))
 (let (($x44861 (or $x44820 $x44857 $x44859 $x44860)))
 (let (($x44865 (or $x44864 $x44820 $x44857 $x44859 $x44860)))
 (let ((@x44870 (mp ((_ quant-inst $ (UINT 8) (vstd!view.View.view.? $ ?x1878 ?x44060) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830)) (or $x44864 $x44861)) (rewrite (= (or $x44864 $x44861) $x44865)) $x44865)))
 (let ((@x49728 (unit-resolution (unit-resolution @x44870 @x14003 $x44861) (mp @x48635 @x48640 $x44818) (or $x44857 $x44859 $x44860))))
 (let (($x45378 (not $x44860)))
 (let (($x45389 (or $x45388 $x45380 $x45378 $x45377 $x45397)))
 (let (($x45358 (or $x44068 $x45357 (not (or $x45352 $x45350 (<= (+ ?x45346 (* (- 1) ?x45344)) 0) $x45343)))))
 (let (($x45376 (not (or $x45374 (not $x45358)))))
 (let (($x45381 (or $x45380 $x45378 $x45377 $x45376)))
 (let (($x45390 (or $x45388 $x45381)))
 (let (($x45382 (or $x45380 $x45378 $x45377 $x45397)))
 (let (($x45383 (= $x45381 $x45382)))
 (let ((@x45387 (trans (monotonicity (rewrite (= $x45376 $x45397)) $x45383) (rewrite (= $x45382 $x45382)) $x45383)))
 (let ((@x45396 (trans (monotonicity @x45387 (= $x45390 (or $x45388 $x45382))) (rewrite (= (or $x45388 $x45382) $x45389)) (= $x45390 $x45389))))
 (let ((@x45405 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7829 ?x7831)) $x45390) @x45396 $x45389)))
 (let ((@x49730 (unit-resolution (unit-resolution @x45405 @x175 @x49679 (or $x45380 $x45378 $x45397)) (unit-resolution @x49728 @x47496 @x47457 $x44860) @x48572 $x45397)))
 (let ((@x45445 (def-axiom (or $x45411 $x45392))))
 (let ((@x45441 (def-axiom (or $x45400 $x44068 $x45357 $x45410))))
 (let ((@x49736 (unit-resolution (unit-resolution @x45441 (unit-resolution @x45445 @x49730 $x45392) $x45392) @x48675 (or $x44068 $x45410))))
 (let ((@x49737 (unit-resolution @x49736 @x49210 $x44068)))
 (let ((@x44159 (not-or-elim @x44165 $x44069)))
 (let ((@x44336 (unit-resolution (def-axiom (or tmp%3 $x44332 $x44139)) @x44159 (or tmp%3 $x44332))))
 (let ((@x44344 (def-axiom (or $x44129 $x44157))))
 (let (($x44192 (not $x44129)))
 (let (($x44135 (or $x44192 $x44134)))
 (let (($x44219 (or $x44193 (not (or (or $x44179 $x44170) (not (or (or $x44176 $x44177) (or $x44178 $x44182))))))))
 (let (($x44230 (not $x44219)))
 (let (($x44224 (or $x44157 $x44143)))
 (let (($x44225 (or $x44224 $x44230)))
 (let (($x44237 (or $x44192 (not $x44225))))
 (let ((@x44189 (monotonicity (rewrite (= $x44129 $x44129)) (rewrite (= $x44158 $x44202)) (= $x44164 (and $x44129 $x44202)))))
 (let ((@x44201 (trans @x44189 (rewrite (= (and $x44129 $x44202) (not $x44135))) (= $x44164 (not $x44135)))))
 (let ((@x44210 (trans (monotonicity @x44201 (= (not $x44164) (not (not $x44135)))) (rewrite (= (not (not $x44135)) $x44135)) (= (not $x44164) $x44135))))
 (let (($x44160 (not $x44164)))
 (let ((@x44163 (mp (not-or-elim @x44165 $x44160) (monotonicity (rewrite (= $x44164 $x44164)) (= $x44160 $x44160)) $x44160)))
 (let ((@x44265 (mp (mp (mp @x44163 @x44210 $x44135) (rewrite (= $x44135 $x44237)) $x44237) (rewrite (= $x44237 $x44135)) $x44135)))
 (let ((@x49791 (unit-resolution @x44265 (unit-resolution @x44344 (unit-resolution @x44336 @x49737 tmp%3) $x44129) $x44134)))
 (let ((@x44458 (def-axiom (or $x44202 $x44076))))
 (let ((@x44349 (def-axiom (or $x44143 tmp%4 (not $x44075)))))
 (let ((@x49698 (unit-resolution @x44349 (unit-resolution @x44458 @x49791 $x44076) (or tmp%4 (not $x44075)))))
 (let ((@x44359 (def-axiom (or $x44133 $x44179))))
 (let ((@x44454 (def-axiom (or $x44196 $x44193 $x44194))))
 (let ((@x49931 (unit-resolution @x44454 (unit-resolution (def-axiom (or $x44202 $x44195)) @x49791 $x44195) $x44195)))
 (let ((@x49932 (unit-resolution @x49931 (unit-resolution @x44359 (unit-resolution @x49698 @x49732 tmp%4) $x44133) $x44194)))
 (let ((@x44444 (def-axiom (or $x44187 $x44080))))
 (let ((@x49938 (monotonicity (monotonicity (unit-resolution @x44444 @x49932 $x44080) (= ?x44082 ?x44060)) (= ?x44083 ?x44066))))
 (let ((@x49989 (trans* (monotonicity @x49938 (= ?x44093 ?x44074)) (symm @x49983 (= ?x44074 ?x47246)) @x48490 (= ?x44093 ?x44043))))
 (let ((@x50020 (monotonicity @x49989 (= ?x44094 ?x44650))))
 (let ((@x50078 (monotonicity (trans* @x50020 (symm @x49979 (= ?x44650 ?x44324)) @x48471 (= ?x44094 ?x44032)) (= ?x44095 ?x44096))))
 (let ((@x50084 (monotonicity (trans* @x50074 (symm @x50078 (= ?x44096 ?x44095)) (= ?x44948 ?x44095)) @x50074 (= $x49431 $x44097))))
 (let ((@x49945 (trans* (monotonicity (trans* @x49938 @x48636 (= ?x44083 ?x44806)) (= ?x44100 ?x48309)) @x48581 @x48575 (symm @x48546 (= ?x48365 ?x48364)) @x48539 @x48441 @x47691 $x44101)))
 (let ((@x44428 (def-axiom (or $x44149 (not $x44101)))))
 (let ((?x44292 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44031)))
 (let ((?x44291 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44031)))
 (let ((?x44293 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44291 ?x44292)))
 (let ((?x44662 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x44293)))
 (let ((@x47847 (symm (monotonicity ((_ th-lemma datatype) (= ?x44031 ?x44293)) (= ?x44037 ?x44662)) (= ?x44662 ?x44037))))
 (let (($x44666 (= ?x44662 ?x44291)))
 (let (($x2664 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc x)))
 (= ?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc x))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc x) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc_accessor_definition))
 ))
 (let ((?x9906 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc x)))
 (let (($x2662 (= ?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc x))))
 (refl (~ $x2662 $x2662)))))
 ))
 (let ((@x9910 (mp~ (asserted $x2664) (nnf-pos (proof-bind ?x9906) (~ $x2664 $x2664)) $x2664)))
 (let (($x44698 (not $x2664)))
 (let (($x44700 (or $x44698 $x44666)))
 (let ((?x44306 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44293)))
 (let (($x44664 (= ?x44662 ?x44306)))
 (let (($x44701 (or $x44698 $x44664)))
 (let (($x44703 (= $x44701 $x44700)))
 (let ((@x44707 (trans (monotonicity (rewrite (= $x44664 $x44666)) $x44703) (rewrite (= $x44700 $x44700)) $x44703)))
 (let ((@x44708 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44291 ?x44292)) $x44701) @x44707 $x44700)))
 (let ((@x47845 (symm (unit-resolution @x44708 @x9910 $x44666) (= ?x44291 ?x44662))))
 (let ((?x45193 (I ?x44291)))
 (let ((?x45209 (%I ?x45193)))
 (let (($x45212 (= ?x44291 ?x45209)))
 (let (($x45211 (or $x44893 $x45212)))
 (let (($x45192 (= ?x44306 (%I (I ?x44306)))))
 (let (($x45213 (or $x44893 $x45192)))
 (let (($x45217 (= $x45213 $x45211)))
 (let ((@x45221 (trans (monotonicity (rewrite (= $x45192 $x45212)) $x45217) (rewrite (= $x45211 $x45211)) $x45217)))
 (let ((@x45222 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44293)) $x45213) @x45221 $x45211)))
 (let ((@x49947 (unit-resolution @x45222 @x8977 $x45212)))
 (let ((@x47849 (trans* @x47845 @x47847 (= ?x44291 ?x44037))))
 (let ((@x47851 (monotonicity @x47849 (= ?x45193 ?x44709))))
 (let ((@x49972 (monotonicity (symm @x47851 (= ?x44709 ?x45193)) (= (%I ?x44709) ?x45209))))
 (let ((?x45186 (%I ?x44709)))
 (let ((?x45181 (Poly%vstd!seq.Seq<u8.>. ?x44710)))
 (let ((?x45185 (vstd!bytes.spec_u64_from_le_bytes.? ?x45181)))
 (let (($x45187 (= ?x45185 ?x45186)))
 (let (($x45188 (not $x45187)))
 (let ((?x45182 (vstd!seq.Seq.len.? $ ?x1876 ?x45181)))
 (let (($x45183 (= ?x45182 8)))
 (let (($x45184 (not $x45183)))
 (let (($x45189 (or $x45184 $x45188)))
 (let (($x45190 (not $x45189)))
 (let ((?x4023 (UINT 64)))
 (let (($x45173 (has_type ?x44709 ?x4023)))
 (let (($x47818 (has_type ?x45193 ?x4023)))
 (let (($x47856 (not $x47818)))
 (let ((@x47858 (monotonicity (symm (monotonicity @x47851 (= $x47818 $x45173)) (= $x45173 $x47818)) (= (not $x45173) $x47856))))
 (let (($x45042 (uInv 64 ?x44291)))
 (let ((@x47864 (symm (monotonicity @x47849 (= $x45042 (uInv 64 ?x44037))) (= (uInv 64 ?x44037) $x45042))))
 (let (($x44494 (uInv 64 ?x44037)))
 (let (($x2675 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2666 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x2620)))
 (let (($x2667 (uInv 64 ?x2666)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (or $x2627 $x2667)))))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc (%Poly%pmemlog!logimpl_v.PersistentHeader. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc_invariant_definition))
 ))
 (let ((?x9913 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2666 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x2620)))
 (let (($x2667 (uInv 64 ?x2666)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2672 (or $x2627 $x2667)))
 (refl (~ $x2672 $x2672)))))))))
 ))
 (let (($x2670 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2666 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x2620)))
 (let (($x2667 (uInv 64 ?x2666)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (=> $x2619 $x2667))))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc (%Poly%pmemlog!logimpl_v.PersistentHeader. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc_invariant_definition))
 ))
 (let ((?x2676 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2666 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x2620)))
 (let (($x2667 (uInv 64 ?x2666)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2672 (or $x2627 $x2667)))
 (let (($x2668 (=> $x2619 $x2667)))
 (rewrite (= $x2668 $x2672))))))))))
 ))
 (let ((@x2680 (mp (asserted $x2670) (quant-intro (proof-bind ?x2676) (= $x2670 $x2675)) $x2675)))
 (let ((@x9917 (mp~ @x2680 (nnf-pos (proof-bind ?x9913) (~ $x2675 $x2675)) $x2675)))
 (let (($x44505 (not $x2675)))
 (let (($x44506 (or $x44505 $x44491 $x44494)))
 (let ((@x44511 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeader. header!)) (or $x44505 (or $x44491 $x44494))) (rewrite (= (or $x44505 (or $x44491 $x44494)) $x44506)) $x44506)))
 (let (($x766 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (or $x762 $x757)))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x9141 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (refl (~ $x763 $x763)))))))))
 ))
 (let (($x760 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (=> $x648 $x757))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x767 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (let (($x758 (=> $x648 $x757)))
 (rewrite (= $x758 $x763))))))))))
 ))
 (let ((@x771 (mp (asserted $x760) (quant-intro (proof-bind ?x767) (= $x760 $x766)) $x766)))
 (let ((@x9145 (mp~ @x771 (nnf-pos (proof-bind ?x9141) (~ $x766 $x766)) $x766)))
 (let (($x45072 (not $x45042)))
 (let (($x47824 (not $x766)))
 (let (($x47826 (or $x47824 $x45072 $x47818)))
 (let ((?x45194 (I ?x44306)))
 (let (($x47803 (has_type ?x45194 ?x4023)))
 (let (($x45013 (uInv 64 ?x44306)))
 (let (($x47802 (not $x45013)))
 (let (($x47816 (or $x47802 $x47803)))
 (let (($x47827 (or $x47824 $x47816)))
 (let ((@x47831 (monotonicity (rewrite (= $x47816 (or $x45072 $x47818))) (= $x47827 (or $x47824 (or $x45072 $x47818))))))
 (let ((@x47835 (trans @x47831 (rewrite (= (or $x47824 (or $x45072 $x47818)) $x47826)) (= $x47827 $x47826))))
 (let ((@x47866 (unit-resolution (mp ((_ quant-inst 64 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44293)) $x47827) @x47835 $x47826) @x9145 (mp (unit-resolution @x44511 @x9917 @x44028 $x44494) @x47864 $x45042) $x47818)))
 (let ((@x47868 (lemma (unit-resolution @x47866 (mp (hypothesis (not $x45173)) @x47858 $x47856) false) $x45173)))
 (let (($x45174 (not $x45173)))
 (let (($x45191 (or $x45174 $x45190)))
 (let (($x14888 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14882 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14882)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11651 (not $x6172)))
 (let (($x14895 (not $x14888)))
 (let (($x14896 (or $x14895 $x11651)))
 (let (($x14897 (not $x14896)))
 (let (($x44558 (or $x44156 $x14897)))
 (let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let (($x14906 (not $x11631)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let (($x14904 (not $x11628)))
 (let (($x14907 (or $x14904 $x14906)))
 (let (($x14908 (not $x14907)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x14911 (or $x11624 $x14908)))
 (let (($x14909 (not $x14911)))
 (let (($x44523 (or $x44029 $x14909 $x11650)))
 (let (($x44524 (not $x44523)))
 (let (($x44559 (not $x44558)))
 (let (($x44560 (or $x44559 $x44524)))
 (let (($x44561 (not $x44560)))
 (let (($x14932 (forall ((no%param Int) )(! (let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let (($x14906 (not $x11631)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let (($x14904 (not $x11628)))
 (let (($x14907 (or $x14904 $x14906)))
 (let (($x14908 (not $x14907)))
 (let ((?x4023 (UINT 64)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x14911 (or $x11624 $x14908)))
 (let (($x14909 (not $x14911)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x14912 (or $x6127 $x14909 $x11650)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11651 (not $x6172)))
 (let (($x14888 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14882 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14882)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14895 (not $x14888)))
 (let (($x14896 (or $x14895 $x11651)))
 (let (($x14897 (not $x14896)))
 (let (($x11605 (not $x6127)))
 (let (($x14902 (or $x11605 $x14897)))
 (not (or (not $x14902) (not $x14912))))))))))))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let (($x11681 (forall ((no%param Int) )(! (let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x11634 (not (or $x11624 (and $x11628 $x11631)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x11683 (or $x6127 $x11634 $x11650)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11605 (not $x6127)))
 (let (($x11659 (or $x11605 $x6177)))
 (and $x11659 $x11683))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x14933 (lambda ((no%param Int) )(let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let (($x14906 (not $x11631)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let (($x14904 (not $x11628)))
 (let (($x14907 (or $x14904 $x14906)))
 (let (($x14908 (not $x14907)))
 (let ((?x4023 (UINT 64)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x14911 (or $x11624 $x14908)))
 (let (($x14909 (not $x14911)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x14912 (or $x6127 $x14909 $x11650)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11651 (not $x6172)))
 (let (($x14888 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14882 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14882)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14895 (not $x14888)))
 (let (($x14896 (or $x14895 $x11651)))
 (let (($x14897 (not $x14896)))
 (let (($x11605 (not $x6127)))
 (let (($x14902 (or $x11605 $x14897)))
 (let (($x14927 (not (or (not $x14902) (not $x14912)))))
 (let (($x11634 (not (or $x11624 (and $x11628 $x11631)))))
 (let (($x11683 (or $x6127 $x11634 $x11650)))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11659 (or $x11605 $x6177)))
 (let (($x11687 (and $x11659 $x11683)))
 (let (($x14914 (= $x11683 $x14912)))
 (let ((@x14920 (trans (monotonicity (rewrite (= $x11634 $x14909)) (rewrite (= $x11650 $x11650)) $x14914) (rewrite (= $x14912 $x14912)) $x14914)))
 (trans (monotonicity (rewrite (= $x11659 $x14902)) @x14920 (= $x11687 (and $x14902 $x14912))) (rewrite (= (and $x14902 $x14912) $x14927)) (= $x11687 $x14927))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x11663 (forall ((no%param Int) )(! (let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x11634 (not (or $x11624 (and $x11628 $x11631)))))
 (let (($x11654 (or $x11634 $x11650)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11605 (not $x6127)))
 (let (($x11659 (or $x11605 $x6177)))
 (and $x11659 (or $x6127 $x11654)))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x11682 (lambda ((no%param Int) )(let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x11634 (not (or $x11624 (and $x11628 $x11631)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x11683 (or $x6127 $x11634 $x11650)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11605 (not $x6127)))
 (let (($x11659 (or $x11605 $x6177)))
 (let (($x11687 (and $x11659 $x11683)))
 (let (($x11660 (and $x11659 (or $x6127 (or $x11634 $x11650)))))
 (rewrite (= $x11660 $x11687)))))))))))))))))))))))))))))))))))))
 ))
 (let (($x6178 (forall ((no%param Int) )(! (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 $x6177))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x11664 (lambda ((no%param Int) )(let ((?x11647 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11644 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11645 (I ?x11644)))
 (let ((?x11646 (vstd!bytes.spec_u64_to_le_bytes.? ?x11645)))
 (let (($x11648 (= ?x11646 ?x11647)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11641 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11642 (= ?x11641 8)))
 (let (($x11643 (not $x11642)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11639 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11640 (not $x11639)))
 (let (($x11649 (or $x11640 $x11643 $x11648)))
 (let (($x11650 (not $x11649)))
 (let ((?x11630 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11625 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11626 (Poly%vstd!seq.Seq<u8.>. ?x11625)))
 (let ((?x11629 (vstd!bytes.spec_u64_from_le_bytes.? ?x11626)))
 (let (($x11631 (= ?x11629 ?x11630)))
 (let ((?x11627 (vstd!seq.Seq.len.? $ ?x1876 ?x11626)))
 (let (($x11628 (= ?x11627 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11623 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11624 (not $x11623)))
 (let (($x11634 (not (or $x11624 (and $x11628 $x11631)))))
 (let (($x11654 (or $x11634 $x11650)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11605 (not $x6127)))
 (let (($x11659 (or $x11605 $x6177)))
 (let (($x11660 (and $x11659 (or $x6127 $x11654))))
 (let (($x6161 (= $x6127 $x6177)))
 (let ((@x11657 (nnf-neg (sk (~ (not $x6155) $x11634)) (sk (~ (not $x6172) $x11650)) (~ (not $x6177) $x11654))))
 (let ((?x11616 (lambda ((s$ Poly) )(let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x6167 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))
 (refl (~ $x6167 $x6167)))))))))))
 ))
 (let ((?x11610 (lambda ((x$ Poly) )(let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (let (($x6152 (or $x6151 $x6135)))
 (refl (~ $x6152 $x6152)))))))))))))
 ))
 (let ((@x11621 (monotonicity (nnf-pos (proof-bind ?x11610) (~ $x6155 $x6155)) (nnf-pos (proof-bind ?x11616) (~ $x6172 $x6172)) (~ $x6177 $x6177))))
 (nnf-pos (refl (~ $x6127 $x6127)) (refl (~ $x11605 $x11605)) @x11621 @x11657 (~ $x6161 $x11660)))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x6149 (forall ((no%param Int) )(! (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 (and $x6138 $x6145))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x6180 (lambda ((no%param Int) )(let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6161 (= $x6127 $x6177)))
 (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6147 (= $x6127 (and $x6138 $x6145))))
 (rewrite (= $x6147 $x6161)))))))))))
 ))
 (let ((@x6168 (mp (asserted $x6149) (quant-intro (proof-bind ?x6180) (= $x6149 $x6178)) $x6178)))
 (let ((@x11673 (mp (mp~ @x6168 (nnf-pos (proof-bind ?x11664) (~ $x6178 $x11663)) $x11663) (quant-intro (proof-bind ?x11682) (= $x11663 $x11681)) $x11681)))
 (let ((@x14887 (mp @x11673 (quant-intro (proof-bind ?x14933) (= $x11681 $x14932)) $x14932)))
 (let (($x44566 (or (not $x14932) $x44561)))
 (let ((@x44565 ((_ quant-inst 0) $x44566)))
 (let ((@x44619 (def-axiom (or $x44560 $x44558))))
 (let ((@x44167 (not-or-elim @x44165 $x44029)))
 (let ((@x44588 (def-axiom (or $x44559 $x44156 $x14897))))
 (let ((@x49954 (unit-resolution (unit-resolution @x44588 @x44167 (or $x44559 $x14897)) (unit-resolution @x44619 (unit-resolution @x44565 @x14887 $x44561) $x44558) $x14897)))
 (let ((@x44580 (def-axiom (or $x14896 $x14888))))
 (let (($x45195 (or $x14895 $x45174 $x45190)))
 (let ((@x45201 (mp ((_ quant-inst (I ?x44037)) (or $x14895 $x45191)) (rewrite (= (or $x14895 $x45191) $x45195)) $x45195)))
 (let ((@x49957 (unit-resolution (unit-resolution @x45201 (unit-resolution @x44580 @x49954 $x14888) $x45191) @x47868 $x45190)))
 (let ((@x45205 (def-axiom (or $x45189 $x45187))))
 (let ((@x49958 (unit-resolution @x45205 @x49957 $x45187)))
 (let (($x44817 (= ?x44065 ?x44067)))
 (let (($x44819 (= $x44817 $x44068)))
 (let (($x44822 (or $x44821 $x44819)))
 (let ((@x44845 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. old_crc_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44066 ?x7829 ?x7831)) $x44822)))
 (let ((@x44848 (def-axiom (or (not $x44819) $x44817 $x44332))))
 (let ((@x49962 (unit-resolution (unit-resolution @x44848 (unit-resolution @x44845 @x9061 $x44819) (or $x44817 $x44332)) @x49737 $x44817)))
 (let ((@x49968 (trans* (monotonicity @x49938 (= ?x44088 ?x44067)) (symm @x49962 (= ?x44067 ?x44065)) @x48531 (= ?x44088 ?x45181))))
 (let ((@x49970 (monotonicity @x49968 (= ?x44089 ?x45185))))
 (let ((@x44403 (def-axiom (or $x44141 (not $x44090)))))
 (let ((@x49976 (unit-resolution @x44403 (trans* @x49970 @x49958 @x49972 (symm @x49947 (= ?x45209 ?x44291)) @x47845 @x47847 $x44090) $x44141)))
 (let ((?x44363 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44084)))
 (let ((?x44362 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44084)))
 (let ((?x44364 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44362 ?x44363)))
 (let ((@x50007 (symm ((_ th-lemma datatype) (= ?x44084 ?x44364)) (= ?x44364 ?x44084))))
 (let ((?x44379 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44364)))
 (let (($x47721 (= ?x44379 ?x44363)))
 (let ((?x47031 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44095)))
 (let ((?x47042 (I ?x44089)))
 (let ((?x47015 (%I ?x47042)))
 (let ((?x47047 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x47015 ?x47031)))
 (let ((?x47068 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x47047)))
 (let (($x47048 (= ?x44084 ?x47047)))
 (let (($x7845 (forall ((header_seq! Poly) )(! (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7837 (pmemlog!logimpl_v.spec_bytes_to_metadata.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7834 ?x7835))))
 (let ((?x7841 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7837))))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7833 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7829 ?x7831))))
 (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (= ?x7828 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I ?x7833)) ?x7841)))))))))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_definition))
 ))
 (let (($x7827 (fuel_bool fuel%pmemlog!logimpl_v.spec_bytes_to_header.)))
 (let (($x7825 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_bytes_to_header.)))
 (let (($x47026 (= $x7827 $x7825)))
 (let ((@x47043 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_bytes_to_header.) (or (not $x30) $x47026)) @x45233 (hypothesis (not $x47026)) false)))
 (let ((@x47056 (lemma @x47043 $x47026)))
 (let ((@x7826 (asserted $x7825)))
 (let ((@x47034 (def-axiom (or (not $x47026) $x7827 (not $x7825)))))
 (let ((@x50001 (unit-resolution (unit-resolution @x47034 @x7826 (or (not $x47026) $x7827)) @x47056 $x7827)))
 (let (($x7848 (not $x7827)))
 (let (($x7849 (or $x7848 $x7845)))
 (let ((?x12454 (lambda ((header_seq! Poly) )(let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7837 (pmemlog!logimpl_v.spec_bytes_to_metadata.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7834 ?x7835))))
 (let ((?x7841 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7837))))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7833 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7829 ?x7831))))
 (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7843 (= ?x7828 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I ?x7833)) ?x7841))))
 (refl (~ $x7843 $x7843))))))))))))))
 ))
 (let ((@x12459 (monotonicity (refl (~ $x7848 $x7848)) (nnf-pos (proof-bind ?x12454) (~ $x7845 $x7845)) (~ $x7849 $x7849))))
 (let ((@x7852 (mp (asserted (=> $x7827 $x7845)) (rewrite (= (=> $x7827 $x7845) $x7849)) $x7849)))
 (let ((@x12463 (mp (mp~ @x7852 @x12459 $x7849) (rewrite (= $x7849 $x7849)) $x7849)))
 (let (($x47052 (or (not $x7845) $x47048)))
 (let ((@x47053 ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x44082)) $x47052)))
 (let ((@x50009 (trans* @x50007 (unit-resolution @x47053 (unit-resolution @x12463 @x50001 $x7845) $x47048) (= ?x44364 ?x47047))))
 (let ((?x44408 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x44094)))
 (let ((?x44407 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x44094)))
 (let ((?x44406 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44094)))
 (let ((?x44409 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44406 ?x44407 ?x44408)))
 (let ((?x47049 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44409)))
 (let ((?x47050 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x47049)))
 (let ((@x49995 (monotonicity (symm ((_ th-lemma datatype) (= ?x44094 ?x44409)) (= ?x44409 ?x44094)) (= ?x47049 ?x44095))))
 (let ((@x50032 (symm (monotonicity (symm @x49995 (= ?x44095 ?x47049)) (= ?x47031 ?x47050)) (= ?x47050 ?x47031))))
 (let (($x47081 (= ?x44409 ?x47050)))
 (let (($x2729 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_box_axiom_definition))
 ))
 (let ((?x9941 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2727 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))))
 (refl (~ $x2727 $x2727)))))
 ))
 (let ((@x9945 (mp~ (asserted $x2729) (nnf-pos (proof-bind ?x9941) (~ $x2729 $x2729)) $x2729)))
 (let (($x44984 (not $x2729)))
 (let (($x47084 (or $x44984 $x47081)))
 (let ((@x47085 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44406 ?x44407 ?x44408)) $x47084)))
 (let (($x44410 (= ?x44094 ?x44409)))
 (let ((@x49990 ((_ th-lemma datatype) $x44410)))
 (let ((?x44581 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x44293)))
 (let ((@x50028 (symm (monotonicity ((_ th-lemma datatype) (= ?x44031 ?x44293)) (= ?x44032 ?x44581)) (= ?x44581 ?x44032))))
 (let (($x44626 (= ?x44581 ?x44292)))
 (let (($x2685 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x)))
 (= ?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata x))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_accessor_definition))
 ))
 (let ((?x9920 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x)))
 (let (($x2683 (= ?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata x))))
 (refl (~ $x2683 $x2683)))))
 ))
 (let ((@x9924 (mp~ (asserted $x2685) (nnf-pos (proof-bind ?x9920) (~ $x2685 $x2685)) $x2685)))
 (let (($x44628 (not $x2685)))
 (let (($x44630 (or $x44628 $x44626)))
 (let ((?x44308 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44293)))
 (let (($x44584 (= ?x44581 ?x44308)))
 (let (($x44631 (or $x44628 $x44584)))
 (let (($x44633 (= $x44631 $x44630)))
 (let ((@x44637 (trans (monotonicity (rewrite (= $x44584 $x44626)) $x44633) (rewrite (= $x44630 $x44630)) $x44633)))
 (let ((@x44638 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44291 ?x44292)) $x44631) @x44637 $x44630)))
 (let ((@x50037 (trans* (symm (unit-resolution @x44638 @x9924 $x44626) (= ?x44292 ?x44581)) @x50028 @x48469 @x49979 (symm @x50020 (= ?x44650 ?x44094)) @x49990 (unit-resolution @x47085 @x9945 $x47081) @x50032 ((_ th-lemma datatype) (= ?x47031 ?x47068)) (symm (monotonicity @x50009 (= ?x44379 ?x47068)) (= ?x47068 ?x44379)) (symm ((_ th-lemma datatype) (= ?x44363 ?x44379)) $x47721) (= ?x44292 ?x44363))))
 (let (($x49349 (= ?x44291 ?x44362)))
 (let ((?x44377 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44364)))
 (let (($x47513 (= ?x44377 ?x44362)))
 (let ((@x50042 (monotonicity @x50009 (= ?x44377 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x47047)))))
 (let ((@x50054 (symm @x50042 (= (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x47047) ?x44377))))
 (let ((?x47066 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x47047)))
 (let (($x47067 (= ?x47015 ?x47066)))
 (let (($x47082 (= ?x44089 ?x47015)))
 (let (($x47098 (or $x44893 $x47082)))
 (let ((@x47099 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x44088)) $x47098)))
 (let ((@x50056 (trans* @x49947 (symm @x49972 (= ?x45209 ?x45186)) (symm @x49958 (= ?x45186 ?x45185)) (symm @x49970 (= ?x45185 ?x44089)) (unit-resolution @x47099 @x8977 $x47082) ((_ th-lemma datatype) $x47067) @x50054 (symm ((_ th-lemma datatype) (= ?x44362 ?x44377)) $x47513) $x49349)))
 (let (($x44294 (= ?x44031 ?x44293)))
 (let ((@x47839 ((_ th-lemma datatype) $x44294)))
 (let ((?x44274 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata header!)))
 (let ((?x44271 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc header!)))
 (let ((?x44249 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44271 ?x44274)))
 (let ((?x44513 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x44249)))
 (let ((?x44514 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x44513)))
 (let ((@x50061 (monotonicity (symm ((_ th-lemma datatype) (= header! ?x44249)) (= ?x44249 header!)) (= ?x44513 ?x44026))))
 (let (($x44522 (= ?x44249 ?x44514)))
 (let (($x2616 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2612 (Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x2612))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeader. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeader_box_axiom_definition))
 ))
 (let ((?x9885 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2612 (Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let (($x2614 (= x (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x2612))))
 (refl (~ $x2614 $x2614)))))
 ))
 (let ((@x9889 (mp~ (asserted $x2616) (nnf-pos (proof-bind ?x9885) (~ $x2616 $x2616)) $x2616)))
 (let (($x44525 (not $x2616)))
 (let (($x44526 (or $x44525 $x44522)))
 (let ((@x44527 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44271 ?x44274)) $x44526)))
 (let (($x44251 (= header! ?x44249)))
 (let ((@x50057 ((_ th-lemma datatype) $x44251)))
 (let ((@x50067 (trans* @x50057 (unit-resolution @x44527 @x9889 $x44522) (monotonicity @x50061 (= ?x44514 ?x44031)) @x47839 (monotonicity @x50056 @x50037 (= ?x44293 ?x44364)) @x50007 $x44085)))
 (let ((@x44396 (def-axiom (or $x44137 (not $x44085)))))
 (let ((@x44440 (def-axiom (or $x44184 $x44176 $x44177 $x44178 $x44182))))
 (let ((@x50069 (unit-resolution @x44440 (unit-resolution @x44396 @x50067 $x44137) @x49976 (unit-resolution @x44428 @x49945 $x44149) (unit-resolution (def-axiom (or $x44187 $x44183)) @x49932 $x44183) $x44178)))
 (let ((@x44421 (def-axiom (or $x44145 $x44419))))
 (let ((@x50090 (mp (unit-resolution @x44421 @x50069 $x44419) (monotonicity (symm @x50084 (= $x44097 $x49431)) (= $x44419 $x50087)) $x50087)))
 (let (($x49642 (or $x44821 $x49431)))
 (let (($x49688 (= ?x44948 ?x44948)))
 (let (($x49689 (= $x49688 $x49431)))
 (let (($x49665 (or $x44821 $x49689)))
 (let (($x49667 (= $x49665 $x49642)))
 (let ((@x49673 (trans (monotonicity (rewrite (= $x49688 true)) (= $x49689 (= true $x49431))) (rewrite (= (= true $x49431) $x49431)) (= $x49689 $x49431))))
 (let ((@x49674 (mp ((_ quant-inst false TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44940) (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44940)) $x49665) (trans (monotonicity @x49673 $x49667) (rewrite (= $x49642 $x49642)) $x49667) $x49642)))
 (unit-resolution (unit-resolution @x49674 @x9061 $x49431) @x50090 false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

