(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10550)
(:version "4.12.5")
unsat
((declare-fun k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38!15 () Poly)
(proof
(let ((?x44517 (vstd!seq.Seq.index.? T&. T& s2! k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38!15)))
 (let ((?x44516 (vstd!seq.Seq.index.? T&. T& s1! k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38!15)))
 (let (($x44551 (= ?x44516 ?x44517)))
 (let (($x44761 (not $x44551)))
 (let ((?x44544 (%I k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38!15)))
 (let ((?x44502 (* (- 1) ?x44544)))
 (let ((?x44573 (+ j! ?x44502)))
 (let (($x44574 (<= ?x44573 0)))
 (let ((?x44504 (+ i! ?x44502)))
 (let (($x44507 (<= ?x44504 0)))
 (let (($x44639 (not $x44507)))
 (let (($x44542 (has_type k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38!15 INT)))
 (let (($x44543 (not $x44542)))
 (let (($x44552 (not %%location_label%%3)))
 (let (($x44634 (forall ((k$ Poly) )(! (let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x44520 (>= (+ (%I k$) (* (- 1) j!)) 0)))
 (let (($x44511 (>= (+ (%I k$) (* (- 1) i!)) 0)))
 (let (($x44613 (not $x44511)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x44613 $x44520 $x44444))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_39))
 ))
 (let (($x44643 (not $x44634)))
 (let (($x44644 (or $x44643 $x44552 $x44543 $x44639 $x44574 $x44551)))
 (let (($x44645 (not $x44644)))
 (let ((?x44422 (vstd!seq.Seq.index.? T&. T& s2! k@)))
 (let ((?x44413 (vstd!seq.Seq.index.? T&. T& s1! k@)))
 (let (($x44429 (= ?x44413 ?x44422)))
 (let (($x44478 (not %%location_label%%2)))
 (let (($x44485 (not tmp%2)))
 (let (($x44486 (or $x44485 $x44478 $x44429)))
 (let (($x44577 (not $x44486)))
 (let (($x44460 (not %%location_label%%1)))
 (let (($x44461 (or $x44460 tmp%2)))
 (let (($x44576 (not $x44461)))
 (let (($x44578 (or $x44576 $x44577)))
 (let (($x44581 (not $x44578)))
 (let ((?x44408 (%I k@)))
 (let ((?x44414 (Sub ?x44408 i!)))
 (let ((?x44415 (I ?x44414)))
 (let ((?x44401 (I j!)))
 (let ((?x44400 (I i!)))
 (let ((?x44403 (vstd!seq.Seq.subrange.? T&. T& s2! ?x44400 ?x44401)))
 (let ((?x44423 (vstd!seq.Seq.index.? T&. T& ?x44403 ?x44415)))
 (let (($x44424 (= ?x44422 ?x44423)))
 (let (($x44425 (= tmp%2 $x44424)))
 (let (($x44482 (not $x44425)))
 (let (($x44493 (not tmp%1)))
 (let (($x44586 (or $x44493 $x44482 $x44581)))
 (let (($x44596 (not $x44586)))
 (let (($x44464 (not %%location_label%%0)))
 (let (($x44465 (or $x44464 tmp%1)))
 (let (($x44595 (not $x44465)))
 (let (($x44597 (or $x44595 $x44596)))
 (let (($x44598 (not $x44597)))
 (let ((?x44402 (vstd!seq.Seq.subrange.? T&. T& s1! ?x44400 ?x44401)))
 (let ((?x44416 (vstd!seq.Seq.index.? T&. T& ?x44402 ?x44415)))
 (let (($x44417 (= ?x44413 ?x44416)))
 (let (($x44418 (= tmp%1 $x44417)))
 (let (($x44480 (not $x44418)))
 (let ((?x44457 (* (- 1) ?x44408)))
 (let ((?x44466 (+ j! ?x44457)))
 (let (($x44467 (<= ?x44466 0)))
 (let ((?x44458 (+ i! ?x44457)))
 (let (($x44459 (<= ?x44458 0)))
 (let (($x44498 (not $x44459)))
 (let (($x44407 (has_type k@ INT)))
 (let (($x44505 (not $x44407)))
 (let (($x44606 (or $x44505 $x44498 $x44467 $x44480 $x44598)))
 (let (($x44404 (= ?x44402 ?x44403)))
 (let ((@x44405 (asserted $x44404)))
 (let ((@x46762 (monotonicity @x44405 (= ?x44416 ?x44423))))
 (let ((?x46311 (I ?x44408)))
 (let (($x46284 (= k@ ?x46311)))
 (let (($x44611 (not $x44606)))
 (let ((@x46802 (hypothesis $x44611)))
 (let ((@x44804 (def-axiom (or $x44606 $x44407))))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x9108 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x9112 (mp~ @x280 (nnf-pos (proof-bind ?x9108) (~ $x275 $x275)) $x275)))
 (let (($x46334 (not $x275)))
 (let (($x46446 (or $x46334 $x44505 $x46284)))
 (let ((@x46439 (mp ((_ quant-inst k@) (or $x46334 (or $x44505 $x46284))) (rewrite (= (or $x46334 (or $x44505 $x46284)) $x46446)) $x46446)))
 (let ((@x46804 (unit-resolution @x46439 @x9112 (unit-resolution @x44804 @x46802 $x44407) $x46284)))
 (let ((?x44847 (%I ?x44400)))
 (let ((?x46358 (%I ?x44415)))
 (let ((?x46549 (I ?x46358)))
 (let ((?x46441 (%I ?x46549)))
 (let ((?x46469 (Add ?x46441 ?x44847)))
 (let ((?x46484 (I ?x46469)))
 (let ((?x46575 (vstd!seq.Seq.index.? T&. T& s1! ?x46484)))
 (let ((?x46574 (vstd!seq.Seq.index.? T&. T& ?x44402 ?x46549)))
 (let (($x46576 (= ?x46574 ?x46575)))
 (let (($x46442 (>= ?x46441 0)))
 (let ((@x44808 (def-axiom (or $x44606 $x44459))))
 (let ((@x46805 (unit-resolution @x44808 @x46802 $x44459)))
 (let ((?x46376 (* (- 1) ?x44847)))
 (let ((?x46496 (+ i! ?x46376)))
 (let (($x46317 (>= ?x46496 0)))
 (let (($x44848 (= i! ?x44847)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x9087 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x9091 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x9087) (~ $x237 $x237)) $x237)))
 (let (($x44849 (not $x237)))
 (let (($x44854 (or $x44849 $x44848)))
 (let ((@x44855 ((_ quant-inst i!) $x44854)))
 (let ((@x46509 (unit-resolution @x44855 @x9091 $x44848)))
 (let ((@x46611 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44848) $x46317)) @x46509 $x46317)))
 (let ((?x46460 (Sub ?x44408 ?x44847)))
 (let ((?x46336 (* (- 1) ?x46460)))
 (let ((?x46599 (+ ?x46441 ?x46336)))
 (let (($x46607 (>= ?x46599 0)))
 (let (($x46598 (= ?x46441 ?x46460)))
 (let ((@x46632 (symm (monotonicity (symm @x46509 (= ?x44847 i!)) (= ?x46460 ?x44414)) (= ?x44414 ?x46460))))
 (let (($x46459 (= ?x44414 ?x46358)))
 (let (($x46483 (or $x44849 $x46459)))
 (let ((@x46488 ((_ quant-inst (Sub ?x44408 i!)) $x46483)))
 (let ((@x46556 (symm (unit-resolution @x46488 @x9091 $x46459) (= ?x46358 ?x44414))))
 (let (($x46557 (= ?x46549 ?x44415)))
 (let (($x46300 (= ?x44415 ?x46549)))
 (let (($x46330 (has_type ?x44415 INT)))
 (let (($x46550 (has_type ?x46549 INT)))
 (let (($x46563 (not $x46550)))
 (let (($x46561 (= $x46330 $x46550)))
 (let ((@x46565 (monotonicity (symm (monotonicity (monotonicity @x46556 $x46557) (= $x46550 $x46330)) $x46561) (= (not $x46330) $x46563))))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x9227 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x9231 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x9227) (~ $x698 $x698)) $x698)))
 (let ((@x46568 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x44415)) (or (not $x698) $x46550)) @x9231 $x46550) (mp (hypothesis (not $x46330)) @x46565 $x46563) false)))
 (let ((@x46569 (lemma @x46568 $x46330)))
 (let (($x46338 (not $x46330)))
 (let (($x46332 (or $x46334 $x46338 $x46300)))
 (let ((@x46326 (mp ((_ quant-inst (I ?x44414)) (or $x46334 (or $x46338 $x46300))) (rewrite (= (or $x46334 (or $x46338 $x46300)) $x46332)) $x46332)))
 (let ((@x46626 (symm (unit-resolution @x46326 @x9112 @x46569 $x46300) $x46557)))
 (let ((@x46628 (monotonicity @x46626 (= ?x46441 ?x46358))))
 (let ((@x46633 (trans* @x46628 @x46556 @x46632 $x46598)))
 (let ((?x46344 (+ ?x44408 ?x46376 ?x46336)))
 (let (($x46413 (<= ?x46344 0)))
 (let (($x46347 (= ?x46344 0)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x9332 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x9336 (mp~ @x956 (nnf-pos (proof-bind ?x9332) (~ $x951 $x951)) $x951)))
 (let (($x46348 (not $x951)))
 (let (($x46398 (or $x46348 $x46347)))
 (let ((?x46467 (+ ?x44847 ?x44457 ?x46460)))
 (let (($x46470 (= ?x46467 0)))
 (let (($x46406 (or $x46348 $x46470)))
 (let (($x46403 (= $x46406 $x46398)))
 (let ((@x46346 (monotonicity (rewrite (= ?x46467 (+ ?x44457 ?x44847 ?x46460))) (= $x46470 (= (+ ?x44457 ?x44847 ?x46460) 0)))))
 (let ((@x46410 (trans @x46346 (rewrite (= (= (+ ?x44457 ?x44847 ?x46460) 0) $x46347)) (= $x46470 $x46347))))
 (let ((@x46319 (mp ((_ quant-inst (%I k@) (%I ?x44400)) $x46406) (trans (monotonicity @x46410 $x46403) (rewrite (= $x46398 $x46398)) $x46403) $x46398)))
 (let ((@x46636 (unit-resolution @x46319 @x9336 $x46347)))
 (let ((@x46640 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46347) $x46413)) @x46636 $x46413)))
 (let ((@x46613 (hypothesis $x44459)))
 (let ((@x46641 ((_ th-lemma arith farkas -1 -1 -1 1 1) @x46613 @x46640 (hypothesis (not $x46442)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46598) $x46607)) @x46633 $x46607) @x46611 false)))
 (let ((@x46643 (lemma @x46641 (or $x46442 $x44498))))
 (let ((@x46806 (unit-resolution @x46643 @x46805 $x46442)))
 (let ((?x44770 (%I ?x44401)))
 (let ((?x46377 (+ ?x44770 ?x46376)))
 (let (($x46378 (>= ?x46377 0)))
 (let (($x44470 (not $x44467)))
 (let ((@x44810 (def-axiom (or $x44606 $x44470))))
 (let ((@x46807 (unit-resolution @x44810 @x46802 $x44470)))
 (let ((@x46612 (hypothesis $x44470)))
 (let ((?x46351 (* (- 1) ?x44770)))
 (let ((?x46499 (+ j! ?x46351)))
 (let (($x46318 (<= ?x46499 0)))
 (let (($x44773 (= j! ?x44770)))
 (let (($x44850 (or $x44849 $x44773)))
 (let ((@x44851 ((_ quant-inst j!) $x44850)))
 (let ((@x46531 (unit-resolution @x44851 @x9091 $x44773)))
 (let ((@x46617 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44773) $x46318)) @x46531 $x46318)))
 (let ((@x46621 (lemma ((_ th-lemma arith farkas 1 1 1 1 1) (hypothesis (not $x46378)) @x46617 @x46613 @x46612 @x46611 false) (or $x46378 $x44498 $x44467))))
 (let ((@x46808 (unit-resolution @x46621 @x46805 @x46807 $x46378)))
 (let ((@x46811 (mp @x46569 (symm (monotonicity @x46626 (= $x46550 $x46330)) $x46561) $x46550)))
 (let ((?x46472 (* (- 1) ?x46441)))
 (let ((?x46361 (Sub ?x44770 ?x44847)))
 (let ((?x46473 (+ ?x46361 ?x46472)))
 (let (($x46474 (<= ?x46473 0)))
 (let (($x46682 (not $x46474)))
 (let (($x46606 (<= ?x46599 0)))
 (let (($x46320 (>= ?x46344 0)))
 (let ((@x46675 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46347) $x46320)) @x46636 $x46320)))
 (let ((?x46362 (* (- 1) ?x46361)))
 (let ((?x46652 (+ ?x44770 ?x46376 ?x46362)))
 (let (($x46667 (<= ?x46652 0)))
 (let (($x46653 (= ?x46652 0)))
 (let (($x46658 (or $x46348 $x46653)))
 (let ((?x46644 (+ ?x44847 ?x46351 ?x46361)))
 (let (($x46645 (= ?x46644 0)))
 (let (($x46659 (or $x46348 $x46645)))
 (let (($x46661 (= $x46659 $x46658)))
 (let ((@x46648 (rewrite (= ?x46644 (+ ?x46351 ?x44847 ?x46361)))))
 (let ((@x46657 (trans (monotonicity @x46648 (= $x46645 (= (+ ?x46351 ?x44847 ?x46361) 0))) (rewrite (= (= (+ ?x46351 ?x44847 ?x46361) 0) $x46653)) (= $x46645 $x46653))))
 (let ((@x46666 (mp ((_ quant-inst (%I ?x44401) (%I ?x44400)) $x46659) (trans (monotonicity @x46657 $x46661) (rewrite (= $x46658 $x46658)) $x46661) $x46658)))
 (let ((@x46680 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46653) $x46667)) (unit-resolution @x46666 @x9336 $x46653) $x46667)))
 (let ((@x46681 ((_ th-lemma arith farkas 1 1 -1 -1 1 1) @x46680 @x46617 @x46612 @x46675 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46598) $x46606)) @x46633 $x46606) (hypothesis $x46474) false)))
 (let ((@x46684 (lemma @x46681 (or $x46682 $x44467))))
 (let ((@x46812 (unit-resolution @x46684 @x46807 $x46682)))
 (let ((?x44363 (vstd!seq.Seq.len.? T&. T& s1!)))
 (let ((?x46431 (+ ?x44363 ?x46351)))
 (let (($x46432 (>= ?x46431 0)))
 (let ((?x44373 (* (- 1) ?x44363)))
 (let ((?x44374 (+ j! ?x44373)))
 (let (($x44367 (<= ?x44374 0)))
 (let ((?x44370 (* (- 1) j!)))
 (let ((?x44371 (+ i! ?x44370)))
 (let (($x44372 (<= ?x44371 0)))
 (let (($x44368 (>= i! 0)))
 (let (($x44382 (and $x44368 $x44372 $x44367)))
 (let (($x44375 (and $x44368 $x44372)))
 (let (($x44379 (and $x44375 $x44367)))
 (let (($x44364 (<= j! ?x44363)))
 (let (($x44362 (and (<= 0 i!) (<= i! j!))))
 (let (($x44365 (and $x44362 $x44364)))
 (let ((@x44381 (monotonicity (rewrite (= $x44362 $x44375)) (rewrite (= $x44364 $x44367)) (= $x44365 $x44379))))
 (let ((@x44387 (mp (asserted $x44365) (trans @x44381 (rewrite (= $x44379 $x44382)) (= $x44365 $x44382)) $x44382)))
 (let ((@x44390 (and-elim @x44387 $x44367)))
 (let (($x46501 (>= ?x46499 0)))
 (let ((@x46835 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44773) $x46501)) @x46531 $x46501)))
 (let ((@x46844 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1) (or $x46432 (not $x44367) (not $x46501))) @x46835 @x44390 $x46432)))
 (let (($x46342 (>= ?x44847 0)))
 (let ((@x44388 (and-elim @x44387 $x44368)))
 (let (($x46497 (<= ?x46496 0)))
 (let ((@x46828 (unit-resolution ((_ th-lemma arith assign-bounds -1 1) (or $x46342 (not $x44368) (not $x46497))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44848) $x46497)) @x46509 $x46497) @x44388 $x46342)))
 (let (($x44778 (has_type ?x44401 INT)))
 (let ((?x46528 (I ?x44770)))
 (let (($x46529 (has_type ?x46528 INT)))
 (let (($x46542 (not $x46529)))
 (let ((@x46539 (monotonicity (monotonicity (symm @x46531 (= ?x44770 j!)) (= ?x46528 ?x44401)) (= $x46529 $x44778))))
 (let ((@x46545 (mp (hypothesis (not $x44778)) (monotonicity (symm @x46539 (= $x44778 $x46529)) (= (not $x44778) $x46542)) $x46542)))
 (let ((@x46547 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x44401)) (or (not $x698) $x46529)) @x9231 $x46529) @x46545 false)))
 (let ((@x46548 (lemma @x46547 $x44778)))
 (let (($x44602 (has_type ?x44400 INT)))
 (let ((?x46506 (I ?x44847)))
 (let (($x46507 (has_type ?x46506 INT)))
 (let (($x46521 (not $x46507)))
 (let ((@x46518 (monotonicity (monotonicity (symm @x46509 (= ?x44847 i!)) (= ?x46506 ?x44400)) (= $x46507 $x44602))))
 (let ((@x46524 (mp (hypothesis (not $x44602)) (monotonicity (symm @x46518 (= $x44602 $x46507)) (= (not $x44602) $x46521)) $x46521)))
 (let ((@x46526 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x44400)) (or (not $x698) $x46507)) @x9231 $x46507) @x46524 false)))
 (let ((@x46527 (lemma @x46526 $x44602)))
 (let ((?x44352 (TYPE%vstd!seq.Seq. T&. T&)))
 (let (($x44353 (has_type s1! ?x44352)))
 (let ((@x44354 (asserted $x44353)))
 (let (($x44348 (sized T&.)))
 (let ((@x44349 (asserted $x44348)))
 (let (($x14430 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x14060 (not $x821)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4686 (sized A&.)))
 (let (($x14380 (not $x4686)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k! INT)))
 (let (($x14174 (not $x4257)))
 (let (($x4684 (has_type j! INT)))
 (let (($x14420 (not $x4684)))
 (or (not (has_type s! (TYPE%vstd!seq.Seq. A&. A&))) $x14420 $x14174 $x271 $x14380 (not (>= (%I j!) 0)) (not (<= (+ (%I j!) (* (- 1) (%I k!))) 0)) (not $x4711) $x14060 $x4741 $x4703)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4682 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x44992 (= $x4682 $x1590)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x44346 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x8920 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x8926 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x8920) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x8931 (mp (mp~ @x37 @x8926 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x44853 (unit-resolution @x8931 @x44346 $x30)))
 (let ((@x44994 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_index.) (or (not $x30) $x44992)) @x44853 (hypothesis (not $x44992)) false)))
 (let ((@x45006 (lemma @x44994 $x44992)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x13511 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x13510 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x13509 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x13508 (not $x1591)))
 (let (($x13507 (not $x1590)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x13506 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x13505 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x13504 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x13503 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x13502 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x13501 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x13500 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x13499 (not $x1582)))
 (let (($x13512 (or $x13499 $x13500 $x13501 $x13502 $x13503 $x13504 $x13505 $x13506 $x13507 $x13508 $x13509 $x13510 $x13511)))
 (let (($x13513 (not $x13512)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x13576 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x13575 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x13574 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x13573 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x13572 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x13571 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x13570 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x13569 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x13568 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x13567 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x13566 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x13565 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x13564 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x13563 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x13562 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x13577 (or $x1598 $x1610 $x13562 $x1621 $x13563 $x13564 $x13565 $x1565 $x13566 $x1633 $x13567 $x13568 $x1576 $x13569 $x13570 $x13571 $x13572 $x13573 $x13574 $x1644 $x13575 $x13576)))
 (let (($x13578 (not $x13577)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x13581 (or $x1669 $x13578)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x13583 (mp @x1673 (rewrite (= $x1670 $x13581)) $x13581)))
 (let ((@x42524 (def-axiom (or $x13577 $x1581))))
 (let (($x13516 (or $x1598 $x13513)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x13518 (mp @x1602 (rewrite (= $x1599 $x13516)) $x13516)))
 (let ((@x46815 (unit-resolution @x13518 (unit-resolution @x42524 (unit-resolution @x13583 @x1650 $x13578) $x1581) $x13513)))
 (let ((@x42484 (def-axiom (or $x13512 $x1590))))
 (let ((@x44999 (def-axiom (or (not $x44992) $x4682 $x13507))))
 (let ((@x46818 (unit-resolution @x44999 (unit-resolution @x42484 @x46815 $x1590) (or (not $x44992) $x4682))))
 (let (($x4749 (not $x4682)))
 (let (($x14435 (or $x4749 $x14430)))
 (let (($x4774 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (or (not $x4685) $x4759 $x4703)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4779 (or $x4749 $x4774)))
 (let ((?x11145 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (refl (~ $x4769 $x4769)))))))))))))))))))))))
 ))
 (let ((@x11150 (monotonicity (refl (~ $x4749 $x4749)) (nnf-pos (proof-bind ?x11145) (~ $x4774 $x4774)) (~ $x4779 $x4779))))
 (let (($x4707 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) (%I j!))))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let ((?x1186 (%I j!)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4686 (sized A&.)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (=> (and $x4685 $x4697) $x4703))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4708 (=> $x4682 $x4707)))
 (let ((?x4775 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) ?x1186)))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x4705 (=> (and $x4685 $x4697) $x4703)))
 (let ((@x4734 (rewrite (= (and $x4686 (and $x4710 $x4714 $x4711)) (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4723 (monotonicity (rewrite (= $x4689 (and $x4710 $x4714))) (rewrite (= $x4691 $x4711)) (= $x4692 (and (and $x4710 $x4714) $x4711)))))
 (let ((@x4728 (trans @x4723 (rewrite (= (and (and $x4710 $x4714) $x4711) (and $x4710 $x4714 $x4711))) (= $x4692 (and $x4710 $x4714 $x4711)))))
 (let ((@x4736 (trans (monotonicity @x4728 (= $x4693 (and $x4686 (and $x4710 $x4714 $x4711)))) @x4734 (= $x4693 (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4742 (monotonicity @x4736 (rewrite (= $x4696 (and $x821 $x4746))) (= $x4697 (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746))))))
 (let ((@x4755 (trans @x4742 (rewrite (= (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746)) $x4745)) (= $x4697 $x4745))))
 (let ((@x4764 (trans (monotonicity @x4755 (= $x4704 (=> $x4745 $x4703))) (rewrite (= (=> $x4745 $x4703) (or $x4759 $x4703))) (= $x4704 (or $x4759 $x4703)))))
 (trans (monotonicity @x4764 (= $x4705 (=> $x4685 (or $x4759 $x4703)))) (rewrite (= (=> $x4685 (or $x4759 $x4703)) $x4769)) (= $x4705 $x4769))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4747 (monotonicity (quant-intro (proof-bind ?x4775) (= $x4707 $x4774)) (= $x4708 (=> $x4682 $x4774)))))
 (let ((@x4784 (mp (asserted $x4708) (trans @x4747 (rewrite (= (=> $x4682 $x4774) $x4779)) (= $x4708 $x4779)) $x4779)))
 (let ((@x14437 (mp (mp (mp~ @x4784 @x11150 $x4779) (rewrite (= $x4779 $x4779)) $x4779) (rewrite (= $x4779 $x14435)) $x14435)))
 (let ((@x46820 (unit-resolution @x14437 (unit-resolution @x46818 @x45006 $x4682) $x14430)))
 (let (($x46456 (not $x46442)))
 (let (($x46578 (not $x46432)))
 (let (($x46383 (not $x46378)))
 (let (($x46350 (not $x46342)))
 (let (($x46341 (not $x44348)))
 (let (($x44780 (not $x44778)))
 (let (($x44603 (not $x44602)))
 (let (($x44575 (not $x44353)))
 (let (($x46494 (not $x14430)))
 (let (($x46587 (or $x46494 $x44575 $x44603 $x44780 $x46563 $x46341 $x46350 $x46383 $x46578 $x46456 $x46474 $x46576)))
 (let ((?x46462 (+ ?x46441 ?x46362)))
 (let (($x46463 (>= ?x46462 0)))
 (let ((?x46419 (+ ?x44770 ?x44373)))
 (let (($x46420 (<= ?x46419 0)))
 (let (($x46421 (not $x46420)))
 (let ((?x46352 (+ ?x44847 ?x46351)))
 (let (($x46353 (<= ?x46352 0)))
 (let (($x46354 (not $x46353)))
 (let (($x46577 (or $x44575 $x44603 $x44780 $x46563 $x46341 $x46350 $x46354 $x46421 $x46456 $x46463 $x46576)))
 (let (($x46588 (or $x46494 $x46577)))
 (let (($x46580 (or $x44575 $x44603 $x44780 $x46563 $x46341 $x46350 $x46383 $x46578 $x46456 $x46474 $x46576)))
 (let (($x46590 (or $x46494 $x46580)))
 (let (($x46582 (= $x46577 $x46580)))
 (let ((@x46464 (monotonicity (rewrite (= ?x46462 (+ ?x46362 ?x46441))) (= $x46463 (>= (+ ?x46362 ?x46441) 0)))))
 (let ((@x46478 (trans @x46464 (rewrite (= (>= (+ ?x46362 ?x46441) 0) $x46474)) (= $x46463 $x46474))))
 (let ((@x46581 (rewrite (= $x46421 $x46578))))
 (let ((@x46386 (rewrite (= $x46354 $x46383))))
 (let ((@x46586 (trans (monotonicity @x46386 @x46581 @x46478 $x46582) (rewrite (= $x46580 $x46580)) $x46582)))
 (let ((@x46596 (trans (monotonicity @x46586 (= $x46588 $x46590)) (rewrite (= $x46590 $x46587)) (= $x46588 $x46587))))
 (let ((@x46846 (unit-resolution (mp ((_ quant-inst T&. T& s1! (I i!) (I j!) (I ?x46358)) $x46588) @x46596 $x46587) @x46820 @x44349 @x44354 @x46527 @x46548 @x46828 @x46844 (or $x46563 $x46383 $x46456 $x46474 $x46576))))
 (let (($x46753 (= k@ ?x46484)))
 (let (($x46751 (= ?x46311 ?x46484)))
 (let (($x46749 (= ?x46484 ?x46311)))
 (let (($x46746 (= ?x46469 ?x44408)))
 (let ((?x46365 (Add ?x46358 ?x44847)))
 (let (($x46744 (= ?x46365 ?x44408)))
 (let (($x46700 (= ?x44408 ?x46365)))
 (let ((?x46687 (* (- 1) ?x46365)))
 (let ((?x46701 (+ ?x44408 ?x46687)))
 (let (($x46703 (>= ?x46701 0)))
 (let ((?x46693 (+ ?x46358 ?x46336)))
 (let (($x46698 (<= ?x46693 0)))
 (let (($x46692 (= ?x46358 ?x46460)))
 (let ((@x46710 (trans* @x46556 @x46632 $x46692)))
 (let ((?x46688 (+ ?x44847 ?x46358 ?x46687)))
 (let (($x46697 (>= ?x46688 0)))
 (let (($x46691 (= ?x46688 0)))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x9325 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x9329 (mp~ @x925 (nnf-pos (proof-bind ?x9325) (~ $x920 $x920)) $x920)))
 (let ((@x46712 (unit-resolution ((_ quant-inst (%I ?x44415) (%I ?x44400)) (or (not $x920) $x46691)) @x9329 $x46691)))
 (let ((@x46722 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 -1) (or $x46703 (not $x46320) (not $x46698) (not $x46697))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46691) $x46697)) @x46712 $x46697) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46692) $x46698)) @x46710 $x46698) @x46675 $x46703)))
 (let (($x46702 (<= ?x46701 0)))
 (let (($x46699 (>= ?x46693 0)))
 (let (($x46696 (<= ?x46688 0)))
 (let ((@x46734 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 -1) (or $x46702 (not $x46413) (not $x46699) (not $x46696))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46691) $x46696)) @x46712 $x46696) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46692) $x46699)) @x46710 $x46699) @x46640 $x46702)))
 (let ((@x46738 ((_ th-lemma arith triangle-eq) (or $x46700 (not $x46702) (not $x46703)))))
 (let ((@x46743 (symm (monotonicity (symm @x46628 (= ?x46358 ?x46441)) (= ?x46365 ?x46469)) (= ?x46469 ?x46365))))
 (let ((@x46750 (monotonicity (trans* @x46743 (symm (unit-resolution @x46738 @x46734 @x46722 $x46700) $x46744) $x46746) $x46749)))
 (let ((@x46748 (hypothesis $x46284)))
 (let ((@x46765 (trans* (monotonicity (trans* @x46748 (symm @x46750 $x46751) $x46753) (= ?x44413 ?x46575)) (symm (hypothesis $x46576) (= ?x46575 ?x46574)) (monotonicity @x44405 @x46626 (= ?x46574 ?x44423)) (symm @x46762 (= ?x44423 ?x44416)) $x44417)))
 (let ((@x46771 (lemma (unit-resolution (hypothesis (not $x44417)) @x46765 false) (or $x44417 (not $x46576) (not $x46284)))))
 (let ((@x46848 (unit-resolution @x46771 (unit-resolution @x46846 @x46812 @x46811 @x46808 @x46806 $x46576) @x46804 $x44417)))
 (let ((@x46853 (monotonicity (trans* @x46848 @x46762 (= ?x44413 ?x44423)) (= $x44429 (= ?x44423 ?x44422)))))
 (let ((@x46859 (symm (trans @x46853 (commutativity (= (= ?x44423 ?x44422) $x44424)) (= $x44429 $x44424)) (= $x44424 $x44429))))
 (let ((?x46465 (vstd!seq.Seq.index.? T&. T& s2! ?x46484)))
 (let ((?x46401 (vstd!seq.Seq.index.? T&. T& ?x44403 ?x46549)))
 (let (($x46486 (= ?x46401 ?x46465)))
 (let ((?x44391 (vstd!seq.Seq.len.? T&. T& s2!)))
 (let ((?x46392 (+ ?x44391 ?x46351)))
 (let (($x46393 (>= ?x46392 0)))
 (let ((?x44394 (* (- 1) ?x44391)))
 (let ((?x44395 (+ j! ?x44394)))
 (let (($x44396 (<= ?x44395 0)))
 (let ((@x44399 (mp (asserted (<= j! ?x44391)) (rewrite (= (<= j! ?x44391) $x44396)) $x44396)))
 (let ((@x46836 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1) (or $x46393 (not $x44396) (not $x46501))) @x46835 @x44399 $x46393)))
 (let (($x44356 (has_type s2! ?x44352)))
 (let ((@x44357 (asserted $x44356)))
 (let (($x46471 (not $x46393)))
 (let (($x44585 (not $x44356)))
 (let (($x46495 (or $x46494 $x44585 $x44603 $x44780 $x46563 $x46341 $x46350 $x46383 $x46471 $x46456 $x46474 $x46486)))
 (let ((?x46355 (+ ?x44770 ?x44394)))
 (let (($x46356 (<= ?x46355 0)))
 (let (($x46357 (not $x46356)))
 (let (($x46487 (or $x44585 $x44603 $x44780 $x46563 $x46341 $x46350 $x46354 $x46357 $x46456 $x46463 $x46486)))
 (let (($x46498 (or $x46494 $x46487)))
 (let (($x46479 (or $x44585 $x44603 $x44780 $x46563 $x46341 $x46350 $x46383 $x46471 $x46456 $x46474 $x46486)))
 (let (($x46502 (or $x46494 $x46479)))
 (let (($x46481 (= $x46487 $x46479)))
 (let ((@x46493 (trans (monotonicity @x46386 (rewrite (= $x46357 $x46471)) @x46478 $x46481) (rewrite (= $x46479 $x46479)) $x46481)))
 (let ((@x46572 (trans (monotonicity @x46493 (= $x46498 $x46502)) (rewrite (= $x46502 $x46495)) (= $x46498 $x46495))))
 (let ((@x46838 (unit-resolution (mp ((_ quant-inst T&. T& s2! (I i!) (I j!) (I ?x46358)) $x46498) @x46572 $x46495) @x46820 @x44349 @x44357 @x46527 @x46548 @x46828 @x46836 (or $x46563 $x46383 $x46456 $x46474 $x46486))))
 (let ((@x46787 (monotonicity (trans* @x46743 (symm (unit-resolution @x46738 @x46722 @x46734 $x46700) $x46744) $x46746) $x46749)))
 (let ((@x46796 (trans* (monotonicity (trans* @x46748 (symm @x46787 $x46751) $x46753) (= ?x44422 ?x46465)) (symm (hypothesis $x46486) (= ?x46465 ?x46401)) (monotonicity @x46626 (= ?x46401 ?x44423)) $x44424)))
 (let ((@x46801 (lemma (unit-resolution (hypothesis (not $x44424)) @x46796 false) (or $x44424 (not $x46486) (not $x46284)))))
 (let ((@x46840 (unit-resolution @x46801 (unit-resolution @x46838 @x46812 @x46811 @x46808 @x46806 $x46486) @x46804 $x44424)))
 (let (($x44830 (not $x44429)))
 (let ((@x44490 (def-axiom (or $x44480 tmp%1 (not $x44417)))))
 (let ((@x46863 (unit-resolution @x44490 @x46848 (unit-resolution (def-axiom (or $x44606 $x44418)) @x46802 $x44418) tmp%1)))
 (let ((@x44744 (def-axiom (or $x44465 $x44493))))
 (let ((@x44802 (def-axiom (or $x44598 $x44595 $x44596))))
 (let ((@x46865 (unit-resolution @x44802 (unit-resolution @x44744 @x46863 $x44465) (unit-resolution (def-axiom (or $x44606 $x44597)) @x46802 $x44597) $x44596)))
 (let ((@x44794 (def-axiom (or $x44586 $x44578))))
 (let ((@x44752 (def-axiom (or $x44482 tmp%2 (not $x44424)))))
 (let ((@x46868 (unit-resolution @x44752 @x46840 (unit-resolution (def-axiom (or $x44586 $x44425)) @x46865 $x44425) tmp%2)))
 (let ((@x44828 (def-axiom (or $x44461 $x44485))))
 (let ((@x44751 (def-axiom (or $x44581 $x44576 $x44577))))
 (let ((@x46870 (unit-resolution @x44751 (unit-resolution @x44828 @x46868 $x44461) (unit-resolution @x44794 @x46865 $x44578) $x44577)))
 (let ((@x44833 (def-axiom (or $x44486 $x44830))))
 (let ((@x46872 (unit-resolution (unit-resolution @x44833 @x46870 $x44830) (mp @x46840 @x46859 $x44429) false)))
 (let ((@x46873 (lemma @x46872 $x44606)))
 (let (($x44650 (or $x44611 $x44645)))
 (let (($x44722 (or $x44574 $x44551)))
 (let (($x44721 (or $x44543 $x44639)))
 (let (($x44709 (forall ((k$ Poly) )(! (let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x44520 (>= (+ (%I k$) (* (- 1) j!)) 0)))
 (let (($x44705 (or $x44520 $x44444)))
 (let (($x44511 (>= (+ (%I k$) (* (- 1) i!)) 0)))
 (let (($x44613 (not $x44511)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (let (($x44703 (or $x271 $x44613)))
 (or $x44703 $x44705))))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_39))
 ))
 (let (($x44714 (not $x44709)))
 (let (($x44720 (or $x44714 $x44552)))
 (let (($x44723 (or $x44720 $x44721)))
 (let (($x44724 (or $x44723 $x44722)))
 (let (($x44729 (not $x44724)))
 (let (($x44672 (not (or $x44576 (not (or (or $x44485 $x44478) $x44429))))))
 (let (($x44679 (or $x44493 $x44482)))
 (let (($x44680 (or $x44679 $x44672)))
 (let (($x44686 (not (or $x44595 (not $x44680)))))
 (let (($x44694 (or $x44467 $x44480)))
 (let (($x44693 (or $x44505 $x44498)))
 (let (($x44695 (or $x44693 $x44694)))
 (let (($x44696 (or $x44695 $x44686)))
 (let (($x44701 (not $x44696)))
 (let (($x44731 (or $x44701 $x44729)))
 (let (($x44816 (= $x44731 $x44650)))
 (let ((@x44655 (rewrite (= $x44650 $x44650))))
 (let ((@x44819 (trans (monotonicity (rewrite (= $x44701 $x44611)) (rewrite (= $x44729 $x44645)) $x44816) @x44655 $x44816)))
 (let (($x44582 (not (or $x44543 (not (and $x44507 (not $x44574))) $x44551))))
 (let (($x44541 (forall ((k$ Poly) )(! (let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x44511 (>= (+ (%I k$) (* (- 1) i!)) 0)))
 (let (($x44526 (and $x44511 (not (>= (+ (%I k$) (* (- 1) j!)) 0)))))
 (let (($x44523 (not $x44526)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x44523 $x44444))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_39))
 ))
 (let (($x44487 (and $x44541 %%location_label%%3 $x44582)))
 (let (($x44506 (or $x44505 (not (and $x44459 $x44470)) $x44480 (and $x44465 (or $x44493 $x44482 (and $x44461 $x44486))))))
 (let (($x44566 (not $x44506)))
 (let (($x44469 (or $x44566 $x44487)))
 (let (($x44651 (= $x44469 $x44650)))
 (let (($x44654 (or $x44543 $x44639 $x44574 $x44551)))
 (let (($x44659 (not $x44654)))
 (let (($x44640 (and $x44634 %%location_label%%3 $x44659)))
 (let ((?x44635 (lambda ((k$ Poly) )(let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x44520 (>= (+ (%I k$) (* (- 1) j!)) 0)))
 (let (($x44511 (>= (+ (%I k$) (* (- 1) i!)) 0)))
 (let (($x44613 (not $x44511)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (let (($x44629 (or $x271 $x44613 $x44520 $x44444)))
 (let (($x44526 (and $x44511 (not $x44520))))
 (let (($x44523 (not $x44526)))
 (let (($x44536 (or $x271 $x44523 $x44444)))
 (let ((@x44621 (monotonicity (rewrite (= $x44526 (not (or $x44613 $x44520)))) (= $x44523 (not (not (or $x44613 $x44520)))))))
 (let ((@x44625 (trans @x44621 (rewrite (= (not (not (or $x44613 $x44520))) (or $x44613 $x44520))) (= $x44523 (or $x44613 $x44520)))))
 (trans (monotonicity @x44625 (= $x44536 (or $x271 (or $x44613 $x44520) $x44444))) (rewrite (= (or $x271 (or $x44613 $x44520) $x44444) $x44629)) (= $x44536 $x44629)))))))))))))))))
 ))
 (let ((@x44642 (monotonicity (quant-intro (proof-bind ?x44635) (= $x44541 $x44634)) (rewrite (= $x44582 $x44659)) (= $x44487 $x44640))))
 (let ((@x44652 (monotonicity (rewrite (= $x44566 $x44611)) (trans @x44642 (rewrite (= $x44640 $x44645)) (= $x44487 $x44645)) $x44651)))
 (let ((?x44513 (* (- 1) i!)))
 (let ((?x44545 (+ ?x44544 ?x44513)))
 (let (($x44547 (>= ?x44545 0)))
 (let (($x44554 (not (or $x44543 (not (and $x44547 (not (>= (+ ?x44544 ?x44370) 0)))) $x44551))))
 (let (($x44560 (and $x44541 %%location_label%%3 $x44554)))
 (let (($x44476 (or $x44566 $x44560)))
 (let (($x44546 (forall ((k$ Poly) )(! (let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x44511 (>= (+ (%I k$) (* (- 1) i!)) 0)))
 (let (($x44526 (and $x44511 (not (>= (+ (%I k$) (* (- 1) j!)) 0)))))
 (let (($x44523 (not $x44526)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x44523 $x44444))))))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38))
 ))
 (let (($x44557 (not $x44541)))
 (let (($x44558 (or $x44557 $x44552 $x44546)))
 (let (($x44528 (not (and $x44506 $x44558))))
 (let ((?x44529 (lambda ((k$ Poly) )(let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x44511 (>= (+ (%I k$) (* (- 1) i!)) 0)))
 (let (($x44526 (and $x44511 (not (>= (+ (%I k$) (* (- 1) j!)) 0)))))
 (let (($x44523 (not $x44526)))
 (let (($x263 (has_type k$ INT)))
 (let (($x271 (not $x263)))
 (let (($x44536 (or $x271 $x44523 $x44444)))
 (refl (~ $x44536 $x44536))))))))))))
 ))
 (let ((@x44537 (nnf-neg (nnf-pos (proof-bind ?x44529) (~ $x44541 $x44541)) (~ (not $x44557) $x44541))))
 (let ((@x44474 (nnf-neg @x44537 (refl (~ %%location_label%%3 %%location_label%%3)) (sk (~ (not $x44546) $x44554)) (~ (not $x44558) $x44560))))
 (let (($x44451 (forall ((k$ Poly) )(! (let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x263 (has_type k$ INT)))
 (=> (and $x263 (and (<= i! (%I k$)) (< (%I k$) j!))) $x44444))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38))
 ))
 (let (($x44449 (forall ((k$ Poly) )(! (let ((?x44443 (vstd!seq.Seq.index.? T&. T& s2! k$)))
 (let ((?x44442 (vstd!seq.Seq.index.? T&. T& s1! k$)))
 (let (($x44444 (= ?x44442 ?x44443)))
 (let (($x263 (has_type k$ INT)))
 (=> (and $x263 (and (<= i! (%I k$)) (< (%I k$) j!))) $x44444))))) :pattern ( (vstd!seq.Seq.index.? T&. T& s1! k$) ) :pattern ( (vstd!seq.Seq.index.? T&. T& s2! k$) ) :qid user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_39))
 ))
 (let (($x44432 (and (=> %%location_label%%1 tmp%2) (=> (and tmp%2 %%location_label%%2) $x44429))))
 (let (($x44436 (=> $x44418 (and (=> %%location_label%%0 tmp%1) (=> (and tmp%1 $x44425) $x44432)))))
 (let (($x44454 (and (=> (and $x44407 (and (<= i! ?x44408) (< ?x44408 j!)) $x44418) (and (=> %%location_label%%0 tmp%1) (=> (and tmp%1 $x44425) $x44432))) (=> (and $x44449 %%location_label%%3) $x44451))))
 (let (($x44455 (not $x44454)))
 (let ((@x44492 (mp~ (mp (asserted $x44455) (rewrite (= $x44455 $x44528)) $x44528) (nnf-neg (refl (~ $x44566 $x44566)) @x44474 (~ $x44528 $x44476)) $x44476)))
 (let ((@x44657 (mp (mp @x44492 (rewrite (= $x44476 $x44469)) $x44469) (trans @x44652 @x44655 $x44651) $x44650)))
 (let ((@x44820 (mp (mp @x44657 (rewrite (= $x44650 $x44731)) $x44731) @x44819 $x44650)))
 (let ((@x46903 (unit-resolution @x44820 @x46873 $x44645)))
 (let ((@x44765 (def-axiom (or $x44644 $x44761))))
 (let (($x46784 (or $x44643 $x44543 $x44639 $x44574 $x44551)))
 (let ((?x44548 (+ ?x44544 ?x44370)))
 (let (($x44525 (>= ?x44548 0)))
 (let (($x46404 (not $x44547)))
 (let (($x46416 (or $x44543 $x46404 $x44525 $x44551)))
 (let (($x46668 (or $x44643 $x46416)))
 (let (($x46780 (= $x46416 $x44654)))
 (let ((@x46603 (monotonicity (rewrite (= ?x44548 (+ ?x44370 ?x44544))) (= $x44525 (>= (+ ?x44370 ?x44544) 0)))))
 (let ((@x46690 (trans @x46603 (rewrite (= (>= (+ ?x44370 ?x44544) 0) $x44574)) (= $x44525 $x44574))))
 (let ((@x46454 (rewrite (= $x46404 $x44639))))
 (let ((@x46877 (monotonicity (trans (monotonicity @x46454 @x46690 $x46780) (rewrite (= $x44654 $x44654)) $x46780) (= $x46668 (or $x44643 $x44654)))))
 (let ((@x46882 (mp ((_ quant-inst k$!skolem_user_pmemlog__logimpl_v__lemma_subrange_equality_implies_index_equality_38!15) $x46668) (trans @x46877 (rewrite (= (or $x44643 $x44654) $x46784)) (= $x46668 $x46784)) $x46784)))
 (unit-resolution @x46882 (unit-resolution (def-axiom (or $x44644 $x44634)) @x46903 $x44634) (unit-resolution (def-axiom (or $x44644 $x44542)) @x46903 $x44542) (unit-resolution (def-axiom (or $x44644 $x44507)) @x46903 $x44507) (unit-resolution (def-axiom (or $x44644 (not $x44574))) @x46903 (not $x44574)) (unit-resolution @x44765 @x46903 $x44761) false))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

