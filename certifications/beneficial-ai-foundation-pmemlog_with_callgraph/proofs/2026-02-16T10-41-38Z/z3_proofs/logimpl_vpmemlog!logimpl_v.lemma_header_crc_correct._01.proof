(:max-memory   21.76
 :memory       21.76
 :num-allocs   790268
 :rlimit-count 13573)
(:version "4.12.5")
unsat
((declare-fun i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 (Poly Poly Type Dcr) Poly)
(proof
(let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x47787 (Poly%vstd!seq.Seq<u8.>. header_bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x47815 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7834 ?x7835)))
 (let ((?x47825 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x47815)))
 (let ((?x47826 (Poly%vstd!seq.Seq<u8.>. ?x47825)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x47809 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7829 ?x7831)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x47827 (ext_eq false ?x1968 ?x47809 ?x47826)))
 (let ((?x47797 (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)))
 (let ((?x47801 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x47797)))
 (let ((?x47802 (Poly%vstd!seq.Seq<u8.>. ?x47801)))
 (let ((?x47792 (Poly%vstd!seq.Seq<u8.>. crc_bytes!)))
 (let (($x47803 (ext_eq false ?x1968 ?x47792 ?x47802)))
 (let (($x48813 (= ?x47815 ?x47797)))
 (let (($x47816 (ext_eq false ?x1968 ?x47815 ?x47797)))
 (let ((?x50467 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47797 ?x47815 ?x1876 $)))
 (let ((?x50469 (vstd!seq.Seq.index.? $ ?x1876 ?x47797 ?x50467)))
 (let ((?x50481 (vstd!seq.Seq.index.? $ ?x1876 ?x47815 ?x50467)))
 (let (($x50484 (= ?x50481 ?x50469)))
 (let ((?x50494 (vstd!seq.Seq.len.? $ ?x1876 ?x47815)))
 (let ((?x50592 (* (- 1) ?x50494)))
 (let ((?x50485 (%I ?x50467)))
 (let ((?x50766 (+ ?x50485 ?x50592)))
 (let (($x50796 (>= ?x50766 0)))
 (let (($x50495 (>= ?x50485 0)))
 (let (($x50496 (not $x50495)))
 (let (($x50497 (has_type ?x50467 INT)))
 (let (($x50582 (not $x50497)))
 (let (($x50822 (or $x50582 $x50496 $x50796 $x50484)))
 (let ((?x51188 (I ?x50485)))
 (let (($x51189 (= ?x50467 ?x51188)))
 (let (($x50826 (not $x50822)))
 (let ((@x51691 (hypothesis $x50826)))
 (let ((@x50785 (def-axiom (or $x50822 $x50497))))
 (let ((@x51692 (unit-resolution @x50785 @x51691 $x50497)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x10684 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x10688 (mp~ @x280 (nnf-pos (proof-bind ?x10684) (~ $x275 $x275)) $x275)))
 (let (($x50282 (not $x275)))
 (let (($x51282 (or $x50282 $x50582 $x51189)))
 (let ((@x51287 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47797 ?x47815 ?x1876 $)) (or $x50282 (or $x50582 $x51189))) (rewrite (= (or $x50282 (or $x50582 $x51189)) $x51282)) $x51282)))
 (let ((?x48145 (%I ?x7831)))
 (let ((?x51166 (Add ?x50485 ?x48145)))
 (let ((?x51167 (I ?x51166)))
 (let ((?x47805 (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797)))
 (let ((?x51168 (vstd!seq.Seq.index.? $ ?x1876 ?x47805 ?x51167)))
 (let ((?x50867 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47805 ?x7831 ?x7835)))
 (let ((?x51165 (vstd!seq.Seq.index.? $ ?x1876 ?x50867 ?x50467)))
 (let (($x51169 (= ?x51165 ?x51168)))
 (let ((?x51036 (%I ?x7835)))
 (let ((?x51044 (Sub ?x51036 ?x48145)))
 (let ((?x51156 (* (- 1) ?x51044)))
 (let ((?x51157 (+ ?x50485 ?x51156)))
 (let (($x51164 (>= ?x51157 0)))
 (let (($x51378 (not $x51164)))
 (let (($x50490 (not $x50796)))
 (let ((@x50600 (def-axiom (or $x50822 $x50490))))
 (let ((@x51718 (unit-resolution @x50600 @x51691 $x50490)))
 (let ((@x51361 (hypothesis $x50490)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x51192 (+ ?x8522 ?x51156)))
 (let (($x51199 (<= ?x51192 0)))
 (let (($x51191 (= ?x8522 ?x51044)))
 (let ((?x48159 (* (- 1) ?x7830)))
 (let ((?x48165 (+ pmemlog!logimpl_v.header_crc_offset.? ?x48159)))
 (let (($x48179 (<= ?x48165 (- 8))))
 (let (($x48166 (= ?x48165 (- 8))))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x10901 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x10905 (mp~ @x925 (nnf-pos (proof-bind ?x10901) (~ $x920 $x920)) $x920)))
 (let (($x48169 (not $x920)))
 (let (($x48170 (or $x48169 $x48166)))
 (let (($x48163 (= (+ 8 pmemlog!logimpl_v.header_crc_offset.? ?x48159) 0)))
 (let (($x48171 (or $x48169 $x48163)))
 (let (($x48173 (= $x48171 $x48170)))
 (let ((@x48177 (trans (monotonicity (rewrite (= $x48163 $x48166)) $x48173) (rewrite (= $x48170 $x48170)) $x48173)))
 (let ((@x48178 (mp ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.? 8) $x48171) @x48177 $x48170)))
 (let ((@x50205 (unit-resolution @x48178 @x10905 $x48166)))
 (let ((@x50206 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48166) $x48179)) @x50205 $x48179)))
 (let (($x48180 (>= ?x48165 (- 8))))
 (let ((@x50209 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48166) $x48180)) @x50205 $x48180)))
 (let (($x49477 (<= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7263 (= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7261 (fuel_bool fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x7259 (fuel_bool_default fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x49448 (= $x7261 $x7259)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x47785 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x10467 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x10461 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x10467) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x10436 (mp (mp~ @x37 @x10461 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x48194 (unit-resolution @x10436 @x47785 $x30)))
 (let ((@x49478 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_crc_offset.) (or (not $x30) $x49448)) @x48194 (hypothesis (not $x49448)) false)))
 (let ((@x49491 (lemma @x49478 $x49448)))
 (let ((@x7260 (asserted $x7259)))
 (let ((@x49469 (def-axiom (or (not $x49448) $x7261 (not $x7259)))))
 (let ((@x50180 (unit-resolution (unit-resolution @x49469 @x7260 (or (not $x49448) $x7261)) @x49491 $x7261)))
 (let (($x7266 (not $x7261)))
 (let (($x7267 (or $x7266 $x7263)))
 (let ((@x7270 (mp (asserted (=> $x7261 $x7263)) (rewrite (= (=> $x7261 $x7263) $x7267)) $x7267)))
 (let ((@x50181 (unit-resolution @x7270 @x50180 $x7263)))
 (let ((@x50213 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7263) $x49477)) @x50181 $x49477)))
 (let (($x47421 (>= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let ((?x47434 (* (- 1) pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x441 (uHi 64)))
 (let ((?x47435 (+ ?x441 ?x47434)))
 (let (($x47436 (<= ?x47435 0)))
 (let (($x47422 (not $x47421)))
 (let (($x47441 (or $x47422 $x47436)))
 (let (($x47467 (not $x47441)))
 (let (($x7271 (uInv 64 pmemlog!logimpl_v.header_crc_offset.?)))
 (let (($x47443 (= $x47441 $x7271)))
 (let (($x47446 (not $x47443)))
 (let (($x15503 (forall ((bits Int) (i Int) )(! (let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x15378 (or $x540 $x578)))
 (not (= $x15378 $x648))))))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let (($x669 (forall ((bits Int) (i Int) )(! (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x584)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x15504 (lambda ((bits Int) (i Int) )(let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x15378 (or $x540 $x578)))
 (let (($x15495 (not (= $x15378 $x648))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x667 (= $x648 $x584)))
 (let (($x15498 (= $x667 $x15495)))
 (let ((@x15381 (rewrite (= $x584 (not $x15378)))))
 (let ((@x15499 (trans (monotonicity @x15381 (= $x667 (= $x648 (not $x15378)))) (rewrite (= (= $x648 (not $x15378)) $x15495)) $x15498)))
 (trans @x15499 (rewrite (= $x15495 $x15495)) $x15498)))))))))))))
 ))
 (let ((?x10782 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (refl (~ $x667 $x667)))))))
 ))
 (let (($x660 (forall ((bits Int) (i Int) )(! (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x548)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x674 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x658 (= $x648 $x548)))
 (rewrite (= $x658 $x667))))))))))
 ))
 (let ((@x640 (mp (asserted $x660) (quant-intro (proof-bind ?x674) (= $x660 $x669)) $x669)))
 (let ((@x15508 (mp (mp~ @x640 (nnf-pos (proof-bind ?x10782) (~ $x669 $x669)) $x669) (quant-intro (proof-bind ?x15504) (= $x669 $x15503)) $x15503)))
 (let (($x47104 (not $x15503)))
 (let (($x47453 (or $x47104 $x47446)))
 (let ((?x47073 (* (- 1) ?x441)))
 (let ((?x47423 (+ pmemlog!logimpl_v.header_crc_offset.? ?x47073)))
 (let (($x47424 (>= ?x47423 0)))
 (let (($x47425 (or $x47422 $x47424)))
 (let (($x47426 (= $x47425 $x7271)))
 (let (($x47427 (not $x47426)))
 (let (($x47454 (or $x47104 $x47427)))
 (let (($x47456 (= $x47454 $x47453)))
 (let (($x47448 (= $x47427 $x47446)))
 (let ((@x47452 (trans (monotonicity (rewrite (= $x47426 $x47443)) $x47448) (rewrite (= $x47446 $x47446)) $x47448)))
 (let ((@x47461 (mp ((_ quant-inst 64 pmemlog!logimpl_v.header_crc_offset.?) $x47454) (trans (monotonicity @x47452 $x47456) (rewrite (= $x47453 $x47453)) $x47456) $x47453)))
 (let ((@x7272 (asserted $x7271)))
 (let ((@x47478 (def-axiom (or $x47443 $x47467 (not $x7271)))))
 (let ((@x50217 (unit-resolution (unit-resolution @x47478 @x7272 (or $x47443 $x47467)) (unit-resolution @x47461 @x15508 $x47446) $x47467)))
 (let ((@x47463 (def-axiom (or $x47441 $x47421))))
 (let ((@x50218 (unit-resolution @x47463 @x50217 $x47421)))
 (let ((@x50220 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x50218 @x50213 @x50209 @x50206 (= ?x7830 8))))
 (let (($x48146 (= ?x7830 ?x48145)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x10663 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x10667 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x10663) (~ $x237 $x237)) $x237)))
 (let (($x48156 (not $x237)))
 (let (($x48157 (or $x48156 $x48146)))
 (let ((@x48158 ((_ quant-inst (Add pmemlog!logimpl_v.header_crc_offset.? 8)) $x48157)))
 (let ((@x50308 (unit-resolution @x48158 @x10667 $x48146)))
 (let ((@x50352 (trans* (symm @x50308 (= ?x48145 ?x7830)) @x50220 (= ?x48145 8))))
 (let (($x7320 (= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7318 (fuel_bool fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x7316 (fuel_bool_default fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x49519 (= $x7318 $x7316)))
 (let ((@x49549 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_size.) (or (not $x30) $x49519)) @x48194 (hypothesis (not $x49519)) false)))
 (let ((@x49562 (lemma @x49549 $x49519)))
 (let ((@x7317 (asserted $x7316)))
 (let ((@x49540 (def-axiom (or (not $x49519) $x7318 (not $x7316)))))
 (let ((@x50383 (unit-resolution (unit-resolution @x49540 @x7317 (or (not $x49519) $x7318)) @x49562 $x7318)))
 (let (($x7323 (not $x7318)))
 (let (($x7324 (or $x7323 $x7320)))
 (let ((@x7327 (mp (asserted (=> $x7318 $x7320)) (rewrite (= (=> $x7318 $x7320) $x7324)) $x7324)))
 (let ((@x50384 (unit-resolution @x7327 @x50383 $x7320)))
 (let ((@x50998 (symm @x50384 (= 32 pmemlog!logimpl_v.header_size.?))))
 (let ((?x50870 (I 32)))
 (let ((?x50846 (%I ?x50870)))
 (let (($x50848 (= ?x50846 32)))
 (let (($x50849 (or $x48156 $x50848)))
 (let (($x50843 (= 32 ?x50846)))
 (let (($x50850 (or $x48156 $x50843)))
 (let (($x50852 (= $x50850 $x50849)))
 (let ((@x50835 (trans (monotonicity (rewrite (= $x50843 $x50848)) $x50852) (rewrite (= $x50849 $x50849)) $x50852)))
 (let ((@x50971 (mp ((_ quant-inst 32) $x50850) @x50835 $x50849)))
 (let ((@x51098 (unit-resolution @x50971 @x10667 $x50848)))
 (let ((@x51105 (monotonicity (symm (monotonicity @x50998 (= ?x50870 ?x7835)) (= ?x7835 ?x50870)) (= ?x51036 ?x50846))))
 (let ((@x51142 (monotonicity (trans* @x51105 @x51098 @x50998 (= ?x51036 pmemlog!logimpl_v.header_size.?)) @x50352 (= ?x51044 ?x8522))))
 (let ((@x51366 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51191) $x51199)) (symm @x51142 $x51191) $x51199)))
 (let ((?x47798 (vstd!seq.Seq.len.? $ ?x1876 ?x47797)))
 (let ((?x48189 (* (- 1) ?x47798)))
 (let ((?x48190 (+ ?x8522 ?x48189)))
 (let (($x48192 (>= ?x48190 0)))
 (let (($x48188 (= ?x8522 ?x47798)))
 (let (($x47799 (= ?x47798 ?x8522)))
 (let ((@x47800 (asserted $x47799)))
 (let ((@x51143 (symm @x47800 $x48188)))
 (let ((@x51371 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48188) $x48192)) @x51143 $x48192)))
 (let ((?x51018 (+ ?x47798 ?x50592)))
 (let (($x51020 (>= ?x51018 0)))
 (let (($x51017 (= ?x47798 ?x50494)))
 (let (($x50583 (= ?x50494 ?x47798)))
 (let ((?x51043 (vstd!seq.Seq.len.? $ ?x1876 ?x50867)))
 (let (($x51045 (= ?x51043 ?x51044)))
 (let (($x51028 (>= ?x48145 0)))
 (let ((?x50287 (* (- 1) ?x48145)))
 (let ((?x50288 (+ ?x7830 ?x50287)))
 (let (($x50289 (<= ?x50288 0)))
 (let ((@x50309 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48146) $x50289)) @x50308 $x50289)))
 (let ((@x51104 (lemma ((_ th-lemma arith farkas 1 1 1 1) @x50309 @x50218 @x50206 (hypothesis (not $x51028)) false) $x51028)))
 (let ((?x51053 (* (- 1) ?x51036)))
 (let ((?x48442 (vstd!seq.Seq.len.? $ ?x1876 ?x47805)))
 (let ((?x51069 (+ ?x48442 ?x51053)))
 (let (($x51070 (>= ?x51069 0)))
 (let ((?x47788 (vstd!seq.Seq.len.? $ ?x1876 ?x47787)))
 (let ((?x48182 (* (- 1) ?x47788)))
 (let ((?x48183 (+ pmemlog!logimpl_v.header_size.? ?x48182)))
 (let (($x48184 (<= ?x48183 0)))
 (let (($x48181 (= pmemlog!logimpl_v.header_size.? ?x47788)))
 (let (($x47789 (= ?x47788 pmemlog!logimpl_v.header_size.?)))
 (let ((@x47790 (asserted $x47789)))
 (let ((@x50374 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48181) $x48184)) (symm @x47790 $x48181) $x48184)))
 (let (($x49536 (>= pmemlog!logimpl_v.header_size.? 32)))
 (let ((@x50385 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x49536)) @x50384 $x49536)))
 (let ((?x48459 (* (- 1) ?x48442)))
 (let ((?x50297 (+ ?x47788 ?x48459)))
 (let (($x50298 (<= ?x50297 0)))
 (let (($x50239 (= ?x47788 ?x48442)))
 (let (($x48087 (= ?x47787 ?x47805)))
 (let (($x47806 (ext_eq false ?x1968 ?x47787 ?x47805)))
 (let (($x48088 (= $x48087 $x47806)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x10747 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x10751 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x10747) (~ $x418 $x418)) $x418)))
 (let (($x48089 (not $x418)))
 (let (($x48105 (or $x48089 $x48088)))
 (let ((@x48106 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797)) $x48105)))
 (let ((@x47807 (asserted $x47806)))
 (let ((@x48110 (def-axiom (or (not $x48088) $x48087 (not $x47806)))))
 (let ((@x50392 (unit-resolution (unit-resolution @x48110 @x47807 (or (not $x48088) $x48087)) (unit-resolution @x48106 @x10751 $x48088) $x48087)))
 (let ((@x50394 (symm @x50392 (= ?x47805 ?x47787))))
 (let ((@x50398 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50239) $x50298)) (symm (monotonicity @x50394 (= ?x48442 ?x47788)) $x50239) $x50298)))
 (let (($x51096 (<= ?x51036 32)))
 (let (($x51012 (= ?x51036 32)))
 (let ((@x51114 (trans* @x51105 @x51098 $x51012)))
 (let ((@x51123 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 -1 1) (or $x51070 (not $x51096) (not $x50298) (not $x49536) (not $x48184))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51012) $x51096)) @x51114 $x51096) @x50398 @x50385 @x50374 $x51070)))
 (let ((?x51054 (+ ?x48145 ?x51053)))
 (let (($x51055 (<= ?x51054 0)))
 (let (($x50290 (>= ?x50288 0)))
 (let ((@x50377 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48146) $x50290)) @x50308 $x50290)))
 (let (($x51097 (>= ?x51036 32)))
 (let ((@x51116 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1) (or $x51055 (not $x51097) (not $x50290) (not $x49477) (not $x48180))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51012) $x51097)) @x51114 $x51097) @x50377 @x50213 @x50209 $x51055)))
 (let (($x50865 (has_type ?x7835 INT)))
 (let (($x50993 (has_type ?x50870 INT)))
 (let (($x51005 (not $x50993)))
 (let ((@x51004 (symm (monotonicity (monotonicity @x50998 (= ?x50870 ?x7835)) (= $x50993 $x50865)) (= $x50865 $x50993))))
 (let ((@x51008 (mp (hypothesis (not $x50865)) (monotonicity @x51004 (= (not $x50865) $x51005)) $x51005)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x10803 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x10807 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x10803) (~ $x698 $x698)) $x698)))
 (let ((@x51010 (unit-resolution (unit-resolution ((_ quant-inst 32) (or (not $x698) $x50993)) @x10807 $x50993) @x51008 false)))
 (let ((@x51011 (lemma @x51010 $x50865)))
 (let (($x48141 (has_type ?x7831 INT)))
 (let ((?x50165 (I 8)))
 (let (($x50166 (has_type ?x50165 INT)))
 (let (($x50229 (not $x50166)))
 (let ((@x50226 (monotonicity (monotonicity (symm @x50220 (= 8 ?x7830)) (= ?x50165 ?x7831)) (= $x50166 $x48141))))
 (let ((@x50232 (mp (hypothesis (not $x48141)) (monotonicity (symm @x50226 (= $x48141 $x50166)) (= (not $x48141) $x50229)) $x50229)))
 (let ((@x50234 (unit-resolution (unit-resolution ((_ quant-inst 8) (or (not $x698) $x50166)) @x10807 $x50166) @x50232 false)))
 (let ((@x50235 (lemma @x50234 $x48141)))
 (let (($x48118 (has_type ?x47805 ?x1968)))
 (let (($x48022 (has_type ?x47792 ?x1968)))
 (let ((?x48060 (%Poly%vstd!seq.Seq<u8.>. ?x47802)))
 (let ((?x50048 (Poly%vstd!seq.Seq<u8.>. ?x48060)))
 (let (($x50021 (has_type ?x50048 ?x1968)))
 (let (($x50086 (not $x50021)))
 (let (($x48085 (= ?x47792 ?x47802)))
 (let (($x48086 (= $x48085 $x47803)))
 (let (($x48090 (or $x48089 $x48086)))
 (let ((@x48091 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. crc_bytes!) (Poly%vstd!seq.Seq<u8.>. ?x47801)) $x48090)))
 (let ((@x47804 (asserted $x47803)))
 (let ((@x48095 (def-axiom (or (not $x48086) $x48085 (not $x47803)))))
 (let ((@x50072 (unit-resolution (unit-resolution @x48095 @x47804 (or (not $x48086) $x48085)) (unit-resolution @x48091 @x10751 $x48086) $x48085)))
 (let ((@x50079 (symm @x50072 (= ?x47802 ?x47792))))
 (let (($x48061 (= ?x47801 ?x48060)))
 (let (($x1966 (forall ((x vstd!seq.Seq<u8.>.) )(! (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x))) :pattern ( (Poly%vstd!seq.Seq<u8.>. x) ) :qid internal_vstd__seq__Seq<u8.>_box_axiom_definition))
 ))
 (let ((?x11253 (lambda ((x vstd!seq.Seq<u8.>.) )(let (($x1964 (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x)))))
 (refl (~ $x1964 $x1964))))
 ))
 (let ((@x11257 (mp~ (asserted $x1966) (nnf-pos (proof-bind ?x11253) (~ $x1966 $x1966)) $x1966)))
 (let (($x48053 (not $x1966)))
 (let (($x48066 (or $x48053 $x48061)))
 (let ((@x48067 ((_ quant-inst (pmemlog!pmemspec_t.spec_crc_bytes.? ?x47797)) $x48066)))
 (let ((@x50077 (monotonicity (symm (unit-resolution @x48067 @x11257 $x48061) (= ?x48060 ?x47801)) (= ?x50048 ?x47802))))
 (let ((@x50085 (symm (monotonicity (trans* @x50077 @x50079 (= ?x50048 ?x47792)) (= $x50021 $x48022)) (= $x48022 $x50021))))
 (let ((@x50089 (mp (hypothesis (not $x48022)) (monotonicity @x50085 (= (not $x48022) $x50086)) $x50086)))
 (let (($x1989 (forall ((x vstd!seq.Seq<u8.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (has_type ?x1962 ?x1968)))) :pattern ( (has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_has_type_always_definition))
 ))
 (let ((?x11267 (lambda ((x vstd!seq.Seq<u8.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (let (($x1987 (has_type ?x1962 ?x1968)))
 (refl (~ $x1987 $x1987)))))))
 ))
 (let ((@x11271 (mp~ (asserted $x1989) (nnf-pos (proof-bind ?x11267) (~ $x1989 $x1989)) $x1989)))
 (let ((@x50091 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47802)) (or (not $x1989) $x50021)) @x11271 $x50021) @x50089 false)))
 (let ((@x50092 (lemma @x50091 $x48022)))
 (let (($x48033 (has_type ?x47797 ?x1968)))
 (let ((?x48056 (%Poly%vstd!seq.Seq<u8.>. ?x47797)))
 (let ((?x50054 (Poly%vstd!seq.Seq<u8.>. ?x48056)))
 (let (($x50055 (has_type ?x50054 ?x1968)))
 (let (($x50107 (not $x50055)))
 (let (($x48057 (= metadata_bytes! ?x48056)))
 (let (($x48062 (or $x48053 $x48057)))
 (let ((@x48063 ((_ quant-inst metadata_bytes!) $x48062)))
 (let ((@x50102 (monotonicity (symm (unit-resolution @x48063 @x11257 $x48057) (= ?x48056 metadata_bytes!)) (= ?x50054 ?x47797))))
 (let ((@x50109 (monotonicity (symm (monotonicity @x50102 (= $x50055 $x48033)) (= $x48033 $x50055)) (= (not $x48033) $x50107))))
 (let ((@x50112 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47797)) (or (not $x1989) $x50055)) @x11271 $x50055) (mp (hypothesis (not $x48033)) @x50109 $x50107) false)))
 (let ((@x50113 (lemma @x50112 $x48033)))
 (let (($x48034 (not $x48033)))
 (let (($x48023 (not $x48022)))
 (let (($x48119 (or $x48023 $x48034 $x48118)))
 (let (($x16863 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x16683 (not $x4525)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x16430 (not $x4101)))
 (or $x16430 $x16683 $x4941)))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let (($x4949 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4941)))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let ((?x16864 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x16683 (not $x4525)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x16430 (not $x4101)))
 (let (($x16858 (or $x16430 $x16683 $x4941)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (let ((@x16850 (monotonicity (rewrite (= $x4526 (not (or $x16430 $x16683)))) (= $x4568 (not (not (or $x16430 $x16683)))))))
 (let ((@x16854 (trans @x16850 (rewrite (= (not (not (or $x16430 $x16683))) (or $x16430 $x16683))) (= $x4568 (or $x16430 $x16683)))))
 (trans (monotonicity @x16854 (= $x4946 (or (or $x16430 $x16683) $x4941))) (rewrite (= (or (or $x16430 $x16683) $x4941) $x16858)) (= $x4946 $x16858))))))))))))))))
 ))
 (let ((?x12747 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (refl (~ $x4946 $x4946)))))))))))
 ))
 (let (($x4944 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> $x4526 $x4941))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let ((?x4950 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (let (($x4942 (=> $x4526 $x4941)))
 (rewrite (= $x4942 $x4946))))))))))))
 ))
 (let ((@x4954 (mp (asserted $x4944) (quant-intro (proof-bind ?x4950) (= $x4944 $x4949)) $x4949)))
 (let ((@x16868 (mp (mp~ @x4954 (nnf-pos (proof-bind ?x12747) (~ $x4949 $x4949)) $x4949) (quant-intro (proof-bind ?x16864) (= $x4949 $x16863)) $x16863)))
 (let (($x48134 (not $x16863)))
 (let (($x48135 (or $x48134 $x48023 $x48034 $x48118)))
 (let ((@x48140 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. crc_bytes!) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)) (or $x48134 $x48119)) (rewrite (= (or $x48134 $x48119) $x48135)) $x48135)))
 (let ((@x50362 (unit-resolution (unit-resolution @x48140 @x16868 $x48119) @x50113 @x50092 $x48118)))
 (let (($x16718 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x16518 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x16517 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x15722 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x16558 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x16532 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x16522 (not $x4256)))
 (or $x16522 $x16532 $x271 $x16558 $x15722 $x16517 $x16518 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x48679 (= $x4641 $x1589)))
 (let ((@x48681 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x48679)) @x48194 (hypothesis (not $x48679)) false)))
 (let ((@x48693 (lemma @x48681 $x48679)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x15869 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x15868 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x15867 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x15866 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x15865 (not $x1590)))
 (let (($x15864 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x15863 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x15862 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x15861 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x15860 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x15859 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x15858 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x15857 (not $x1582)))
 (let (($x15870 (or $x15857 $x15858 $x15859 $x15860 $x15861 $x15862 $x15863 $x15864 $x15865 $x15866 $x15867 $x15868 $x15869)))
 (let (($x15871 (not $x15870)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x15934 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x15933 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x15932 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x15931 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x15930 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x15929 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x15928 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x15927 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x15926 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x15925 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x15924 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x15923 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x15922 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x15921 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x15920 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x15935 (or $x1598 $x1610 $x15920 $x1621 $x15921 $x15922 $x15923 $x1565 $x15924 $x1633 $x15925 $x15926 $x1576 $x15927 $x15928 $x15929 $x15930 $x15931 $x15932 $x1644 $x15933 $x15934)))
 (let (($x15936 (not $x15935)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x15939 (or $x1669 $x15936)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x15941 (mp @x1673 (rewrite (= $x1670 $x15939)) $x15939)))
 (let ((@x45890 (def-axiom (or $x15935 $x1581))))
 (let (($x15874 (or $x1598 $x15871)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x15876 (mp @x1602 (rewrite (= $x1599 $x15874)) $x15874)))
 (let ((@x50355 (unit-resolution @x15876 (unit-resolution @x45890 (unit-resolution @x15941 @x1650 $x15936) $x1581) $x15871)))
 (let ((@x45848 (def-axiom (or $x15870 $x1589))))
 (let ((@x48686 (def-axiom (or (not $x48679) $x4641 $x15864))))
 (let ((@x50358 (unit-resolution @x48686 (unit-resolution @x45848 @x50355 $x1589) (or (not $x48679) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x16769 (or $x4675 $x16718)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x12689 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x12712 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x12689) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x4233 (<= ?x1191 ?x264)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 $x4233)))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643)))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x4233 (<= ?x1191 ?x264)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 $x4233)))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664)))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x16771 (mp (mp (mp~ @x4681 @x12712 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x16769)) $x16769)))
 (let ((@x50360 (unit-resolution @x16771 (unit-resolution @x50358 @x48693 $x4641) $x16718)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x51075 (not $x51070)))
 (let (($x51060 (not $x51055)))
 (let (($x51029 (not $x51028)))
 (let (($x48336 (not $x174)))
 (let (($x50866 (not $x50865)))
 (let (($x48142 (not $x48141)))
 (let (($x48472 (not $x48118)))
 (let (($x50249 (not $x16718)))
 (let (($x51091 (or $x50249 $x48472 $x48142 $x50866 $x48336 $x51029 $x51060 $x51075 $x51045)))
 (let ((?x51040 (+ ?x51036 ?x48459)))
 (let (($x51041 (<= ?x51040 0)))
 (let (($x51042 (not $x51041)))
 (let ((?x51037 (+ ?x51036 ?x50287)))
 (let (($x51038 (>= ?x51037 0)))
 (let (($x51039 (not $x51038)))
 (let (($x51046 (or $x48472 $x48142 $x50866 $x48336 $x51029 $x51039 $x51042 $x51045)))
 (let (($x51092 (or $x50249 $x51046)))
 (let ((@x51023 (rewrite (= (or $x50249 (or $x48472 $x48142 $x50866 $x48336 $x51029 $x51060 $x51075 $x51045)) $x51091))))
 (let (($x51086 (or $x48472 $x48142 $x50866 $x48336 $x51029 $x51060 $x51075 $x51045)))
 (let (($x51077 (= $x51046 $x51086)))
 (let ((@x51090 (trans (monotonicity (rewrite (= $x51039 $x51060)) (rewrite (= $x51042 $x51075)) $x51077) (rewrite (= $x51086 $x51086)) $x51077)))
 (let ((@x51025 (trans (monotonicity @x51090 (= $x51092 (or $x50249 $x51086))) @x51023 (= $x51092 $x51091))))
 (let ((@x51124 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797) (I ?x7830) (I pmemlog!logimpl_v.header_size.?)) $x51092) @x51025 $x51091) @x175 @x50360 @x50362 @x50235 @x51011 @x51116 @x51123 @x51104 $x51045)))
 (let ((@x50222 (symm @x50220 (= 8 ?x7830))))
 (let (($x7277 (= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let (($x7275 (fuel_bool fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x7273 (fuel_bool_default fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x49465 (= $x7275 $x7273)))
 (let ((@x49495 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_head_offset.) (or (not $x30) $x49465)) @x48194 (hypothesis (not $x49465)) false)))
 (let ((@x49508 (lemma @x49495 $x49465)))
 (let ((@x7274 (asserted $x7273)))
 (let ((@x49486 (def-axiom (or (not $x49465) $x7275 (not $x7273)))))
 (let ((@x51127 (unit-resolution (unit-resolution @x49486 @x7274 (or (not $x49465) $x7275)) @x49508 $x7275)))
 (let (($x7280 (not $x7275)))
 (let (($x7281 (or $x7280 $x7277)))
 (let ((@x7284 (mp (asserted (=> $x7275 $x7277)) (rewrite (= (=> $x7275 $x7277) $x7281)) $x7281)))
 (let ((@x51130 (trans* (unit-resolution @x7284 @x51127 $x7277) @x50222 (= pmemlog!logimpl_v.header_head_offset.? ?x7830))))
 (let ((@x51136 (monotonicity @x50394 (symm (monotonicity @x51130 (= ?x7834 ?x7831)) (= ?x7831 ?x7834)) (= ?x50867 ?x47815))))
 (let ((@x51138 (symm @x51136 (= ?x47815 ?x50867))))
 (let ((@x51146 (unit-resolution (hypothesis (not $x50583)) (trans* (monotonicity @x51138 (= ?x50494 ?x51043)) @x51124 @x51142 @x51143 $x50583) false)))
 (let ((@x51147 (lemma @x51146 $x50583)))
 (let ((@x51376 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51017) $x51020)) (symm @x51147 $x51017) $x51020)))
 (let ((@x51380 (lemma ((_ th-lemma arith farkas -1 -1 -1 1 1) @x51376 @x51371 (hypothesis $x51164) @x51366 @x51361 false) (or $x51378 $x50796))))
 (let ((@x50787 (def-axiom (or $x50822 $x50495))))
 (let ((@x51754 (unit-resolution @x50787 @x51691 $x50495)))
 (let (($x16788 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16418 (not $x821)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4686 (sized A&.)))
 (let (($x16738 (not $x4686)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k! INT)))
 (let (($x16532 (not $x4257)))
 (let (($x4684 (has_type j! INT)))
 (let (($x16778 (not $x4684)))
 (or (not (has_type s! (TYPE%vstd!seq.Seq. A&. A&))) $x16778 $x16532 $x271 $x16738 (not (>= (%I j!) 0)) (not (<= (+ (%I j!) (* (- 1) (%I k!))) 0)) (not $x4711) $x16418 $x4741 $x4703)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4682 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x48694 (= $x4682 $x1590)))
 (let ((@x48696 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_index.) (or (not $x30) $x48694)) @x48194 (hypothesis (not $x48694)) false)))
 (let ((@x48708 (lemma @x48696 $x48694)))
 (let ((@x48701 (def-axiom (or (not $x48694) $x4682 $x15865))))
 (let ((@x50920 (unit-resolution @x48701 (unit-resolution (def-axiom (or $x15870 $x1590)) @x50355 $x1590) (or (not $x48694) $x4682))))
 (let (($x4749 (not $x4682)))
 (let (($x16793 (or $x4749 $x16788)))
 (let (($x4774 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (or (not $x4685) $x4759 $x4703)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4779 (or $x4749 $x4774)))
 (let ((?x12721 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (refl (~ $x4769 $x4769)))))))))))))))))))))))
 ))
 (let ((@x12726 (monotonicity (refl (~ $x4749 $x4749)) (nnf-pos (proof-bind ?x12721) (~ $x4774 $x4774)) (~ $x4779 $x4779))))
 (let (($x4707 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) (%I j!))))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let ((?x1186 (%I j!)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4686 (sized A&.)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (=> (and $x4685 $x4697) $x4703))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4708 (=> $x4682 $x4707)))
 (let ((?x4775 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) ?x1186)))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x4705 (=> (and $x4685 $x4697) $x4703)))
 (let ((@x4734 (rewrite (= (and $x4686 (and $x4710 $x4714 $x4711)) (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4723 (monotonicity (rewrite (= $x4689 (and $x4710 $x4714))) (rewrite (= $x4691 $x4711)) (= $x4692 (and (and $x4710 $x4714) $x4711)))))
 (let ((@x4728 (trans @x4723 (rewrite (= (and (and $x4710 $x4714) $x4711) (and $x4710 $x4714 $x4711))) (= $x4692 (and $x4710 $x4714 $x4711)))))
 (let ((@x4736 (trans (monotonicity @x4728 (= $x4693 (and $x4686 (and $x4710 $x4714 $x4711)))) @x4734 (= $x4693 (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4742 (monotonicity @x4736 (rewrite (= $x4696 (and $x821 $x4746))) (= $x4697 (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746))))))
 (let ((@x4755 (trans @x4742 (rewrite (= (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746)) $x4745)) (= $x4697 $x4745))))
 (let ((@x4764 (trans (monotonicity @x4755 (= $x4704 (=> $x4745 $x4703))) (rewrite (= (=> $x4745 $x4703) (or $x4759 $x4703))) (= $x4704 (or $x4759 $x4703)))))
 (trans (monotonicity @x4764 (= $x4705 (=> $x4685 (or $x4759 $x4703)))) (rewrite (= (=> $x4685 (or $x4759 $x4703)) $x4769)) (= $x4705 $x4769))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4747 (monotonicity (quant-intro (proof-bind ?x4775) (= $x4707 $x4774)) (= $x4708 (=> $x4682 $x4774)))))
 (let ((@x4784 (mp (asserted $x4708) (trans @x4747 (rewrite (= (=> $x4682 $x4774) $x4779)) (= $x4708 $x4779)) $x4779)))
 (let ((@x16795 (mp (mp (mp~ @x4784 @x12726 $x4779) (rewrite (= $x4779 $x4779)) $x4779) (rewrite (= $x4779 $x16793)) $x16793)))
 (let ((@x50922 (unit-resolution @x16795 (unit-resolution @x50920 @x48708 $x4682) $x16788)))
 (let (($x50511 (not $x16788)))
 (let (($x51223 (or $x50511 $x48472 $x48142 $x50866 $x50582 $x48336 $x51029 $x51060 $x51075 $x50496 $x51164 $x51169)))
 (let (($x51170 (or $x48472 $x48142 $x50866 $x50582 $x48336 $x51029 $x51060 $x51042 $x50496 $x51164 $x51169)))
 (let (($x51229 (or $x50511 $x51170)))
 (let (($x51175 (or $x48472 $x48142 $x50866 $x50582 $x48336 $x51029 $x51060 $x51075 $x50496 $x51164 $x51169)))
 (let (($x51228 (or $x50511 $x51175)))
 (let (($x51176 (= $x51170 $x51175)))
 (let ((@x51222 (trans (monotonicity (rewrite (= $x51042 $x51075)) $x51176) (rewrite (= $x51175 $x51175)) $x51176)))
 (let ((@x51237 (trans (monotonicity @x51222 (= $x51229 $x51228)) (rewrite (= $x51228 $x51223)) (= $x51229 $x51223))))
 (let ((@x51770 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797) (I ?x7830) (I pmemlog!logimpl_v.header_size.?) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47797 ?x47815 ?x1876 $)) $x51229) @x51237 $x51223) @x175 @x50922 @x50362 @x50235 @x51692 @x51754 @x51011 @x51116 @x51123 @x51104 (unit-resolution @x51380 @x51718 $x51378) $x51169)))
 (let ((?x50169 (%Poly%vstd!seq.Seq<u8.>. ?x47809)))
 (let ((?x50170 (Poly%vstd!seq.Seq<u8.>. ?x50169)))
 (let ((?x50254 (vstd!seq.Seq.len.? $ ?x1876 ?x50170)))
 (let ((?x51381 (%I ?x51167)))
 (let ((?x51485 (I ?x51381)))
 (let ((?x51279 (%I ?x51485)))
 (let ((?x51415 (Sub ?x51279 ?x50254)))
 (let ((?x51410 (I ?x51415)))
 (let ((?x51416 (vstd!seq.Seq.index.? $ ?x1876 ?x47797 ?x51410)))
 (let ((?x51386 (vstd!seq.Seq.add.? $ ?x1876 ?x50170 ?x47797)))
 (let ((?x51321 (vstd!seq.Seq.index.? $ ?x1876 ?x51386 ?x51485)))
 (let (($x51417 (= ?x51321 ?x51416)))
 (let ((?x51356 (* (- 1) ?x51279)))
 (let ((?x51332 (+ ?x50254 ?x51356)))
 (let (($x51333 (<= ?x51332 0)))
 (let ((?x51397 (* (- 1) ?x51381)))
 (let ((?x51461 (+ ?x51279 ?x51397)))
 (let (($x51463 (>= ?x51461 0)))
 (let (($x51466 (= ?x51279 ?x51381)))
 (let (($x51493 (= ?x51485 ?x51167)))
 (let (($x51083 (= ?x51167 ?x51485)))
 (let (($x51359 (has_type ?x51167 INT)))
 (let (($x51486 (has_type ?x51485 INT)))
 (let (($x51499 (not $x51486)))
 (let (($x51497 (= $x51359 $x51486)))
 (let (($x51495 (= $x51486 $x51359)))
 (let (($x51453 (= ?x51166 ?x51381)))
 (let (($x51456 (or $x48156 $x51453)))
 (let ((@x51457 ((_ quant-inst (Add ?x50485 ?x48145)) $x51456)))
 (let ((@x51488 (unit-resolution @x51457 @x10667 $x51453)))
 (let ((@x51498 (symm (monotonicity (monotonicity (symm @x51488 (= ?x51381 ?x51166)) $x51493) $x51495) $x51497)))
 (let ((@x51502 (mp (hypothesis (not $x51359)) (monotonicity @x51498 (= (not $x51359) $x51499)) $x51499)))
 (let ((@x51504 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x51167)) (or (not $x698) $x51486)) @x10807 $x51486) @x51502 false)))
 (let ((@x51505 (lemma @x51504 $x51359)))
 (let (($x51360 (not $x51359)))
 (let (($x51033 (or $x50282 $x51360 $x51083)))
 (let ((@x51081 (mp ((_ quant-inst (I ?x51166)) (or $x50282 (or $x51360 $x51083))) (rewrite (= (or $x50282 (or $x51360 $x51083)) $x51033)) $x51033)))
 (let ((@x51609 (symm (unit-resolution @x51081 @x10688 @x51505 $x51083) $x51493)))
 (let ((@x51610 (monotonicity @x51609 $x51466)))
 (let ((?x47793 (vstd!seq.Seq.len.? $ ?x1876 ?x47792)))
 (let (($x48186 (<= ?x47793 8)))
 (let (($x47794 (= ?x47793 8)))
 (let ((@x47795 (asserted $x47794)))
 (let ((@x50681 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47794) $x48186)) @x47795 $x48186)))
 (let ((?x51454 (Add ?x50485 8)))
 (let ((?x51455 (* (- 1) ?x51454)))
 (let ((?x51172 (+ ?x51166 ?x51455)))
 (let (($x51174 (>= ?x51172 0)))
 (let (($x51171 (= ?x51166 ?x51454)))
 (let ((@x51599 (symm (monotonicity (trans* @x50222 @x50308 (= 8 ?x48145)) (= ?x51454 ?x51166)) $x51171)))
 (let ((@x51776 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51171) $x51174)) @x51599 $x51174)))
 (let ((?x51460 (+ ?x50485 ?x51455)))
 (let (($x51179 (<= ?x51460 (- 8))))
 (let (($x51013 (= ?x51460 (- 8))))
 (let (($x51154 (or $x48169 $x51013)))
 (let (($x51459 (= (+ 8 ?x50485 ?x51455) 0)))
 (let (($x51155 (or $x48169 $x51459)))
 (let (($x51160 (= $x51155 $x51154)))
 (let ((@x51163 (trans (monotonicity (rewrite (= $x51459 $x51013)) $x51160) (rewrite (= $x51154 $x51154)) $x51160)))
 (let ((@x51178 (mp ((_ quant-inst (%I ?x50467) 8) $x51155) @x51163 $x51154)))
 (let ((@x51590 (unit-resolution @x51178 @x10905 $x51013)))
 (let ((@x51779 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51013) $x51179)) @x51590 $x51179)))
 (let ((?x51151 (+ ?x51166 ?x51397)))
 (let (($x51152 (<= ?x51151 0)))
 (let ((?x48567 (vstd!seq.Seq.len.? $ ?x1876 ?x47809)))
 (let ((?x48584 (* (- 1) ?x48567)))
 (let ((?x50246 (+ ?x47793 ?x48584)))
 (let (($x50248 (>= ?x50246 0)))
 (let (($x50245 (= ?x47793 ?x48567)))
 (let ((?x48306 (vstd!seq.Seq.len.? $ ?x1876 ?x47802)))
 (let (($x48576 (= ?x48567 ?x48306)))
 (let ((@x50418 (monotonicity @x50079 (= ?x48306 ?x47793))))
 (let ((@x50422 (symm @x50418 (= ?x47793 ?x48306))))
 (let ((@x50420 (symm @x47795 (= 8 ?x47793))))
 (let ((?x50314 (Sub 8 0)))
 (let (($x50330 (= ?x50314 8)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x10908 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x10912 (mp~ @x956 (nnf-pos (proof-bind ?x10908) (~ $x951 $x951)) $x951)))
 (let (($x48073 (not $x951)))
 (let (($x50335 (or $x48073 $x50330)))
 (let ((?x50313 (* (- 1) 8)))
 (let ((?x50315 (+ 0 ?x50313 ?x50314)))
 (let (($x50316 (= ?x50315 0)))
 (let (($x50336 (or $x48073 $x50316)))
 (let (($x50338 (= $x50336 $x50335)))
 (let ((@x50326 (trans (monotonicity (rewrite (= ?x50313 (- 8))) (= ?x50315 (+ 0 (- 8) ?x50314))) (rewrite (= (+ 0 (- 8) ?x50314) (+ (- 8) ?x50314))) (= ?x50315 (+ (- 8) ?x50314)))))
 (let ((@x50334 (trans (monotonicity @x50326 (= $x50316 (= (+ (- 8) ?x50314) 0))) (rewrite (= (= (+ (- 8) ?x50314) 0) $x50330)) (= $x50316 $x50330))))
 (let ((@x50343 (mp ((_ quant-inst 8 0) $x50336) (trans (monotonicity @x50334 $x50338) (rewrite (= $x50335 $x50335)) $x50338) $x50335)))
 (let ((?x48154 (%I ?x7829)))
 (let (($x48155 (= pmemlog!logimpl_v.header_crc_offset.? ?x48154)))
 (let (($x48161 (or $x48156 $x48155)))
 (let ((@x48162 ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.?) $x48161)))
 (let ((@x50303 (unit-resolution @x48162 @x10667 $x48155)))
 (let ((@x50348 (trans* (symm @x50303 (= ?x48154 pmemlog!logimpl_v.header_crc_offset.?)) @x50181 (= ?x48154 0))))
 (let ((?x50274 (Sub ?x48145 ?x48154)))
 (let ((?x50272 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47805 ?x7829 ?x7831)))
 (let ((?x50273 (vstd!seq.Seq.len.? $ ?x1876 ?x50272)))
 (let (($x50275 (= ?x50273 ?x50274)))
 (let ((?x50265 (* (- 1) ?x48154)))
 (let ((?x50266 (+ ?x48145 ?x50265)))
 (let (($x50267 (>= ?x50266 0)))
 (let ((?x50277 (+ pmemlog!logimpl_v.header_crc_offset.? ?x50265)))
 (let (($x50286 (>= ?x50277 0)))
 (let ((@x50311 ((_ th-lemma arith farkas 1 1 1 1) (hypothesis (not $x50267)) @x50309 @x50206 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48155) $x50286)) @x50303 $x50286) false)))
 (let ((@x50312 (lemma @x50311 $x50267)))
 (let ((?x50269 (+ ?x48145 ?x48459)))
 (let (($x50270 (<= ?x50269 0)))
 (let (($x50404 (not $x48184)))
 (let (($x50403 (not $x49536)))
 (let (($x50402 (not $x50298)))
 (let (($x50401 (not $x48180)))
 (let (($x50400 (not $x49477)))
 (let (($x50399 (not $x50290)))
 (let ((@x50407 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1 1 1) (or $x50270 $x50399 $x50400 $x50401 $x50402 $x50403 $x50404)) @x50398 @x50213 @x50385 @x50377 @x50374 @x50209 $x50270)))
 (let (($x50257 (>= ?x48154 0)))
 (let (($x50278 (<= ?x50277 0)))
 (let ((@x50369 (unit-resolution ((_ th-lemma arith assign-bounds -1 1) (or $x50257 $x47422 (not $x50278))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48155) $x50278)) @x50303 $x50278) @x50218 $x50257)))
 (let (($x48132 (has_type ?x7829 INT)))
 (let ((?x7131 (I 0)))
 (let (($x50161 (has_type ?x7131 INT)))
 (let (($x50190 (not $x50161)))
 (let ((@x50183 (symm @x50181 (= 0 pmemlog!logimpl_v.header_crc_offset.?))))
 (let ((@x50189 (symm (monotonicity (monotonicity @x50183 (= ?x7131 ?x7829)) (= $x50161 $x48132)) (= $x48132 $x50161))))
 (let ((@x50193 (mp (hypothesis (not $x48132)) (monotonicity @x50189 (= (not $x48132) $x50190)) $x50190)))
 (let ((@x50195 (unit-resolution (unit-resolution ((_ quant-inst 0) (or (not $x698) $x50161)) @x10807 $x50161) @x50193 false)))
 (let ((@x50196 (lemma @x50195 $x48132)))
 (let (($x50271 (not $x50270)))
 (let (($x50268 (not $x50267)))
 (let (($x50258 (not $x50257)))
 (let (($x48133 (not $x48132)))
 (let (($x50250 (or $x50249 $x48472 $x48133 $x48142 $x48336 $x50258 $x50268 $x50271 $x50275)))
 (let ((@x50293 (rewrite (= (or $x50249 (or $x48472 $x48133 $x48142 $x48336 $x50258 $x50268 $x50271 $x50275)) $x50250))))
 (let ((@x50294 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830)) (or $x50249 (or $x48472 $x48133 $x48142 $x48336 $x50258 $x50268 $x50271 $x50275))) @x50293 $x50250)))
 (let ((@x50408 (unit-resolution @x50294 @x175 @x50360 @x50362 @x50196 @x50235 @x50369 @x50407 @x50312 $x50275)))
 (let ((@x50414 (monotonicity (symm (monotonicity @x50394 (= ?x50272 ?x47809)) (= ?x47809 ?x50272)) (= ?x48567 ?x50273))))
 (let ((@x50423 (trans* @x50414 @x50408 (monotonicity @x50352 @x50348 (= ?x50274 ?x50314)) (unit-resolution @x50343 @x10912 $x50330) @x50420 @x50422 $x48576)))
 (let ((@x50426 (lemma (unit-resolution (hypothesis (not $x48576)) @x50423 false) $x48576)))
 (let ((@x50675 (symm @x50426 (= ?x48306 ?x48567))))
 (let ((@x50677 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50245) $x50248)) (trans* @x50422 @x50675 $x50245) $x50248)))
 (let ((?x50238 (* (- 1) ?x50254)))
 (let ((?x50283 (+ ?x48567 ?x50238)))
 (let (($x50280 (>= ?x50283 0)))
 (let (($x50237 (= ?x48567 ?x50254)))
 (let (($x50171 (= ?x47809 ?x50170)))
 (let (($x48143 (has_type ?x47809 ?x1968)))
 (let (($x48018 (has_type ?x47787 ?x1968)))
 (let ((@x51620 (mp @x50362 (symm (monotonicity @x50392 (= $x48018 $x48118)) (= $x48118 $x48018)) $x48018)))
 (let (($x48019 (not $x48018)))
 (let (($x48144 (or $x48019 $x48133 $x48142 $x48143)))
 (let (($x16552 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x16532 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x16522 (not $x4256)))
 (or $x16522 $x16532 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x16553 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x16532 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x16522 (not $x4256)))
 (let (($x16547 (or $x16522 $x16532 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x16539 (monotonicity (rewrite (= $x4258 (not (or $x16522 $x16532 $x271)))) (= $x4266 (not (not (or $x16522 $x16532 $x271)))))))
 (let ((@x16543 (trans @x16539 (rewrite (= (not (not (or $x16522 $x16532 $x271))) (or $x16522 $x16532 $x271))) (= $x4266 (or $x16522 $x16532 $x271)))))
 (trans (monotonicity @x16543 (= $x4269 (or (or $x16522 $x16532 $x271) $x4261))) (rewrite (= (or (or $x16522 $x16532 $x271) $x4261) $x16547)) (= $x4269 $x16547))))))))))))))))))
 ))
 (let ((?x12457 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x16557 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x12457) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x16553) (= $x4272 $x16552)) $x16552)))
 (let (($x48147 (not $x16552)))
 (let (($x48148 (or $x48147 $x48019 $x48133 $x48142 $x48143)))
 (let ((@x48153 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830)) (or $x48147 $x48144)) (rewrite (= (or $x48147 $x48144) $x48148)) $x48148)))
 (let ((@x51622 (unit-resolution (unit-resolution @x48153 @x16557 $x48144) @x51620 (or $x48133 $x48142 $x48143))))
 (let ((@x51623 (unit-resolution @x51622 @x50235 @x50196 $x48143)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x11260 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x11264 (mp~ @x1986 (nnf-pos (proof-bind ?x11260) (~ $x1981 $x1981)) $x1981)))
 (let (($x48597 (not $x48143)))
 (let (($x50163 (not $x1981)))
 (let (($x50164 (or $x50163 $x48597 $x50171)))
 (let ((@x50236 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7829 ?x7831)) (or $x50163 (or $x48597 $x50171))) (rewrite (= (or $x50163 (or $x48597 $x50171)) $x50164)) $x50164)))
 (let ((@x51626 (symm (unit-resolution @x50236 @x11264 @x51623 $x50171) (= ?x50170 ?x47809))))
 (let ((@x51628 (monotonicity @x51626 (= ?x50254 ?x48567))))
 (let ((@x51725 (symm @x51628 $x50237)))
 (let (($x51793 (not $x51179)))
 (let (($x51792 (not $x51174)))
 (let (($x51794 (or $x51333 (not $x50280) (not $x48186) (not $x50248) (not $x51463) (not $x51152) $x51792 $x50496 $x51793)))
 (let ((@x51796 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 1 1 -1 1 1 -1) $x51794) @x51754 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50237) $x50280)) @x51725 $x50280) @x50677 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51453) $x51152)) @x51488 $x51152) @x51779 @x51776 @x50681 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51466) $x51463)) @x51610 $x51463) $x51333)))
 (let ((?x51422 (Add ?x50254 ?x47798)))
 (let ((?x51423 (nClip ?x51422)))
 (let ((?x51424 (* (- 1) ?x51423)))
 (let ((?x51413 (+ ?x51279 ?x51424)))
 (let (($x51414 (>= ?x51413 0)))
 (let (($x51666 (not $x51414)))
 (let (($x51474 (>= ?x51460 (- 8))))
 (let ((@x51591 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51013) $x51474)) @x51590 $x51474)))
 (let (($x51173 (<= ?x51172 0)))
 (let ((@x51600 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51171) $x51173)) @x51599 $x51173)))
 (let (($x51150 (>= ?x51151 0)))
 (let (($x51462 (<= ?x51461 0)))
 (let ((?x48741 (Add ?x48306 ?x47798)))
 (let ((?x48742 (nClip ?x48741)))
 (let ((?x51480 (+ ?x48742 ?x51424)))
 (let (($x51481 (<= ?x51480 0)))
 (let (($x51079 (= ?x48742 ?x51423)))
 (let ((@x51634 (monotonicity (monotonicity (trans* @x51628 @x50426 (= ?x50254 ?x48306)) (= ?x51422 ?x48741)) (= ?x51423 ?x48742))))
 (let ((@x51636 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51079) $x51481)) (symm @x51634 $x51079) $x51481)))
 (let (($x50157 (>= ?x48742 32)))
 (let (($x50155 (= ?x48742 32)))
 (let ((?x48739 (vstd!seq.Seq.add.? $ ?x1876 ?x47802 ?x47797)))
 (let ((?x48740 (vstd!seq.Seq.len.? $ ?x1876 ?x48739)))
 (let ((@x51653 (monotonicity (trans* (monotonicity @x50079 (= ?x48739 ?x47805)) @x50394 (= ?x48739 ?x47787)) (= ?x48740 ?x47788))))
 (let (($x48743 (= ?x48740 ?x48742)))
 (let (($x48337 (has_type ?x47802 ?x1968)))
 (let ((@x50957 (mp @x50092 (symm (monotonicity @x50079 (= $x48337 $x48022)) (= $x48022 $x48337)) $x48337)))
 (let (($x16877 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x16683 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x16430 (not $x4101)))
 (or $x16430 $x16683 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4955 (fuel_bool fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x48724 (= $x4955 $x1592)))
 (let ((@x48726 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_len.) (or (not $x30) $x48724)) @x48194 (hypothesis (not $x48724)) false)))
 (let ((@x48738 (lemma @x48726 $x48724)))
 (let ((@x48731 (def-axiom (or (not $x48724) $x4955 $x15867))))
 (let ((@x51644 (unit-resolution @x48731 (unit-resolution (def-axiom (or $x15870 $x1592)) @x50355 $x1592) (or (not $x48724) $x4955))))
 (let (($x4985 (not $x4955)))
 (let (($x16882 (or $x4985 $x16877)))
 (let (($x4977 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4986 (or $x4985 $x4977)))
 (let ((?x12756 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (refl (~ $x4972 $x4972))))))))))))))))
 ))
 (let ((@x12761 (monotonicity (refl (~ $x4985 $x4985)) (nnf-pos (proof-bind ?x12756) (~ $x4977 $x4977)) (~ $x4986 $x4986))))
 (let (($x4963 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4959)))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4964 (=> $x4955 $x4963)))
 (let ((?x4978 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let (($x4961 (=> (and $x4526 $x3858) $x4959)))
 (let ((@x4971 (monotonicity (rewrite (= $x4960 (or $x4431 $x4959))) (= $x4961 (=> $x4526 (or $x4431 $x4959))))))
 (trans @x4971 (rewrite (= (=> $x4526 (or $x4431 $x4959)) $x4972)) (= $x4961 $x4972)))))))))))))))))))
 ))
 (let ((@x4984 (monotonicity (quant-intro (proof-bind ?x4978) (= $x4963 $x4977)) (= $x4964 (=> $x4955 $x4977)))))
 (let ((@x4991 (mp (asserted $x4964) (trans @x4984 (rewrite (= (=> $x4955 $x4977) $x4986)) (= $x4964 $x4986)) $x4986)))
 (let ((@x16884 (mp (mp (mp~ @x4991 @x12761 $x4986) (rewrite (= $x4986 $x4986)) $x4986) (rewrite (= $x4986 $x16882)) $x16882)))
 (let (($x48338 (not $x48337)))
 (let (($x48747 (not $x16877)))
 (let (($x48748 (or $x48747 $x48338 $x48034 $x48336 $x48743)))
 (let ((@x48753 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x47801) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)) (or $x48747 (or $x48338 $x48034 $x48336 $x48743))) (rewrite (= (or $x48747 (or $x48338 $x48034 $x48336 $x48743)) $x48748)) $x48748)))
 (let ((@x51648 (unit-resolution @x48753 @x175 (unit-resolution @x16884 (unit-resolution @x51644 @x48738 $x4955) $x16877) (or $x48338 $x48034 $x48743))))
 (let ((@x51654 (trans* (symm (unit-resolution @x51648 @x50113 @x50957 $x48743) (= ?x48742 ?x48740)) @x51653 @x47790 @x50384 $x50155)))
 (let ((?x48070 (* (- 1) ?x8522)))
 (let ((?x48071 (+ pmemlog!logimpl_v.header_size.? ?x48070)))
 (let (($x48084 (>= ?x48071 8)))
 (let (($x48068 (= ?x48071 8)))
 (let (($x48074 (or $x48073 $x48068)))
 (let (($x48065 (= (+ 8 (* (- 1) pmemlog!logimpl_v.header_size.?) ?x8522) 0)))
 (let (($x48075 (or $x48073 $x48065)))
 (let (($x48077 (= $x48075 $x48074)))
 (let ((@x48081 (trans (monotonicity (rewrite (= $x48065 $x48068)) $x48077) (rewrite (= $x48074 $x48074)) $x48077)))
 (let ((@x48082 (mp ((_ quant-inst pmemlog!logimpl_v.header_size.? 8) $x48075) @x48081 $x48074)))
 (let ((@x51661 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48068) $x48084)) (unit-resolution @x48082 @x10912 $x48068) $x48084)))
 (let (($x49548 (<= pmemlog!logimpl_v.header_size.? 32)))
 (let ((@x51665 ((_ th-lemma arith farkas -1 -1 1 -1 -1 -1 1 1 -1 1 -1 1) @x51376 @x51371 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x49548)) @x50384 $x49548) @x51661 (hypothesis $x51414) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50155) $x50157)) @x51654 $x50157) @x51636 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51466) $x51462)) @x51610 $x51462) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51453) $x51150)) @x51488 $x51150) @x51600 @x51591 @x51361 false)))
 (let ((@x51668 (lemma @x51665 (or $x51666 $x50796))))
 (let (($x50252 (has_type ?x50170 ?x1968)))
 (let ((@x51810 (mp @x51623 (symm (monotonicity @x51626 (= $x50252 $x48143)) (= $x48143 $x50252)) $x50252)))
 (let (($x16945 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x4282 (sized A&.)))
 (let (($x16558 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x16886 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x16522 (not $x4256)))
 (or $x16522 $x16886 $x271 $x16558 $x4555 $x5071 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5048 (fuel_bool fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x48767 (= $x5048 $x1594)))
 (let ((@x48769 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index2.) (or (not $x30) $x48767)) @x48194 (hypothesis (not $x48767)) false)))
 (let ((@x48781 (lemma @x48769 $x48767)))
 (let ((@x48774 (def-axiom (or (not $x48767) $x5048 $x15869))))
 (let ((@x51803 (unit-resolution @x48774 (unit-resolution (def-axiom (or $x15870 $x1594)) @x50355 $x1594) (or (not $x48767) $x5048))))
 (let (($x5079 (not $x5048)))
 (let (($x16950 (or $x5079 $x16945)))
 (let (($x5101 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5087 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5106 (or $x5079 $x5101)))
 (let ((?x12784 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (refl (~ $x5096 $x5096)))))))))))))))))))))))
 ))
 (let ((@x12789 (monotonicity (refl (~ $x5079 $x5079)) (nnf-pos (proof-bind ?x12784) (~ $x5101 $x5101)) (~ $x5106 $x5106))))
 (let (($x5062 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x4282 (sized A&.)))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x5055) $x5059)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5063 (=> $x5048 $x5062)))
 (let ((?x5102 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x5061 (=> (and $x4994 $x5055) $x5059)))
 (let ((@x5072 (monotonicity (rewrite (= $x5054 (and $x4552 $x5076))) (= $x5055 (and $x4282 (and $x4552 $x5076))))))
 (let ((@x5083 (trans @x5072 (rewrite (= (and $x4282 (and $x4552 $x5076)) $x5075)) (= $x5055 $x5075))))
 (let ((@x5092 (trans (monotonicity @x5083 (= $x5060 (=> $x5075 $x5059))) (rewrite (= (=> $x5075 $x5059) (or $x5087 $x5059))) (= $x5060 (or $x5087 $x5059)))))
 (trans (monotonicity @x5092 (= $x5061 (=> $x4994 (or $x5087 $x5059)))) (rewrite (= (=> $x4994 (or $x5087 $x5059)) $x5096)) (= $x5061 $x5096))))))))))))))))))))))))))))))
 ))
 (let ((@x5077 (monotonicity (quant-intro (proof-bind ?x5102) (= $x5062 $x5101)) (= $x5063 (=> $x5048 $x5101)))))
 (let ((@x5111 (mp (asserted $x5063) (trans @x5077 (rewrite (= (=> $x5048 $x5101) $x5106)) (= $x5063 $x5106)) $x5106)))
 (let ((@x16952 (mp (mp (mp~ @x5111 @x12789 $x5106) (rewrite (= $x5106 $x5106)) $x5106) (rewrite (= $x5106 $x16950)) $x16950)))
 (let (($x51419 (not $x51333)))
 (let (($x50253 (not $x50252)))
 (let (($x51439 (not $x16945)))
 (let (($x51440 (or $x51439 $x50253 $x48034 $x51499 $x48336 $x51419 $x51414 $x51417)))
 (let ((?x51346 (+ ?x51279 ?x50238)))
 (let (($x51347 (>= ?x51346 0)))
 (let (($x51409 (not $x51347)))
 (let (($x51418 (or $x50253 $x48034 $x51499 $x48336 $x51409 $x51414 $x51417)))
 (let (($x51445 (or $x51439 $x51418)))
 (let ((@x51450 (rewrite (= (or $x51439 (or $x50253 $x48034 $x51499 $x48336 $x51419 $x51414 $x51417)) $x51440))))
 (let (($x51441 (or $x50253 $x48034 $x51499 $x48336 $x51419 $x51414 $x51417)))
 (let (($x51444 (= $x51418 $x51441)))
 (let ((@x51438 (trans (monotonicity (rewrite (= $x51409 $x51419)) $x51444) (rewrite (= $x51441 $x51441)) $x51444)))
 (let ((@x51452 (trans (monotonicity @x51438 (= $x51445 (or $x51439 $x51441))) @x51450 (= $x51445 $x51440))))
 (let ((@x51812 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x50169) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!) (I ?x51381)) $x51445) @x51452 $x51440) @x175 (unit-resolution @x16952 (unit-resolution @x51803 @x48781 $x5048) $x16945) @x50113 @x51810 (or $x51499 $x51419 $x51414 $x51417))))
 (let ((@x51813 (unit-resolution @x51812 (unit-resolution @x51668 @x51718 $x51666) (mp @x51505 (symm (monotonicity @x51609 $x51495) $x51497) $x51486) @x51796 $x51417)))
 (let ((?x51670 (Sub ?x51166 8)))
 (let (($x51693 (= ?x50485 ?x51670)))
 (let ((?x51676 (* (- 1) ?x51670)))
 (let ((?x51694 (+ ?x50485 ?x51676)))
 (let (($x51695 (<= ?x51694 0)))
 (let ((?x51677 (+ ?x51166 ?x51676)))
 (let (($x51689 (<= ?x51677 8)))
 (let (($x51675 (= ?x51677 8)))
 (let (($x51680 (or $x48073 $x51675)))
 (let (($x51674 (= (+ 8 (* (- 1) ?x51166) ?x51670) 0)))
 (let (($x51681 (or $x48073 $x51674)))
 (let (($x51683 (= $x51681 $x51680)))
 (let ((@x51687 (trans (monotonicity (rewrite (= $x51674 $x51675)) $x51683) (rewrite (= $x51680 $x51680)) $x51683)))
 (let ((@x51819 (unit-resolution (mp ((_ quant-inst (Add ?x50485 ?x48145) 8) $x51681) @x51687 $x51680) @x10912 $x51675)))
 (let ((@x51836 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x51695 $x51792 $x51793 (not $x51689))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51675) $x51689)) @x51819 $x51689) @x51776 @x51779 $x51695)))
 (let (($x51696 (>= ?x51694 0)))
 (let (($x51690 (>= ?x51677 8)))
 (let ((@x51829 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x51696 (not $x51173) (not $x51474) (not $x51690))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51675) $x51690)) @x51819 $x51690) @x51600 @x51591 $x51696)))
 (let ((@x51837 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x51693 (not $x51695) (not $x51696))) @x51829 @x51836 $x51693)))
 (let ((@x51734 (monotonicity (trans* @x51488 (symm @x51610 (= ?x51381 ?x51279)) (= ?x51166 ?x51279)) (trans* @x50420 @x50422 @x50675 @x51725 (= 8 ?x50254)) (= ?x51670 ?x51415))))
 (let ((@x51740 (trans* (symm @x51734 (= ?x51415 ?x51670)) (symm (hypothesis $x51693) (= ?x51670 ?x50485)) (= ?x51415 ?x50485))))
 (let ((@x51747 (trans* (hypothesis $x51189) (symm (monotonicity @x51740 (= ?x51410 ?x51188)) (= ?x51188 ?x51410)) (= ?x50467 ?x51410))))
 (let (($x48103 (= ?x47809 ?x47792)))
 (let (($x47810 (ext_eq false ?x1968 ?x47809 ?x47792)))
 (let (($x48578 (ext_eq false ?x1968 ?x47809 ?x47802)))
 (let ((?x48561 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47802 ?x47809 ?x1876 $)))
 (let ((?x48562 (vstd!seq.Seq.index.? $ ?x1876 ?x47802 ?x48561)))
 (let ((?x48563 (vstd!seq.Seq.index.? $ ?x1876 ?x47809 ?x48561)))
 (let (($x48564 (= ?x48563 ?x48562)))
 (let ((?x48565 (%I ?x48561)))
 (let ((?x48615 (+ ?x48565 ?x48584)))
 (let (($x48616 (>= ?x48615 0)))
 (let (($x48570 (>= ?x48565 0)))
 (let (($x48571 (not $x48570)))
 (let (($x48572 (has_type ?x48561 INT)))
 (let (($x48573 (not $x48572)))
 (let (($x48621 (or $x48573 $x48571 $x48616 $x48564)))
 (let (($x48642 (not $x48616)))
 (let (($x48627 (not $x48621)))
 (let ((@x50871 (hypothesis $x48627)))
 (let ((@x48644 (def-axiom (or $x48621 $x48642))))
 (let ((@x50872 (unit-resolution @x48644 @x50871 $x48642)))
 (let (($x50648 (<= (+ ?x48306 (* (- 1) (%I (I (%I (I (Add ?x48565 ?x48154))))))) 0)))
 (let ((?x50451 (Add ?x48565 ?x48154)))
 (let ((?x50452 (I ?x50451)))
 (let ((?x50687 (%I ?x50452)))
 (let ((?x50799 (I ?x50687)))
 (let ((?x50577 (vstd!seq.Seq.index.? $ ?x1876 ?x47802 ?x50799)))
 (let ((?x50576 (vstd!seq.Seq.index.? $ ?x1876 ?x48739 ?x50799)))
 (let (($x50578 (= ?x50576 ?x50577)))
 (let (($x50940 (not $x50578)))
 (let ((?x50486 (I ?x48565)))
 (let (($x50487 (= ?x48561 ?x50486)))
 (let ((@x48639 (def-axiom (or $x48621 $x48572))))
 (let ((@x50906 (unit-resolution @x48639 @x50871 $x48572)))
 (let (($x50537 (or $x50282 $x48573 $x50487)))
 (let ((@x50541 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47802 ?x47809 ?x1876 $)) (or $x50282 (or $x48573 $x50487))) (rewrite (= (or $x50282 (or $x48573 $x50487)) $x50537)) $x50537)))
 (let (($x50768 (= ?x50451 ?x50687)))
 (let (($x50771 (or $x48156 $x50768)))
 (let ((@x50772 ((_ quant-inst (Add ?x48565 ?x48154)) $x50771)))
 (let ((@x50802 (unit-resolution @x50772 @x10667 $x50768)))
 (let ((@x50888 (monotonicity (trans* @x50183 @x50303 (= 0 ?x48154)) (= (Add ?x48565 0) ?x50451))))
 (let ((?x50769 (Add ?x48565 0)))
 (let ((?x50770 (* (- 1) ?x50769)))
 (let ((?x50279 (+ ?x48565 ?x50770)))
 (let (($x50444 (<= ?x50279 0)))
 (let (($x50432 (= ?x50279 0)))
 (let (($x50281 (or $x48169 $x50432)))
 (let (($x50774 (= (+ 0 ?x48565 ?x50770) 0)))
 (let (($x50430 (or $x48169 $x50774)))
 (let (($x50435 (= $x50430 $x50281)))
 (let ((@x50440 (trans (monotonicity (rewrite (= $x50774 $x50432)) $x50435) (rewrite (= $x50281 $x50281)) $x50435)))
 (let ((@x50443 (mp ((_ quant-inst (%I ?x48561) 0) $x50430) @x50440 $x50281)))
 (let ((@x50876 (unit-resolution @x50443 @x10905 $x50432)))
 (let ((@x50877 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50432) $x50444)) @x50876 $x50444)))
 (let (($x50445 (>= ?x50279 0)))
 (let ((@x50901 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50432) $x50445)) @x50876 $x50445)))
 (let ((@x50909 (monotonicity (trans* ((_ th-lemma arith eq-propagate 1 1) @x50901 @x50877 (= ?x48565 ?x50769)) @x50888 @x50802 (= ?x48565 ?x50687)) (= ?x50486 ?x50799))))
 (let ((@x50915 (trans* (symm @x50909 (= ?x50799 ?x50486)) (symm (unit-resolution @x50541 @x10688 @x50906 $x50487) (= ?x50486 ?x48561)) (= ?x50799 ?x48561))))
 (let ((@x50410 (monotonicity @x50394 (= ?x50272 ?x47809))))
 (let ((?x50450 (vstd!seq.Seq.index.? $ ?x1876 ?x50272 ?x48561)))
 (let ((?x50453 (vstd!seq.Seq.index.? $ ?x1876 ?x47805 ?x50452)))
 (let (($x50454 (= ?x50450 ?x50453)))
 (let ((?x50447 (* (- 1) ?x50274)))
 (let ((?x50448 (+ ?x48565 ?x50447)))
 (let (($x50449 (>= ?x50448 0)))
 (let (($x50683 (not $x50449)))
 (let (($x50498 (>= ?x50274 8)))
 (let (($x50489 (= ?x50274 8)))
 (let ((@x50669 (trans* (symm @x50408 (= ?x50274 ?x50273)) (monotonicity @x50410 (= ?x50273 ?x48567)) @x50426 @x50418 @x47795 $x50489)))
 (let ((@x50682 ((_ th-lemma arith farkas 1 -1 -1 -1 1) @x50681 @x50677 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50489) $x50498)) @x50669 $x50498) (hypothesis $x50449) (hypothesis $x48642) false)))
 (let ((@x50685 (lemma @x50682 (or $x50683 $x48616))))
 (let ((@x48641 (def-axiom (or $x48621 $x48570))))
 (let ((@x50923 (unit-resolution @x48641 @x50871 $x48570)))
 (let (($x50515 (or $x50511 $x48472 $x48133 $x48142 $x48573 $x48336 $x50258 $x50268 $x50271 $x48571 $x50449 $x50454)))
 (let ((?x50438 (+ ?x48154 ?x50287)))
 (let (($x50439 (<= ?x50438 0)))
 (let (($x50446 (not $x50439)))
 (let (($x50455 (or $x48472 $x48133 $x48142 $x48573 $x48336 $x50258 $x50446 $x50271 $x48571 $x50449 $x50454)))
 (let (($x50517 (or $x50511 $x50455)))
 (let (($x50476 (or $x48472 $x48133 $x48142 $x48573 $x48336 $x50258 $x50268 $x50271 $x48571 $x50449 $x50454)))
 (let (($x50516 (or $x50511 $x50476)))
 (let (($x50507 (= $x50455 $x50476)))
 (let ((@x50510 (trans (monotonicity (rewrite (= $x50446 $x50268)) $x50507) (rewrite (= $x50476 $x50476)) $x50507)))
 (let ((@x50527 (trans (monotonicity @x50510 (= $x50517 $x50516)) (rewrite (= $x50516 $x50515)) (= $x50517 $x50515))))
 (let ((@x50530 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47802 ?x47809 ?x1876 $)) $x50517) @x50527 $x50515)))
 (let ((@x50925 (unit-resolution @x50530 @x175 @x50922 @x50362 @x50196 @x50235 @x50906 @x50923 @x50369 @x50407 @x50312 (unit-resolution @x50685 @x50872 $x50683) $x50454)))
 (let (($x50807 (= ?x50799 ?x50452)))
 (let (($x50263 (= ?x50452 ?x50799)))
 (let (($x50659 (has_type ?x50452 INT)))
 (let (($x50800 (has_type ?x50799 INT)))
 (let (($x50813 (not $x50800)))
 (let (($x50811 (= $x50659 $x50800)))
 (let (($x50809 (= $x50800 $x50659)))
 (let ((@x50812 (symm (monotonicity (monotonicity (symm @x50802 (= ?x50687 ?x50451)) $x50807) $x50809) $x50811)))
 (let ((@x50816 (mp (hypothesis (not $x50659)) (monotonicity @x50812 (= (not $x50659) $x50813)) $x50813)))
 (let ((@x50818 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x50452)) (or (not $x698) $x50800)) @x10807 $x50800) @x50816 false)))
 (let ((@x50819 (lemma @x50818 $x50659)))
 (let (($x50686 (not $x50659)))
 (let (($x50295 (or $x50282 $x50686 $x50263)))
 (let ((@x50241 (mp ((_ quant-inst (I ?x50451)) (or $x50282 (or $x50686 $x50263))) (rewrite (= (or $x50282 (or $x50686 $x50263)) $x50295)) $x50295)))
 (let ((@x50884 (symm (unit-resolution @x50241 @x10688 @x50819 $x50263) $x50807)))
 (let ((@x50927 (monotonicity @x50079 (= ?x48739 ?x47805))))
 (let ((@x50935 (trans* (monotonicity @x50927 @x50884 (= ?x50576 ?x50453)) (symm @x50925 (= ?x50453 ?x50450)) (monotonicity @x50410 (= ?x50450 ?x48563)) (= ?x50576 ?x48563))))
 (let ((@x50939 (symm (monotonicity @x50935 (monotonicity @x50915 (= ?x50577 ?x48562)) (= $x50578 $x48564)) (= $x48564 $x50578))))
 (let ((@x50943 (mp (unit-resolution (def-axiom (or $x48621 (not $x48564))) @x50871 (not $x48564)) (monotonicity @x50939 (= (not $x48564) $x50940)) $x50940)))
 (let ((?x50531 (%I ?x50799)))
 (let (($x50532 (>= ?x50531 0)))
 (let ((?x50778 (+ ?x50531 ?x50770)))
 (let (($x50781 (>= ?x50778 0)))
 (let (($x50775 (= ?x50531 ?x50769)))
 (let ((@x50806 (symm @x50802 (= ?x50687 ?x50451))))
 (let ((@x50891 (trans* (monotonicity @x50884 (= ?x50531 ?x50687)) @x50806 (symm @x50888 (= ?x50451 ?x50769)) $x50775)))
 (let ((@x50895 ((_ th-lemma arith farkas -1 1 -1 1) (hypothesis $x48570) (hypothesis (not $x50532)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50775) $x50781)) @x50891 $x50781) @x50877 false)))
 (let ((@x50897 (lemma @x50895 (or $x50532 $x48571))))
 (let (($x16917 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16418 (not $x821)))
 (let (($x4282 (sized A&.)))
 (let (($x16558 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x16886 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x16522 (not $x4256)))
 (or $x16522 $x16886 $x271 $x16558 $x16418 $x4552 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x4992 (fuel_bool fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x48745 (= $x4992 $x1593)))
 (let ((@x48754 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index1.) (or (not $x30) $x48745)) @x48194 (hypothesis (not $x48745)) false)))
 (let ((@x48766 (lemma @x48754 $x48745)))
 (let ((@x48759 (def-axiom (or (not $x48745) $x4992 $x15868))))
 (let ((@x50950 (unit-resolution @x48759 (unit-resolution (def-axiom (or $x15870 $x1593)) @x50355 $x1593) (or (not $x48745) $x4992))))
 (let (($x5013 (not $x4992)))
 (let (($x16922 (or $x5013 $x16917)))
 (let (($x5037 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5022 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5042 (or $x5013 $x5037)))
 (let ((?x12770 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (refl (~ $x5032 $x5032)))))))))))))))))))))
 ))
 (let ((@x12775 (monotonicity (refl (~ $x5013 $x5013)) (nnf-pos (proof-bind ?x12770) (~ $x5037 $x5037)) (~ $x5042 $x5042))))
 (let (($x5002 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4282 (sized A&.)))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x4995) $x4998))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5003 (=> $x4992 $x5002)))
 (let ((?x5038 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x5000 (=> (and $x4994 $x4995) $x4998)))
 (let ((@x5009 (monotonicity (rewrite (= $x4531 (and $x821 $x4555))) (= $x4995 (and $x4282 (and $x821 $x4555))))))
 (let ((@x5018 (trans @x5009 (rewrite (= (and $x4282 (and $x821 $x4555)) $x5010)) (= $x4995 $x5010))))
 (let ((@x5027 (trans (monotonicity @x5018 (= $x4999 (=> $x5010 $x4998))) (rewrite (= (=> $x5010 $x4998) (or $x5022 $x4998))) (= $x4999 (or $x5022 $x4998)))))
 (trans (monotonicity @x5027 (= $x5000 (=> $x4994 (or $x5022 $x4998)))) (rewrite (= (=> $x4994 (or $x5022 $x4998)) $x5032)) (= $x5000 $x5032)))))))))))))))))))))))))))))
 ))
 (let ((@x5011 (monotonicity (quant-intro (proof-bind ?x5038) (= $x5002 $x5037)) (= $x5003 (=> $x4992 $x5037)))))
 (let ((@x5047 (mp (asserted $x5003) (trans @x5011 (rewrite (= (=> $x4992 $x5037) $x5042)) (= $x5003 $x5042)) $x5042)))
 (let ((@x16924 (mp (mp (mp~ @x5047 @x12775 $x5042) (rewrite (= $x5042 $x5042)) $x5042) (rewrite (= $x5042 $x16922)) $x16922)))
 (let (($x50571 (not $x50532)))
 (let (($x50657 (not $x16917)))
 (let (($x50658 (or $x50657 $x48338 $x48034 $x50813 $x48336 $x50571 $x50648 $x50578)))
 (let ((?x48323 (* (- 1) ?x48306)))
 (let ((?x50572 (+ ?x50531 ?x48323)))
 (let (($x50573 (>= ?x50572 0)))
 (let (($x50579 (or $x48338 $x48034 $x50813 $x48336 $x50571 $x50573 $x50578)))
 (let (($x50634 (or $x50657 $x50579)))
 (let ((@x50630 (rewrite (= (or $x50657 (or $x48338 $x48034 $x50813 $x48336 $x50571 $x50648 $x50578)) $x50658))))
 (let (($x50651 (or $x48338 $x48034 $x50813 $x48336 $x50571 $x50648 $x50578)))
 (let (($x50652 (= $x50579 $x50651)))
 (let ((@x50642 (rewrite (= ?x50572 (+ ?x48323 ?x50531)))))
 (let ((@x50650 (trans (monotonicity @x50642 (= $x50573 (>= (+ ?x48323 ?x50531) 0))) (rewrite (= (>= (+ ?x48323 ?x50531) 0) $x50648)) (= $x50573 $x50648))))
 (let ((@x50628 (monotonicity (trans (monotonicity @x50650 $x50652) (rewrite (= $x50651 $x50651)) $x50652) (= $x50634 (or $x50657 $x50651)))))
 (let ((@x50959 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x47801) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!) (I ?x50687)) $x50634) (trans @x50628 @x50630 (= $x50634 $x50658)) $x50658) @x175 (unit-resolution @x16924 (unit-resolution @x50950 @x48766 $x4992) $x16917) @x50113 @x50957 (or $x50813 $x50571 $x50648 $x50578))))
 (let ((@x50960 (unit-resolution @x50959 (unit-resolution @x50897 @x50923 $x50532) (mp @x50819 (symm (monotonicity @x50884 $x50809) $x50811) $x50800) @x50943 $x50648)))
 (let (($x50780 (>= ?x48306 8)))
 (let ((@x50965 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x48306 8)) $x50780)) (trans* @x50418 @x47795 (= ?x48306 8)) $x50780)))
 (let (($x50779 (<= ?x50778 0)))
 (let ((@x50969 ((_ th-lemma arith farkas 1 -1 -1 1 -1 1 1) @x50681 @x50677 @x50901 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50775) $x50779)) @x50891 $x50779) @x50965 @x50960 @x50872 false)))
 (let ((@x50970 (lemma @x50969 $x48621)))
 (let (($x48577 (not $x48576)))
 (let (($x48609 (or $x48578 $x48577 $x48627)))
 (let (($x48617 (not $x48609)))
 (let (($x48588 (forall ((i$ Poly) )(! (let ((?x47797 (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)))
 (let ((?x47801 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x47797)))
 (let ((?x47802 (Poly%vstd!seq.Seq<u8.>. ?x47801)))
 (let ((?x1876 (UINT 8)))
 (let ((?x48320 (vstd!seq.Seq.index.? $ ?x1876 ?x47802 i$)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x47787 (Poly%vstd!seq.Seq<u8.>. header_bytes!)))
 (let ((?x47809 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7829 ?x7831)))
 (let ((?x48581 (vstd!seq.Seq.index.? $ ?x1876 ?x47809 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16418 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x16418 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x47809))) 0) (= ?x48581 ?x48320)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_crc_offset.?) (I (Add pmemlog!logimpl_v.header_crc_offset.? 8))) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? (Poly%vstd!seq.Seq<u8.>. metadata_bytes!))) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x48589 (not $x48588)))
 (let (($x48590 (or $x48577 $x48589)))
 (let (($x48591 (not $x48590)))
 (let (($x48592 (not $x48578)))
 (let (($x48593 (or $x48592 $x48591)))
 (let (($x48594 (not $x48593)))
 (let (($x48628 (or $x48594 $x48617)))
 (let (($x48614 (not $x48628)))
 (let (($x16762 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x12556 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12568 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12556) (vstd!seq.Seq.index.? A&. A& s2! ?x12556))))
 (let (($x12607 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x12556))) 0)))
 (let (($x12558 (not (has_type ?x12556 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12553 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x16743 (not (or $x4527 $x12553 (not (or $x12558 (not (>= (%I ?x12556) 0)) $x12607 $x12568))))))
 (let (($x16714 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16418 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x16418 $x4552 $x4534))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x12540 (not $x4527)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x16683 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x16430 (not $x4101)))
 (or $x16430 $x16683 $x4431 (not (or (not (or $x12540 (not (or $x12553 (not $x16714))))) $x16743)))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4524 (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x48286 (= $x4524 $x1587)))
 (let ((@x48288 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_ext_equal.) (or (not $x30) $x48286)) @x48194 (hypothesis (not $x48286)) false)))
 (let ((@x48300 (lemma @x48288 $x48286)))
 (let ((@x48293 (def-axiom (or (not $x48286) $x4524 $x15862))))
 (let ((@x51702 (unit-resolution @x48293 (unit-resolution (def-axiom (or $x15870 $x1587)) @x50355 $x1587) (or (not $x48286) $x4524))))
 (let (($x4583 (not $x4524)))
 (let (($x16695 (or $x4583 $x16762)))
 (let (($x12621 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x12556 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12568 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12556) (vstd!seq.Seq.index.? A&. A& s2! ?x12556))))
 (let (($x12607 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x12556))) 0)))
 (let ((?x12559 (%I ?x12556)))
 (let (($x12560 (>= ?x12559 0)))
 (let (($x12558 (not (has_type ?x12556 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12553 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x12540 (not $x4527)))
 (let (($x12579 (or $x12540 $x4548)))
 (let (($x12622 (and $x12579 (or $x4527 $x12553 (not (or $x12558 (not (and $x12560 (not $x12607))) $x12568))))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x12622)))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x12595 (or $x4583 $x12621)))
 (let (($x12586 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x12556 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12568 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12556) (vstd!seq.Seq.index.? A&. A& s2! ?x12556))))
 (let (($x12562 (>= (+ (%I ?x12556) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x12559 (%I ?x12556)))
 (let (($x12560 (>= ?x12559 0)))
 (let (($x12558 (not (has_type ?x12556 INT))))
 (let (($x12570 (not (or $x12558 (not (and $x12560 (not $x12562))) $x12568))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12553 (not $x4529)))
 (let (($x12574 (or $x12553 $x12570)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x12540 (not $x4527)))
 (let (($x12579 (or $x12540 $x4548)))
 (let (($x12580 (and $x12579 (or $x4527 $x12574))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x12580)))))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x12591 (or $x4583 $x12586)))
 (let (($x4576 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4559))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4584 (or $x4583 $x4576)))
 (let ((?x12587 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x12556 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12568 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12556) (vstd!seq.Seq.index.? A&. A& s2! ?x12556))))
 (let (($x12562 (>= (+ (%I ?x12556) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x12559 (%I ?x12556)))
 (let (($x12560 (>= ?x12559 0)))
 (let (($x12558 (not (has_type ?x12556 INT))))
 (let (($x12570 (not (or $x12558 (not (and $x12560 (not $x12562))) $x12568))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12553 (not $x4529)))
 (let (($x12574 (or $x12553 $x12570)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x12540 (not $x4527)))
 (let (($x12579 (or $x12540 $x4548)))
 (let (($x12580 (and $x12579 (or $x4527 $x12574))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x12583 (or $x4568 $x4431 $x12580)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let ((@x12555 (refl (~ $x12553 $x12553))))
 (let ((?x12547 (lambda ((i$ Poly) )(let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4569 (or $x271 $x4554 $x4534)))
 (refl (~ $x4569 $x4569))))))))))))))))
 ))
 (let ((@x12544 (refl (~ $x4529 $x4529))))
 (let ((@x12552 (monotonicity @x12544 (nnf-pos (proof-bind ?x12547) (~ $x4574 $x4574)) (~ $x4548 $x4548))))
 (let ((@x12582 (nnf-pos (refl (~ $x4527 $x4527)) (refl (~ $x12540 $x12540)) @x12552 (nnf-neg @x12555 (sk (~ (not $x4574) $x12570)) (~ (not $x4548) $x12574)) (~ $x4559 $x12580))))
 (let ((@x12537 (refl (~ $x4431 $x4431))))
 (let ((@x12535 (refl (~ $x4568 $x4568))))
 (monotonicity @x12535 @x12537 @x12582 (~ $x4570 $x12583))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x12593 (monotonicity (refl (~ $x4583 $x4583)) (nnf-pos (proof-bind ?x12587) (~ $x4576 $x12586)) (~ $x4584 $x12591))))
 (let (($x4545 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x3858 (sized A&.)))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4541))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4546 (=> $x4524 $x4545)))
 (let ((?x4577 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4543 (=> (and $x4526 $x3858) $x4541)))
 (let ((@x4564 (trans (monotonicity (rewrite (= $x4541 $x4559)) (= $x4542 (=> $x3858 $x4559))) (rewrite (= (=> $x3858 $x4559) (or $x4431 $x4559))) (= $x4542 (or $x4431 $x4559)))))
 (trans (monotonicity @x4564 (= $x4543 (=> $x4526 (or $x4431 $x4559)))) (rewrite (= (=> $x4526 (or $x4431 $x4559)) $x4570)) (= $x4543 $x4570)))))))))))))))))))))))
 ))
 (let ((@x4582 (monotonicity (quant-intro (proof-bind ?x4577) (= $x4545 $x4576)) (= $x4546 (=> $x4524 $x4576)))))
 (let ((@x4589 (mp (asserted $x4546) (trans @x4582 (rewrite (= (=> $x4524 $x4576) $x4584)) (= $x4546 $x4584)) $x4584)))
 (let ((@x16684 (mp (mp (mp~ @x4589 @x12593 $x12591) (rewrite (= $x12591 $x12595)) $x12595) (rewrite (= $x12595 $x16695)) $x16695)))
 (let ((@x51704 (unit-resolution @x16684 (unit-resolution @x51702 @x48300 $x4524) $x16762)))
 (let (($x48423 (not $x16762)))
 (let (($x48605 (or $x48423 $x48597 $x48338 $x48336 $x48614)))
 (let (($x48579 (or $x48578 $x48577 (not (or $x48573 $x48571 (<= (+ ?x48567 (* (- 1) ?x48565)) 0) $x48564)))))
 (let (($x48596 (not (or $x48594 (not $x48579)))))
 (let (($x48598 (or $x48597 $x48338 $x48336 $x48596)))
 (let (($x48606 (or $x48423 $x48598)))
 (let (($x48599 (or $x48597 $x48338 $x48336 $x48614)))
 (let (($x48600 (= $x48598 $x48599)))
 (let ((@x48604 (trans (monotonicity (rewrite (= $x48596 $x48614)) $x48600) (rewrite (= $x48599 $x48599)) $x48600)))
 (let ((@x48612 (trans (monotonicity @x48604 (= $x48606 (or $x48423 $x48599))) (rewrite (= (or $x48423 $x48599) $x48605)) (= $x48606 $x48605))))
 (let ((@x48613 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7829 ?x7831) (Poly%vstd!seq.Seq<u8.>. ?x47801)) $x48606) @x48612 $x48605)))
 (let ((@x51708 (unit-resolution (unit-resolution @x48613 @x175 @x51704 (or $x48597 $x48338 $x48614)) @x50957 (or $x48597 $x48614))))
 (let ((@x48661 (def-axiom (or $x48628 $x48609))))
 (let ((@x48657 (def-axiom (or $x48617 $x48578 $x48577 $x48627))))
 (let ((@x51712 (unit-resolution @x48657 @x50426 (unit-resolution @x48661 (unit-resolution @x51708 @x51623 $x48614) $x48609) (or $x48578 $x48627))))
 (let ((@x51716 (mp (unit-resolution @x51712 @x50970 $x48578) (monotonicity @x50079 (= $x48578 $x47810)) $x47810)))
 (let (($x48104 (= $x48103 $x47810)))
 (let (($x48120 (or $x48089 $x48104)))
 (let ((@x48121 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7829 ?x7831) (Poly%vstd!seq.Seq<u8.>. crc_bytes!)) $x48120)))
 (let ((@x48124 (def-axiom (or (not $x48104) $x48103 (not $x47810)))))
 (let ((@x51699 (unit-resolution @x48124 (unit-resolution @x48121 @x10751 $x48104) (or $x48103 (not $x47810)))))
 (let ((@x51717 (unit-resolution @x51699 @x51716 $x48103)))
 (let ((@x51756 (monotonicity (monotonicity (trans* @x51626 @x51717 (= ?x50170 ?x47792)) (= ?x51386 ?x47805)) @x51609 (= ?x51321 ?x51168))))
 (let ((@x51761 (trans* (monotonicity @x51138 (= ?x50481 ?x51165)) (hypothesis $x51169) (symm @x51756 (= ?x51168 ?x51321)) (hypothesis $x51417) (symm (monotonicity @x51747 (= ?x50469 ?x51416)) (= ?x51416 ?x50469)) $x50484)))
 (let ((@x51769 (lemma (unit-resolution (hypothesis (not $x50484)) @x51761 false) (or (not $x51693) $x50484 (not $x51417) (not $x51169) (not $x51189)))))
 (let ((@x51838 (unit-resolution @x51769 @x51837 (unit-resolution (def-axiom (or $x50822 (not $x50484))) @x51691 (not $x50484)) @x51813 @x51770 (unit-resolution @x51287 @x10688 @x51692 $x51189) false)))
 (let ((@x51839 (lemma @x51838 $x50822)))
 (let (($x50586 (not $x50583)))
 (let (($x50762 (or $x47816 $x50586 $x50826)))
 (let (($x50797 (not $x50762)))
 (let (($x50594 (forall ((i$ Poly) )(! (let ((?x47797 (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x50590 (vstd!seq.Seq.index.? $ ?x1876 ?x47797 i$)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x47787 (Poly%vstd!seq.Seq<u8.>. header_bytes!)))
 (let ((?x47815 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7834 ?x7835)))
 (let ((?x50589 (vstd!seq.Seq.index.? $ ?x1876 ?x47815 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16418 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x16418 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x47815))) 0) (= ?x50589 ?x50590))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_head_offset.?) (I pmemlog!logimpl_v.header_size.?)) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x50597 (not $x50594)))
 (let (($x50598 (or $x50586 $x50597)))
 (let (($x50574 (not $x50598)))
 (let (($x47934 (not $x47816)))
 (let (($x50565 (or $x47934 $x50574)))
 (let (($x50567 (not $x50565)))
 (let (($x50827 (or $x50567 $x50797)))
 (let (($x50765 (not $x50827)))
 (let (($x50569 (has_type ?x47815 ?x1968)))
 (let (($x50868 (has_type ?x50867 ?x1968)))
 (let (($x50847 (or $x48147 $x48472 $x48142 $x50866 $x50868)))
 (let ((@x50842 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x47792 ?x47797) (I ?x7830) (I pmemlog!logimpl_v.header_size.?)) (or $x48147 (or $x48472 $x48142 $x50866 $x50868))) (rewrite (= (or $x48147 (or $x48472 $x48142 $x50866 $x50868)) $x50847)) $x50847)))
 (let ((@x51185 (unit-resolution (unit-resolution @x50842 @x16557 @x50362 @x50235 (or $x50866 $x50868)) @x51011 $x50868)))
 (let (($x50570 (not $x50569)))
 (let (($x50750 (or $x48423 $x50570 $x48034 $x48336 $x50765)))
 (let (($x50587 (or $x47816 $x50586 (not (or $x50582 $x50496 (<= (+ ?x50494 (* (- 1) ?x50485)) 0) $x50484)))))
 (let (($x50568 (not (or $x50567 (not $x50587)))))
 (let (($x50752 (or $x50570 $x48034 $x48336 $x50568)))
 (let (($x50751 (or $x48423 $x50752)))
 (let (($x50754 (or $x50570 $x48034 $x48336 $x50765)))
 (let (($x50755 (= $x50752 $x50754)))
 (let ((@x50759 (trans (monotonicity (rewrite (= $x50568 $x50765)) $x50755) (rewrite (= $x50754 $x50754)) $x50755)))
 (let ((@x50763 (trans (monotonicity @x50759 (= $x50751 (or $x48423 $x50754))) (rewrite (= (or $x48423 $x50754) $x50750)) (= $x50751 $x50750))))
 (let ((@x50764 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7834 ?x7835) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)) $x50751) @x50763 $x50750)))
 (let ((@x51195 (unit-resolution (unit-resolution @x50764 @x175 @x51704 @x50113 (or $x50570 $x50765)) (mp @x51185 (monotonicity @x51136 (= $x50868 $x50569)) $x50569) $x50765)))
 (let ((@x50862 (def-axiom (or $x50827 $x50762))))
 (let ((@x50860 (def-axiom (or $x50797 $x47816 $x50586 $x50826))))
 (let ((@x51197 (unit-resolution (unit-resolution @x50860 (unit-resolution @x50862 @x51195 $x50762) $x50762) @x51147 (or $x47816 $x50826))))
 (let ((@x51198 (unit-resolution @x51197 @x51839 $x47816)))
 (let (($x50468 (= $x48813 $x47816)))
 (let (($x50470 (or $x48089 $x50468)))
 (let ((@x50471 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (vstd!seq.Seq.subrange.? $ ?x1876 ?x47787 ?x7834 ?x7835) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)) $x50470)))
 (let ((@x50478 (def-axiom (or (not $x50468) $x48813 $x47934))))
 (let ((@x51210 (unit-resolution (unit-resolution @x50478 (unit-resolution @x50471 @x10751 $x50468) (or $x48813 $x47934)) @x51198 $x48813)))
 (let ((@x51289 (monotonicity @x51717 (monotonicity (monotonicity @x51210 (= ?x47825 ?x47801)) (= ?x47826 ?x47802)) (= $x47827 $x47803))))
 (let (($x47975 (not $x47827)))
 (let (($x47855 (not %%location_label%%4)))
 (let (($x47856 (or $x47855 $x47827)))
 (let (($x47879 (not $x47856)))
 (let (($x47851 (not %%location_label%%3)))
 (let (($x47852 (or $x47851 $x47816)))
 (let ((@x47970 (def-axiom (or $x47852 $x47934))))
 (let (($x47846 (not $x47852)))
 (let (($x47847 (not %%location_label%%2)))
 (let (($x47848 (or $x47847 $x47810)))
 (let (($x47842 (not $x47848)))
 (let (($x47880 (or $x47842 $x47846 $x47879)))
 (let (($x47881 (not $x47880)))
 (let (($x47869 (not tmp%2)))
 (let (($x47884 (or $x47869 $x47881)))
 (let (($x47889 (not $x47884)))
 (let (($x47843 (not %%location_label%%1)))
 (let (($x47844 (or $x47843 tmp%2)))
 (let (($x47817 (= tmp%2 $x47816)))
 (let (($x47888 (not $x47844)))
 (let (($x47890 (or $x47888 $x47889)))
 (let (($x47891 (not $x47890)))
 (let (($x47860 (not $x47817)))
 (let (($x47866 (not tmp%1)))
 (let (($x47896 (or $x47866 $x47860 $x47891)))
 (let (($x47882 (not $x47896)))
 (let (($x47839 (not %%location_label%%0)))
 (let (($x47840 (or $x47839 tmp%1)))
 (let (($x47811 (= tmp%1 $x47810)))
 (let (($x47867 (or $x47866 $x47860 (and $x47844 (or $x47869 (and $x47848 $x47852 $x47856))))))
 (let (($x47874 (and $x47840 $x47867)))
 (let (($x47850 (not $x47811)))
 (let (($x47861 (not (or $x47850 $x47874))))
 (let (($x47830 (and (=> %%location_label%%2 $x47810) (and (=> %%location_label%%3 $x47816) (=> %%location_label%%4 $x47827)))))
 (let (($x47834 (=> (and tmp%1 $x47817) (and (=> %%location_label%%1 tmp%2) (=> tmp%2 $x47830)))))
 (let (($x47837 (not (=> $x47811 (and (=> %%location_label%%0 tmp%1) $x47834)))))
 (let ((@x47845 (mp (asserted $x47837) (rewrite (= $x47837 $x47861)) $x47861)))
 (let ((@x47877 (not-or-elim @x47845 $x47811)))
 (let ((@x47954 (unit-resolution (def-axiom (or tmp%1 (not $x47810) $x47850)) @x47877 (or tmp%1 (not $x47810)))))
 (let ((@x47960 (def-axiom (or $x47840 $x47866))))
 (let (($x47887 (not $x47840)))
 (let (($x47883 (or $x47887 $x47882)))
 (let (($x47912 (not (or $x47888 (not (or $x47869 (not (or (or $x47842 $x47846) $x47879))))))))
 (let (($x47917 (or $x47866 $x47860)))
 (let (($x47918 (or $x47917 $x47912)))
 (let (($x47925 (or $x47887 (not $x47918))))
 (let ((@x47885 (monotonicity (rewrite (= $x47840 $x47840)) (rewrite (= $x47867 $x47896)) (= $x47874 (and $x47840 $x47896)))))
 (let ((@x47895 (trans @x47885 (rewrite (= (and $x47840 $x47896) (not $x47883))) (= $x47874 (not $x47883)))))
 (let ((@x47903 (trans (monotonicity @x47895 (= (not $x47874) (not (not $x47883)))) (rewrite (= (not (not $x47883)) $x47883)) (= (not $x47874) $x47883))))
 (let (($x47876 (not $x47874)))
 (let ((@x47849 (mp (not-or-elim @x47845 $x47876) (monotonicity (rewrite (= $x47874 $x47874)) (= $x47876 $x47876)) $x47876)))
 (let ((@x47949 (mp (mp (mp @x47849 @x47903 $x47883) (rewrite (= $x47883 $x47925)) $x47925) (rewrite (= $x47925 $x47883)) $x47883)))
 (let ((@x51294 (unit-resolution @x47949 (unit-resolution @x47960 (unit-resolution @x47954 @x51716 tmp%1) $x47840) $x47882)))
 (let ((@x48003 (def-axiom (or $x47896 $x47817))))
 (let ((@x47930 (def-axiom (or $x47860 tmp%2 $x47934))))
 (let ((@x51274 (unit-resolution @x47930 (unit-resolution @x48003 @x51294 $x47817) (or tmp%2 $x47934))))
 (let ((@x47962 (def-axiom (or $x47844 $x47869))))
 (let ((@x47999 (def-axiom (or $x47891 $x47888 $x47889))))
 (let ((@x51273 (unit-resolution @x47999 (unit-resolution (def-axiom (or $x47896 $x47890)) @x51294 $x47890) $x47890)))
 (let ((@x51276 (unit-resolution @x51273 (unit-resolution @x47962 (unit-resolution @x51274 @x51198 tmp%2) $x47844) $x47889)))
 (let ((@x47991 (def-axiom (or $x47884 $x47880))))
 (let ((@x47987 (def-axiom (or $x47881 $x47842 $x47846 $x47879))))
 (let ((@x51281 (unit-resolution @x47987 (unit-resolution (def-axiom (or $x47848 (not $x47810))) @x51716 $x47848) (or $x47881 $x47846 $x47879))))
 (let ((@x51342 (unit-resolution @x51281 (unit-resolution @x47991 @x51276 $x47880) (unit-resolution @x47970 @x51198 $x47852) $x47879)))
 (let ((@x47977 (def-axiom (or $x47856 $x47975))))
 (unit-resolution (unit-resolution @x47977 @x51342 $x47975) (mp @x47804 (symm @x51289 (= $x47803 $x47827)) $x47827) false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

