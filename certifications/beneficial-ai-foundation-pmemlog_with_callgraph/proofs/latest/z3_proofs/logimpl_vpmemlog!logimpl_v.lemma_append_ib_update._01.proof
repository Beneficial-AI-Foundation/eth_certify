(:max-memory   21.76
 :memory       21.76
 :num-allocs   790268
 :rlimit-count 13473)
(:version "4.12.5")
unsat
((declare-fun chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28 () Poly)
(declare-fun pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 (Poly vstd!seq.Seq<u8.>. vstd!seq.Seq<u8.>. Type Dcr) Poly)
(declare-fun T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 (%%Function%% Type Type) Poly)
(declare-fun s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 () Poly)
(declare-fun x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 () Poly)
(declare-fun chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 (vstd!seq.Seq<u8.>. Int vstd!seq.Seq<u8.>.) Poly)
(declare-fun s2$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!11 (Poly Type Dcr) Poly)
(declare-fun s1$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!12 (Poly Type Dcr) Poly)
(proof
(let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x48663 (%Poly%vstd!seq.Seq<u8.>. ?x47674)))
 (let ((?x55990 (Poly%vstd!seq.Seq<u8.>. ?x48663)))
 (let ((?x56011 (pmemlog!logimpl_v.spec_get_live_header.? ?x55990)))
 (let ((?x56012 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x56011)))
 (let ((?x56013 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x56012)))
 (let ((?x56014 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x56013)))
 (let ((?x56015 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x56014)))
 (let ((?x56016 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x56015)))
 (let ((?x56017 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x56016)))
 (let ((?x56018 (I ?x56017)))
 (let ((?x56019 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x56016)))
 (let ((?x56020 (I ?x56019)))
 (let ((?x56021 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x56020 ?x56018)))
 (let ((?x56041 (Add ?x56017 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x56047 (Sub ?x56041 ?x56021)))
 (let ((?x47745 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x48676 (%Poly%vstd!seq.Seq<u8.>. ?x47745)))
 (let ((?x55989 (Poly%vstd!seq.Seq<u8.>. ?x48676)))
 (let ((?x1876 (UINT 8)))
 (let ((?x56010 (vstd!seq.Seq.len.? $ ?x1876 ?x55989)))
 (let ((?x56048 (Sub ?x56010 ?x56047)))
 (let ((?x56049 (Add pmemlog!logimpl_v.contents_offset.? ?x56048)))
 (let ((?x56050 (I ?x56049)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x56051 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55990 ?x7471 ?x56050)))
 (let ((?x56052 (I ?x56041)))
 (let ((?x56024 (I ?x56021)))
 (let ((?x56053 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55990 ?x56024 ?x56052)))
 (let ((?x56054 (vstd!seq.Seq.add.? $ ?x1876 ?x56053 ?x56051)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x56055 (ext_eq false ?x1968 ?x55989 ?x56054)))
 (let (($x56056 (not $x56055)))
 (let ((?x56057 (I ?x56010)))
 (let ((?x56058 (I ?x56047)))
 (let ((?x56059 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55989 ?x56058 ?x56057)))
 (let (($x56060 (ext_eq false ?x1968 ?x56051 ?x56059)))
 (let (($x56061 (not $x56060)))
 (let ((?x7131 (I 0)))
 (let ((?x56062 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55989 ?x7131 ?x56058)))
 (let (($x56063 (ext_eq false ?x1968 ?x56053 ?x56062)))
 (let (($x56064 (not $x56063)))
 (let (($x56065 (or $x56064 $x56061 $x56056)))
 (let (($x56066 (not $x56065)))
 (let ((?x56186 (* (- 1) ?x56041)))
 (let ((?x56022 (Add ?x56021 ?x56010)))
 (let ((?x56187 (+ ?x56022 ?x56186)))
 (let (($x56189 (>= ?x56187 0)))
 (let (($x56196 (not $x56189)))
 (let (($x56199 (or $x56196 $x56066)))
 (let (($x56198 (not $x56199)))
 (let ((?x56023 (I ?x56022)))
 (let ((?x56025 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55990 ?x56024 ?x56023)))
 (let (($x56026 (ext_eq false ?x1968 ?x56025 ?x55989)))
 (let ((?x56029 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x56016)))
 (let ((?x56030 (I ?x56029)))
 (let ((?x56031 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x56030 ?x56018)))
 (let ((?x56208 (* (- 1) ?x56031)))
 (let ((?x56209 (+ ?x56021 ?x56208)))
 (let (($x56210 (>= ?x56209 0)))
 (let (($x56215 (not $x56210)))
 (let (($x56217 (or $x56215 $x56189 $x56026)))
 (let ((?x47746 (vstd!seq.Seq.len.? $ ?x1876 ?x47745)))
 (let ((?x47731 (pmemlog!logimpl_v.spec_get_live_header.? ?x47674)))
 (let ((?x47738 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x47731)))
 (let ((?x47739 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x47738)))
 (let ((?x47740 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x47739)))
 (let ((?x47741 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x47740)))
 (let ((?x47742 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x47741)))
 (let ((?x47754 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x47742)))
 (let ((?x47795 (I ?x47754)))
 (let ((?x47743 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x47742)))
 (let ((?x47797 (I ?x47743)))
 (let ((?x47798 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x47797 ?x47795)))
 (let ((?x47802 (Add ?x47798 ?x47746)))
 (let ((?x47837 (* (- 1) ?x47802)))
 (let ((?x47799 (Add ?x47754 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x47838 (+ ?x47799 ?x47837)))
 (let (($x47835 (<= ?x47838 0)))
 (let ((?x47824 (I ?x47802)))
 (let ((?x47804 (I ?x47798)))
 (let ((?x47825 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x47804 ?x47824)))
 (let (($x47826 (ext_eq false ?x1968 ?x47825 ?x47745)))
 (let (($x48677 (= bytes_to_append! ?x48676)))
 (let (($x1966 (forall ((x vstd!seq.Seq<u8.>.) )(! (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x))) :pattern ( (Poly%vstd!seq.Seq<u8.>. x) ) :qid internal_vstd__seq__Seq<u8.>_box_axiom_definition))
 ))
 (let ((?x11198 (lambda ((x vstd!seq.Seq<u8.>.) )(let (($x1964 (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x)))))
 (refl (~ $x1964 $x1964))))
 ))
 (let ((@x11202 (mp~ (asserted $x1966) (nnf-pos (proof-bind ?x11198) (~ $x1966 $x1966)) $x1966)))
 (let (($x48673 (not $x1966)))
 (let (($x48682 (or $x48673 $x48677)))
 (let ((@x48683 ((_ quant-inst bytes_to_append!) $x48682)))
 (let ((@x56780 (symm (unit-resolution @x48683 @x11202 $x48677) (= ?x48676 bytes_to_append!))))
 (let ((@x56782 (monotonicity @x56780 (= ?x55989 ?x47745))))
 (let ((@x61514 (monotonicity @x56782 (= ?x56010 ?x47746))))
 (let (($x48664 (= pm! ?x48663)))
 (let (($x48674 (or $x48673 $x48664)))
 (let ((@x48675 ((_ quant-inst pm!) $x48674)))
 (let ((@x56800 (symm (unit-resolution @x48675 @x11202 $x48664) (= ?x48663 pm!))))
 (let ((@x56802 (monotonicity @x56800 (= ?x55990 ?x47674))))
 (let ((@x61513 (monotonicity (monotonicity (monotonicity @x56802 (= ?x56011 ?x47731)) (= ?x56012 ?x47738)) (= ?x56013 ?x47739))))
 (let ((@x61544 (monotonicity (monotonicity (monotonicity @x61513 (= ?x56014 ?x47740)) (= ?x56015 ?x47741)) (= ?x56016 ?x47742))))
 (let ((@x60976 (monotonicity @x61544 (= ?x56017 ?x47754))))
 (let ((@x61114 (monotonicity @x60976 (= ?x56018 ?x47795))))
 (let ((@x61591 (monotonicity (monotonicity (monotonicity @x61544 (= ?x56019 ?x47743)) (= ?x56020 ?x47797)) @x61114 (= ?x56021 ?x47798))))
 (let ((@x61595 (monotonicity @x61591 @x61514 (= ?x56022 ?x47802))))
 (let ((@x60325 (monotonicity @x61591 (= ?x56024 ?x47804))))
 (let ((@x61604 (monotonicity @x56802 @x60325 (monotonicity @x61595 (= ?x56023 ?x47824)) (= ?x56025 ?x47825))))
 (let ((@x61607 (symm (monotonicity @x61604 @x56782 (= $x56026 $x47826)) (= $x47826 $x56026))))
 (let (($x47846 (not $x47835)))
 (let ((@x67151 (hypothesis $x47846)))
 (let ((?x47852 (* (- 1) ?x47798)))
 (let ((?x47750 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x47742)))
 (let ((?x47794 (I ?x47750)))
 (let ((?x47796 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x47794 ?x47795)))
 (let ((?x47853 (+ ?x47796 ?x47852)))
 (let (($x47854 (<= ?x47853 0)))
 (let ((?x56028 (* (- 1) ?x56022)))
 (let ((?x58029 (+ ?x47802 ?x56028)))
 (let (($x58168 (>= ?x58029 0)))
 (let (($x57950 (= ?x47802 ?x56022)))
 (let ((@x66661 (symm @x61595 $x57950)))
 (let ((@x66775 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x57950) $x58168)) @x66661 $x58168)))
 (let ((?x57851 (+ ?x47799 ?x56186)))
 (let (($x58179 (<= ?x57851 0)))
 (let (($x57943 (= ?x47799 ?x56041)))
 (let ((@x67157 (monotonicity @x60976 (= ?x56041 ?x47799))))
 (let ((@x67159 (symm @x67157 $x57943)))
 (let ((@x67162 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 1) (or $x56196 (not $x58179) (not $x58168) $x47835)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x57943) $x58179)) @x67159 $x58179) @x66775 (or $x56196 $x47835))))
 (let ((@x67134 (unit-resolution @x67162 @x67151 $x56196)))
 (let (($x47920 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x48379 (not $x47920)))
 (let (($x47996 (not %%location_label%%0)))
 (let (($x47997 (or $x47996 $x47920)))
 (let (($x48055 (not $x47997)))
 (let ((?x47924 (I new_ib!)))
 (let ((?x47925 (vstd!bytes.spec_u64_to_le_bytes.? ?x47924)))
 (let ((?x47935 (Poly%vstd!seq.Seq<u8.>. ?x47925)))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x47998 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47674 ?x7427 ?x47935 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28)))
 (let ((?x47999 (Poly%vstd!seq.Seq<u8.>. ?x47998)))
 (let ((?x48038 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x47999)))
 (let (($x48042 (%B ?x48038)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x48034 (has_type chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28 ?x1998)))
 (let (($x48035 (not $x48034)))
 (let (($x48056 (not %%location_label%%3)))
 (let (($x48130 (or $x48056 $x48035 $x48042)))
 (let (($x48133 (not $x48130)))
 (let ((?x47936 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47674 ?x7427 ?x47935)))
 (let ((?x47937 (Poly%vstd!seq.Seq<u8.>. ?x47936)))
 (let ((?x47940 (pmemlog!logimpl_v.pm_to_views.? ?x47937)))
 (let ((?x47941 (Poly%tuple%3. ?x47940)))
 (let ((?x47942 (%Poly%tuple%3. ?x47941)))
 (let ((?x47943 (tuple%3./tuple%3/0 ?x47942)))
 (let ((?x47944 (%I ?x47943)))
 (let (($x47974 (= new_ib! ?x47944)))
 (let (($x48123 (not $x47974)))
 (let ((?x47723 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x47730 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x47723)))
 (let ((?x47732 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x47730)))
 (let ((?x47939 (pmemlog!logimpl_v.spec_get_live_header.? ?x47937)))
 (let ((?x47971 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x47939)))
 (let (($x47972 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeader. ?x47971 ?x47732)))
 (let (($x48122 (not $x47972)))
 (let ((?x47967 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x47937)))
 (let (($x47968 (%B ?x47967)))
 (let (($x48121 (not $x47968)))
 (let ((?x47938 (pmemlog!logimpl_v.impl&%0.recover.? ?x47937)))
 (let ((?x47945 (Poly%core!option.Option. ?x47938)))
 (let ((?x47691 (pmemlog!logimpl_v.impl&%0.recover.? ?x47674)))
 (let ((?x47897 (Poly%core!option.Option. ?x47691)))
 (let ((?x47946 (tuple%2./tuple%2 ?x47897 ?x47945)))
 (let ((?x47948 (Poly%tuple%2. ?x47946)))
 (let ((?x47949 (%Poly%tuple%2. ?x47948)))
 (let ((?x47950 (tuple%2./tuple%2/0 ?x47949)))
 (let ((?x47951 (%Poly%core!option.Option. ?x47950)))
 (let ((?x47958 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47951)))
 (let ((?x47959 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47958)))
 (let ((?x47963 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47959)))
 (let ((?x47964 (pmemlog!infinitelog_t.impl&%0.append.? ?x47963 ?x47745)))
 (let ((?x47965 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47964)))
 (let ((?x47954 (tuple%2./tuple%2/1 ?x47949)))
 (let ((?x47955 (%Poly%core!option.Option. ?x47954)))
 (let ((?x47960 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47955)))
 (let ((?x47961 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47960)))
 (let ((?x47962 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47961)))
 (let (($x47966 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47962 ?x47965)))
 (let (($x48120 (not $x47966)))
 (let (($x48021 ((_ is core!option.Option./Some ) ?x47955)))
 (let (($x48119 (not $x48021)))
 (let (($x48011 ((_ is core!option.Option./Some ) ?x47951)))
 (let (($x48118 (not $x48011)))
 (let (($x48124 (or $x48118 $x48119 $x48120 $x48121 $x48122 $x48123)))
 (let (($x48125 (not $x48124)))
 (let (($x48039 (not %%location_label%%2)))
 (let (($x48128 (or $x48039 $x48125)))
 (let (($x48126 (not $x48128)))
 (let (($x48136 (or $x48126 $x48133)))
 (let (($x48145 (not $x48136)))
 (let (($x47933 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! tmp%1 ib_bytes@)))
 (let (($x48050 (not $x47933)))
 (let (($x48146 (or $x48050 $x48145)))
 (let (($x48147 (not $x48146)))
 (let (($x47931 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! tmp%1 ib_bytes@)))
 (let (($x48000 (not %%location_label%%1)))
 (let (($x48001 (or $x48000 $x47931)))
 (let (($x48012 (not $x48001)))
 (let (($x48152 (or $x48012 $x48147)))
 (let (($x48158 (not $x48152)))
 (let (($x47929 (= tmp%1 pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let (($x48047 (not $x47929)))
 (let (($x47927 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. 0)))
 (let (($x48024 (not $x47927)))
 (let (($x47926 (= ib_bytes@ ?x47925)))
 (let (($x48013 (not $x47926)))
 (let (($x47922 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x48029 (not $x47922)))
 (let (($x48159 (or $x48029 $x48013 $x48024 $x48047 $x48158)))
 (let ((?x47898 (%Poly%core!option.Option. ?x47897)))
 (let ((?x47899 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47898)))
 (let ((?x47900 (pmemlog!infinitelog_t.impl&%0.append.? ?x47899 ?x47745)))
 (let ((?x47901 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47900)))
 (let ((?x47902 (core!option.Option./Some ?x47901)))
 (let ((?x47486 (%Poly%vstd!seq.Seq<u8.>. ?x47999)))
 (let ((?x63187 (Poly%vstd!seq.Seq<u8.>. ?x47486)))
 (let ((?x64841 (pmemlog!logimpl_v.impl&%0.recover.? ?x63187)))
 (let (($x64849 (= ?x64841 ?x47902)))
 (let ((?x69445 (I 12331324665725530551)))
 (let ((?x69486 (vstd!bytes.spec_u64_to_le_bytes.? ?x69445)))
 (let ((?x69487 (Poly%vstd!seq.Seq<u8.>. ?x69486)))
 (let ((?x69488 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x55990 ?x7427 ?x69487)))
 (let ((?x69489 (Poly%vstd!seq.Seq<u8.>. ?x69488)))
 (let ((?x69490 (pmemlog!logimpl_v.impl&%0.recover.? ?x69489)))
 (let ((?x69491 (Poly%core!option.Option. ?x69490)))
 (let ((?x55991 (pmemlog!logimpl_v.impl&%0.recover.? ?x55990)))
 (let ((?x55992 (Poly%core!option.Option. ?x55991)))
 (let ((?x69492 (tuple%2./tuple%2 ?x55992 ?x69491)))
 (let ((?x69493 (Poly%tuple%2. ?x69492)))
 (let ((?x69494 (%Poly%tuple%2. ?x69493)))
 (let ((?x69499 (tuple%2./tuple%2/1 ?x69494)))
 (let ((?x69500 (%Poly%core!option.Option. ?x69499)))
 (let ((?x69682 (core!option.Option./Some/?0 ?x69500)))
 (let ((?x69698 (core!option.Option./Some ?x69682)))
 (let (($x49130 (= ?x47946 ?x47949)))
 (let (($x3448 (forall ((x tuple%2.) )(! (= x (%Poly%tuple%2. (Poly%tuple%2. x))) :pattern ( (Poly%tuple%2. x) ) :qid internal_crate__tuple__2_box_axiom_definition))
 ))
 (let ((?x11982 (lambda ((x tuple%2.) )(let (($x3446 (= x (%Poly%tuple%2. (Poly%tuple%2. x)))))
 (refl (~ $x3446 $x3446))))
 ))
 (let ((@x11986 (mp~ (asserted $x3448) (nnf-pos (proof-bind ?x11982) (~ $x3448 $x3448)) $x3448)))
 (let (($x49135 (not $x3448)))
 (let (($x49136 (or $x49135 $x49130)))
 (let ((@x49137 ((_ quant-inst (tuple%2./tuple%2 ?x47897 ?x47945)) $x49136)))
 (let ((@x60823 (unit-resolution @x49137 @x11986 $x49130)))
 (let ((?x48396 (tuple%2./tuple%2/?1 ?x47949)))
 (let ((?x48395 (tuple%2./tuple%2/?0 ?x47949)))
 (let ((?x48397 (tuple%2./tuple%2 ?x48395 ?x48396)))
 (let (($x48398 (= ?x47949 ?x48397)))
 (let ((@x60822 ((_ th-lemma datatype) $x48398)))
 (let ((@x62891 (symm @x60822 (= ?x48397 ?x47949))))
 (let ((?x48401 (tuple%2./tuple%2/?1 ?x48397)))
 (let (($x49157 (= ?x48401 ?x48396)))
 (let (($x48402 (= ?x48396 ?x48401)))
 (let ((@x62867 ((_ th-lemma datatype) $x48402)))
 (let ((@x62883 (symm @x62867 $x49157)))
 (let ((@x60825 (trans* @x60823 @x60822 (= ?x47946 ?x48397))))
 (let ((@x62872 (monotonicity @x60825 (= (tuple%2./tuple%2/?1 ?x47946) ?x48401))))
 (let ((?x48393 (tuple%2./tuple%2/?1 ?x47946)))
 (let (($x48394 (= ?x47945 ?x48393)))
 (let ((@x62866 ((_ th-lemma datatype) $x48394)))
 (let (($x60641 (= pmemlog!pmemspec_t.cdb1_val.? new_ib!)))
 (let (($x47699 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x47698 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x47708 (not $x47698)))
 (let (($x56027 (not $x56026)))
 (let ((?x56226 (+ ?x56022 ?x56208)))
 (let (($x56227 (>= ?x56226 0)))
 (let (($x56232 (or $x56227 $x56027)))
 (let (($x56238 (not $x56232)))
 (let (($x56219 (or $x56210 $x56238)))
 (let (($x56228 (not $x56219)))
 (let (($x56216 (not $x56217)))
 (let (($x56239 (or $x56198 $x56216 $x56228)))
 (let (($x56225 (not $x56239)))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x56200 (or $x10317 $x56225)))
 (let (($x56230 (not $x56200)))
 (let ((?x55993 (%Poly%core!option.Option. ?x55992)))
 (let ((?x55994 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x55993)))
 (let ((?x55995 (pmemlog!infinitelog_t.impl&%0.append.? ?x55994 ?x55989)))
 (let ((?x55996 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x55995)))
 (let ((?x55997 (core!option.Option./Some ?x55996)))
 (let ((?x55998 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! ?x48676 ?x48663 Perm& Perm&.)))
 (let ((?x55999 (pmemlog!logimpl_v.impl&%0.recover.? ?x55998)))
 (let (($x56000 (= ?x55999 ?x55997)))
 (let (($x56001 (= ?x55999 ?x55991)))
 (let (($x56002 (or $x56001 $x56000)))
 (let ((?x56003 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x55998)))
 (let (($x56004 (%B ?x56003)))
 (let (($x56005 (= $x56004 $x56002)))
 (let (($x56006 (has_type ?x55998 ?x1968)))
 (let (($x56007 (not $x56006)))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x56008 (or $x10334 $x56007 $x56005)))
 (let (($x56009 (not $x56008)))
 (let (($x47792 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x56074 (or $x10255 $x47792)))
 (let (($x56075 (not $x56074)))
 (let ((?x56076 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x55990)))
 (let (($x56077 (%B ?x56076)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x56078 (or $x10251 $x56077)))
 (let (($x56079 (not $x56078)))
 (let ((?x48671 (%Poly%vstd!seq.Seq<u8.>. ?x47723)))
 (let ((?x56080 (Poly%vstd!seq.Seq<u8.>. ?x48671)))
 (let ((?x56081 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x56080)))
 (let ((?x56082 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x56081)))
 (let ((?x56083 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x56082)))
 (let ((?x56084 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x56083)))
 (let ((?x56085 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x56084)))
 (let ((?x56086 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x56085)))
 (let ((?x56091 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x56086)))
 (let ((?x56181 (* (- 1) ?x56091)))
 (let ((?x56087 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x56086)))
 (let ((?x56088 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x56086)))
 (let ((?x56089 (Sub ?x56088 ?x56087)))
 (let ((?x56182 (+ ?x56089 ?x56181)))
 (let (($x56183 (>= ?x56182 0)))
 (let (($x56094 (= ?x56091 ?x56017)))
 (let (($x56095 (not $x56094)))
 (let (($x56096 (= ?x56087 ?x56029)))
 (let (($x56097 (not $x56096)))
 (let ((?x56098 (Add ?x56019 ?x56010)))
 (let (($x56099 (= ?x56088 ?x56098)))
 (let (($x56100 (not $x56099)))
 (let (($x56188 (or $x56100 $x56097 $x56095 $x56183)))
 (let (($x56194 (not $x56188)))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x56174 (or $x10245 $x56194)))
 (let (($x56195 (not $x56174)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x56105 (vstd!seq.Seq.subrange.? $ ?x1876 ?x56080 ?x7834 ?x7835)))
 (let ((?x56106 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x56105)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x56107 (vstd!seq.Seq.subrange.? $ ?x1876 ?x56080 ?x7829 ?x7831)))
 (let ((?x56108 (%Poly%vstd!seq.Seq<u8.>. ?x56107)))
 (let (($x56109 (= ?x56108 ?x56106)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x56110 (or $x10215 $x56109)))
 (let (($x56111 (not $x56110)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x56112 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55990 ?x9036 ?x7453)))
 (let ((?x56113 (%Poly%vstd!seq.Seq<u8.>. ?x56112)))
 (let (($x56114 (= ?x56113 ?x48671)))
 (let (($x56159 (= pmemlog!pmemspec_t.cdb1_val.? 11756720295082287198)))
 (let (($x56169 (not $x56159)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x56170 (or $x10209 $x56169 $x56114)))
 (let (($x56171 (not $x56170)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x56119 (vstd!seq.Seq.subrange.? $ ?x1876 ?x55990 ?x9030 ?x7447)))
 (let ((?x56120 (%Poly%vstd!seq.Seq<u8.>. ?x56119)))
 (let (($x56121 (= ?x56120 ?x48671)))
 (let (($x6736 (= pmemlog!pmemspec_t.cdb0_val.? 11756720295082287198)))
 (let (($x56162 (not $x6736)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x56166 (or $x10196 $x56162 $x56121)))
 (let (($x56164 (not $x56166)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x56161 (or $x10185 $x6736 $x56159)))
 (let (($x56163 (not $x56161)))
 (let (($x56128 ((_ is core!option.Option./Some ) ?x55991)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x56129 (or $x10179 $x56128)))
 (let (($x56130 (not $x56129)))
 (let ((?x56131 (vstd!seq.Seq.len.? $ ?x1876 ?x55990)))
 (let ((?x56132 (* (- 1) ?x56131)))
 (let ((?x56133 (+ pmemlog!logimpl_v.contents_offset.? ?x56132)))
 (let (($x56134 (>= ?x56133 0)))
 (let (($x56135 (not $x56134)))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x56136 (or $x10167 $x56135)))
 (let (($x56137 (not $x56136)))
 (let (($x56138 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& ?x48663 11756720295082287198 ?x48676 ?x48671 perm!)))
 (let (($x60683 (or $x56138 $x56137 $x56130 $x56163 $x56164 $x56171 $x56111 $x56195 $x56079 $x56075 $x56230 $x56009)))
 (let (($x60784 (not $x60683)))
 (let (($x56146 (forall ((pm_state$ Poly) )(! (let ((?x47745 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x48676 (%Poly%vstd!seq.Seq<u8.>. ?x47745)))
 (let ((?x55989 (Poly%vstd!seq.Seq<u8.>. ?x48676)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x48663 (%Poly%vstd!seq.Seq<u8.>. ?x47674)))
 (let ((?x55990 (Poly%vstd!seq.Seq<u8.>. ?x48663)))
 (let ((?x55991 (pmemlog!logimpl_v.impl&%0.recover.? ?x55990)))
 (let ((?x55992 (Poly%core!option.Option. ?x55991)))
 (let ((?x55993 (%Poly%core!option.Option. ?x55992)))
 (let ((?x55994 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x55993)))
 (let ((?x55995 (pmemlog!infinitelog_t.impl&%0.append.? ?x55994 ?x55989)))
 (let ((?x55996 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x55995)))
 (let ((?x55997 (core!option.Option./Some ?x55996)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47894 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x47895 (%B ?x47894)))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (= $x47895 (or (= ?x7629 ?x55991) (= ?x7629 ?x55997)))))))))))))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x56147 (or $x10334 $x56146)))
 (let (($x56148 (not $x56147)))
 (let (($x56151 (not $x56138)))
 (let (($x60401 (or $x56151 (not (or $x56137 $x56130 $x56163 $x56164 $x56171 $x56111 $x56195 $x56079 $x56075 $x56230 $x56148)))))
 (let (($x60739 (or (not $x60401) $x60784)))
 (let (($x60998 (not $x60739)))
 (let (($x19597 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x15024 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x10265))))
 (let ((?x15026 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x15024 ?x6680))))
 (let ((?x15027 (core!option.Option./Some ?x15026)))
 (let ((?x15016 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! bytes_to_append! pm! Perm& Perm&.)))
 (let ((?x15021 (pmemlog!logimpl_v.impl&%0.recover.? ?x15016)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x15019 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x15016)))
 (let (($x15030 (= (%B ?x15019) (or (= ?x15021 ?x10027) (= ?x15021 ?x15027)))))
 (let (($x15018 (not (has_type ?x15016 ?x1968))))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x19577 (not (or $x10334 $x15018 $x15030))))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? ?x6675))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10270 (not $x10259)))
 (let (($x19547 (or (not (or $x10270 (not (or (not $x10103) (not $x10109) (not $x10112))))) (not (or (not $x10278) $x10259 $x10120)) (not (or $x10278 (not (or $x10269 (not $x10120))))))))
 (let (($x19548 (not $x19547)))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x19562 (not (or $x10317 $x19548))))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let (($x15008 (not $x10256)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let (($x15005 (not $x10252)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x19495 (or (not (= ?x10059 (Add ?x10065 ?x8518))) (not (= ?x10068 ?x10069)) (not (= ?x10072 ?x10073)) $x10228)))
 (let (($x19496 (not $x19495)))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x19561 (not (or $x10245 $x19496))))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let (($x14999 (not $x10216)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let (($x14996 (not $x10210)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x14993 (not $x10197)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let (($x14990 (not $x10186)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let (($x14987 (not $x10180)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x14984 (not $x10168)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x19580 (or $x10012 $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x19561 $x15005 $x15008 $x19562 $x19577)))
 (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10335 (or $x10334 $x10326)))
 (let (($x15037 (not $x10335)))
 (let (($x14949 (not $x10012)))
 (let (($x19569 (or $x14949 (not (or $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x19561 $x15005 $x15008 $x19562 $x15037)))))
 (not (or (not $x19569) (not $x19580))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_req__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let (($x15063 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x15024 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x10265))))
 (let ((?x15026 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x15024 ?x6680))))
 (let ((?x15027 (core!option.Option./Some ?x15026)))
 (let ((?x15016 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! bytes_to_append! pm! Perm& Perm&.)))
 (let ((?x15021 (pmemlog!logimpl_v.impl&%0.recover.? ?x15016)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x15019 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x15016)))
 (let (($x15030 (= (%B ?x15019) (or (= ?x15021 ?x10027) (= ?x15021 ?x15027)))))
 (let (($x15018 (not (has_type ?x15016 ?x1968))))
 (let (($x15032 (not (or $x15018 $x15030))))
 (let (($x15036 (and %%global_location_label%%121 $x15032)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? ?x6675))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let (($x10270 (not $x10259)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x15011 (not $x10318)))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let (($x15008 (not $x10256)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let (($x15005 (not $x10252)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x10246 (or $x10245 $x10237)))
 (let (($x15002 (not $x10246)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let (($x14999 (not $x10216)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let (($x14996 (not $x10210)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x14993 (not $x10197)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let (($x14990 (not $x10186)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let (($x14987 (not $x10180)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x14984 (not $x10168)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x15065 (or $x10012 $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x15002 $x15005 $x15008 $x15011 $x15036)))
 (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x10335 (or $x10334 $x10326)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x14949 (not $x10012)))
 (let (($x15045 (or $x14949 $x10340)))
 (and $x15045 $x15065))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_req__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let ((?x19598 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x15024 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x10265))))
 (let ((?x15026 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x15024 ?x6680))))
 (let ((?x15027 (core!option.Option./Some ?x15026)))
 (let ((?x15016 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! bytes_to_append! pm! Perm& Perm&.)))
 (let ((?x15021 (pmemlog!logimpl_v.impl&%0.recover.? ?x15016)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x15019 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x15016)))
 (let (($x15030 (= (%B ?x15019) (or (= ?x15021 ?x10027) (= ?x15021 ?x15027)))))
 (let (($x15018 (not (has_type ?x15016 ?x1968))))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x19577 (not (or $x10334 $x15018 $x15030))))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? ?x6675))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10270 (not $x10259)))
 (let (($x19547 (or (not (or $x10270 (not (or (not $x10103) (not $x10109) (not $x10112))))) (not (or (not $x10278) $x10259 $x10120)) (not (or $x10278 (not (or $x10269 (not $x10120))))))))
 (let (($x19548 (not $x19547)))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x19562 (not (or $x10317 $x19548))))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let (($x15008 (not $x10256)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let (($x15005 (not $x10252)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x19495 (or (not (= ?x10059 (Add ?x10065 ?x8518))) (not (= ?x10068 ?x10069)) (not (= ?x10072 ?x10073)) $x10228)))
 (let (($x19496 (not $x19495)))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x19561 (not (or $x10245 $x19496))))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let (($x14999 (not $x10216)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let (($x14996 (not $x10210)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x14993 (not $x10197)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let (($x14990 (not $x10186)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let (($x14987 (not $x10180)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x14984 (not $x10168)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x19580 (or $x10012 $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x19561 $x15005 $x15008 $x19562 $x19577)))
 (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10335 (or $x10334 $x10326)))
 (let (($x15037 (not $x10335)))
 (let (($x14949 (not $x10012)))
 (let (($x19569 (or $x14949 (not (or $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x19561 $x15005 $x15008 $x19562 $x15037)))))
 (let (($x19592 (not (or (not $x19569) (not $x19580)))))
 (let (($x15032 (not (or $x15018 $x15030))))
 (let (($x15036 (and %%global_location_label%%121 $x15032)))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x15011 (not $x10318)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10246 (or $x10245 $x10237)))
 (let (($x15002 (not $x10246)))
 (let (($x15065 (or $x10012 $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x15002 $x15005 $x15008 $x15011 $x15036)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x15045 (or $x14949 $x10340)))
 (let (($x15069 (and $x15045 $x15065)))
 (let (($x19581 (= $x15065 $x19580)))
 (let ((@x19582 (monotonicity (rewrite (= $x15002 $x19561)) (rewrite (= $x15011 $x19562)) (rewrite (= $x15036 $x19577)) $x19581)))
 (let ((@x19588 (monotonicity (rewrite (= $x15045 $x19569)) (trans @x19582 (rewrite (= $x19580 $x19580)) $x19581) (= $x15069 (and $x19569 $x19580)))))
 (trans @x19588 (rewrite (= (and $x19569 $x19580) $x19592)) (= $x15069 $x19592))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x15049 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x15024 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x10265))))
 (let ((?x15026 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x15024 ?x6680))))
 (let ((?x15027 (core!option.Option./Some ?x15026)))
 (let ((?x15016 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! bytes_to_append! pm! Perm& Perm&.)))
 (let ((?x15021 (pmemlog!logimpl_v.impl&%0.recover.? ?x15016)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x15019 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x15016)))
 (let (($x15030 (= (%B ?x15019) (or (= ?x15021 ?x10027) (= ?x15021 ?x15027)))))
 (let (($x15018 (not (has_type ?x15016 ?x1968))))
 (let (($x15032 (not (or $x15018 $x15030))))
 (let (($x15036 (and %%global_location_label%%121 $x15032)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? ?x6675))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let (($x10270 (not $x10259)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x15011 (not $x10318)))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let (($x15008 (not $x10256)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let (($x15005 (not $x10252)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x10246 (or $x10245 $x10237)))
 (let (($x15002 (not $x10246)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let (($x14999 (not $x10216)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let (($x14996 (not $x10210)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x14993 (not $x10197)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let (($x14990 (not $x10186)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let (($x14987 (not $x10180)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x14984 (not $x10168)))
 (let (($x15040 (or $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x15002 $x15005 $x15008 $x15011 $x15036)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x10335 (or $x10334 $x10326)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x14949 (not $x10012)))
 (let (($x15045 (or $x14949 $x10340)))
 (and $x15045 (or $x10012 $x15040)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_req__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let ((?x15064 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x15024 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x10265))))
 (let ((?x15026 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x15024 ?x6680))))
 (let ((?x15027 (core!option.Option./Some ?x15026)))
 (let ((?x15016 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! bytes_to_append! pm! Perm& Perm&.)))
 (let ((?x15021 (pmemlog!logimpl_v.impl&%0.recover.? ?x15016)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x15019 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x15016)))
 (let (($x15030 (= (%B ?x15019) (or (= ?x15021 ?x10027) (= ?x15021 ?x15027)))))
 (let (($x15018 (not (has_type ?x15016 ?x1968))))
 (let (($x15032 (not (or $x15018 $x15030))))
 (let (($x15036 (and %%global_location_label%%121 $x15032)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? ?x6675))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let (($x10270 (not $x10259)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x15011 (not $x10318)))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let (($x15008 (not $x10256)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let (($x15005 (not $x10252)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x10246 (or $x10245 $x10237)))
 (let (($x15002 (not $x10246)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let (($x14999 (not $x10216)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let (($x14996 (not $x10210)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x14993 (not $x10197)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let (($x14990 (not $x10186)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let (($x14987 (not $x10180)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x14984 (not $x10168)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x15065 (or $x10012 $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x15002 $x15005 $x15008 $x15011 $x15036)))
 (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x10335 (or $x10334 $x10326)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x14949 (not $x10012)))
 (let (($x15045 (or $x14949 $x10340)))
 (let (($x15069 (and $x15045 $x15065)))
 (let (($x15040 (or $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x15002 $x15005 $x15008 $x15011 $x15036)))
 (let (($x15046 (and $x15045 (or $x10012 $x15040))))
 (rewrite (= $x15046 $x15069))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x10341 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x10335 (or $x10334 $x10326)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? (Poly%vstd!seq.Seq<u8.>. pm!)))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let (($x10270 (not $x10259)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x10246 (or $x10245 $x10237)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (= $x10012 $x10340))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_req__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let ((?x15050 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x15024 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x10265))))
 (let ((?x15026 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x15024 ?x6680))))
 (let ((?x15027 (core!option.Option./Some ?x15026)))
 (let ((?x15016 (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! bytes_to_append! pm! Perm& Perm&.)))
 (let ((?x15021 (pmemlog!logimpl_v.impl&%0.recover.? ?x15016)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x15019 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x15016)))
 (let (($x15030 (= (%B ?x15019) (or (= ?x15021 ?x10027) (= ?x15021 ?x15027)))))
 (let (($x15018 (not (has_type ?x15016 ?x1968))))
 (let (($x15032 (not (or $x15018 $x15030))))
 (let (($x15036 (and %%global_location_label%%121 $x15032)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? ?x6675))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let (($x10270 (not $x10259)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x15011 (not $x10318)))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let (($x15008 (not $x10256)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let (($x15005 (not $x10252)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x10246 (or $x10245 $x10237)))
 (let (($x15002 (not $x10246)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let (($x14999 (not $x10216)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let (($x14996 (not $x10210)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x14993 (not $x10197)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let (($x14990 (not $x10186)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let (($x14987 (not $x10180)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x14984 (not $x10168)))
 (let (($x15040 (or $x14984 $x14987 $x14990 $x14993 $x14996 $x14999 $x15002 $x15005 $x15008 $x15011 $x15036)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x10335 (or $x10334 $x10326)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x14949 (not $x10012)))
 (let (($x15045 (or $x14949 $x10340)))
 (let (($x15046 (and $x15045 (or $x10012 $x15040))))
 (let (($x10324 (= $x10012 $x10340)))
 (let ((@x15039 (nnf-neg (refl (~ %%global_location_label%%121 %%global_location_label%%121)) (sk (~ (not $x10326) $x15032)) (~ (not $x10335) $x15036))))
 (let ((@x15043 (nnf-neg (refl (~ $x14984 $x14984)) (refl (~ $x14987 $x14987)) (refl (~ $x14990 $x14990)) (refl (~ $x14993 $x14993)) (refl (~ $x14996 $x14996)) (refl (~ $x14999 $x14999)) (refl (~ $x15002 $x15002)) (refl (~ $x15005 $x15005)) (refl (~ $x15008 $x15008)) (refl (~ $x15011 $x15011)) @x15039 (~ (not $x10340) $x15040))))
 (let ((?x14976 (lambda ((pm_state$ Poly) )(let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x10323 (or $x1977 $x10142)))
 (refl (~ $x10323 $x10323))))))))))))))))
 ))
 (let ((@x14977 (proof-bind ?x14976)))
 (let ((@x14981 (monotonicity (refl (~ $x10334 $x10334)) (nnf-pos @x14977 (~ $x10326 $x10326)) (~ $x10335 $x10335))))
 (let ((@x14983 (monotonicity (refl (~ $x10168 $x10168)) (refl (~ $x10180 $x10180)) (refl (~ $x10186 $x10186)) (refl (~ $x10197 $x10197)) (refl (~ $x10210 $x10210)) (refl (~ $x10216 $x10216)) (refl (~ $x10246 $x10246)) (refl (~ $x10252 $x10252)) (refl (~ $x10256 $x10256)) (refl (~ $x10318 $x10318)) @x14981 (~ $x10340 $x10340))))
 (nnf-pos (refl (~ $x10012 $x10012)) (refl (~ $x14949 $x14949)) @x14983 @x15043 (~ $x10324 $x15046)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x10150 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let (($x10145 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (=> $x1969 $x10142)))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? (Poly%vstd!seq.Seq<u8.>. pm!)))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10117 (and (<= ?x10090 ?x10092) (< ?x10096 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10127 (and (and (=> (>= ?x10096 ?x10093) (and (and $x10103 $x10109) $x10112)) (=> $x10117 $x10120)) (=> (< ?x10092 ?x10090) (and (< ?x10096 ?x10090) $x10120)))))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let (($x10078 (and (and (and (= ?x10059 (Add ?x10065 ?x8518)) (= ?x10068 ?x10069)) (= ?x10072 ?x10073)) (< ?x10076 ?x10072))))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10045 (=> $x10032 $x10044)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10039 (=> $x10031 $x10038)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let (($x10028 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x10027)))
 (let ((?x10020 (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))
 (let (($x10023 (> ?x10020 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x10147 (and (=> %%global_location_label%%111 $x10023) (=> %%global_location_label%%112 $x10028) (=> %%global_location_label%%113 (or $x10031 $x10032)) (=> (and %%global_location_label%%114 $x10031) $x10038) (=> (and %%global_location_label%%115 $x10032) $x10044) (=> %%global_location_label%%116 $x10049) (=> %%global_location_label%%117 $x10078) (=> %%global_location_label%%118 $x10082) (=> %%global_location_label%%119 $x10085) (=> %%global_location_label%%120 $x10127) (=> %%global_location_label%%121 $x10145))))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (= $x10012 $x10147))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_req__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let ((?x10343 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let (($x10326 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x10142))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10334 (not %%global_location_label%%121)))
 (let (($x10335 (or $x10334 $x10326)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x10060 (Poly%pmemlog!logimpl_v.PersistentHeader. (pmemlog!logimpl_v.spec_get_live_header.? (Poly%vstd!seq.Seq<u8.>. pm!)))))
 (let ((?x10062 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x10060))))
 (let ((?x10064 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10062))))
 (let ((?x10073 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10064)))
 (let ((?x10089 (I ?x10073)))
 (let ((?x10065 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10064)))
 (let ((?x10092 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10065) ?x10089)))
 (let ((?x10096 (Add ?x10092 ?x8518)))
 (let ((?x10098 (I ?x10092)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10120 (ext_eq false ?x1968 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I ?x10096)) ?x6680)))
 (let ((?x10261 (* (- 1) ?x10096)))
 (let ((?x10069 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10064)))
 (let ((?x10090 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x10069) ?x10089)))
 (let (($x10269 (<= (+ ?x10090 ?x10261) 0)))
 (let (($x10278 (<= (+ ?x10090 (* (- 1) ?x10092)) 0)))
 (let (($x10259 (<= (+ (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10261) 0)))
 (let (($x10270 (not $x10259)))
 (let ((?x10104 (Add pmemlog!logimpl_v.contents_offset.? (Sub ?x8518 (Sub (Add ?x10073 pmemlog!logimpl_v.contents_offset.?) ?x10092)))))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x7471 (I ?x10104))))
 (let ((?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x10098 (I (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))))
 (let (($x10112 (ext_eq false ?x1968 ?x6680 (vstd!seq.Seq.add.? $ ?x1876 ?x10100 ?x10106))))
 (let ((?x10093 (Add ?x10073 pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x10094 (Sub ?x10093 ?x10092)))
 (let ((?x10101 (I ?x10094)))
 (let (($x10109 (ext_eq false ?x1968 ?x10106 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 ?x10101 (I ?x8518)))))
 (let (($x10103 (ext_eq false ?x1968 ?x10100 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6680 (I 0) ?x10101))))
 (let (($x10309 (and (or $x10270 (and $x10103 $x10109 $x10112)) (or (not (and $x10278 $x10270)) $x10120) (or $x10278 (and (not $x10269) $x10120)))))
 (let (($x10317 (not %%global_location_label%%120)))
 (let (($x10318 (or $x10317 $x10309)))
 (let (($x10085 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x10255 (not %%global_location_label%%119)))
 (let (($x10256 (or $x10255 $x10085)))
 (let ((?x10081 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x6675)))
 (let (($x10082 (%B ?x10081)))
 (let (($x10251 (not %%global_location_label%%118)))
 (let (($x10252 (or $x10251 $x10082)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let ((?x10055 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x10052))))
 (let ((?x10057 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x10055))))
 (let ((?x10058 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x10057)))
 (let ((?x10068 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x10058)))
 (let ((?x10059 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x10058)))
 (let ((?x10076 (Sub ?x10059 ?x10068)))
 (let ((?x10072 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x10058)))
 (let (($x10228 (<= (+ ?x10072 (* (- 1) ?x10076)) 0)))
 (let (($x10074 (= ?x10072 ?x10073)))
 (let (($x10070 (= ?x10068 ?x10069)))
 (let (($x10067 (= ?x10059 (Add ?x10065 ?x8518))))
 (let (($x10237 (and $x10067 $x10070 $x10074 (not $x10228))))
 (let (($x10245 (not %%global_location_label%%117)))
 (let (($x10246 (or $x10245 $x10237)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x9760 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7834 ?x7835)))
 (let ((?x9761 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x9760)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x9759 (vstd!seq.Seq.subrange.? $ ?x1876 ?x6683 ?x7829 ?x7831)))
 (let (($x10049 (= (%Poly%vstd!seq.Seq<u8.>. ?x9759) ?x9761)))
 (let (($x10215 (not %%global_location_label%%116)))
 (let (($x10216 (or $x10215 $x10049)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x9036 (I pmemlog!logimpl_v.header2_pos.?)))
 (let ((?x10043 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9036 ?x7453))))
 (let (($x10044 (= ?x10043 new_header_bytes!)))
 (let (($x10032 (= new_ib! pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x10202 (not $x10032)))
 (let (($x10209 (not %%global_location_label%%115)))
 (let (($x10210 (or $x10209 $x10202 $x10044)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x9030 (I pmemlog!logimpl_v.header1_pos.?)))
 (let ((?x10037 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 ?x6675 ?x9030 ?x7447))))
 (let (($x10038 (= ?x10037 new_header_bytes!)))
 (let (($x10031 (= new_ib! pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x10189 (not $x10031)))
 (let (($x10196 (not %%global_location_label%%114)))
 (let (($x10197 (or $x10196 $x10189 $x10038)))
 (let (($x10185 (not %%global_location_label%%113)))
 (let (($x10186 (or $x10185 $x10031 $x10032)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let (($x10173 ((_ is core!option.Option./Some ) ?x10027)))
 (let (($x10179 (not %%global_location_label%%112)))
 (let (($x10180 (or $x10179 $x10173)))
 (let ((?x10158 (+ pmemlog!logimpl_v.contents_offset.? (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))))
 (let (($x10161 (not (>= ?x10158 0))))
 (let (($x10167 (not %%global_location_label%%111)))
 (let (($x10168 (or $x10167 $x10161)))
 (let (($x10340 (and $x10168 $x10180 $x10186 $x10197 $x10210 $x10216 $x10246 $x10252 $x10256 $x10318 $x10335)))
 (let (($x10012 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x10324 (= $x10012 $x10340)))
 (let (($x10145 (forall ((pm_state$ Poly) )(! (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x6674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10132 (pmemlog!logimpl_v.impl&%0.recover.? ?x6674)))
 (let ((?x10136 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. (Poly%core!option.Option. ?x10132)))))
 (let ((?x10138 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10136 ?x9341))))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10130 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x10142 (= (%B ?x10130) (or (= ?x7629 ?x10132) (= ?x7629 (core!option.Option./Some ?x10138))))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (=> $x1969 $x10142)))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49))
 ))
 (let (($x10122 (and (=> (>= ?x10096 ?x10093) (and (and $x10103 $x10109) $x10112)) (=> (and (<= ?x10090 ?x10092) (< ?x10096 ?x10093)) $x10120))))
 (let (($x10127 (and $x10122 (=> (< ?x10092 ?x10090) (and (< ?x10096 ?x10090) $x10120)))))
 (let (($x10078 (and (and (and $x10067 $x10070) $x10074) (< ?x10076 ?x10072))))
 (let ((?x10020 (vstd!seq.Seq.len.? $ ?x1876 ?x6675)))
 (let (($x10023 (> ?x10020 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x10147 (and (=> %%global_location_label%%111 $x10023) (=> %%global_location_label%%112 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x10027)) (=> %%global_location_label%%113 (or $x10031 $x10032)) (=> (and %%global_location_label%%114 $x10031) $x10038) (=> (and %%global_location_label%%115 $x10032) $x10044) (=> %%global_location_label%%116 $x10049) (=> %%global_location_label%%117 $x10078) (=> %%global_location_label%%118 $x10082) (=> %%global_location_label%%119 $x10085) (=> %%global_location_label%%120 $x10127) (=> %%global_location_label%%121 $x10145))))
 (let (($x10148 (= $x10012 $x10147)))
 (rewrite (= $x10148 $x10324))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x10281 (mp (asserted $x10150) (quant-intro (proof-bind ?x10343) (= $x10150 $x10341)) $x10341)))
 (let ((@x15055 (mp (mp~ @x10281 (nnf-pos (proof-bind ?x15050) (~ $x10341 $x15049)) $x15049) (quant-intro (proof-bind ?x15064) (= $x15049 $x15063)) $x15063)))
 (let ((@x19500 (mp @x15055 (quant-intro (proof-bind ?x19598) (= $x15063 $x19597)) $x19597)))
 (let (($x60997 (not $x19597)))
 (let (($x60742 (or $x60997 $x60998)))
 (let ((?x56036 (* (- 1) ?x56021)))
 (let ((?x56037 (+ ?x56031 ?x56036)))
 (let (($x56038 (<= ?x56037 0)))
 (let (($x56070 (or (not (or (not (<= (+ ?x56041 ?x56028) 0)) $x56066)) (not (or (not $x56038) (<= (+ ?x56041 ?x56028) 0) $x56026)) (not (or $x56038 (not (or (<= (+ ?x56031 ?x56028) 0) $x56027)))))))
 (let (($x56073 (not (or $x10317 (not $x56070)))))
 (let (($x56103 (or $x10245 (not (or $x56100 $x56097 $x56095 (<= (+ ?x56091 (* (- 1) ?x56089)) 0))))))
 (let (($x56104 (not $x56103)))
 (let (($x56118 (not (or $x10209 (not (= 11756720295082287198 pmemlog!pmemspec_t.cdb1_val.?)) $x56114))))
 (let (($x56125 (not (or $x10196 (not (= 11756720295082287198 pmemlog!pmemspec_t.cdb0_val.?)) $x56121))))
 (let (($x56115 (= 11756720295082287198 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x56122 (= 11756720295082287198 pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x56127 (not (or $x10185 $x56122 $x56115))))
 (let (($x56140 (not (or $x56138 $x56137 $x56130 $x56127 $x56125 $x56118 $x56111 $x56104 $x56079 $x56075 $x56073 $x56009))))
 (let (($x56152 (or $x56151 (not (or $x56137 $x56130 $x56127 $x56125 $x56118 $x56111 $x56104 $x56079 $x56075 $x56073 $x56148)))))
 (let (($x56155 (not (or (not $x56152) $x56140))))
 (let (($x60996 (or $x60997 $x56155)))
 (let (($x60741 (= $x60996 $x60742)))
 (let ((@x60960 (trans (monotonicity (rewrite (= $x56155 $x60998)) $x60741) (rewrite (= $x60742 $x60742)) $x60741)))
 (let ((@x60930 (unit-resolution (def-axiom (or $x60739 $x60683)) (unit-resolution (mp ((_ quant-inst Perm&. Perm& (%Poly%vstd!seq.Seq<u8.>. ?x47674) 11756720295082287198 (%Poly%vstd!seq.Seq<u8.>. ?x47745) (%Poly%vstd!seq.Seq<u8.>. ?x47723) perm!) $x60996) @x60960 $x60742) @x19500 $x60998) $x60683)))
 (let (($x48672 (= new_header_bytes! ?x48671)))
 (let (($x48678 (or $x48673 $x48672)))
 (let ((@x48679 ((_ quant-inst new_header_bytes!) $x48678)))
 (let ((@x58467 (unit-resolution @x48679 @x11202 $x48672)))
 (let ((?x47702 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x9030 ?x7447)))
 (let ((?x47703 (%Poly%vstd!seq.Seq<u8.>. ?x47702)))
 (let (($x47705 (= ?x47703 new_header_bytes!)))
 (let ((@x61101 (hypothesis $x47698)))
 (let (($x47709 (or $x47708 $x47705)))
 (let ((@x47712 (mp (asserted (=> $x47698 $x47705)) (rewrite (= (=> $x47698 $x47705) $x47709)) $x47709)))
 (let ((@x60947 (unit-resolution @x47712 @x61101 $x47705)))
 (let ((@x67559 (trans* (monotonicity (monotonicity @x56802 (= ?x56119 ?x47702)) (= ?x56120 ?x47703)) @x60947 @x58467 $x56121)))
 (let ((@x46963 (def-axiom (or $x56166 (not $x56121)))))
 (let (($x61654 (= $x56077 true)))
 (let ((?x47789 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x47674)))
 (let (($x47790 (%B ?x47789)))
 (let ((@x47791 (asserted $x47790)))
 (let ((@x48572 (iff-true @x47791 (= $x47790 true))))
 (let ((@x61768 (trans* (monotonicity (monotonicity @x56802 (= ?x56076 ?x47789)) (= $x56077 $x47790)) @x48572 $x61654)))
 (let ((@x60550 (def-axiom (or $x56078 (not $x56077)))))
 (let ((@x61767 (unit-resolution @x60550 (mp @x61768 (rewrite (= $x61654 $x56077)) $x56077) $x56078)))
 (let (($x47424 (= $x56128 true)))
 (let (($x47694 ((_ is core!option.Option./Some ) ?x47691)))
 (let ((@x47697 (mp (asserted ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x47691)) (rewrite (= ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x47691) $x47694)) $x47694)))
 (let ((@x48560 (iff-true @x47697 (= $x47694 true))))
 (let ((@x61764 (trans* (monotonicity (monotonicity @x56802 (= ?x55991 ?x47691)) (= $x56128 $x47694)) @x48560 $x47424)))
 (let ((@x61006 (def-axiom (or $x56129 (not $x56128)))))
 (let ((@x61774 (unit-resolution @x61006 (mp @x61764 (rewrite (= $x47424 $x56128)) $x56128) $x56129)))
 (let ((?x47726 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47723 ?x7834 ?x7835)))
 (let ((?x47727 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x47726)))
 (let ((@x58471 (symm @x58467 (= ?x48671 new_header_bytes!))))
 (let ((@x58473 (monotonicity @x58471 (= ?x56080 ?x47723))))
 (let ((@x60934 (symm (monotonicity (monotonicity @x58473 (= ?x56105 ?x47726)) (= ?x56106 ?x47727)) (= ?x47727 ?x56106))))
 (let ((?x47724 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47723 ?x7829 ?x7831)))
 (let ((?x47725 (%Poly%vstd!seq.Seq<u8.>. ?x47724)))
 (let (($x47728 (= ?x47725 ?x47727)))
 (let ((@x47729 (asserted $x47728)))
 (let ((@x61221 (trans* (monotonicity (monotonicity @x58473 (= ?x56107 ?x47724)) (= ?x56108 ?x47725)) @x47729 @x60934 $x56109)))
 (let ((@x60658 (def-axiom (or $x56110 (not $x56109)))))
 (let ((@x61225 (unit-resolution @x60658 @x61221 $x56110)))
 (let ((@x61232 (commutativity (= $x60641 $x47699))))
 (let (($x6733 (fuel_bool fuel%pmemlog!pmemspec_t.cdb0_val.)))
 (let (($x6731 (fuel_bool_default fuel%pmemlog!pmemspec_t.cdb0_val.)))
 (let (($x49795 (= $x6733 $x6731)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x47660 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x10497 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x10443 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x10497) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x10450 (mp (mp~ @x37 @x10443 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x49237 (unit-resolution @x10450 @x47660 $x30)))
 (let ((@x49812 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.cdb0_val.) (or (not $x30) $x49795)) @x49237 (hypothesis (not $x49795)) false)))
 (let ((@x49825 (lemma @x49812 $x49795)))
 (let ((@x6732 (asserted $x6731)))
 (let ((@x49803 (def-axiom (or (not $x49795) $x6733 (not $x6731)))))
 (let ((@x61319 (unit-resolution (unit-resolution @x49803 @x6732 (or (not $x49795) $x6733)) @x49825 $x6733)))
 (let (($x6739 (not $x6733)))
 (let (($x6740 (or $x6739 $x6736)))
 (let ((@x6743 (mp (asserted (=> $x6733 $x6736)) (rewrite (= (=> $x6733 $x6736) $x6740)) $x6740)))
 (let ((@x61320 (unit-resolution @x6743 @x61319 $x6736)))
 (let ((@x61231 (symm @x61320 $x56122)))
 (let ((@x61501 (trans* @x61231 (symm @x61101 (= pmemlog!pmemspec_t.cdb0_val.? new_ib!)) (= 11756720295082287198 new_ib!))))
 (let ((@x60394 (symm (trans (monotonicity @x61501 (= $x56159 $x60641)) @x61232 (= $x56159 $x47699)) (= $x47699 $x56159))))
 (let (($x60606 (not $x60641)))
 (let ((?x48603 (* (- 1) new_ib!)))
 (let ((?x55706 (+ pmemlog!pmemspec_t.cdb1_val.? ?x48603)))
 (let (($x55713 (<= ?x55706 0)))
 (let (($x60141 (not $x55713)))
 (let ((?x55656 (+ pmemlog!pmemspec_t.cdb0_val.? ?x48603)))
 (let (($x55701 (>= ?x55656 0)))
 (let (($x60613 (= pmemlog!pmemspec_t.cdb0_val.? new_ib!)))
 (let ((@x61475 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x60613) $x55701)) (mp @x61101 (symm (commutativity (= $x60613 $x47698)) (= $x47698 $x60613)) $x60613) $x55701)))
 (let (($x49811 (<= pmemlog!pmemspec_t.cdb0_val.? 11756720295082287198)))
 (let ((@x60787 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x56162 $x49811)) @x61320 $x49811)))
 (let (($x49817 (>= pmemlog!pmemspec_t.cdb1_val.? 12331324665725530551)))
 (let (($x6751 (= pmemlog!pmemspec_t.cdb1_val.? 12331324665725530551)))
 (let (($x6748 (fuel_bool fuel%pmemlog!pmemspec_t.cdb1_val.)))
 (let (($x6746 (fuel_bool_default fuel%pmemlog!pmemspec_t.cdb1_val.)))
 (let (($x49800 (= $x6748 $x6746)))
 (let ((@x49830 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.cdb1_val.) (or (not $x30) $x49800)) @x49237 (hypothesis (not $x49800)) false)))
 (let ((@x49843 (lemma @x49830 $x49800)))
 (let ((@x6747 (asserted $x6746)))
 (let ((@x49821 (def-axiom (or (not $x49800) $x6748 (not $x6746)))))
 (let ((@x60238 (unit-resolution (unit-resolution @x49821 @x6747 (or (not $x49800) $x6748)) @x49843 $x6748)))
 (let (($x6754 (not $x6748)))
 (let (($x6755 (or $x6754 $x6751)))
 (let ((@x6758 (mp (asserted (=> $x6748 $x6751)) (rewrite (= (=> $x6748 $x6751) $x6755)) $x6755)))
 (let ((@x60927 (unit-resolution @x6758 @x60238 $x6751)))
 (let ((@x61263 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1) (or $x60141 (not $x49817) (not $x49811) (not $x55701))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x6751) $x49817)) @x60927 $x49817) @x60787 (or $x60141 (not $x55701)))))
 (let ((@x60974 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x60606 $x55713)) (unit-resolution @x61263 @x61475 $x60141) $x60606)))
 (let ((@x60984 (mp @x60974 (monotonicity (trans* @x61232 @x60394 (= $x60641 $x56159)) (= $x60606 $x56169)) $x56169)))
 (let ((@x61317 (unit-resolution (def-axiom (or $x56170 $x56159)) @x60984 $x56170)))
 (let ((@x61321 (symm (monotonicity @x56800 @x61501 @x56780 @x58471 (= $x56138 $x47920)) (= $x47920 $x56138))))
 (let ((@x60771 (monotonicity @x61321 (= $x48379 $x56151))))
 (let (($x65729 (= false true)))
 (let (($x61147 (= ?x48038 ?x47789)))
 (let ((?x55926 (B $x47790)))
 (let (($x55911 (= ?x47789 ?x55926)))
 (let (($x49113 (has_type ?x47789 BOOL)))
 (let (($x48648 (has_type ?x47674 ?x1968)))
 (let (($x56755 (has_type ?x55990 ?x1968)))
 (let (($x56807 (not $x56755)))
 (let ((@x56809 (monotonicity (symm (monotonicity @x56802 (= $x56755 $x48648)) (= $x48648 $x56755)) (= (not $x48648) $x56807))))
 (let (($x1989 (forall ((x vstd!seq.Seq<u8.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (has_type ?x1962 ?x1968)))) :pattern ( (has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_has_type_always_definition))
 ))
 (let ((?x11212 (lambda ((x vstd!seq.Seq<u8.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (let (($x1987 (has_type ?x1962 ?x1968)))
 (refl (~ $x1987 $x1987)))))))
 ))
 (let ((@x11216 (mp~ (asserted $x1989) (nnf-pos (proof-bind ?x11212) (~ $x1989 $x1989)) $x1989)))
 (let ((@x56812 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47674)) (or (not $x1989) $x56755)) @x11216 $x56755) (mp (hypothesis (not $x48648)) @x56809 $x56807) false)))
 (let ((@x56813 (lemma @x56812 $x48648)))
 (let (($x47671 (has_type perm! Perm&)))
 (let ((@x47672 (asserted $x47671)))
 (let (($x17781 (forall ((Self%&. Dcr) (Self%& Type) (AbstractStorage&. Dcr) (AbstractStorage& Type) (self! Poly) (state! Poly) )(! (let ((?x6808 (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!)))
 (let (($x6809 (has_type ?x6808 BOOL)))
 (let (($x3469 (has_type state! AbstractStorage&)))
 (let (($x16220 (not $x3469)))
 (let (($x1791 (has_type self! Self%&)))
 (let (($x15875 (not $x1791)))
 (or $x15875 $x16220 $x6809))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!) ) :qid internal_pmemlog!sccf.CheckPermission.check_permission.?_pre_post_definition))
 ))
 (let (($x6817 (forall ((Self%&. Dcr) (Self%& Type) (AbstractStorage&. Dcr) (AbstractStorage& Type) (self! Poly) (state! Poly) )(! (let ((?x6808 (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!)))
 (let (($x6809 (has_type ?x6808 BOOL)))
 (let (($x3469 (has_type state! AbstractStorage&)))
 (let (($x1791 (has_type self! Self%&)))
 (let (($x3470 (and $x1791 $x3469)))
 (let (($x3479 (not $x3470)))
 (or $x3479 $x6809))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!) ) :qid internal_pmemlog!sccf.CheckPermission.check_permission.?_pre_post_definition))
 ))
 (let ((?x17782 (lambda ((Self%&. Dcr) (Self%& Type) (AbstractStorage&. Dcr) (AbstractStorage& Type) (self! Poly) (state! Poly) )(let ((?x6808 (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!)))
 (let (($x6809 (has_type ?x6808 BOOL)))
 (let (($x3469 (has_type state! AbstractStorage&)))
 (let (($x16220 (not $x3469)))
 (let (($x1791 (has_type self! Self%&)))
 (let (($x15875 (not $x1791)))
 (let (($x17776 (or $x15875 $x16220 $x6809)))
 (let (($x3470 (and $x1791 $x3469)))
 (let (($x3479 (not $x3470)))
 (let (($x6814 (or $x3479 $x6809)))
 (let ((@x16227 (monotonicity (rewrite (= $x3470 (not (or $x15875 $x16220)))) (= $x3479 (not (not (or $x15875 $x16220)))))))
 (let ((@x16231 (trans @x16227 (rewrite (= (not (not (or $x15875 $x16220))) (or $x15875 $x16220))) (= $x3479 (or $x15875 $x16220)))))
 (trans (monotonicity @x16231 (= $x6814 (or (or $x15875 $x16220) $x6809))) (rewrite (= (or (or $x15875 $x16220) $x6809) $x17776)) (= $x6814 $x17776)))))))))))))))
 ))
 (let ((?x13654 (lambda ((Self%&. Dcr) (Self%& Type) (AbstractStorage&. Dcr) (AbstractStorage& Type) (self! Poly) (state! Poly) )(let ((?x6808 (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!)))
 (let (($x6809 (has_type ?x6808 BOOL)))
 (let (($x3469 (has_type state! AbstractStorage&)))
 (let (($x1791 (has_type self! Self%&)))
 (let (($x3470 (and $x1791 $x3469)))
 (let (($x3479 (not $x3470)))
 (let (($x6814 (or $x3479 $x6809)))
 (refl (~ $x6814 $x6814))))))))))
 ))
 (let (($x6812 (forall ((Self%&. Dcr) (Self%& Type) (AbstractStorage&. Dcr) (AbstractStorage& Type) (self! Poly) (state! Poly) )(! (let ((?x6808 (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!)))
 (let (($x6809 (has_type ?x6808 BOOL)))
 (let (($x3469 (has_type state! AbstractStorage&)))
 (let (($x1791 (has_type self! Self%&)))
 (let (($x3470 (and $x1791 $x3469)))
 (=> $x3470 $x6809)))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!) ) :qid internal_pmemlog!sccf.CheckPermission.check_permission.?_pre_post_definition))
 ))
 (let ((?x6818 (lambda ((Self%&. Dcr) (Self%& Type) (AbstractStorage&. Dcr) (AbstractStorage& Type) (self! Poly) (state! Poly) )(let ((?x6808 (pmemlog!sccf.CheckPermission.check_permission.? Self%&. Self%& AbstractStorage&. AbstractStorage& self! state!)))
 (let (($x6809 (has_type ?x6808 BOOL)))
 (let (($x3469 (has_type state! AbstractStorage&)))
 (let (($x1791 (has_type self! Self%&)))
 (let (($x3470 (and $x1791 $x3469)))
 (let (($x3479 (not $x3470)))
 (let (($x6814 (or $x3479 $x6809)))
 (let (($x6810 (=> $x3470 $x6809)))
 (rewrite (= $x6810 $x6814)))))))))))
 ))
 (let ((@x6822 (mp (asserted $x6812) (quant-intro (proof-bind ?x6818) (= $x6812 $x6817)) $x6817)))
 (let ((@x17786 (mp (mp~ @x6822 (nnf-pos (proof-bind ?x13654) (~ $x6817 $x6817)) $x6817) (quant-intro (proof-bind ?x17782) (= $x6817 $x17781)) $x17781)))
 (let (($x48649 (not $x48648)))
 (let (($x49112 (not $x47671)))
 (let (($x49117 (not $x17781)))
 (let (($x49118 (or $x49117 $x49112 $x48649 $x49113)))
 (let ((@x49123 (mp ((_ quant-inst Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ ?x1876) perm! (Poly%vstd!seq.Seq<u8.>. pm!)) (or $x49117 (or $x49112 $x48649 $x49113))) (rewrite (= (or $x49117 (or $x49112 $x48649 $x49113)) $x49118)) $x49118)))
 (let ((@x65494 (unit-resolution (unit-resolution @x49123 @x17786 @x47672 (or $x48649 $x49113)) @x56813 $x49113)))
 (let (($x256 (forall ((x Poly) )(! (let (($x247 (= x (B (%B x)))))
 (or (not (has_type x BOOL)) $x247)) :pattern ( (has_type x BOOL) ) :qid prelude_box_unbox_bool))
 ))
 (let ((?x10622 (lambda ((x Poly) )(let (($x247 (= x (B (%B x)))))
 (let (($x253 (or (not (has_type x BOOL)) $x247)))
 (refl (~ $x253 $x253)))))
 ))
 (let (($x250 (forall ((x Poly) )(! (let (($x247 (= x (B (%B x)))))
 (let (($x244 (has_type x BOOL)))
 (=> $x244 $x247))) :pattern ( (has_type x BOOL) ) :qid prelude_box_unbox_bool))
 ))
 (let ((?x257 (lambda ((x Poly) )(let (($x247 (= x (B (%B x)))))
 (let (($x253 (or (not (has_type x BOOL)) $x247)))
 (let (($x244 (has_type x BOOL)))
 (let (($x248 (=> $x244 $x247)))
 (rewrite (= $x248 $x253)))))))
 ))
 (let ((@x261 (mp (asserted $x250) (quant-intro (proof-bind ?x257) (= $x250 $x256)) $x256)))
 (let ((@x10626 (mp~ @x261 (nnf-pos (proof-bind ?x10622) (~ $x256 $x256)) $x256)))
 (let (($x55925 (not $x49113)))
 (let (($x56253 (not $x256)))
 (let (($x56254 (or $x56253 $x55925 $x55911)))
 (let ((@x56264 (mp ((_ quant-inst (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x47674)) (or $x56253 (or $x55925 $x55911))) (rewrite (= (or $x56253 (or $x55925 $x55911)) $x56254)) $x56254)))
 (let ((?x47601 (I 11756720295082287198)))
 (let ((?x62114 (vstd!bytes.spec_u64_to_le_bytes.? ?x47601)))
 (let ((?x62112 (Poly%vstd!seq.Seq<u8.>. ?x62114)))
 (let ((?x62116 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x55990 ?x7427 ?x62112)))
 (let ((?x62109 (Poly%vstd!seq.Seq<u8.>. ?x62116)))
 (let ((?x61487 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x62109)))
 (let (($x61477 (%B ?x61487)))
 (let (($x62613 (= ?x62109 ?x47937)))
 (let (($x62612 (= ?x62116 ?x47936)))
 (let ((@x68689 (monotonicity (monotonicity (trans* @x61101 @x61320 (= new_ib! 11756720295082287198)) (= ?x47924 ?x47601)) (= ?x47925 ?x62114))))
 (let ((@x68691 (monotonicity @x68689 (= ?x47935 ?x62112))))
 (let ((@x69062 (symm @x56802 (= ?x47674 ?x55990))))
 (let ((@x69141 (monotonicity (symm (monotonicity @x69062 @x68691 (= ?x47936 ?x62116)) $x62612) $x62613)))
 (let ((?x61488 (pmemlog!logimpl_v.pm_to_views.? ?x62109)))
 (let ((?x61493 (Poly%tuple%3. ?x61488)))
 (let ((?x61504 (%Poly%tuple%3. ?x61493)))
 (let ((?x61505 (tuple%3./tuple%3/0 ?x61504)))
 (let ((?x61503 (%I ?x61505)))
 (let (($x48597 (= ?x61503 11756720295082287198)))
 (let (($x48598 (not $x48597)))
 (let ((?x62118 (pmemlog!logimpl_v.spec_get_live_header.? ?x62109)))
 (let (($x62115 (= ?x62118 ?x56081)))
 (let (($x61113 (not $x62115)))
 (let (($x47536 (not $x61477)))
 (let ((?x62119 (pmemlog!logimpl_v.impl&%0.recover.? ?x62109)))
 (let ((?x62120 (Poly%core!option.Option. ?x62119)))
 (let ((?x62110 (tuple%2./tuple%2 ?x55992 ?x62120)))
 (let ((?x62122 (Poly%tuple%2. ?x62110)))
 (let ((?x62131 (%Poly%tuple%2. ?x62122)))
 (let ((?x47537 (tuple%2./tuple%2/0 ?x62131)))
 (let ((?x62132 (%Poly%core!option.Option. ?x47537)))
 (let ((?x61466 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x62132)))
 (let ((?x61467 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x61466)))
 (let ((?x61478 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x61467)))
 (let ((?x61495 (pmemlog!infinitelog_t.impl&%0.append.? ?x61478 ?x55989)))
 (let ((?x61496 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x61495)))
 (let ((?x62121 (tuple%2./tuple%2/1 ?x62131)))
 (let ((?x62117 (%Poly%core!option.Option. ?x62121)))
 (let ((?x47535 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x62117)))
 (let ((?x61153 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47535)))
 (let ((?x60549 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x61153)))
 (let (($x61489 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x60549 ?x61496)))
 (let (($x61492 (not $x61489)))
 (let (($x62134 ((_ is core!option.Option./Some ) ?x62117)))
 (let (($x62135 (not $x62134)))
 (let (($x62133 ((_ is core!option.Option./Some ) ?x62132)))
 (let (($x47538 (not $x62133)))
 (let (($x48600 (or $x47538 $x62135 $x61492 $x47536 $x61113 $x48598)))
 (let (($x64712 (not $x48600)))
 (let (($x60464 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& ?x48663 11756720295082287198 ?x48676 ?x48671 perm!)))
 (let (($x64434 (= $x48600 $x60464)))
 (let (($x64583 (not $x64434)))
 (let (($x19513 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let (($x10282 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let ((?x10152 (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!)))))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10162 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6675 ?x7427 ?x10152))))
 (let ((?x10219 (tuple%3./tuple%3/0 (%Poly%tuple%3. (Poly%tuple%3. (pmemlog!logimpl_v.pm_to_views.? ?x10162))))))
 (let (($x10303 (= new_ib! (%I ?x10219))))
 (let (($x15264 (not $x10303)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let (($x10272 (= (pmemlog!logimpl_v.spec_get_live_header.? ?x10162) ?x10052)))
 (let (($x15261 (not $x10272)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10300 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x10162)))
 (let (($x10302 (%B ?x10300)))
 (let (($x15258 (not $x10302)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x10299 (tuple%2./tuple%2 ?x10265 (Poly%core!option.Option. (pmemlog!logimpl_v.impl&%0.recover.? ?x10162)))))
 (let ((?x10290 (%Poly%tuple%2. (Poly%tuple%2. ?x10299))))
 (let ((?x10291 (%Poly%core!option.Option. (tuple%2./tuple%2/0 ?x10290))))
 (let ((?x10338 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10291)))
 (let ((?x10292 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10338))))
 (let ((?x10293 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10292 ?x6680))))
 (let ((?x10333 (%Poly%core!option.Option. (tuple%2./tuple%2/1 ?x10290))))
 (let ((?x10295 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10333)))
 (let ((?x10298 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10295))))
 (let (($x10260 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10298 ?x10293)))
 (let (($x15255 (not $x10260)))
 (let (($x10224 ((_ is core!option.Option./Some ) ?x10333)))
 (let (($x15252 (not $x10224)))
 (let (($x10319 ((_ is core!option.Option./Some ) ?x10291)))
 (let (($x15249 (not $x10319)))
 (let (($x19502 (or $x15249 $x15252 $x15255 $x15258 $x15261 $x15264)))
 (not (= $x19502 $x10282)))))))))))))))))))))))))))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let (($x10230 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let ((?x10152 (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!)))))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10162 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6675 ?x7427 ?x10152))))
 (let ((?x10219 (tuple%3./tuple%3/0 (%Poly%tuple%3. (Poly%tuple%3. (pmemlog!logimpl_v.pm_to_views.? ?x10162))))))
 (let (($x10303 (= new_ib! (%I ?x10219))))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let (($x10272 (= (pmemlog!logimpl_v.spec_get_live_header.? ?x10162) ?x10052)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10300 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x10162)))
 (let (($x10302 (%B ?x10300)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x10299 (tuple%2./tuple%2 ?x10265 (Poly%core!option.Option. (pmemlog!logimpl_v.impl&%0.recover.? ?x10162)))))
 (let ((?x10290 (%Poly%tuple%2. (Poly%tuple%2. ?x10299))))
 (let ((?x10291 (%Poly%core!option.Option. (tuple%2./tuple%2/0 ?x10290))))
 (let ((?x10338 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10291)))
 (let ((?x10292 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10338))))
 (let ((?x10293 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10292 ?x6680))))
 (let ((?x10333 (%Poly%core!option.Option. (tuple%2./tuple%2/1 ?x10290))))
 (let ((?x10295 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10333)))
 (let ((?x10298 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10295))))
 (let (($x10260 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10298 ?x10293)))
 (let (($x10224 ((_ is core!option.Option./Some ) ?x10333)))
 (let (($x10319 ((_ is core!option.Option./Some ) ?x10291)))
 (let (($x10241 (and $x10319 $x10224 $x10260 $x10302 $x10272 $x10303)))
 (let (($x10282 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (= $x10282 $x10241))))))))))))))))))))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let ((?x19514 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let (($x10282 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let ((?x10152 (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!)))))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10162 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6675 ?x7427 ?x10152))))
 (let ((?x10219 (tuple%3./tuple%3/0 (%Poly%tuple%3. (Poly%tuple%3. (pmemlog!logimpl_v.pm_to_views.? ?x10162))))))
 (let (($x10303 (= new_ib! (%I ?x10219))))
 (let (($x15264 (not $x10303)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let (($x10272 (= (pmemlog!logimpl_v.spec_get_live_header.? ?x10162) ?x10052)))
 (let (($x15261 (not $x10272)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10300 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x10162)))
 (let (($x10302 (%B ?x10300)))
 (let (($x15258 (not $x10302)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x10299 (tuple%2./tuple%2 ?x10265 (Poly%core!option.Option. (pmemlog!logimpl_v.impl&%0.recover.? ?x10162)))))
 (let ((?x10290 (%Poly%tuple%2. (Poly%tuple%2. ?x10299))))
 (let ((?x10291 (%Poly%core!option.Option. (tuple%2./tuple%2/0 ?x10290))))
 (let ((?x10338 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10291)))
 (let ((?x10292 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10338))))
 (let ((?x10293 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10292 ?x6680))))
 (let ((?x10333 (%Poly%core!option.Option. (tuple%2./tuple%2/1 ?x10290))))
 (let ((?x10295 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10333)))
 (let ((?x10298 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10295))))
 (let (($x10260 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10298 ?x10293)))
 (let (($x15255 (not $x10260)))
 (let (($x10224 ((_ is core!option.Option./Some ) ?x10333)))
 (let (($x15252 (not $x10224)))
 (let (($x10319 ((_ is core!option.Option./Some ) ?x10291)))
 (let (($x15249 (not $x10319)))
 (let (($x19502 (or $x15249 $x15252 $x15255 $x15258 $x15261 $x15264)))
 (let (($x19565 (not (= $x19502 $x10282))))
 (let (($x10241 (and $x10319 $x10224 $x10260 $x10302 $x10272 $x10303)))
 (let (($x10248 (= $x10282 $x10241)))
 (let (($x19568 (= $x10248 $x19565)))
 (let ((@x19559 (monotonicity (rewrite (= $x10241 (not $x19502))) (= $x10248 (= $x10282 (not $x19502))))))
 (trans (trans @x19559 (rewrite (= (= $x10282 (not $x19502)) $x19565)) $x19568) (rewrite (= $x19565 $x19565)) $x19568)))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((?x15058 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let ((?x10152 (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!)))))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10162 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6675 ?x7427 ?x10152))))
 (let ((?x10219 (tuple%3./tuple%3/0 (%Poly%tuple%3. (Poly%tuple%3. (pmemlog!logimpl_v.pm_to_views.? ?x10162))))))
 (let (($x10303 (= new_ib! (%I ?x10219))))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let (($x10272 (= (pmemlog!logimpl_v.spec_get_live_header.? ?x10162) ?x10052)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10300 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x10162)))
 (let (($x10302 (%B ?x10300)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x10299 (tuple%2./tuple%2 ?x10265 (Poly%core!option.Option. (pmemlog!logimpl_v.impl&%0.recover.? ?x10162)))))
 (let ((?x10290 (%Poly%tuple%2. (Poly%tuple%2. ?x10299))))
 (let ((?x10291 (%Poly%core!option.Option. (tuple%2./tuple%2/0 ?x10290))))
 (let ((?x10338 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10291)))
 (let ((?x10292 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10338))))
 (let ((?x10293 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10292 ?x6680))))
 (let ((?x10333 (%Poly%core!option.Option. (tuple%2./tuple%2/1 ?x10290))))
 (let ((?x10295 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10333)))
 (let ((?x10298 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10295))))
 (let (($x10260 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10298 ?x10293)))
 (let (($x10224 ((_ is core!option.Option./Some ) ?x10333)))
 (let (($x10319 ((_ is core!option.Option./Some ) ?x10291)))
 (let (($x10241 (and $x10319 $x10224 $x10260 $x10302 $x10272 $x10303)))
 (let (($x10282 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x10248 (= $x10282 $x10241)))
 (refl (~ $x10248 $x10248))))))))))))))))))))))))))))))))))
 ))
 (let (($x10307 (forall ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(! (let ((?x10152 (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!)))))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10162 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6675 ?x7427 ?x10152))))
 (let ((?x10219 (tuple%3./tuple%3/0 (%Poly%tuple%3. (Poly%tuple%3. (pmemlog!logimpl_v.pm_to_views.? ?x10162))))))
 (let (($x10303 (= new_ib! (%I ?x10219))))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let (($x10272 (= (pmemlog!logimpl_v.spec_get_live_header.? ?x10162) ?x10052)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10300 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x10162)))
 (let (($x10302 (%B ?x10300)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x10299 (tuple%2./tuple%2 ?x10265 (Poly%core!option.Option. (pmemlog!logimpl_v.impl&%0.recover.? ?x10162)))))
 (let ((?x10290 (%Poly%tuple%2. (Poly%tuple%2. ?x10299))))
 (let ((?x10291 (%Poly%core!option.Option. (tuple%2./tuple%2/0 ?x10290))))
 (let ((?x10338 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10291)))
 (let ((?x10292 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10338))))
 (let ((?x10293 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10292 ?x6680))))
 (let ((?x10333 (%Poly%core!option.Option. (tuple%2./tuple%2/1 ?x10290))))
 (let ((?x10295 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10333)))
 (let ((?x10298 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10295))))
 (let (($x10260 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10298 ?x10293)))
 (let (($x10337 (and (and ((_ is-tuple%2./tuple%2 tuple%2./tuple%2  is-tuple%2./tuple%2) ?x10299) ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x10291)) ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x10333))))
 (let (($x10304 (and (and (and $x10337 (and $x10260 $x10302)) $x10272) $x10303)))
 (let (($x10282 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (= $x10282 $x10304)))))))))))))))))))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed._definition))
 ))
 (let ((?x10233 (lambda ((Perm&. Dcr) (Perm& Type) (pm! vstd!seq.Seq<u8.>.) (new_ib! Int) (bytes_to_append! vstd!seq.Seq<u8.>.) (new_header_bytes! vstd!seq.Seq<u8.>.) (perm! Poly) )(let ((?x10152 (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!)))))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x6675 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10162 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6675 ?x7427 ?x10152))))
 (let ((?x10219 (tuple%3./tuple%3/0 (%Poly%tuple%3. (Poly%tuple%3. (pmemlog!logimpl_v.pm_to_views.? ?x10162))))))
 (let (($x10303 (= new_ib! (%I ?x10219))))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. new_header_bytes!)))
 (let ((?x10052 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x6683)))
 (let (($x10272 (= (pmemlog!logimpl_v.spec_get_live_header.? ?x10162) ?x10052)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x10300 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x10162)))
 (let (($x10302 (%B ?x10300)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x10027 (pmemlog!logimpl_v.impl&%0.recover.? ?x6675)))
 (let ((?x10265 (Poly%core!option.Option. ?x10027)))
 (let ((?x10299 (tuple%2./tuple%2 ?x10265 (Poly%core!option.Option. (pmemlog!logimpl_v.impl&%0.recover.? ?x10162)))))
 (let ((?x10290 (%Poly%tuple%2. (Poly%tuple%2. ?x10299))))
 (let ((?x10291 (%Poly%core!option.Option. (tuple%2./tuple%2/0 ?x10290))))
 (let ((?x10338 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10291)))
 (let ((?x10292 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10338))))
 (let ((?x10293 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (pmemlog!infinitelog_t.impl&%0.append.? ?x10292 ?x6680))))
 (let ((?x10333 (%Poly%core!option.Option. (tuple%2./tuple%2/1 ?x10290))))
 (let ((?x10295 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10333)))
 (let ((?x10298 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10295))))
 (let (($x10260 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x10298 ?x10293)))
 (let (($x10224 ((_ is core!option.Option./Some ) ?x10333)))
 (let (($x10319 ((_ is core!option.Option./Some ) ?x10291)))
 (let (($x10241 (and $x10319 $x10224 $x10260 $x10302 $x10272 $x10303)))
 (let (($x10282 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& pm! new_ib! bytes_to_append! new_header_bytes! perm!)))
 (let (($x10248 (= $x10282 $x10241)))
 (let (($x10337 (and (and ((_ is-tuple%2./tuple%2 tuple%2./tuple%2  is-tuple%2./tuple%2) ?x10299) ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x10291)) ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x10333))))
 (let (($x10304 (and (and (and $x10337 (and $x10260 $x10302)) $x10272) $x10303)))
 (let (($x10305 (= $x10282 $x10304)))
 (rewrite (= $x10305 $x10248)))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x10312 (mp (asserted $x10307) (quant-intro (proof-bind ?x10233) (= $x10307 $x10230)) $x10230)))
 (let ((@x19518 (mp (mp~ @x10312 (nnf-pos (proof-bind ?x15058) (~ $x10230 $x10230)) $x10230) (quant-intro (proof-bind ?x19514) (= $x10230 $x19513)) $x19513)))
 (let (($x64578 (not $x19513)))
 (let (($x64576 (or $x64578 $x64583)))
 (let (($x61506 (= 11756720295082287198 ?x61503)))
 (let (($x60460 (not $x61506)))
 (let (($x60463 (or $x47538 $x62135 $x61492 $x47536 $x61113 $x60460)))
 (let (($x59887 (= $x60463 $x60464)))
 (let (($x60776 (not $x59887)))
 (let (($x64579 (or $x64578 $x60776)))
 (let (($x64582 (= $x64579 $x64576)))
 (let (($x64584 (= $x60776 $x64583)))
 (let ((@x64575 (trans (monotonicity (rewrite (= $x59887 $x64434)) $x64584) (rewrite (= $x64583 $x64583)) $x64584)))
 (let ((@x64656 (mp ((_ quant-inst Perm&. Perm& (%Poly%vstd!seq.Seq<u8.>. ?x47674) 11756720295082287198 (%Poly%vstd!seq.Seq<u8.>. ?x47745) (%Poly%vstd!seq.Seq<u8.>. ?x47723) perm!) $x64579) (trans (monotonicity @x64575 $x64582) (rewrite (= $x64576 $x64576)) $x64582) $x64576)))
 (let ((@x65476 (symm (monotonicity @x56800 @x61501 @x56780 @x58471 (= $x60464 $x47922)) (= $x47922 $x60464))))
 (let (($x48160 (not $x48159)))
 (let ((@x65497 (hypothesis $x48160)))
 (let ((@x48536 (def-axiom (or $x48159 $x47922))))
 (let ((@x65559 (unit-resolution @x48536 @x65497 $x47922)))
 (let ((@x65661 (unit-resolution (def-axiom (or $x64434 $x64712 (not $x60464))) (mp @x65559 @x65476 $x60464) (unit-resolution @x64656 @x19518 $x64583) $x64712)))
 (let ((@x65669 (mp (unit-resolution (def-axiom (or $x48600 $x61477)) @x65661 $x61477) (monotonicity (monotonicity @x69141 (= ?x61487 ?x47967)) (= $x61477 $x47968)) $x47968)))
 (let ((@x65652 (trans* (iff-true @x65669 (= $x47968 true)) (symm @x48572 (= true $x47790)) (= $x47968 $x47790))))
 (let ((?x62063 (B $x47968)))
 (let (($x62064 (= ?x47967 ?x62063)))
 (let (($x62061 (has_type ?x47967 BOOL)))
 (let ((?x49698 (%%lambda%%1 $ ?x1876 ?x47674 ?x7427 ?x47935)))
 (let ((?x49714 (mk_fun ?x49698)))
 (let ((?x49730 (Poly%fun%1. ?x49714)))
 (let ((?x47675 (vstd!seq.Seq.len.? $ ?x1876 ?x47674)))
 (let ((?x49725 (I ?x47675)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x49731 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 ?x49725 ?x49730)))
 (let ((?x49732 (%Poly%vstd!seq.Seq<u8.>. ?x49731)))
 (let ((?x57826 (Poly%vstd!seq.Seq<u8.>. ?x49732)))
 (let ((?x61959 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x57826)))
 (let (($x61953 (has_type ?x61959 BOOL)))
 (let (($x49733 (= ?x47936 ?x49732)))
 (let (($x6529 (forall ((prewrite_contents! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x6525 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 (I (vstd!seq.Seq.len.? $ ?x1876 prewrite_contents!)) (Poly%fun%1. (mk_fun (%%lambda%%1 $ ?x1876 prewrite_contents! write_addr! write_bytes!))))))
 (let ((?x6519 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? prewrite_contents! write_addr! write_bytes!)))
 (= ?x6519 (%Poly%vstd!seq.Seq<u8.>. ?x6525)))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_write.? prewrite_contents! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_contents_to_reflect_write.?_definition))
 ))
 (let (($x6517 (fuel_bool fuel%pmemlog!pmemspec_t.update_contents_to_reflect_write.)))
 (let (($x6492 (fuel_bool_default fuel%pmemlog!pmemspec_t.update_contents_to_reflect_write.)))
 (let (($x49709 (= $x6517 $x6492)))
 (let ((@x49726 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.update_contents_to_reflect_write.) (or (not $x30) $x49709)) @x49237 (hypothesis (not $x49709)) false)))
 (let ((@x49739 (lemma @x49726 $x49709)))
 (let ((@x6512 (asserted $x6492)))
 (let ((@x49717 (def-axiom (or (not $x49709) $x6517 (not $x6492)))))
 (let ((@x68974 (unit-resolution (unit-resolution @x49717 @x6512 (or (not $x49709) $x6517)) @x49739 $x6517)))
 (let (($x6532 (not $x6517)))
 (let (($x6533 (or $x6532 $x6529)))
 (let ((?x13514 (lambda ((prewrite_contents! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x6525 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 (I (vstd!seq.Seq.len.? $ ?x1876 prewrite_contents!)) (Poly%fun%1. (mk_fun (%%lambda%%1 $ ?x1876 prewrite_contents! write_addr! write_bytes!))))))
 (let ((?x6519 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? prewrite_contents! write_addr! write_bytes!)))
 (let (($x6527 (= ?x6519 (%Poly%vstd!seq.Seq<u8.>. ?x6525))))
 (refl (~ $x6527 $x6527))))))))
 ))
 (let ((@x13519 (monotonicity (refl (~ $x6532 $x6532)) (nnf-pos (proof-bind ?x13514) (~ $x6529 $x6529)) (~ $x6533 $x6533))))
 (let ((@x6536 (mp (asserted (=> $x6517 $x6529)) (rewrite (= (=> $x6517 $x6529) $x6533)) $x6533)))
 (let ((@x13523 (mp (mp~ @x6536 @x13519 $x6533) (rewrite (= $x6533 $x6533)) $x6533)))
 (let (($x49736 (not $x6529)))
 (let (($x49737 (or $x49736 $x49733)))
 (let ((@x49738 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.incorruptible_bool_pos.?) (Poly%vstd!seq.Seq<u8.>. ?x47925)) $x49737)))
 (let ((@x68980 (monotonicity (unit-resolution @x49738 (unit-resolution @x13523 @x68974 $x6529) $x49733) (= ?x47937 ?x57826))))
 (let ((@x68997 (symm @x68980 (= ?x57826 ?x47937))))
 (let ((@x65684 (monotonicity @x68997 (= ?x61959 ?x47967))))
 (let ((@x65690 (symm (monotonicity (symm @x65684 (= ?x47967 ?x61959)) (= $x62061 $x61953)) (= $x61953 $x62061))))
 (let (($x61234 (has_type ?x57826 ?x1968)))
 (let (($x58110 (= ?x49731 ?x57826)))
 (let (($x49742 (has_type ?x49731 ?x1968)))
 (let (($x49740 (has_type ?x49730 ?x6520)))
 (let ((?x49744 (%Poly%fun%1. ?x49730)))
 (let ((?x58909 (mk_fun ?x49744)))
 (let ((?x58910 (Poly%fun%1. ?x58909)))
 (let (($x58911 (has_type ?x58910 ?x6520)))
 (let (($x58421 (not $x58911)))
 (let (($x49758 (= ?x49714 ?x49698)))
 (let (($x226 (forall ((x %%Function%%) )(! (let ((?x223 (mk_fun x)))
 (= ?x223 x)) :pattern ( (mk_fun x) ) :qid prelude_mk_fun))
 ))
 (let ((?x10594 (lambda ((x %%Function%%) )(refl (~ (= (mk_fun x) x) (= (mk_fun x) x))))
 ))
 (let ((@x10598 (mp~ (asserted $x226) (nnf-pos (proof-bind ?x10594) (~ $x226 $x226)) $x226)))
 (let (($x49763 (not $x226)))
 (let (($x49764 (or $x49763 $x49758)))
 (let ((@x49765 ((_ quant-inst (%%lambda%%1 $ ?x1876 ?x47674 ?x7427 ?x47935)) $x49764)))
 (let ((@x58793 (unit-resolution @x49765 @x10598 $x49758)))
 (let (($x49745 (= ?x49714 ?x49744)))
 (let (($x1726 (forall ((x %%Function%%) )(! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ( (Poly%fun%1. x) ) :qid internal_crate__fun__1_box_axiom_definition))
 ))
 (let ((?x11042 (lambda ((x %%Function%%) )(let (($x1724 (= x (%Poly%fun%1. (Poly%fun%1. x)))))
 (refl (~ $x1724 $x1724))))
 ))
 (let ((@x11046 (mp~ (asserted $x1726) (nnf-pos (proof-bind ?x11042) (~ $x1726 $x1726)) $x1726)))
 (let (($x49755 (not $x1726)))
 (let (($x49756 (or $x49755 $x49745)))
 (let ((@x49757 ((_ quant-inst (mk_fun ?x49698)) $x49756)))
 (let ((@x59105 (symm (unit-resolution @x49757 @x11046 $x49745) (= ?x49744 ?x49714))))
 (let ((@x58172 (monotonicity (monotonicity (trans* @x59105 @x58793 (= ?x49744 ?x49698)) (= ?x58909 ?x49714)) (= ?x58910 ?x49730))))
 (let ((@x58344 (monotonicity (symm (monotonicity @x58172 (= $x58911 $x49740)) (= $x49740 $x58911)) (= (not $x49740) $x58421))))
 (let ((?x58902 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x49744 ?x1876 INT)))
 (let ((?x58905 (%%apply%%0 ?x49744 ?x58902)))
 (let (($x58906 (has_type ?x58905 ?x1876)))
 (let (($x58903 (has_type ?x58902 INT)))
 (let (($x58904 (not $x58903)))
 (let (($x58907 (or $x58904 $x58906)))
 (let ((?x58913 (%I ?x58902)))
 (let ((?x58914 (I ?x58913)))
 (let (($x58949 (has_type ?x58914 INT)))
 (let (($x58929 (= ?x58902 ?x58914)))
 (let (($x58908 (not $x58907)))
 (let ((@x57722 (hypothesis $x58908)))
 (let ((@x58579 (def-axiom (or $x58907 $x58903))))
 (let ((@x57776 (unit-resolution @x58579 @x57722 $x58903)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x10629 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x10633 (mp~ @x280 (nnf-pos (proof-bind ?x10629) (~ $x275 $x275)) $x275)))
 (let (($x58118 (not $x275)))
 (let (($x58120 (or $x58118 $x58904 $x58929)))
 (let ((@x58119 (mp ((_ quant-inst (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x49744 ?x1876 INT)) (or $x58118 (or $x58904 $x58929))) (rewrite (= (or $x58118 (or $x58904 $x58929)) $x58120)) $x58120)))
 (let ((@x58360 (symm (unit-resolution @x58119 @x10633 @x57776 $x58929) (= ?x58914 ?x58902))))
 (let ((@x58160 (mp @x57776 (symm (monotonicity @x58360 (= $x58949 $x58903)) (= $x58903 $x58949)) $x58949)))
 (let ((?x58940 (vstd!seq.Seq.index.? $ ?x1876 ?x47674 ?x58902)))
 (let (($x58953 (has_type ?x58940 ?x1876)))
 (let ((@x58788 (monotonicity (monotonicity @x58360 (= (vstd!seq.Seq.index.? $ ?x1876 ?x47674 ?x58914) ?x58940)) (= (has_type (vstd!seq.Seq.index.? $ ?x1876 ?x47674 ?x58914) ?x1876) $x58953))))
 (let ((?x58984 (vstd!seq.Seq.index.? $ ?x1876 ?x47674 ?x58914)))
 (let (($x58985 (has_type ?x58984 ?x1876)))
 (let (($x16390 (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(! (let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x16361 (not $x4101)))
 (or $x16361 $x271 $x4116)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& self! i!) ) :qid internal_vstd!seq.Seq.index.?_pre_post_definition))
 ))
 (let (($x4128 (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(! (let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (or $x4124 $x4116)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& self! i!) ) :qid internal_vstd!seq.Seq.index.?_pre_post_definition))
 ))
 (let ((?x16391 (lambda ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x16361 (not $x4101)))
 (let (($x16385 (or $x16361 $x271 $x4116)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (let (($x4125 (or $x4124 $x4116)))
 (let ((@x16377 (monotonicity (rewrite (= $x4110 (not (or $x16361 $x271)))) (= $x4124 (not (not (or $x16361 $x271)))))))
 (let ((@x16381 (trans @x16377 (rewrite (= (not (not (or $x16361 $x271))) (or $x16361 $x271))) (= $x4124 (or $x16361 $x271)))))
 (trans (monotonicity @x16381 (= $x4125 (or (or $x16361 $x271) $x4116))) (rewrite (= (or (or $x16361 $x271) $x4116) $x16385)) (= $x4125 $x16385))))))))))))))))
 ))
 (let ((?x12346 (lambda ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (let (($x4125 (or $x4124 $x4116)))
 (refl (~ $x4125 $x4125)))))))))))
 ))
 (let (($x4119 (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(! (let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (=> $x4110 $x4116))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& self! i!) ) :qid internal_vstd!seq.Seq.index.?_pre_post_definition))
 ))
 (let ((?x4129 (lambda ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (let (($x4125 (or $x4124 $x4116)))
 (let (($x4117 (=> $x4110 $x4116)))
 (rewrite (= $x4117 $x4125))))))))))))
 ))
 (let ((@x4133 (mp (asserted $x4119) (quant-intro (proof-bind ?x4129) (= $x4119 $x4128)) $x4128)))
 (let ((@x16395 (mp (mp~ @x4133 (nnf-pos (proof-bind ?x12346) (~ $x4128 $x4128)) $x4128) (quant-intro (proof-bind ?x16391) (= $x4128 $x16390)) $x16390)))
 (let (($x58950 (not $x58949)))
 (let (($x57966 (not $x16390)))
 (let (($x57968 (or $x57966 $x48649 $x58950 $x58985)))
 (let ((@x57971 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x58913)) (or $x57966 (or $x48649 $x58950 $x58985))) (rewrite (= (or $x57966 (or $x48649 $x58950 $x58985)) $x57968)) $x57968)))
 (let ((@x58371 (unit-resolution (unit-resolution @x57971 @x16395 @x56813 (or $x58950 $x58985)) @x58160 $x58985)))
 (let ((?x58957 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x58914 ?x58940 ?x7131 ?x47935)))
 (let (($x58958 (uInv 8 ?x58957)))
 (let (($x59213 (not $x58958)))
 (let ((?x58941 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x58902 ?x58940 ?x7131 ?x47935)))
 (let (($x59004 (uInv 8 ?x58941)))
 (let (($x59005 (not $x59004)))
 (let ((@x59212 (symm (monotonicity (monotonicity @x58360 (= ?x58957 ?x58941)) (= $x58958 $x59004)) (= $x59004 $x58958))))
 (let ((?x58942 (I ?x58941)))
 (let (($x59013 (has_type ?x58942 ?x1876)))
 (let (($x59201 (not $x59013)))
 (let (($x7220 (= pmemlog!logimpl_v.incorruptible_bool_pos.? 0)))
 (let (($x7218 (fuel_bool fuel%pmemlog!logimpl_v.incorruptible_bool_pos.)))
 (let (($x7216 (fuel_bool_default fuel%pmemlog!logimpl_v.incorruptible_bool_pos.)))
 (let (($x50217 (= $x7218 $x7216)))
 (let ((@x50234 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.incorruptible_bool_pos.) (or (not $x30) $x50217)) @x49237 (hypothesis (not $x50217)) false)))
 (let ((@x50247 (lemma @x50234 $x50217)))
 (let ((@x7217 (asserted $x7216)))
 (let ((@x50225 (def-axiom (or (not $x50217) $x7218 (not $x7216)))))
 (let ((@x58895 (unit-resolution (unit-resolution @x50225 @x7217 (or (not $x50217) $x7218)) @x50247 $x7218)))
 (let (($x7223 (not $x7218)))
 (let (($x7224 (or $x7223 $x7220)))
 (let ((@x7227 (mp (asserted (=> $x7218 $x7220)) (rewrite (= (=> $x7218 $x7220) $x7224)) $x7224)))
 (let ((@x58896 (unit-resolution @x7227 @x58895 $x7220)))
 (let ((@x58900 (symm (monotonicity @x58896 (= ?x7427 ?x7131)) (= ?x7131 ?x7427))))
 (let ((@x59186 (symm (monotonicity @x58900 (= (%%lambda%%1 $ ?x1876 ?x47674 ?x7131 ?x47935) ?x49698)) (= ?x49698 (%%lambda%%1 $ ?x1876 ?x47674 ?x7131 ?x47935)))))
 (let ((@x59188 (trans* @x59105 @x58793 @x59186 (= ?x49744 (%%lambda%%1 $ ?x1876 ?x47674 ?x7131 ?x47935)))))
 (let ((@x59190 (monotonicity @x59188 (= ?x58905 (%%apply%%0 (%%lambda%%1 $ ?x1876 ?x47674 ?x7131 ?x47935) ?x58902)))))
 (let ((@x59194 (symm @x59190 (= (%%apply%%0 (%%lambda%%1 $ ?x1876 ?x47674 ?x7131 ?x47935) ?x58902) ?x58905))))
 (let ((?x58931 (%%lambda%%1 $ ?x1876 ?x47674 ?x7131 ?x47935)))
 (let ((?x58932 (%%apply%%0 ?x58931 ?x58902)))
 (let (($x58943 (= ?x58932 ?x58942)))
 (let (($x6500 (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Poly) (addr$ Poly) )(! (let ((?x6494 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr$ (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 addr$) %%hole%%3 %%hole%%4)))
 (let ((?x6514 (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) addr$)))
 (= ?x6514 (I ?x6494)))) :pattern ( (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) addr$) ) :qid k!5591))
 ))
 (let ((?x13505 (lambda ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Poly) (addr$ Poly) )(let ((?x6494 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr$ (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 addr$) %%hole%%3 %%hole%%4)))
 (let ((?x6514 (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) addr$)))
 (let (($x6498 (= ?x6514 (I ?x6494))))
 (refl (~ $x6498 $x6498))))))
 ))
 (let ((@x13509 (mp~ (asserted $x6500) (nnf-pos (proof-bind ?x13505) (~ $x6500 $x6500)) $x6500)))
 (let ((@x59192 (symm (unit-resolution ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I 0) (Poly%vstd!seq.Seq<u8.>. ?x47925) (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x49744 ?x1876 INT)) (or (not $x6500) $x58943)) @x13509 $x58943) (= ?x58942 ?x58932))))
 (let ((@x59200 (symm (monotonicity (trans* @x59192 @x59194 (= ?x58942 ?x58905)) (= $x59013 $x58906)) (= $x58906 $x59013))))
 (let ((@x59204 (mp (unit-resolution (def-axiom (or $x58907 (not $x58906))) @x57722 (not $x58906)) (monotonicity @x59200 (= (not $x58906) $x59201)) $x59201)))
 (let (($x59014 (or $x59005 $x59013)))
 (let (($x766 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (or $x762 $x757)))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x10776 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (refl (~ $x763 $x763)))))))))
 ))
 (let (($x760 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (=> $x648 $x757))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x767 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (let (($x758 (=> $x648 $x757)))
 (rewrite (= $x758 $x763))))))))))
 ))
 (let ((@x771 (mp (asserted $x760) (quant-intro (proof-bind ?x767) (= $x760 $x766)) $x766)))
 (let ((@x10780 (mp~ @x771 (nnf-pos (proof-bind ?x10776) (~ $x766 $x766)) $x766)))
 (let (($x58051 (not $x766)))
 (let (($x58050 (or $x58051 $x59005 $x59013)))
 (let ((@x58273 (mp ((_ quant-inst 8 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x58902 ?x58940 ?x7131 ?x47935)) (or $x58051 $x59014)) (rewrite (= (or $x58051 $x59014) $x58050)) $x58050)))
 (let ((@x59216 (mp (unit-resolution (unit-resolution @x58273 @x10780 $x59014) @x59204 $x59005) (monotonicity @x59212 (= $x59005 $x59213)) $x59213)))
 (let (($x58955 (has_type ?x47935 ?x1968)))
 (let ((?x48684 (%Poly%vstd!seq.Seq<u8.>. ?x47935)))
 (let ((?x59165 (Poly%vstd!seq.Seq<u8.>. ?x48684)))
 (let (($x59166 (has_type ?x59165 ?x1968)))
 (let (($x59179 (not $x59166)))
 (let (($x48685 (= ?x47925 ?x48684)))
 (let (($x48690 (or $x48673 $x48685)))
 (let ((@x48691 ((_ quant-inst (vstd!bytes.spec_u64_to_le_bytes.? ?x47924)) $x48690)))
 (let ((@x59172 (symm (unit-resolution @x48691 @x11202 $x48685) (= ?x48684 ?x47925))))
 (let ((@x59174 (monotonicity @x59172 (= ?x59165 ?x47935))))
 (let ((@x59181 (monotonicity (symm (monotonicity @x59174 (= $x59166 $x58955)) (= $x58955 $x59166)) (= (not $x58955) $x59179))))
 (let ((@x59184 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47935)) (or (not $x1989) $x59166)) @x11216 $x59166) (mp (hypothesis (not $x58955)) @x59181 $x59179) false)))
 (let ((@x59185 (lemma @x59184 $x58955)))
 (let (($x50967 (has_type ?x7131 INT)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x10748 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x10752 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x10748) (~ $x698 $x698)) $x698)))
 (let ((@x58674 (unit-resolution ((_ quant-inst 0) (or (not $x698) $x50967)) @x10752 (hypothesis (not $x50967)) false)))
 (let ((@x58677 (lemma @x58674 $x50967)))
 (let (($x17596 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x16463 (not $x4257)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x17575 (not $x6464)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x16729 (not $x4789)))
 (or $x16729 $x17575 $x16463 $x1977 $x6466))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_pre_post_definition))
 ))
 (let (($x6474 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (or $x6470 $x6466))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_pre_post_definition))
 ))
 (let ((?x17597 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x16463 (not $x4257)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x17575 (not $x6464)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x16729 (not $x4789)))
 (let (($x17591 (or $x16729 $x17575 $x16463 $x1977 $x6466)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (let (($x6471 (or $x6470 $x6466)))
 (let ((@x17585 (rewrite (= (not (not (or $x16729 $x17575 $x16463 $x1977))) (or $x16729 $x17575 $x16463 $x1977)))))
 (let ((@x17583 (monotonicity (rewrite (= $x6465 (not (or $x16729 $x17575 $x16463 $x1977)))) (= $x6470 (not (not (or $x16729 $x17575 $x16463 $x1977)))))))
 (let ((@x17590 (monotonicity (trans @x17583 @x17585 (= $x6470 (or $x16729 $x17575 $x16463 $x1977))) (= $x6471 (or (or $x16729 $x17575 $x16463 $x1977) $x6466)))))
 (trans @x17590 (rewrite (= (or (or $x16729 $x17575 $x16463 $x1977) $x6466) $x17591)) (= $x6471 $x17591))))))))))))))))))))))
 ))
 (let ((?x13491 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (let (($x6471 (or $x6470 $x6466)))
 (refl (~ $x6471 $x6471))))))))))))))
 ))
 (let (($x6468 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (=> $x6465 $x6466)))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_pre_post_definition))
 ))
 (let ((?x6475 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (let (($x6471 (or $x6470 $x6466)))
 (let (($x6467 (=> $x6465 $x6466)))
 (rewrite (= $x6467 $x6471)))))))))))))))
 ))
 (let ((@x6479 (mp (asserted $x6468) (quant-intro (proof-bind ?x6475) (= $x6468 $x6474)) $x6474)))
 (let ((@x17601 (mp (mp~ @x6479 (nnf-pos (proof-bind ?x13491) (~ $x6474 $x6474)) $x6474) (quant-intro (proof-bind ?x17597) (= $x6474 $x17596)) $x17596)))
 (let (($x58956 (not $x58955)))
 (let (($x50968 (not $x50967)))
 (let (($x58954 (not $x58953)))
 (let (($x57786 (not $x17596)))
 (let (($x57798 (or $x57786 $x58950 $x58954 $x50968 $x58956 $x58958)))
 (let ((@x58113 (mp ((_ quant-inst (I ?x58913) (vstd!seq.Seq.index.? $ ?x1876 ?x47674 ?x58902) (I 0) (Poly%vstd!seq.Seq<u8.>. ?x47925)) (or $x57786 (or $x58950 $x58954 $x50968 $x58956 $x58958))) (rewrite (= (or $x57786 (or $x58950 $x58954 $x50968 $x58956 $x58958)) $x57798)) $x57798)))
 (let ((@x59219 (unit-resolution (unit-resolution @x58113 @x17601 @x58677 @x59185 (or $x58950 $x58954 $x58958)) @x59216 (mp @x58371 @x58788 $x58953) @x58160 false)))
 (let ((@x59220 (lemma @x59219 $x58907)))
 (let (($x11068 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(! (let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let ((?x11054 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 x T%1& T%0&)))
 (let (($x11060 (not (or (not (has_type ?x11054 T%0&)) (has_type (%%apply%%0 x ?x11054) T%1&)))))
 (or $x11060 $x1758))))))) :pattern ( (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) ) :qid internal_crate__fun__1_constructor_definition))
 ))
 (let (($x1781 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(! (let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let (($x1767 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (or (not (has_type T%0 T%0&)) $x1753)) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1775 (not $x1767)))
 (or $x1775 $x1758))))))) :pattern ( (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) ) :qid internal_crate__fun__1_constructor_definition))
 ))
 (let ((?x11069 (lambda ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let ((?x11054 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 x T%1& T%0&)))
 (let (($x11060 (not (or (not (has_type ?x11054 T%0&)) (has_type (%%apply%%0 x ?x11054) T%1&)))))
 (let (($x11065 (or $x11060 $x1758)))
 (let (($x1767 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (or (not (has_type T%0 T%0&)) $x1753)) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1775 (not $x1767)))
 (let (($x1776 (or $x1775 $x1758)))
 (monotonicity (sk (~ $x1775 $x11060)) (refl (~ $x1758 $x1758)) (~ $x1776 $x11065)))))))))))))
 ))
 (let (($x1761 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(! (let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let (($x1756 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (let (($x1750 (has_type T%0 T%0&)))
 (=> $x1750 $x1753))) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (=> $x1756 $x1758)))))) :pattern ( (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) ) :qid internal_crate__fun__1_constructor_definition))
 ))
 (let ((?x1782 (lambda ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let (($x1767 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (or (not (has_type T%0 T%0&)) $x1753)) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1775 (not $x1767)))
 (let (($x1776 (or $x1775 $x1758)))
 (let (($x1756 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (let (($x1750 (has_type T%0 T%0&)))
 (=> $x1750 $x1753))) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1759 (=> $x1756 $x1758)))
 (let ((?x1768 (lambda ((T%0 Poly) )(let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (let (($x1764 (or (not (has_type T%0 T%0&)) $x1753)))
 (let (($x1750 (has_type T%0 T%0&)))
 (let (($x1754 (=> $x1750 $x1753)))
 (rewrite (= $x1754 $x1764)))))))
 ))
 (let ((@x1774 (monotonicity (quant-intro (proof-bind ?x1768) (= $x1756 $x1767)) (= $x1759 (=> $x1767 $x1758)))))
 (trans @x1774 (rewrite (= (=> $x1767 $x1758) $x1776)) (= $x1759 $x1776))))))))))))))
 ))
 (let ((@x1786 (mp (asserted $x1761) (quant-intro (proof-bind ?x1782) (= $x1761 $x1781)) $x1781)))
 (let ((@x11073 (mp~ @x1786 (nnf-pos (proof-bind ?x11069) (~ $x1781 $x11068)) $x11068)))
 (let (($x58729 (not $x11068)))
 (let (($x58688 (or $x58729 $x58908 $x58911)))
 (let ((@x58733 (mp ((_ quant-inst $ INT $ (UINT 8) (%Poly%fun%1. ?x49730)) (or $x58729 (or $x58908 $x58911))) (rewrite (= (or $x58729 (or $x58908 $x58911)) $x58688)) $x58688)))
 (let ((@x58924 (unit-resolution (unit-resolution @x58733 @x11073 @x59220 $x58911) (mp (hypothesis (not $x49740)) @x58344 $x58421) false)))
 (let ((@x58925 (lemma @x58924 $x49740)))
 (let (($x49734 (has_type ?x49725 NAT)))
 (let ((?x49753 (%I ?x49725)))
 (let (($x49754 (= ?x47675 ?x49753)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x10608 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x10612 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x10608) (~ $x237 $x237)) $x237)))
 (let (($x48740 (not $x237)))
 (let (($x49760 (or $x48740 $x49754)))
 (let ((@x49761 ((_ quant-inst (vstd!seq.Seq.len.? $ ?x1876 ?x47674)) $x49760)))
 (let ((@x58813 (unit-resolution @x49761 @x10612 $x49754)))
 (let ((@x60441 (monotonicity (symm @x58813 (= ?x49753 ?x47675)) (= (I ?x49753) ?x49725))))
 (let ((?x58796 (I ?x49753)))
 (let (($x58797 (has_type ?x58796 NAT)))
 (let ((?x58799 (* (- 1) ?x49753)))
 (let ((?x58800 (+ ?x47675 ?x58799)))
 (let (($x58808 (<= ?x58800 0)))
 (let ((@x58814 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49754) $x58808)) @x58813 $x58808)))
 (let ((?x7409 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_log_size_offset.?)))
 (let ((?x7410 (uClip 64 ?x7409)))
 (let ((?x50495 (* (- 1) ?x7410)))
 (let ((?x50535 (+ ?x7409 ?x50495)))
 (let (($x50536 (<= ?x50535 0)))
 (let (($x50484 (= ?x7409 ?x7410)))
 (let ((?x50508 (* (- 1) ?x7409)))
 (let ((?x441 (uHi 64)))
 (let ((?x50509 (+ ?x441 ?x50508)))
 (let (($x50510 (<= ?x50509 0)))
 (let (($x50480 (>= ?x7409 0)))
 (let (($x50481 (not $x50480)))
 (let (($x50515 (or $x50481 $x50510 $x50484)))
 (let (($x50521 (not $x50515)))
 (let ((?x50496 (+ ?x441 ?x50495)))
 (let (($x50497 (<= ?x50496 0)))
 (let (($x50476 (>= ?x7410 0)))
 (let (($x50477 (not $x50476)))
 (let (($x50523 (or $x50477 $x50497 $x50521)))
 (let (($x50530 (not $x50523)))
 (let (($x15339 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x15323 (or $x540 $x578 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (not (or (not (>= ?x543 0)) $x564 (not $x15323)))))))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let (($x586 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (and $x558 $x569 $x587)))))))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let ((?x15340 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x15323 (or $x540 $x578 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x15334 (not (or (not (>= ?x543 0)) $x564 (not $x15323)))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (let ((@x15312 (rewrite (= $x584 (not (or $x540 $x578))))))
 (let ((@x15319 (trans (monotonicity @x15312 (= $x581 (not (not (or $x540 $x578))))) (rewrite (= (not (not (or $x540 $x578))) (or $x540 $x578))) (= $x581 (or $x540 $x578)))))
 (let ((@x15327 (trans (monotonicity @x15319 (= $x587 (or (or $x540 $x578) $x550))) (rewrite (= (or (or $x540 $x578) $x550) $x15323)) (= $x587 $x15323))))
 (trans (monotonicity @x15327 (= $x593 (and $x558 $x569 $x15323))) (rewrite (= (and $x558 $x569 $x15323) $x15334)) (= $x593 $x15334))))))))))))))))))))
 ))
 (let ((?x10706 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (refl (~ $x593 $x593)))))))))))))
 ))
 (let (($x554 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (and (<= 0 ?x543) (< ?x543 (uHi bits)) (=> $x548 $x550)))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let ((?x588 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (let (($x552 (and (<= 0 ?x543) (< ?x543 (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) $x550))))
 (rewrite (= $x552 $x593))))))))))))))
 ))
 (let ((@x571 (mp (asserted $x554) (quant-intro (proof-bind ?x588) (= $x554 $x586)) $x586)))
 (let ((@x15344 (mp (mp~ @x571 (nnf-pos (proof-bind ?x10706) (~ $x586 $x586)) $x586) (quant-intro (proof-bind ?x15340) (= $x586 $x15339)) $x15339)))
 (let (($x50440 (not $x15339)))
 (let (($x50522 (or $x50440 $x50530)))
 (let (($x50487 (or $x50477 (>= (+ ?x7410 (* (- 1) ?x441)) 0) (not (or $x50481 (>= (+ ?x7409 (* (- 1) ?x441)) 0) $x50484)))))
 (let (($x50488 (not $x50487)))
 (let (($x50524 (or $x50440 $x50488)))
 (let (($x50526 (= $x50524 $x50522)))
 (let ((@x50532 (trans (monotonicity (rewrite (= $x50488 $x50530)) $x50526) (rewrite (= $x50522 $x50522)) $x50526)))
 (let ((@x50534 (mp ((_ quant-inst 64 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_log_size_offset.?)) $x50524) @x50532 $x50522)))
 (let ((@x58849 (unit-resolution @x50534 @x15344 $x50530)))
 (let ((@x50554 (def-axiom (or $x50523 $x50515))))
 (let (($x50603 (>= ?x7409 64)))
 (let (($x50601 (= ?x7409 64)))
 (let ((?x50574 (Add 40 24)))
 (let (($x50585 (= ?x50574 64)))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x10846 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x10850 (mp~ @x925 (nnf-pos (proof-bind ?x10846) (~ $x920 $x920)) $x920)))
 (let (($x48769 (not $x920)))
 (let (($x50589 (or $x48769 $x50585)))
 (let ((?x50575 (* (- 1) ?x50574)))
 (let ((?x50576 (+ 24 40 ?x50575)))
 (let (($x50577 (= ?x50576 0)))
 (let (($x50590 (or $x48769 $x50577)))
 (let (($x50592 (= $x50590 $x50589)))
 (let ((@x50583 (monotonicity (rewrite (= ?x50576 (+ 64 ?x50575))) (= $x50577 (= (+ 64 ?x50575) 0)))))
 (let ((@x50588 (trans @x50583 (rewrite (= (= (+ 64 ?x50575) 0) $x50585)) (= $x50577 $x50585))))
 (let ((@x50597 (mp ((_ quant-inst 40 24) $x50590) (trans (monotonicity @x50588 $x50592) (rewrite (= $x50589 $x50589)) $x50592) $x50589)))
 (let (($x7306 (= pmemlog!logimpl_v.header_log_size_offset.? 24)))
 (let (($x7303 (fuel_bool fuel%pmemlog!logimpl_v.header_log_size_offset.)))
 (let (($x7301 (fuel_bool_default fuel%pmemlog!logimpl_v.header_log_size_offset.)))
 (let (($x50310 (= $x7303 $x7301)))
 (let ((@x50340 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_log_size_offset.) (or (not $x30) $x50310)) @x49237 (hypothesis (not $x50310)) false)))
 (let ((@x50353 (lemma @x50340 $x50310)))
 (let ((@x7302 (asserted $x7301)))
 (let ((@x50331 (def-axiom (or (not $x50310) $x7303 (not $x7301)))))
 (let ((@x58827 (unit-resolution (unit-resolution @x50331 @x7302 (or (not $x50310) $x7303)) @x50353 $x7303)))
 (let (($x7309 (not $x7303)))
 (let (($x7310 (or $x7309 $x7306)))
 (let ((@x7313 (mp (asserted (=> $x7303 $x7306)) (rewrite (= (=> $x7303 $x7306) $x7310)) $x7310)))
 (let ((@x58828 (unit-resolution @x7313 @x58827 $x7306)))
 (let (($x7249 (= pmemlog!logimpl_v.header2_pos.? 40)))
 (let (($x7246 (fuel_bool fuel%pmemlog!logimpl_v.header2_pos.)))
 (let (($x7244 (fuel_bool_default fuel%pmemlog!logimpl_v.header2_pos.)))
 (let (($x50239 (= $x7246 $x7244)))
 (let ((@x50269 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header2_pos.) (or (not $x30) $x50239)) @x49237 (hypothesis (not $x50239)) false)))
 (let ((@x50282 (lemma @x50269 $x50239)))
 (let ((@x7245 (asserted $x7244)))
 (let ((@x50260 (def-axiom (or (not $x50239) $x7246 (not $x7244)))))
 (let ((@x58831 (unit-resolution (unit-resolution @x50260 @x7245 (or (not $x50239) $x7246)) @x50282 $x7246)))
 (let (($x7252 (not $x7246)))
 (let (($x7253 (or $x7252 $x7249)))
 (let ((@x7256 (mp (asserted (=> $x7246 $x7249)) (rewrite (= (=> $x7246 $x7249) $x7253)) $x7253)))
 (let ((@x58832 (unit-resolution @x7256 @x58831 $x7249)))
 (let ((@x58835 (trans* (monotonicity @x58832 @x58828 (= ?x7409 ?x50574)) (unit-resolution @x50597 @x10850 $x50585) $x50601)))
 (let ((@x58847 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50601) $x50603)) @x58835 $x50603)))
 (let ((@x58848 (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x50603) $x50480)) @x58847 $x50480)))
 (let (($x50540 (not $x50510)))
 (let (($x47656 (>= ?x441 18446744073709551616)))
 (let (($x443 (= ?x441 18446744073709551616)))
 (let ((@x444 (asserted $x443)))
 (let ((@x58840 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x443) $x47656)) @x444 $x47656)))
 (let (($x50602 (<= ?x7409 64)))
 (let ((@x58836 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50601) $x50602)) @x58835 $x50602)))
 (let ((@x58841 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x50540 (not $x47656) (not $x50602))) @x58836 @x58840 $x50540)))
 (let ((@x50547 (def-axiom (or $x50521 $x50481 $x50510 $x50484))))
 (let ((@x58851 (unit-resolution @x50547 @x58841 @x58848 (unit-resolution @x50554 @x58849 $x50515) $x50484)))
 (let ((@x58852 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50484) $x50536)) @x58851 $x50536)))
 (let ((?x7411 (Add ?x7410 8)))
 (let ((?x50426 (* (- 1) ?x7411)))
 (let ((?x50559 (+ ?x7410 ?x50426)))
 (let (($x50572 (<= ?x50559 (- 8))))
 (let (($x50560 (= ?x50559 (- 8))))
 (let (($x50563 (or $x48769 $x50560)))
 (let (($x50558 (= (+ 8 ?x7410 ?x50426) 0)))
 (let (($x50564 (or $x48769 $x50558)))
 (let (($x50566 (= $x50564 $x50563)))
 (let ((@x50570 (trans (monotonicity (rewrite (= $x50558 $x50560)) $x50566) (rewrite (= $x50563 $x50563)) $x50566)))
 (let ((@x50571 (mp ((_ quant-inst (uClip 64 ?x7409) 8) $x50564) @x50570 $x50563)))
 (let ((@x58856 (unit-resolution @x50571 @x10850 $x50560)))
 (let ((@x58857 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50560) $x50572)) @x58856 $x50572)))
 (let ((?x7412 (uClip 64 ?x7411)))
 (let ((?x50413 (* (- 1) ?x7412)))
 (let ((?x50454 (+ ?x7411 ?x50413)))
 (let (($x50455 (<= ?x50454 0)))
 (let (($x50401 (= ?x7411 ?x7412)))
 (let ((?x50427 (+ ?x441 ?x50426)))
 (let (($x50428 (<= ?x50427 0)))
 (let (($x50397 (>= ?x7411 0)))
 (let (($x50398 (not $x50397)))
 (let (($x50433 (or $x50398 $x50428 $x50401)))
 (let (($x50439 (not $x50433)))
 (let ((?x50414 (+ ?x441 ?x50413)))
 (let (($x50415 (<= ?x50414 0)))
 (let (($x50391 (>= ?x7412 0)))
 (let (($x50364 (not $x50391)))
 (let (($x50441 (or $x50364 $x50415 $x50439)))
 (let (($x50448 (not $x50441)))
 (let (($x50442 (or $x50440 $x50448)))
 (let (($x50404 (or $x50364 (>= (+ ?x7412 (* (- 1) ?x441)) 0) (not (or $x50398 (>= (+ ?x7411 (* (- 1) ?x441)) 0) $x50401)))))
 (let (($x50406 (not $x50404)))
 (let (($x50443 (or $x50440 $x50406)))
 (let (($x50445 (= $x50443 $x50442)))
 (let ((@x50452 (trans (monotonicity (rewrite (= $x50406 $x50448)) $x50445) (rewrite (= $x50442 $x50442)) $x50445)))
 (let ((@x50453 (mp ((_ quant-inst 64 (Add ?x7410 8)) $x50443) @x50452 $x50442)))
 (let ((@x50473 (def-axiom (or $x50441 $x50433))))
 (let ((@x58875 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x50397 $x50477 (not $x50572))) (unit-resolution (def-axiom (or $x50523 $x50476)) @x58849 $x50476) @x58857 $x50397)))
 (let (($x50459 (not $x50428)))
 (let (($x50573 (>= ?x50559 (- 8))))
 (let ((@x58869 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50560) $x50573)) @x58856 $x50573)))
 (let (($x50537 (>= ?x50535 0)))
 (let ((@x58866 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50484) $x50537)) @x58851 $x50537)))
 (let ((@x58870 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1) (or $x50459 (not $x47656) (not $x50573) (not $x50602) (not $x50537))) @x58866 @x58840 @x58869 @x58836 $x50459)))
 (let ((@x50466 (def-axiom (or $x50439 $x50398 $x50428 $x50401))))
 (let ((@x58878 (unit-resolution @x50466 @x58870 @x58875 (unit-resolution @x50473 (unit-resolution @x50453 @x15344 $x50448) $x50433) $x50401)))
 (let ((@x58879 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50401) $x50455)) @x58878 $x50455)))
 (let ((?x50598 (+ pmemlog!logimpl_v.contents_offset.? ?x50413)))
 (let (($x50600 (>= ?x50598 0)))
 (let (($x7413 (= pmemlog!logimpl_v.contents_offset.? ?x7412)))
 (let (($x7407 (fuel_bool fuel%pmemlog!logimpl_v.contents_offset.)))
 (let (($x7405 (fuel_bool_default fuel%pmemlog!logimpl_v.contents_offset.)))
 (let (($x50375 (= $x7407 $x7405)))
 (let ((@x50392 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.contents_offset.) (or (not $x30) $x50375)) @x49237 (hypothesis (not $x50375)) false)))
 (let ((@x50405 (lemma @x50392 $x50375)))
 (let ((@x7406 (asserted $x7405)))
 (let ((@x50383 (def-axiom (or (not $x50375) $x7407 (not $x7405)))))
 (let ((@x58885 (unit-resolution (unit-resolution @x50383 @x7406 (or (not $x50375) $x7407)) @x50405 $x7407)))
 (let (($x7416 (not $x7407)))
 (let (($x7417 (or $x7416 $x7413)))
 (let ((@x7420 (mp (asserted (=> $x7407 $x7413)) (rewrite (= (=> $x7407 $x7413) $x7417)) $x7417)))
 (let ((@x58886 (unit-resolution @x7420 @x58885 $x7413)))
 (let ((@x58887 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7413) $x50600)) @x58886 $x50600)))
 (let ((?x47683 (* (- 1) ?x47675)))
 (let ((?x47684 (+ pmemlog!logimpl_v.contents_offset.? ?x47683)))
 (let (($x47682 (>= ?x47684 0)))
 (let (($x47687 (not $x47682)))
 (let (($x47679 (not (<= ?x47675 pmemlog!logimpl_v.contents_offset.?))))
 (let (($x47676 (> ?x47675 pmemlog!logimpl_v.contents_offset.?)))
 (let ((@x47686 (trans (rewrite (= $x47676 $x47679)) (rewrite (= $x47679 $x47687)) (= $x47676 $x47687))))
 (let ((@x47689 (mp (asserted $x47676) @x47686 $x47687)))
 (let (($x58794 (>= ?x49753 0)))
 (let (($x58795 (not $x58794)))
 (let (($x58798 (or $x58795 $x58797)))
 (let (($x719 (forall ((x Int) )(! (let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x536 (>= x 0)))
 (let (($x540 (not $x536)))
 (or $x540 $x704))))) :pattern ( (has_type (I x) NAT) ) :qid prelude_has_type_nat))
 ))
 (let ((?x10755 (lambda ((x Int) )(let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x536 (>= x 0)))
 (let (($x540 (not $x536)))
 (let (($x714 (or $x540 $x704)))
 (refl (~ $x714 $x714))))))))
 ))
 (let (($x707 (forall ((x Int) )(! (let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x524 (<= 0 x)))
 (=> $x524 $x704)))) :pattern ( (has_type (I x) NAT) ) :qid prelude_has_type_nat))
 ))
 (let ((?x720 (lambda ((x Int) )(let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x536 (>= x 0)))
 (let (($x540 (not $x536)))
 (let (($x714 (or $x540 $x704)))
 (let (($x524 (<= 0 x)))
 (let (($x705 (=> $x524 $x704)))
 (trans (monotonicity (rewrite (= $x524 $x536)) (= $x705 (=> $x536 $x704))) (rewrite (= (=> $x536 $x704) $x714)) (= $x705 $x714))))))))))
 ))
 (let ((@x724 (mp (asserted $x707) (quant-intro (proof-bind ?x720) (= $x707 $x719)) $x719)))
 (let ((@x10759 (mp~ @x724 (nnf-pos (proof-bind ?x10755) (~ $x719 $x719)) $x719)))
 (let (($x58801 (not $x719)))
 (let (($x58802 (or $x58801 $x58795 $x58797)))
 (let ((@x58807 (mp ((_ quant-inst (%I ?x49725)) (or $x58801 $x58798)) (rewrite (= (or $x58801 $x58798) $x58802)) $x58802)))
 (let ((@x58891 (unit-resolution (unit-resolution @x58807 @x10759 $x58798) (hypothesis (not $x58797)) $x58795)))
 (let ((@x58893 (lemma ((_ th-lemma arith farkas 1 1 1 1 1 1 1 1) @x58891 @x47689 @x58887 @x58879 @x58857 @x58848 @x58852 @x58814 false) $x58797)))
 (let ((@x68965 (mp @x58893 (monotonicity @x60441 (= $x58797 $x49734)) $x49734)))
 (let (($x49741 (not $x49740)))
 (let (($x49735 (not $x49734)))
 (let (($x49743 (or $x49735 $x49741 $x49742)))
 (let (($x16538 (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(! (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x16220 (not $x3469)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x16518 (not $x4399)))
 (or $x16518 $x16220 $x4403)))))))) :pattern ( (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) ) :qid internal_vstd!seq.Seq.new.?_pre_post_definition))
 ))
 (let (($x4412 (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(! (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (or $x4408 $x4403)))))))) :pattern ( (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) ) :qid internal_vstd!seq.Seq.new.?_pre_post_definition))
 ))
 (let ((?x16539 (lambda ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x16220 (not $x3469)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x16518 (not $x4399)))
 (let (($x16533 (or $x16518 $x16220 $x4403)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (let (($x4409 (or $x4408 $x4403)))
 (let ((@x16525 (monotonicity (rewrite (= $x4400 (not (or $x16518 $x16220)))) (= $x4408 (not (not (or $x16518 $x16220)))))))
 (let ((@x16529 (trans @x16525 (rewrite (= (not (not (or $x16518 $x16220))) (or $x16518 $x16220))) (= $x4408 (or $x16518 $x16220)))))
 (trans (monotonicity @x16529 (= $x4409 (or (or $x16518 $x16220) $x4403))) (rewrite (= (or (or $x16518 $x16220) $x4403) $x16533)) (= $x4409 $x16533))))))))))))))))
 ))
 (let ((?x12444 (lambda ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (let (($x4409 (or $x4408 $x4403)))
 (refl (~ $x4409 $x4409)))))))))))
 ))
 (let (($x4406 (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(! (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (=> $x4400 $x4403))))))) :pattern ( (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) ) :qid internal_vstd!seq.Seq.new.?_pre_post_definition))
 ))
 (let ((?x4413 (lambda ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (let (($x4409 (or $x4408 $x4403)))
 (let (($x4404 (=> $x4400 $x4403)))
 (rewrite (= $x4404 $x4409))))))))))))
 ))
 (let ((@x4417 (mp (asserted $x4406) (quant-intro (proof-bind ?x4413) (= $x4406 $x4412)) $x4412)))
 (let ((@x16543 (mp (mp~ @x4417 (nnf-pos (proof-bind ?x12444) (~ $x4412 $x4412)) $x4412) (quant-intro (proof-bind ?x16539) (= $x4412 $x16538)) $x16538)))
 (let (($x49746 (not $x16538)))
 (let (($x49747 (or $x49746 $x49735 $x49741 $x49742)))
 (let ((@x49752 (mp ((_ quant-inst $ (UINT 8) $ (TYPE%fun%1. $ INT $ ?x1876) (I ?x47675) (Poly%fun%1. ?x49714)) (or $x49746 $x49743)) (rewrite (= (or $x49746 $x49743) $x49747)) $x49747)))
 (let ((@x68970 (unit-resolution (unit-resolution (unit-resolution @x49752 @x16543 $x49743) @x68965 (or $x49741 $x49742)) @x58925 $x49742)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x11205 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x11209 (mp~ @x1986 (nnf-pos (proof-bind ?x11205) (~ $x1981 $x1981)) $x1981)))
 (let (($x58005 (not $x49742)))
 (let (($x57707 (not $x1981)))
 (let (($x58103 (or $x57707 $x58005 $x58110)))
 (let ((@x58030 (mp ((_ quant-inst (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 ?x49725 ?x49730)) (or $x57707 (or $x58005 $x58110))) (rewrite (= (or $x57707 (or $x58005 $x58110)) $x58103)) $x58103)))
 (let ((@x68982 (symm (unit-resolution @x58030 @x11209 @x68970 $x58110) (= ?x57826 ?x49731))))
 (let ((@x65677 (mp @x68970 (symm (monotonicity @x68982 (= $x61234 $x49742)) (= $x49742 $x61234)) $x61234)))
 (let (($x61235 (not $x61234)))
 (let (($x64925 (or $x49117 $x49112 $x61235 $x61953)))
 (let ((@x64945 (mp ((_ quant-inst Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ ?x1876) perm! (Poly%vstd!seq.Seq<u8.>. ?x49732)) (or $x49117 (or $x49112 $x61235 $x61953))) (rewrite (= (or $x49117 (or $x49112 $x61235 $x61953)) $x64925)) $x64925)))
 (let ((@x65678 (unit-resolution (unit-resolution @x64945 @x17786 @x47672 (or $x61235 $x61953)) @x65677 $x61953)))
 (let (($x62062 (not $x62061)))
 (let (($x62066 (or $x62062 $x62064)))
 (let (($x65583 (or $x56253 $x62062 $x62064)))
 (let ((@x65833 (mp ((_ quant-inst (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x47937)) (or $x56253 $x62066)) (rewrite (= (or $x56253 $x62066) $x65583)) $x65583)))
 (let ((@x65680 (unit-resolution (unit-resolution @x65833 @x10626 $x62066) (mp @x65678 @x65690 $x62061) $x62064)))
 (let ((?x64784 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x63187)))
 (let (($x64890 (= ?x64784 ?x61959)))
 (let (($x64838 (= ?x61959 ?x64784)))
 (let (($x63188 (has_type ?x63187 ?x1968)))
 (let (($x62558 (has_type ?x47999 ?x1968)))
 (let (($x63199 (= $x62558 $x63188)))
 (let (($x63197 (= $x63188 $x62558)))
 (let (($x63195 (= ?x63187 ?x47999)))
 (let (($x62750 (= ?x47999 ?x63187)))
 (let (($x63201 (not $x63188)))
 (let (($x47487 (= ?x47998 ?x47486)))
 (let (($x47491 (or $x48673 $x47487)))
 (let ((@x61668 ((_ quant-inst (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47674 ?x7427 ?x47935 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28)) $x47491)))
 (let ((@x63190 (unit-resolution @x61668 @x11202 $x47487)))
 (let ((@x63200 (symm (monotonicity (monotonicity (symm @x63190 (= ?x47486 ?x47998)) $x63195) $x63197) $x63199)))
 (let ((@x63204 (mp (hypothesis (not $x62558)) (monotonicity @x63200 (= (not $x62558) $x63201)) $x63201)))
 (let ((@x63206 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47999)) (or (not $x1989) $x63188)) @x11216 $x63188) @x63204 false)))
 (let ((@x63207 (lemma @x63206 $x62558)))
 (let (($x62563 (not $x62558)))
 (let (($x62807 (or $x57707 $x62563 $x62750)))
 (let ((@x62808 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x47998)) (or $x57707 (or $x62563 $x62750))) (rewrite (= (or $x57707 (or $x62563 $x62750)) $x62807)) $x62807)))
 (let ((@x65665 (unit-resolution @x62808 @x11209 @x63207 $x62750)))
 (let ((@x65630 (mp @x63207 (symm (monotonicity (symm @x65665 $x63195) $x63197) $x63199) $x63188)))
 (let ((?x7768 (pmemlog!main_t.recovery_view.? ?x7131)))
 (let ((?x64787 (%%apply%%0 ?x7768 ?x63187)))
 (let ((?x61933 (%%apply%%0 ?x7768 ?x57826)))
 (let (($x64830 (= ?x61933 ?x64787)))
 (let (($x69145 (= ?x63187 ?x57826)))
 (let ((?x47546 (%Poly%vstd!set.Set<int.>. chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28)))
 (let ((?x47547 (Poly%vstd!set.Set<int.>. ?x47546)))
 (let (($x47479 (= chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28 ?x47547)))
 (let ((@x65711 (rewrite (= (= $x48021 true) $x48021))))
 (let (($x65705 (= $x48021 true)))
 (let ((@x65648 (iff-true (unit-resolution (def-axiom (or $x48600 $x62134)) @x65661 $x62134) (= $x62134 true))))
 (let ((?x60872 (tuple%2./tuple%2/?1 ?x62110)))
 (let (($x60731 (= ?x60872 ?x62120)))
 (let ((@x65697 ((_ th-lemma datatype) $x60731)))
 (let (($x62706 (= ?x62110 ?x62131)))
 (let (($x62803 (or $x49135 $x62706)))
 (let ((@x62809 ((_ quant-inst (tuple%2./tuple%2 ?x55992 ?x62120)) $x62803)))
 (let ((@x65700 (symm (unit-resolution @x62809 @x11986 $x62706) (= ?x62131 ?x62110))))
 (let ((@x65645 (monotonicity @x65700 (= (tuple%2./tuple%2/?1 ?x62131) ?x60872))))
 (let ((?x60863 (tuple%2./tuple%2/?1 ?x62131)))
 (let (($x62707 (= ?x62121 ?x60863)))
 (let (($x3514 (forall ((x tuple%2.) )(! (let ((?x3510 (tuple%2./tuple%2/1 x)))
 (= ?x3510 (tuple%2./tuple%2/?1 x))) :pattern ( (tuple%2./tuple%2/1 x) ) :qid internal_tuple__2./tuple__2/1_accessor_definition))
 ))
 (let ((?x12017 (lambda ((x tuple%2.) )(let ((?x3510 (tuple%2./tuple%2/1 x)))
 (let (($x3512 (= ?x3510 (tuple%2./tuple%2/?1 x))))
 (refl (~ $x3512 $x3512)))))
 ))
 (let ((@x12021 (mp~ (asserted $x3514) (nnf-pos (proof-bind ?x12017) (~ $x3514 $x3514)) $x3514)))
 (let (($x49161 (not $x3514)))
 (let (($x62778 (or $x49161 $x62707)))
 (let ((@x62779 ((_ quant-inst (%Poly%tuple%2. ?x62122)) $x62778)))
 (let ((@x65474 (monotonicity (trans* (unit-resolution @x62779 @x12021 $x62707) @x65645 @x65697 (= ?x62121 ?x62120)) (= ?x62117 (%Poly%core!option.Option. ?x62120)))))
 (let ((?x47421 (%Poly%core!option.Option. ?x62120)))
 (let (($x47419 (= ?x62119 ?x47421)))
 (let (($x2085 (forall ((x core!option.Option.) )(! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ( (Poly%core!option.Option. x) ) :qid internal_core__option__Option_box_axiom_definition))
 ))
 (let ((?x11282 (lambda ((x core!option.Option.) )(let (($x2083 (= x (%Poly%core!option.Option. (Poly%core!option.Option. x)))))
 (refl (~ $x2083 $x2083))))
 ))
 (let ((@x11286 (mp~ (asserted $x2085) (nnf-pos (proof-bind ?x11282) (~ $x2085 $x2085)) $x2085)))
 (let (($x49127 (not $x2085)))
 (let (($x47433 (or $x49127 $x47419)))
 (let ((@x61752 ((_ quant-inst (pmemlog!logimpl_v.impl&%0.recover.? ?x62109)) $x47433)))
 (let ((@x65631 (unit-resolution @x61752 @x11286 $x47419)))
 (let ((?x49125 (%Poly%core!option.Option. ?x47945)))
 (let (($x49126 (= ?x47938 ?x49125)))
 (let (($x49132 (or $x49127 $x49126)))
 (let ((@x49133 ((_ quant-inst (pmemlog!logimpl_v.impl&%0.recover.? ?x47937)) $x49132)))
 (let ((@x62865 (unit-resolution @x49133 @x11286 $x49126)))
 (let ((@x62908 (symm @x62865 (= ?x49125 ?x47938))))
 (let ((@x62876 (symm @x62866 (= ?x48393 ?x47945))))
 (let ((@x62874 (symm @x62872 (= ?x48401 ?x48393))))
 (let ((?x49149 (tuple%2./tuple%2/1 ?x48397)))
 (let (($x49159 (= ?x49149 ?x48396)))
 (let (($x49163 (or $x49161 $x49159)))
 (let (($x49150 (= ?x49149 ?x48401)))
 (let (($x49164 (or $x49161 $x49150)))
 (let (($x49166 (= $x49164 $x49163)))
 (let ((@x49170 (trans (monotonicity (rewrite (= $x49150 $x49159)) $x49166) (rewrite (= $x49163 $x49163)) $x49166)))
 (let ((@x49171 (mp ((_ quant-inst (tuple%2./tuple%2 ?x48395 ?x48396)) $x49164) @x49170 $x49163)))
 (let ((@x62868 (unit-resolution @x49171 @x12021 $x49159)))
 (let ((@x62870 (monotonicity @x60822 (= ?x47954 ?x49149))))
 (let ((@x62906 (monotonicity (trans* @x62870 @x62868 @x62867 @x62874 @x62876 (= ?x47954 ?x47945)) (= ?x47955 ?x49125))))
 (let ((@x65663 (trans* @x62906 @x62908 (symm (monotonicity @x69141 (= ?x62119 ?x47938)) (= ?x47938 ?x62119)) @x65631 (symm @x65474 (= ?x47421 ?x62117)) (= ?x47955 ?x62117))))
 (let (($x51793 (= ?x47944 pmemlog!pmemspec_t.cdb0_val.?)))
 (let (($x65795 (= pmemlog!pmemspec_t.cdb0_val.? ?x47944)))
 (let ((@x65819 (trans (monotonicity @x61101 (= $x47974 $x65795)) (commutativity (= $x65795 $x51793)) (= $x47974 $x51793))))
 (let ((?x7428 (Add pmemlog!logimpl_v.incorruptible_bool_pos.? 8)))
 (let ((?x7429 (I ?x7428)))
 (let ((?x50617 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47937 ?x7427 ?x7429)))
 (let ((?x50606 (vstd!bytes.spec_u64_from_le_bytes.? ?x50617)))
 (let ((?x50607 (I ?x50606)))
 (let ((?x51034 (%I ?x50607)))
 (let ((?x50647 (vstd!seq.Seq.len.? $ ?x1876 ?x47937)))
 (let ((?x50648 (I ?x50647)))
 (let ((?x50649 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47937 ?x7471 ?x50648)))
 (let ((?x50650 (%Poly%vstd!seq.Seq<u8.>. ?x50649)))
 (let ((?x50651 (Poly%vstd!seq.Seq<u8.>. ?x50650)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x50638 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47937 ?x7451 ?x7453)))
 (let ((?x50639 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x50638)))
 (let ((?x50640 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x50639)))
 (let ((?x50641 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x50640)))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x50634 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47937 ?x7439 ?x7441)))
 (let ((?x50635 (vstd!bytes.spec_u64_from_le_bytes.? ?x50634)))
 (let ((?x50636 (I ?x50635)))
 (let ((?x50637 (%I ?x50636)))
 (let ((?x50642 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x50637 ?x50641)))
 (let ((?x50643 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x50642)))
 (let ((?x50644 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x50643)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x50626 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47937 ?x7445 ?x7447)))
 (let ((?x50627 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x50626)))
 (let ((?x50628 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x50627)))
 (let ((?x50629 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x50628)))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x50622 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47937 ?x7433 ?x7435)))
 (let ((?x50623 (vstd!bytes.spec_u64_from_le_bytes.? ?x50622)))
 (let ((?x50624 (I ?x50623)))
 (let ((?x50625 (%I ?x50624)))
 (let ((?x50630 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x50625 ?x50629)))
 (let ((?x50632 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x50630)))
 (let ((?x50633 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x50632)))
 (let ((?x50645 (pmemlog!logimpl_v.HeaderView./HeaderView ?x50633 ?x50644)))
 (let ((?x50646 (Poly%pmemlog!logimpl_v.HeaderView. ?x50645)))
 (let ((?x50652 (tuple%3./tuple%3 ?x50607 ?x50646 ?x50651)))
 (let ((?x50857 (tuple%3./tuple%3/?0 ?x50652)))
 (let (($x50858 (= ?x50607 ?x50857)))
 (let ((@x65746 ((_ th-lemma datatype) $x50858)))
 (let ((?x48468 (tuple%3./tuple%3/?2 ?x47940)))
 (let ((?x48467 (tuple%3./tuple%3/?1 ?x47940)))
 (let ((?x48466 (tuple%3./tuple%3/?0 ?x47940)))
 (let ((?x48469 (tuple%3./tuple%3 ?x48466 ?x48467 ?x48468)))
 (let ((?x49208 (Poly%tuple%3. ?x48469)))
 (let ((?x49209 (%Poly%tuple%3. ?x49208)))
 (let ((?x49225 (tuple%3./tuple%3/?2 ?x49209)))
 (let ((?x49224 (tuple%3./tuple%3/?1 ?x49209)))
 (let ((?x49223 (tuple%3./tuple%3/?0 ?x49209)))
 (let ((?x49226 (tuple%3./tuple%3 ?x49223 ?x49224 ?x49225)))
 (let ((?x49228 (tuple%3./tuple%3/?0 ?x49226)))
 (let (($x49227 (= ?x49209 ?x49226)))
 (let ((@x65726 ((_ th-lemma datatype) $x49227)))
 (let (($x49217 (= ?x48469 ?x49209)))
 (let (($x3607 (forall ((x tuple%3.) )(! (= x (%Poly%tuple%3. (Poly%tuple%3. x))) :pattern ( (Poly%tuple%3. x) ) :qid internal_crate__tuple__3_box_axiom_definition))
 ))
 (let ((?x12052 (lambda ((x tuple%3.) )(let (($x3605 (= x (%Poly%tuple%3. (Poly%tuple%3. x)))))
 (refl (~ $x3605 $x3605))))
 ))
 (let ((@x12056 (mp~ (asserted $x3607) (nnf-pos (proof-bind ?x12052) (~ $x3607 $x3607)) $x3607)))
 (let (($x49220 (not $x3607)))
 (let (($x49221 (or $x49220 $x49217)))
 (let ((@x49222 ((_ quant-inst (tuple%3./tuple%3 ?x48466 ?x48467 ?x48468)) $x49221)))
 (let (($x48470 (= ?x47940 ?x48469)))
 (let ((@x65740 ((_ th-lemma datatype) $x48470)))
 (let (($x50653 (= ?x47940 ?x50652)))
 (let (($x7481 (forall ((pm! Poly) )(! (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7473 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 (I (vstd!seq.Seq.len.? $ ?x1876 pm!)))))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7465 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x7467 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I (vstd!bytes.spec_u64_from_le_bytes.? ?x7442))) (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7465))))
 (let ((?x7469 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7467))))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7458 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let ((?x7460 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I (vstd!bytes.spec_u64_from_le_bytes.? ?x7436))) (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7458))))
 (let ((?x7462 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7460))))
 (let ((?x7476 (Poly%pmemlog!logimpl_v.HeaderView. (pmemlog!logimpl_v.HeaderView./HeaderView ?x7462 ?x7469))))
 (let ((?x7428 (Add pmemlog!logimpl_v.incorruptible_bool_pos.? 8)))
 (let ((?x7429 (I ?x7428)))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x7431 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7427 ?x7429))))
 (let ((?x7478 (tuple%3./tuple%3 (I ?x7431) ?x7476 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7473)))))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (= ?x7426 ?x7478))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.pm_to_views.? pm!) ) :qid internal_pmemlog!logimpl_v.pm_to_views.?_definition))
 ))
 (let (($x7425 (fuel_bool fuel%pmemlog!logimpl_v.pm_to_views.)))
 (let (($x7423 (fuel_bool_default fuel%pmemlog!logimpl_v.pm_to_views.)))
 (let (($x50604 (= $x7425 $x7423)))
 (let ((@x50618 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.pm_to_views.) (or (not $x30) $x50604)) @x49237 (hypothesis (not $x50604)) false)))
 (let ((@x50631 (lemma @x50618 $x50604)))
 (let ((@x7424 (asserted $x7423)))
 (let ((@x50610 (def-axiom (or (not $x50604) $x7425 (not $x7423)))))
 (let ((@x65707 (unit-resolution (unit-resolution @x50610 @x7424 (or (not $x50604) $x7425)) @x50631 $x7425)))
 (let (($x7484 (not $x7425)))
 (let (($x7485 (or $x7484 $x7481)))
 (let ((?x13915 (lambda ((pm! Poly) )(let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7473 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 (I (vstd!seq.Seq.len.? $ ?x1876 pm!)))))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7465 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x7467 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I (vstd!bytes.spec_u64_from_le_bytes.? ?x7442))) (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7465))))
 (let ((?x7469 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7467))))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7458 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let ((?x7460 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I (vstd!bytes.spec_u64_from_le_bytes.? ?x7436))) (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7458))))
 (let ((?x7462 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7460))))
 (let ((?x7476 (Poly%pmemlog!logimpl_v.HeaderView. (pmemlog!logimpl_v.HeaderView./HeaderView ?x7462 ?x7469))))
 (let ((?x7428 (Add pmemlog!logimpl_v.incorruptible_bool_pos.? 8)))
 (let ((?x7429 (I ?x7428)))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x7431 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7427 ?x7429))))
 (let ((?x7478 (tuple%3./tuple%3 (I ?x7431) ?x7476 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7473)))))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let (($x7479 (= ?x7426 ?x7478)))
 (refl (~ $x7479 $x7479))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x13920 (monotonicity (refl (~ $x7484 $x7484)) (nnf-pos (proof-bind ?x13915) (~ $x7481 $x7481)) (~ $x7485 $x7485))))
 (let ((@x7488 (mp (asserted (=> $x7425 $x7481)) (rewrite (= (=> $x7425 $x7481) $x7485)) $x7485)))
 (let ((@x13924 (mp (mp~ @x7488 @x13920 $x7485) (rewrite (= $x7485 $x7485)) $x7485)))
 (let ((@x65701 (unit-resolution @x13924 @x65707 $x7481)))
 (let (($x50656 (not $x7481)))
 (let (($x50657 (or $x50656 $x50653)))
 (let ((@x50658 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x47936)) $x50657)))
 (let ((@x65734 (trans* (symm (unit-resolution @x50658 @x65701 $x50653) (= ?x50652 ?x47940)) @x65740 (unit-resolution @x49222 @x12056 $x49217) @x65726 (= ?x50652 ?x49226))))
 (let ((@x65768 (monotonicity @x65734 (= ?x50857 ?x49228))))
 (let (($x49229 (= ?x49223 ?x49228)))
 (let ((@x65731 ((_ th-lemma datatype) $x49229)))
 (let ((?x53239 (tuple%3./tuple%3/0 ?x49226)))
 (let (($x53243 (= ?x53239 ?x49223)))
 (let (($x3655 (forall ((x tuple%3.) )(! (let ((?x3651 (tuple%3./tuple%3/0 x)))
 (= ?x3651 (tuple%3./tuple%3/?0 x))) :pattern ( (tuple%3./tuple%3/0 x) ) :qid internal_tuple__3./tuple__3/0_accessor_definition))
 ))
 (let ((?x12073 (lambda ((x tuple%3.) )(let ((?x3651 (tuple%3./tuple%3/0 x)))
 (let (($x3653 (= ?x3651 (tuple%3./tuple%3/?0 x))))
 (refl (~ $x3653 $x3653)))))
 ))
 (let ((@x12077 (mp~ (asserted $x3655) (nnf-pos (proof-bind ?x12073) (~ $x3655 $x3655)) $x3655)))
 (let (($x53228 (not $x3655)))
 (let (($x53245 (or $x53228 $x53243)))
 (let (($x53240 (= ?x53239 ?x49228)))
 (let (($x53247 (or $x53228 $x53240)))
 (let (($x53249 (= $x53247 $x53245)))
 (let ((@x53253 (trans (monotonicity (rewrite (= $x53240 $x53243)) $x53249) (rewrite (= $x53245 $x53245)) $x53249)))
 (let ((@x53254 (mp ((_ quant-inst (tuple%3./tuple%3 ?x49223 ?x49224 ?x49225)) $x53247) @x53253 $x53245)))
 (let ((@x65748 (unit-resolution @x53254 @x12077 $x53243)))
 (let ((@x65747 (symm (monotonicity (symm @x65740 (= ?x48469 ?x47940)) (= ?x49208 ?x47941)) (= ?x47941 ?x49208))))
 (let ((@x65735 (monotonicity (trans* (monotonicity @x65747 (= ?x47942 ?x49209)) @x65726 (= ?x47942 ?x49226)) (= ?x47943 ?x53239))))
 (let ((@x65765 (trans* @x65735 @x65748 @x65731 (symm @x65768 (= ?x49228 ?x50857)) (symm @x65746 (= ?x50857 ?x50607)) (= ?x47943 ?x50607))))
 (let ((@x65764 (symm (monotonicity @x65765 (= ?x47944 ?x51034)) (= ?x51034 ?x47944))))
 (let (($x51035 (= ?x50606 ?x51034)))
 (let (($x51040 (or $x48740 $x51035)))
 (let ((@x51041 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x50617)) $x51040)))
 (let ((@x65745 (unit-resolution @x51041 @x10612 $x51035)))
 (let ((?x62813 (vstd!seq.Seq.subrange.? $ ?x1876 ?x62109 ?x7427 ?x7429)))
 (let ((?x62816 (vstd!bytes.spec_u64_from_le_bytes.? ?x62813)))
 (let ((@x65763 (monotonicity (symm (monotonicity @x69141 (= ?x62813 ?x50617)) (= ?x50617 ?x62813)) (= ?x50606 ?x62816))))
 (let ((@x65786 (symm @x65763 (= ?x62816 ?x50606))))
 (let ((?x62833 (I ?x62816)))
 (let ((?x63473 (%I ?x62833)))
 (let (($x63476 (= ?x62816 ?x63473)))
 (let (($x63481 (or $x48740 $x63476)))
 (let ((@x63482 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x62813)) $x63481)))
 (let ((@x65783 (symm (unit-resolution @x63482 @x10612 $x63476) (= ?x63473 ?x62816))))
 (let ((?x60665 (tuple%3./tuple%3/?0 ?x61504)))
 (let (($x61382 (= ?x61505 ?x60665)))
 (let (($x60557 (or $x53228 $x61382)))
 (let ((@x47603 ((_ quant-inst (%Poly%tuple%3. ?x61493)) $x60557)))
 (let (($x62861 (= ?x61488 ?x61504)))
 (let (($x62027 (or $x49220 $x62861)))
 (let ((@x62028 ((_ quant-inst (pmemlog!logimpl_v.pm_to_views.? ?x62109)) $x62027)))
 (let ((@x65723 (monotonicity (symm (unit-resolution @x62028 @x12056 $x62861) (= ?x61504 ?x61488)) (= ?x60665 (tuple%3./tuple%3/?0 ?x61488)))))
 (let ((?x60637 (tuple%3./tuple%3/?0 ?x61488)))
 (let ((?x62848 (vstd!seq.Seq.len.? $ ?x1876 ?x62109)))
 (let ((?x62849 (I ?x62848)))
 (let ((?x62850 (vstd!seq.Seq.subrange.? $ ?x1876 ?x62109 ?x7471 ?x62849)))
 (let ((?x62361 (%Poly%vstd!seq.Seq<u8.>. ?x62850)))
 (let ((?x62362 (Poly%vstd!seq.Seq<u8.>. ?x62361)))
 (let ((?x62837 (vstd!seq.Seq.subrange.? $ ?x1876 ?x62109 ?x7451 ?x7453)))
 (let ((?x62839 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x62837)))
 (let ((?x62844 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x62839)))
 (let ((?x62840 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x62844)))
 (let ((?x62842 (vstd!seq.Seq.subrange.? $ ?x1876 ?x62109 ?x7439 ?x7441)))
 (let ((?x62843 (vstd!bytes.spec_u64_from_le_bytes.? ?x62842)))
 (let ((?x62822 (I ?x62843)))
 (let ((?x62823 (%I ?x62822)))
 (let ((?x62845 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x62823 ?x62840)))
 (let ((?x62838 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x62845)))
 (let ((?x62846 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x62838)))
 (let ((?x62828 (vstd!seq.Seq.subrange.? $ ?x1876 ?x62109 ?x7445 ?x7447)))
 (let ((?x62829 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x62828)))
 (let ((?x62830 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x62829)))
 (let ((?x62834 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x62830)))
 (let ((?x62831 (vstd!seq.Seq.subrange.? $ ?x1876 ?x62109 ?x7433 ?x7435)))
 (let ((?x62817 (vstd!bytes.spec_u64_from_le_bytes.? ?x62831)))
 (let ((?x62818 (I ?x62817)))
 (let ((?x62825 (%I ?x62818)))
 (let ((?x62835 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x62825 ?x62834)))
 (let ((?x62836 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x62835)))
 (let ((?x62832 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x62836)))
 (let ((?x62841 (pmemlog!logimpl_v.HeaderView./HeaderView ?x62832 ?x62846)))
 (let ((?x62847 (Poly%pmemlog!logimpl_v.HeaderView. ?x62841)))
 (let ((?x62863 (tuple%3./tuple%3 ?x62833 ?x62847 ?x62362)))
 (let ((?x63177 (tuple%3./tuple%3/?0 ?x62863)))
 (let (($x62864 (= ?x61488 ?x62863)))
 (let (($x61796 (or $x50656 $x62864)))
 (let ((@x61884 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x62116)) $x61796)))
 (let ((@x65725 (monotonicity (symm (unit-resolution @x61884 @x65701 $x62864) (= ?x62863 ?x61488)) (= ?x63177 ?x60637))))
 (let ((@x65733 (trans* ((_ th-lemma datatype) (= ?x62833 ?x63177)) @x65725 (symm @x65723 (= ?x60637 ?x60665)) (symm (unit-resolution @x47603 @x12077 $x61382) (= ?x60665 ?x61505)) (= ?x62833 ?x61505))))
 (let ((@x65776 (symm (monotonicity @x65733 (= ?x63473 ?x61503)) (= ?x61503 ?x63473))))
 (let ((@x65801 (monotonicity (trans* @x65776 @x65783 @x65786 @x65745 @x65764 (= ?x61503 ?x47944)) @x61231 (= $x48597 $x51793))))
 (let ((@x65712 (unit-resolution (def-axiom (or $x48600 $x48597)) @x65661 $x48597)))
 (let ((@x65815 (mp @x65712 (trans* @x65801 (symm @x65819 (= $x51793 $x47974)) (= $x48597 $x47974)) $x47974)))
 (let ((@x65816 (trans* @x65645 @x65697 (monotonicity (monotonicity @x69141 (= ?x62119 ?x47938)) (= ?x62120 ?x47945)) @x62866 @x62872 @x62883 (= ?x60863 ?x48396))))
 (let ((?x48399 (tuple%2./tuple%2/?0 ?x48397)))
 (let (($x49174 (= ?x48399 ?x48395)))
 (let (($x48400 (= ?x48395 ?x48399)))
 (let ((@x62146 ((_ th-lemma datatype) $x48400)))
 (let ((@x62230 (symm @x62146 $x49174)))
 (let ((@x62148 (monotonicity @x60825 (= (tuple%2./tuple%2/?0 ?x47946) ?x48399))))
 (let ((?x48391 (tuple%2./tuple%2/?0 ?x47946)))
 (let (($x48392 (= ?x47897 ?x48391)))
 (let ((@x62145 ((_ th-lemma datatype) $x48392)))
 (let ((@x62227 (monotonicity @x56802 (= ?x55991 ?x47691))))
 (let ((@x62229 (monotonicity @x62227 (= ?x55992 ?x47897))))
 (let ((@x65834 (symm ((_ th-lemma datatype) (= ?x55992 (tuple%2./tuple%2/?0 ?x62110))) (= (tuple%2./tuple%2/?0 ?x62110) ?x55992))))
 (let ((@x65825 (monotonicity @x65700 (= (tuple%2./tuple%2/?0 ?x62131) (tuple%2./tuple%2/?0 ?x62110)))))
 (let ((@x65835 (trans* @x65825 @x65834 @x62229 @x62145 @x62148 @x62230 (= (tuple%2./tuple%2/?0 ?x62131) ?x48395))))
 (let ((@x65792 (monotonicity @x65835 @x65816 (= (tuple%2./tuple%2 (tuple%2./tuple%2/?0 ?x62131) ?x60863) ?x48397))))
 (let ((@x65839 (symm ((_ th-lemma datatype) (= (tuple%2./tuple%2 (tuple%2./tuple%2/?0 ?x62131) ?x60863) ?x62131)) (= ?x62131 (tuple%2./tuple%2 (tuple%2./tuple%2/?0 ?x62131) ?x60863)))))
 (let ((@x68872 (monotonicity (monotonicity (trans* @x65839 @x65792 @x62891 (= ?x62131 ?x47949)) (= ?x47537 ?x47950)) (= ?x62132 ?x47951))))
 (let ((@x69013 (monotonicity (monotonicity (monotonicity @x68872 (= ?x61466 ?x47958)) (= ?x61467 ?x47959)) (= ?x61478 ?x47963))))
 (let ((@x69294 (symm @x62906 (= ?x49125 ?x47955))))
 (let ((@x65639 (monotonicity @x69141 (= ?x62119 ?x47938))))
 (let ((@x69295 (trans* @x65474 (symm @x65631 (= ?x47421 ?x62119)) @x65639 @x62865 @x69294 (= ?x62117 ?x47955))))
 (let ((@x69301 (monotonicity (monotonicity (monotonicity @x69295 (= ?x47535 ?x47960)) (= ?x61153 ?x47961)) (= ?x60549 ?x47962))))
 (let ((@x69303 (monotonicity @x69301 (monotonicity (monotonicity @x69013 @x56782 (= ?x61495 ?x47964)) (= ?x61496 ?x47965)) (= $x61489 $x47966))))
 (let (($x62499 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeader. ?x47732 ?x47732)))
 (let (($x62686 (not $x62499)))
 (let (($x62687 (= $x48122 $x62686)))
 (let (($x62684 (= $x47972 $x62499)))
 (let (($x62682 (= $x62499 $x47972)))
 (let (($x62629 (= ?x47732 ?x47971)))
 (let (($x62627 (= ?x47971 ?x47732)))
 (let (($x62620 (= ?x47939 ?x47730)))
 (let (($x61547 (= ?x56081 ?x47730)))
 (let ((@x62625 (symm (monotonicity (symm @x58473 (= ?x47723 ?x56080)) (= ?x47730 ?x56081)) $x61547)))
 (let (($x62605 (= ?x62112 ?x47935)))
 (let ((@x62611 (monotonicity (monotonicity (monotonicity @x61501 (= ?x47601 ?x47924)) (= ?x62114 ?x47925)) $x62605)))
 (let ((@x62619 (monotonicity (monotonicity (monotonicity @x56802 @x62611 $x62612) $x62613) (= ?x62118 ?x47939))))
 (let ((@x62628 (monotonicity (trans* (symm @x62619 (= ?x47939 ?x62118)) (hypothesis $x62115) @x62625 $x62620) $x62627)))
 (let ((@x62600 (hypothesis $x48122)))
 (let ((@x62674 (mp @x62600 (monotonicity (symm (monotonicity (symm @x62628 $x62629) $x62682) $x62684) $x62687) $x62686)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x10692 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x10696 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x10692) (~ $x418 $x418)) $x418)))
 (let (($x60866 (not $x418)))
 (let (($x62583 (or $x60866 $x62499)))
 (let (($x62570 (= ?x47732 ?x47732)))
 (let (($x62571 (= $x62570 $x62499)))
 (let (($x62598 (or $x60866 $x62571)))
 (let (($x62594 (= $x62598 $x62583)))
 (let ((@x62582 (trans (monotonicity (rewrite (= $x62570 true)) (= $x62571 (= true $x62499))) (rewrite (= (= true $x62499) $x62499)) (= $x62571 $x62499))))
 (let ((@x62597 (mp ((_ quant-inst false TYPE%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x47730) (Poly%pmemlog!logimpl_v.PersistentHeader. ?x47730)) $x62598) (trans (monotonicity @x62582 $x62594) (rewrite (= $x62583 $x62583)) $x62594) $x62583)))
 (let ((@x62675 (unit-resolution @x62597 @x10696 $x62499)))
 (let ((@x69306 (unit-resolution (lemma (unit-resolution @x62675 @x62674 false) (or $x47972 $x61113 $x47708)) (unit-resolution (def-axiom (or $x48600 $x62115)) @x65661 $x62115) @x61101 $x47972)))
 (let (($x62188 (= $x48011 true)))
 (let ((?x48585 (core!option.Option./Some/?0 ?x47691)))
 (let ((?x48586 (core!option.Option./Some ?x48585)))
 (let (($x48587 (= ?x47691 ?x48586)))
 (let ((@x62167 (symm (unit-resolution ((_ th-lemma datatype) (or $x48587 (not $x47694))) @x47697 $x48587) (= ?x48586 ?x47691))))
 (let ((?x49115 (Poly%core!option.Option. ?x48586)))
 (let ((?x49116 (%Poly%core!option.Option. ?x49115)))
 (let (($x49124 (= ?x48586 ?x49116)))
 (let (($x49128 (or $x49127 $x49124)))
 (let ((@x49129 ((_ quant-inst (core!option.Option./Some ?x48585)) $x49128)))
 (let ((@x62180 (symm (unit-resolution @x49129 @x11286 $x49124) (= ?x49116 ?x48586))))
 (let ((@x62152 (symm @x62145 (= ?x48391 ?x47897))))
 (let ((@x62150 (symm @x62148 (= ?x48399 ?x48391))))
 (let ((?x49172 (tuple%2./tuple%2/0 ?x48397)))
 (let (($x49176 (= ?x49172 ?x48395)))
 (let (($x3493 (forall ((x tuple%2.) )(! (let ((?x3489 (tuple%2./tuple%2/0 x)))
 (= ?x3489 (tuple%2./tuple%2/?0 x))) :pattern ( (tuple%2./tuple%2/0 x) ) :qid internal_tuple__2./tuple__2/0_accessor_definition))
 ))
 (let ((?x12003 (lambda ((x tuple%2.) )(let ((?x3489 (tuple%2./tuple%2/0 x)))
 (let (($x3491 (= ?x3489 (tuple%2./tuple%2/?0 x))))
 (refl (~ $x3491 $x3491)))))
 ))
 (let ((@x12007 (mp~ (asserted $x3493) (nnf-pos (proof-bind ?x12003) (~ $x3493 $x3493)) $x3493)))
 (let (($x49178 (not $x3493)))
 (let (($x49180 (or $x49178 $x49176)))
 (let (($x49173 (= ?x49172 ?x48399)))
 (let (($x49181 (or $x49178 $x49173)))
 (let (($x49183 (= $x49181 $x49180)))
 (let ((@x49187 (trans (monotonicity (rewrite (= $x49173 $x49176)) $x49183) (rewrite (= $x49180 $x49180)) $x49183)))
 (let ((@x49188 (mp ((_ quant-inst (tuple%2./tuple%2 ?x48395 ?x48396)) $x49181) @x49187 $x49180)))
 (let ((@x62168 (unit-resolution @x49188 @x12007 $x49176)))
 (let ((@x62170 (monotonicity @x60822 (= ?x47950 ?x49172))))
 (let ((@x62176 (trans* @x62170 @x62168 @x62146 @x62150 @x62152 (symm (monotonicity @x62167 (= ?x49115 ?x47897)) (= ?x47897 ?x49115)) (= ?x47950 ?x49115))))
 (let ((@x62178 (monotonicity @x62176 (= ?x47951 ?x49116))))
 (let ((@x62189 (trans* (monotonicity (trans* @x62178 @x62180 @x62167 (= ?x47951 ?x47691)) (= $x48011 $x47694)) @x48560 $x62188)))
 (let ((@x62192 (mp @x62189 (rewrite (= $x62188 $x48011)) $x48011)))
 (let ((@x48501 (def-axiom (or $x48125 $x48118 $x48119 $x48120 $x48121 $x48122 $x48123))))
 (let ((@x69308 (unit-resolution @x48501 @x62192 (or $x48125 $x48119 $x48120 $x48121 $x48122 $x48123))))
 (let ((@x69309 (unit-resolution @x69308 @x65669 @x69306 (mp (unit-resolution (def-axiom (or $x48600 $x61489)) @x65661 $x61489) @x69303 $x47966) @x65815 (mp (trans* (monotonicity @x65663 (= $x48021 $x62134)) @x65648 $x65705) @x65711 $x48021) $x48125)))
 (let ((@x48505 (def-axiom (or $x48128 $x48124))))
 (let ((@x48544 (def-axiom (or $x48159 $x48152))))
 (let ((@x69264 (unit-resolution @x48544 @x65497 $x48152)))
 (let ((@x48542 (def-axiom (or $x48159 $x47929))))
 (let ((@x69208 (unit-resolution @x48542 @x65497 $x47929)))
 (let ((@x48538 (def-axiom (or $x48159 $x47926))))
 (let ((@x69209 (unit-resolution @x48538 @x65497 $x47926)))
 (let ((?x58972 (vstd!seq.Seq.len.? $ ?x1876 ?x47935)))
 (let (($x61836 (= ?x58972 8)))
 (let ((@x69272 (symm (monotonicity @x68691 (= ?x58972 (vstd!seq.Seq.len.? $ ?x1876 ?x62112))) (= (vstd!seq.Seq.len.? $ ?x1876 ?x62112) ?x58972))))
 (let ((@x69155 (monotonicity @x69272 (= (= (vstd!seq.Seq.len.? $ ?x1876 ?x62112) 8) $x61836))))
 (let ((?x64476 (vstd!seq.Seq.len.? $ ?x1876 ?x62112)))
 (let (($x64477 (= ?x64476 8)))
 (let (($x64482 (or (not $x64477) (not (= (vstd!bytes.spec_u64_from_le_bytes.? ?x62112) (%I ?x47601))))))
 (let (($x64483 (not $x64482)))
 (let ((?x4023 (UINT 64)))
 (let (($x64474 (has_type ?x47601 ?x4023)))
 (let ((@x69055 (symm @x65735 (= ?x53239 ?x47943))))
 (let ((@x69050 (symm @x65748 (= ?x49223 ?x53239))))
 (let (($x53241 (= ?x49228 ?x49223)))
 (let ((@x69045 (symm @x65731 $x53241)))
 (let ((@x69044 (monotonicity (trans* (symm @x65712 $x61506) @x65776 @x65783 @x65786 (= 11756720295082287198 ?x50606)) (= ?x47601 ?x50607))))
 (let ((@x69283 (monotonicity (trans* @x69044 @x65746 @x65768 @x69045 @x69050 @x69055 (= ?x47601 ?x47943)) (= $x64474 (has_type ?x47943 ?x4023)))))
 (let (($x57052 (has_type ?x47943 ?x4023)))
 (let ((?x7490 (TYPE%tuple%3. $ ?x4023 $ TYPE%pmemlog!logimpl_v.HeaderView. $ ?x1968)))
 (let (($x49192 (has_type ?x47941 ?x7490)))
 (let (($x48692 (has_type ?x47937 ?x1968)))
 (let ((?x48680 (%Poly%vstd!seq.Seq<u8.>. ?x47937)))
 (let ((?x57468 (Poly%vstd!seq.Seq<u8.>. ?x48680)))
 (let (($x57469 (has_type ?x57468 ?x1968)))
 (let (($x57495 (not $x57469)))
 (let (($x48681 (= ?x47936 ?x48680)))
 (let (($x48686 (or $x48673 $x48681)))
 (let ((@x48687 ((_ quant-inst (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47674 ?x7427 ?x47935)) $x48686)))
 (let ((@x57490 (monotonicity (symm (unit-resolution @x48687 @x11202 $x48681) (= ?x48680 ?x47936)) (= ?x57468 ?x47937))))
 (let ((@x57497 (monotonicity (symm (monotonicity @x57490 (= $x57469 $x48692)) (= $x48692 $x57469)) (= (not $x48692) $x57495))))
 (let ((@x57500 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47937)) (or (not $x1989) $x57469)) @x11216 $x57469) (mp (hypothesis (not $x48692)) @x57497 $x57495) false)))
 (let ((@x57501 (lemma @x57500 $x48692)))
 (let (($x48693 (not $x48692)))
 (let (($x49193 (or $x48693 $x49192)))
 (let (($x7498 (forall ((pm! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x4023 (UINT 64)))
 (let ((?x7490 (TYPE%tuple%3. $ ?x4023 $ TYPE%pmemlog!logimpl_v.HeaderView. $ ?x1968)))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let (($x7491 (has_type ?x7489 ?x7490)))
 (let (($x1969 (has_type pm! ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x7491)))))))))) :pattern ( (pmemlog!logimpl_v.pm_to_views.? pm!) ) :qid internal_pmemlog!logimpl_v.pm_to_views.?_pre_post_definition))
 ))
 (let ((?x13927 (lambda ((pm! Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x4023 (UINT 64)))
 (let ((?x7490 (TYPE%tuple%3. $ ?x4023 $ TYPE%pmemlog!logimpl_v.HeaderView. $ ?x1968)))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let (($x7491 (has_type ?x7489 ?x7490)))
 (let (($x1969 (has_type pm! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7495 (or $x1977 $x7491)))
 (refl (~ $x7495 $x7495)))))))))))))
 ))
 (let (($x7493 (forall ((pm! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x4023 (UINT 64)))
 (let ((?x7490 (TYPE%tuple%3. $ ?x4023 $ TYPE%pmemlog!logimpl_v.HeaderView. $ ?x1968)))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let (($x7491 (has_type ?x7489 ?x7490)))
 (let (($x1969 (has_type pm! ?x1968)))
 (=> $x1969 $x7491))))))))) :pattern ( (pmemlog!logimpl_v.pm_to_views.? pm!) ) :qid internal_pmemlog!logimpl_v.pm_to_views.?_pre_post_definition))
 ))
 (let ((?x7499 (lambda ((pm! Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x4023 (UINT 64)))
 (let ((?x7490 (TYPE%tuple%3. $ ?x4023 $ TYPE%pmemlog!logimpl_v.HeaderView. $ ?x1968)))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let (($x7491 (has_type ?x7489 ?x7490)))
 (let (($x1969 (has_type pm! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7495 (or $x1977 $x7491)))
 (let (($x7492 (=> $x1969 $x7491)))
 (rewrite (= $x7492 $x7495))))))))))))))
 ))
 (let ((@x7503 (mp (asserted $x7493) (quant-intro (proof-bind ?x7499) (= $x7493 $x7498)) $x7498)))
 (let ((@x13931 (mp~ @x7503 (nnf-pos (proof-bind ?x13927) (~ $x7498 $x7498)) $x7498)))
 (let (($x49210 (not $x7498)))
 (let (($x49211 (or $x49210 $x48693 $x49192)))
 (let ((@x49216 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x47936)) (or $x49210 $x49193)) (rewrite (= (or $x49210 $x49193) $x49211)) $x49211)))
 (let (($x3666 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly) )(! (let ((?x3611 (%Poly%tuple%3. x)))
 (let ((?x3657 (tuple%3./tuple%3/0 ?x3611)))
 (let (($x3658 (has_type ?x3657 T%0&)))
 (let ((?x3609 (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)))
 (let (($x3610 (has_type x ?x3609)))
 (let (($x3618 (not $x3610)))
 (or $x3618 $x3658))))))) :pattern ( (tuple%3./tuple%3/0 (%Poly%tuple%3. x)) (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) ) :qid internal_tuple__3./tuple__3/0_invariant_definition))
 ))
 (let ((?x12080 (lambda ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly) )(let ((?x3611 (%Poly%tuple%3. x)))
 (let ((?x3657 (tuple%3./tuple%3/0 ?x3611)))
 (let (($x3658 (has_type ?x3657 T%0&)))
 (let ((?x3609 (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)))
 (let (($x3610 (has_type x ?x3609)))
 (let (($x3618 (not $x3610)))
 (let (($x3663 (or $x3618 $x3658)))
 (refl (~ $x3663 $x3663))))))))))
 ))
 (let (($x3661 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly) )(! (let ((?x3611 (%Poly%tuple%3. x)))
 (let ((?x3657 (tuple%3./tuple%3/0 ?x3611)))
 (let (($x3658 (has_type ?x3657 T%0&)))
 (let ((?x3609 (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)))
 (let (($x3610 (has_type x ?x3609)))
 (=> $x3610 $x3658)))))) :pattern ( (tuple%3./tuple%3/0 (%Poly%tuple%3. x)) (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) ) :qid internal_tuple__3./tuple__3/0_invariant_definition))
 ))
 (let ((?x3667 (lambda ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly) )(let ((?x3611 (%Poly%tuple%3. x)))
 (let ((?x3657 (tuple%3./tuple%3/0 ?x3611)))
 (let (($x3658 (has_type ?x3657 T%0&)))
 (let ((?x3609 (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)))
 (let (($x3610 (has_type x ?x3609)))
 (let (($x3618 (not $x3610)))
 (let (($x3663 (or $x3618 $x3658)))
 (let (($x3659 (=> $x3610 $x3658)))
 (rewrite (= $x3659 $x3663)))))))))))
 ))
 (let ((@x3671 (mp (asserted $x3661) (quant-intro (proof-bind ?x3667) (= $x3661 $x3666)) $x3666)))
 (let ((@x12084 (mp~ @x3671 (nnf-pos (proof-bind ?x12080) (~ $x3666 $x3666)) $x3666)))
 (let (($x56986 (not $x49192)))
 (let (($x56274 (not $x3666)))
 (let (($x57015 (or $x56274 $x56986 $x57052)))
 (let ((@x56995 (mp ((_ quant-inst $ (UINT 64) $ TYPE%pmemlog!logimpl_v.HeaderView. $ (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%tuple%3. ?x47940)) (or $x56274 (or $x56986 $x57052))) (rewrite (= (or $x56274 (or $x56986 $x57052)) $x57015)) $x57015)))
 (let ((@x69211 (unit-resolution @x56995 @x12084 (unit-resolution (unit-resolution @x49216 @x13931 $x49193) @x57501 $x49192) $x57052)))
 (let (($x64475 (not $x64474)))
 (let (($x64484 (or $x64475 $x64483)))
 (let (($x17373 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x17367 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x17367)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x13286 (not $x6172)))
 (let (($x17380 (not $x17373)))
 (let (($x17381 (or $x17380 $x13286)))
 (let (($x17382 (not $x17381)))
 (let (($x61626 (or $x48024 $x17382)))
 (let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x17393 (not (or (not (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)) (not $x13266)))))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x17396 (or $x13259 $x17393)))
 (let (($x17394 (not $x17396)))
 (let (($x61625 (not (or $x47927 $x17394 $x13285))))
 (let (($x61627 (not $x61626)))
 (let (($x61645 (or $x61627 $x61625)))
 (let (($x61646 (not $x61645)))
 (let (($x17417 (forall ((no%param Int) )(! (let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1876 (UINT 8)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x17393 (not (or (not (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)) (not $x13266)))))
 (let ((?x4023 (UINT 64)))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x17396 (or $x13259 $x17393)))
 (let (($x17394 (not $x17396)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x17397 (or $x6127 $x17394 $x13285)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x13286 (not $x6172)))
 (let (($x17373 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x17367 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x17367)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x17380 (not $x17373)))
 (let (($x17381 (or $x17380 $x13286)))
 (let (($x17382 (not $x17381)))
 (let (($x13240 (not $x6127)))
 (let (($x17387 (or $x13240 $x17382)))
 (not (or (not $x17387) (not $x17397)))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let (($x13316 (forall ((no%param Int) )(! (let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1876 (UINT 8)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x13263 (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x13269 (not (or $x13259 (and $x13263 $x13266)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x13318 (or $x6127 $x13269 $x13285)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x13240 (not $x6127)))
 (let (($x13294 (or $x13240 $x6177)))
 (and $x13294 $x13318)))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x17418 (lambda ((no%param Int) )(let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1876 (UINT 8)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x17393 (not (or (not (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)) (not $x13266)))))
 (let ((?x4023 (UINT 64)))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x17396 (or $x13259 $x17393)))
 (let (($x17394 (not $x17396)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x17397 (or $x6127 $x17394 $x13285)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x13286 (not $x6172)))
 (let (($x17373 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x17367 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x17367)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x17380 (not $x17373)))
 (let (($x17381 (or $x17380 $x13286)))
 (let (($x17382 (not $x17381)))
 (let (($x13240 (not $x6127)))
 (let (($x17387 (or $x13240 $x17382)))
 (let (($x17412 (not (or (not $x17387) (not $x17397)))))
 (let (($x13269 (not (or $x13259 (and (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8) $x13266)))))
 (let (($x13318 (or $x6127 $x13269 $x13285)))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x13294 (or $x13240 $x6177)))
 (let (($x13322 (and $x13294 $x13318)))
 (let (($x17399 (= $x13318 $x17397)))
 (let ((@x17405 (trans (monotonicity (rewrite (= $x13269 $x17394)) (rewrite (= $x13285 $x13285)) $x17399) (rewrite (= $x17397 $x17397)) $x17399)))
 (trans (monotonicity (rewrite (= $x13294 $x17387)) @x17405 (= $x13322 (and $x17387 $x17397))) (rewrite (= (and $x17387 $x17397) $x17412)) (= $x13322 $x17412)))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x13298 (forall ((no%param Int) )(! (let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1876 (UINT 8)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x13263 (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x13269 (not (or $x13259 (and $x13263 $x13266)))))
 (let (($x13289 (or $x13269 $x13285)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x13240 (not $x6127)))
 (let (($x13294 (or $x13240 $x6177)))
 (and $x13294 (or $x6127 $x13289))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x13317 (lambda ((no%param Int) )(let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1876 (UINT 8)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x13263 (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x13269 (not (or $x13259 (and $x13263 $x13266)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x13318 (or $x6127 $x13269 $x13285)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x13240 (not $x6127)))
 (let (($x13294 (or $x13240 $x6177)))
 (let (($x13322 (and $x13294 $x13318)))
 (let (($x13295 (and $x13294 (or $x6127 (or $x13269 $x13285)))))
 (rewrite (= $x13295 $x13322))))))))))))))))))))))))))))
 ))
 (let (($x6178 (forall ((no%param Int) )(! (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 $x6177))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x13299 (lambda ((no%param Int) )(let ((?x13282 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x13279 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1876 (UINT 8)))
 (let ((?x13276 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x13274 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x13284 (or (not $x13274) (not (= ?x13276 8)) (= (vstd!bytes.spec_u64_to_le_bytes.? (I ?x13279)) ?x13282))))
 (let (($x13285 (not $x13284)))
 (let ((?x13260 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x13261 (Poly%vstd!seq.Seq<u8.>. ?x13260)))
 (let (($x13266 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x13261) (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6))))
 (let (($x13263 (= (vstd!seq.Seq.len.? $ ?x1876 ?x13261) 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x13258 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x13259 (not $x13258)))
 (let (($x13269 (not (or $x13259 (and $x13263 $x13266)))))
 (let (($x13289 (or $x13269 $x13285)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x13240 (not $x6127)))
 (let (($x13294 (or $x13240 $x6177)))
 (let (($x13295 (and $x13294 (or $x6127 $x13289))))
 (let (($x6161 (= $x6127 $x6177)))
 (let ((@x13292 (nnf-neg (sk (~ (not $x6155) $x13269)) (sk (~ (not $x6172) $x13285)) (~ (not $x6177) $x13289))))
 (let ((?x13251 (lambda ((s$ Poly) )(let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x6167 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))
 (refl (~ $x6167 $x6167)))))))))))
 ))
 (let ((?x13245 (lambda ((x$ Poly) )(let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (let (($x6152 (or $x6151 $x6135)))
 (refl (~ $x6152 $x6152)))))))))))))
 ))
 (let ((@x13256 (monotonicity (nnf-pos (proof-bind ?x13245) (~ $x6155 $x6155)) (nnf-pos (proof-bind ?x13251) (~ $x6172 $x6172)) (~ $x6177 $x6177))))
 (nnf-pos (refl (~ $x6127 $x6127)) (refl (~ $x13240 $x13240)) @x13256 @x13292 (~ $x6161 $x13295))))))))))))))))))))))))))))))))
 ))
 (let (($x6149 (forall ((no%param Int) )(! (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 (and $x6138 $x6145))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x6180 (lambda ((no%param Int) )(let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6161 (= $x6127 $x6177)))
 (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6147 (= $x6127 (and $x6138 $x6145))))
 (rewrite (= $x6147 $x6161)))))))))))
 ))
 (let ((@x6168 (mp (asserted $x6149) (quant-intro (proof-bind ?x6180) (= $x6149 $x6178)) $x6178)))
 (let ((@x13308 (mp (mp~ @x6168 (nnf-pos (proof-bind ?x13299) (~ $x6178 $x13298)) $x13298) (quant-intro (proof-bind ?x13317) (= $x13298 $x13316)) $x13316)))
 (let ((@x17372 (mp @x13308 (quant-intro (proof-bind ?x17418) (= $x13316 $x17417)) $x17417)))
 (let ((@x69287 (unit-resolution (def-axiom (or $x61645 $x61626)) (unit-resolution ((_ quant-inst 0) (or (not $x17417) $x61646)) @x17372 $x61646) $x61626)))
 (let ((@x69113 (unit-resolution (def-axiom (or $x61627 $x48024 $x17382)) (unit-resolution (def-axiom (or $x48159 $x47927)) @x65497 $x47927) (or $x61627 $x17382))))
 (let ((@x69115 (unit-resolution (def-axiom (or $x17381 $x17373)) (unit-resolution @x69113 @x69287 $x17382) $x17373)))
 (let (($x64788 (or $x17380 $x64475 $x64483)))
 (let ((@x64789 (mp ((_ quant-inst (I 11756720295082287198)) (or $x17380 $x64484)) (rewrite (= (or $x17380 $x64484) $x64788)) $x64788)))
 (let ((@x69127 (unit-resolution (unit-resolution @x64789 @x69115 $x64484) (mp @x69211 (symm @x69283 (= $x57052 $x64474)) $x64474) $x64483)))
 (let (($x62089 (>= (+ ?x56131 (* (- 1) (Add 0 (vstd!seq.Seq.len.? $ ?x1876 ?x59165)))) 0)))
 (let (($x62306 (not $x62089)))
 (let (($x10159 (not %%global_location_label%%125)))
 (let (($x62090 (or $x10159 $x62089)))
 (let (($x62092 (not $x62090)))
 (let (($x62124 (<= ?x56131 0)))
 (let (($x62291 (not $x62124)))
 (let (($x10193 (not %%global_location_label%%124)))
 (let (($x62129 (or $x10193 $x62291)))
 (let (($x62292 (not $x62129)))
 (let ((?x62076 (EucMod 0 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x62077 (= ?x62076 0)))
 (let (($x10203 (not %%global_location_label%%123)))
 (let (($x62078 (or $x10203 $x62077)))
 (let (($x62079 (not $x62078)))
 (let ((?x62067 (vstd!seq.Seq.len.? $ ?x1876 ?x59165)))
 (let (($x62068 (= ?x62067 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10244 (not %%global_location_label%%122)))
 (let (($x62073 (or $x10244 $x62068)))
 (let (($x62074 (not $x62073)))
 (let (($x48986 (or $x62074 $x62079 $x62292 $x62092)))
 (let (($x62094 (req%pmemlog!logimpl_v.lemma_single_write_crash. ?x48663 0 ?x48684)))
 (let (($x62354 (= $x48986 $x62094)))
 (let (($x62368 (not $x62354)))
 (let (($x19606 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let (($x10253 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8502 (vstd!seq.Seq.len.? $ ?x1876 ?x1962)))
 (let ((?x10220 (Add write_addr! ?x8502)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x10159 (not %%global_location_label%%125)))
 (let (($x10160 (or $x10159 (>= (+ ?x8518 (* (- 1) ?x10220)) 0))))
 (let (($x10193 (not %%global_location_label%%124)))
 (let (($x19523 (or $x10193 (not (or (not (>= write_addr! 0)) (>= (+ write_addr! (* (- 1) ?x8518)) 0))))))
 (let (($x10316 (= (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) 0)))
 (let (($x10203 (not %%global_location_label%%123)))
 (let (($x10204 (or $x10203 $x10316)))
 (let (($x10313 (= ?x8502 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10244 (not %%global_location_label%%122)))
 (let (($x10247 (or $x10244 $x10313)))
 (let (($x19536 (or (not $x10247) (not $x10204) (not $x19523) (not $x10160))))
 (not (= $x19536 $x10253)))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_req__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let (($x10171 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8502 (vstd!seq.Seq.len.? $ ?x1876 ?x1962)))
 (let ((?x10220 (Add write_addr! ?x8502)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x10159 (not %%global_location_label%%125)))
 (let (($x10160 (or $x10159 (>= (+ ?x8518 (* (- 1) ?x10220)) 0))))
 (let (($x10193 (not %%global_location_label%%124)))
 (let (($x10201 (or $x10193 (and (>= write_addr! 0) (not (>= (+ write_addr! (* (- 1) ?x8518)) 0))))))
 (let (($x10316 (= (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) 0)))
 (let (($x10203 (not %%global_location_label%%123)))
 (let (($x10204 (or $x10203 $x10316)))
 (let (($x10313 (= ?x8502 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10244 (not %%global_location_label%%122)))
 (let (($x10247 (or $x10244 $x10313)))
 (let (($x10170 (and $x10247 $x10204 $x10201 $x10160)))
 (let (($x10253 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (= $x10253 $x10170))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_req__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let ((?x19607 (lambda ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(let (($x10253 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8502 (vstd!seq.Seq.len.? $ ?x1876 ?x1962)))
 (let ((?x10220 (Add write_addr! ?x8502)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x10159 (not %%global_location_label%%125)))
 (let (($x10160 (or $x10159 (>= (+ ?x8518 (* (- 1) ?x10220)) 0))))
 (let (($x10193 (not %%global_location_label%%124)))
 (let (($x19523 (or $x10193 (not (or (not (>= write_addr! 0)) (>= (+ write_addr! (* (- 1) ?x8518)) 0))))))
 (let (($x10316 (= (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) 0)))
 (let (($x10203 (not %%global_location_label%%123)))
 (let (($x10204 (or $x10203 $x10316)))
 (let (($x10313 (= ?x8502 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10244 (not %%global_location_label%%122)))
 (let (($x10247 (or $x10244 $x10313)))
 (let (($x19536 (or (not $x10247) (not $x10204) (not $x19523) (not $x10160))))
 (let (($x19551 (not (= $x19536 $x10253))))
 (let (($x10201 (or $x10193 (and (>= write_addr! 0) (not (>= (+ write_addr! (* (- 1) ?x8518)) 0))))))
 (let (($x10170 (and $x10247 $x10204 $x10201 $x10160)))
 (let (($x10182 (= $x10253 $x10170)))
 (let (($x19498 (= $x10182 $x19551)))
 (let ((@x19526 (monotonicity (rewrite (= $x10201 $x19523)) (= $x10170 (and $x10247 $x10204 $x19523 $x10160)))))
 (let ((@x19541 (trans @x19526 (rewrite (= (and $x10247 $x10204 $x19523 $x10160) (not $x19536))) (= $x10170 (not $x19536)))))
 (let ((@x19602 (trans (monotonicity @x19541 (= $x10182 (= $x10253 (not $x19536)))) (rewrite (= (= $x10253 (not $x19536)) $x19551)) $x19498)))
 (trans @x19602 (rewrite (= $x19551 $x19551)) $x19498))))))))))))))))))))))))))))
 ))
 (let ((?x15074 (lambda ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8502 (vstd!seq.Seq.len.? $ ?x1876 ?x1962)))
 (let ((?x10220 (Add write_addr! ?x8502)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x10159 (not %%global_location_label%%125)))
 (let (($x10160 (or $x10159 (>= (+ ?x8518 (* (- 1) ?x10220)) 0))))
 (let (($x10193 (not %%global_location_label%%124)))
 (let (($x10201 (or $x10193 (and (>= write_addr! 0) (not (>= (+ write_addr! (* (- 1) ?x8518)) 0))))))
 (let (($x10316 (= (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) 0)))
 (let (($x10203 (not %%global_location_label%%123)))
 (let (($x10204 (or $x10203 $x10316)))
 (let (($x10313 (= ?x8502 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10244 (not %%global_location_label%%122)))
 (let (($x10247 (or $x10244 $x10313)))
 (let (($x10170 (and $x10247 $x10204 $x10201 $x10160)))
 (let (($x10253 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x10182 (= $x10253 $x10170)))
 (refl (~ $x10182 $x10182))))))))))))))))))))))
 ))
 (let (($x10242 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x8502 (vstd!seq.Seq.len.? $ ?x1876 ?x1962)))
 (let ((?x10220 (Add write_addr! ?x8502)))
 (let (($x10316 (= (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) 0)))
 (let (($x10313 (= ?x8502 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10238 (and (=> %%global_location_label%%122 $x10313) (=> %%global_location_label%%123 $x10316) (=> %%global_location_label%%124 (and (<= 0 write_addr!) (< write_addr! ?x8518))) (=> %%global_location_label%%125 (<= ?x10220 ?x8518)))))
 (let (($x10253 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (= $x10253 $x10238))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_req__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let ((?x10342 (lambda ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8502 (vstd!seq.Seq.len.? $ ?x1876 ?x1962)))
 (let ((?x10220 (Add write_addr! ?x8502)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x10159 (not %%global_location_label%%125)))
 (let (($x10160 (or $x10159 (>= (+ ?x8518 (* (- 1) ?x10220)) 0))))
 (let (($x10193 (not %%global_location_label%%124)))
 (let (($x10201 (or $x10193 (and (>= write_addr! 0) (not (>= (+ write_addr! (* (- 1) ?x8518)) 0))))))
 (let (($x10316 (= (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) 0)))
 (let (($x10203 (not %%global_location_label%%123)))
 (let (($x10204 (or $x10203 $x10316)))
 (let (($x10313 (= ?x8502 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let (($x10244 (not %%global_location_label%%122)))
 (let (($x10247 (or $x10244 $x10313)))
 (let (($x10170 (and $x10247 $x10204 $x10201 $x10160)))
 (let (($x10253 (req%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x10182 (= $x10253 $x10170)))
 (let (($x10238 (and (=> %%global_location_label%%122 $x10313) (=> %%global_location_label%%123 $x10316) (=> %%global_location_label%%124 (and (<= 0 write_addr!) (< write_addr! ?x8518))) (=> %%global_location_label%%125 (<= ?x10220 ?x8518)))))
 (let (($x10239 (= $x10253 $x10238)))
 (rewrite (= $x10239 $x10182))))))))))))))))))))))))
 ))
 (let ((@x10207 (mp (asserted $x10242) (quant-intro (proof-bind ?x10342) (= $x10242 $x10171)) $x10171)))
 (let ((@x19611 (mp (mp~ @x10207 (nnf-pos (proof-bind ?x15074) (~ $x10171 $x10171)) $x10171) (quant-intro (proof-bind ?x19607) (= $x10171 $x19606)) $x19606)))
 (let (($x62385 (not $x19606)))
 (let (($x62379 (or $x62385 $x62368)))
 (let (($x62080 (or $x10193 (not (or (not (>= 0 0)) (>= (+ 0 ?x56132) 0))))))
 (let (($x62075 (not $x62080)))
 (let (($x62093 (or $x62074 $x62079 $x62075 $x62092)))
 (let (($x62095 (= $x62093 $x62094)))
 (let (($x62096 (not $x62095)))
 (let (($x62382 (or $x62385 $x62096)))
 (let (($x62386 (= $x62382 $x62379)))
 (let (($x62367 (= $x62096 $x62368)))
 (let ((@x62383 (trans (monotonicity (rewrite (= $x62095 $x62354)) $x62367) (rewrite (= $x62368 $x62368)) $x62367)))
 (let ((@x62390 (mp ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47674) 0 (%Poly%vstd!seq.Seq<u8.>. ?x47935)) $x62382) (trans (monotonicity @x62383 $x62386) (rewrite (= $x62379 $x62379)) $x62386) $x62379)))
 (let (($x60522 (not $x62094)))
 (let (($x62341 (= ?x48684 ib_bytes@)))
 (let (($x62455 (= 0 tmp%1)))
 (let (($x62423 (= pmemlog!logimpl_v.incorruptible_bool_pos.? tmp%1)))
 (let ((@x62445 (symm @x58896 (= 0 pmemlog!logimpl_v.incorruptible_bool_pos.?))))
 (let ((@x62457 (monotonicity @x56800 (trans* @x62445 (symm (hypothesis $x47929) $x62423) $x62455) (trans* @x59172 (symm (hypothesis $x47926) (= ?x47925 ib_bytes@)) $x62341) (= $x62094 $x47931))))
 (let ((@x62461 (mp (hypothesis (not $x47931)) (monotonicity (symm @x62457 (= $x47931 $x62094)) (= (not $x47931) $x60522)) $x60522)))
 (let ((@x62462 (unit-resolution (def-axiom (or $x62354 $x48986 $x62094)) @x62461 (unit-resolution @x62390 @x19611 $x62368) $x48986)))
 (let (($x8219 (= pmemlog!pmemspec_t.persistence_chunk_size.? 8)))
 (let (($x8217 (fuel_bool fuel%pmemlog!pmemspec_t.persistence_chunk_size.)))
 (let (($x8211 (fuel_bool_default fuel%pmemlog!pmemspec_t.persistence_chunk_size.)))
 (let (($x55635 (= $x8217 $x8211)))
 (let ((@x55652 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.persistence_chunk_size.) (or (not $x30) $x55635)) @x49237 (hypothesis (not $x55635)) false)))
 (let ((@x55665 (lemma @x55652 $x55635)))
 (let ((@x8214 (asserted $x8211)))
 (let ((@x55643 (def-axiom (or (not $x55635) $x8217 (not $x8211)))))
 (let ((@x62692 (unit-resolution (unit-resolution @x55643 @x8214 (or (not $x55635) $x8217)) @x55665 $x8217)))
 (let (($x8225 (not $x8217)))
 (let (($x8226 (or $x8225 $x8219)))
 (let ((@x8229 (mp (asserted (=> $x8217 $x8219)) (rewrite (= (=> $x8217 $x8219) $x8226)) $x8226)))
 (let ((@x62693 (unit-resolution @x8229 @x62692 $x8219)))
 (let ((@x62463 (hypothesis $x61836)))
 (let ((@x62464 (monotonicity @x59174 (= ?x62067 ?x58972))))
 (let ((@x62466 (trans* @x62464 @x62463 (symm @x62693 (= 8 pmemlog!pmemspec_t.persistence_chunk_size.?)) $x62068)))
 (let ((?x56649 (+ ?x47675 ?x56132)))
 (let (($x56650 (<= ?x56649 0)))
 (let ((@x61442 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x47675 ?x56131)) $x56650)) (symm (monotonicity @x56802 (= ?x56131 ?x47675)) (= ?x47675 ?x56131)) $x56650)))
 (let ((@x62334 ((_ th-lemma arith farkas 1 1 1 1 1 1 1 1) @x58887 (hypothesis $x62124) @x61442 @x58879 @x58857 @x58848 @x58852 @x47689 false)))
 (let ((@x62335 (lemma @x62334 $x62291)))
 (let ((?x62631 (EucMod 0 8)))
 (let (($x62650 (= ?x62631 0)))
 (let (($x1010 (forall ((x Int) (y Int) )(! (= (+ (EucMod x y) (* (- 1) (mod x y))) 0) :pattern ( (EucMod x y) ) :qid prelude_eucmod))
 ))
 (let ((?x10874 (lambda ((x Int) (y Int) )(let (($x1007 (= (+ (EucMod x y) (* (- 1) (mod x y))) 0)))
 (refl (~ $x1007 $x1007))))
 ))
 (let (($x1003 (forall ((x Int) (y Int) )(! (let ((?x1000 (mod x y)))
 (let ((?x999 (EucMod x y)))
 (= ?x999 ?x1000))) :pattern ( (EucMod x y) ) :qid prelude_eucmod))
 ))
 (let ((?x1011 (lambda ((x Int) (y Int) )(let (($x1007 (= (+ (EucMod x y) (* (- 1) (mod x y))) 0)))
 (let ((?x1000 (mod x y)))
 (let ((?x999 (EucMod x y)))
 (let (($x1001 (= ?x999 ?x1000)))
 (rewrite (= $x1001 $x1007)))))))
 ))
 (let ((@x1015 (mp (asserted $x1003) (quant-intro (proof-bind ?x1011) (= $x1003 $x1010)) $x1010)))
 (let ((@x10878 (mp~ @x1015 (nnf-pos (proof-bind ?x10874) (~ $x1010 $x1010)) $x1010)))
 (let (($x54671 (not $x1010)))
 (let (($x49003 (or $x54671 $x62650)))
 (let (($x62635 (= (+ ?x62631 (* (- 1) (mod 0 8))) 0)))
 (let (($x49004 (or $x54671 $x62635)))
 (let (($x62639 (= $x49004 $x49003)))
 (let ((@x62643 (trans (monotonicity (rewrite (= $x62635 $x62650)) $x62639) (rewrite (= $x49003 $x49003)) $x62639)))
 (let ((@x62644 (mp ((_ quant-inst 0 8) $x49004) @x62643 $x49003)))
 (let ((@x62696 (trans* (monotonicity @x62693 (= ?x62076 ?x62631)) (unit-resolution @x62644 @x10878 $x62650) $x62077)))
 (let ((@x62699 (lemma (unit-resolution (hypothesis (not $x62077)) @x62696 false) $x62077)))
 (let ((@x62470 (unit-resolution (def-axiom (or (not $x48986) $x62074 $x62079 $x62292 $x62092)) (unit-resolution (def-axiom (or $x62078 (not $x62077))) @x62699 $x62078) (unit-resolution (def-axiom (or $x62129 $x62124)) @x62335 $x62129) (or (not $x48986) $x62074 $x62092))))
 (let ((@x62471 (unit-resolution @x62470 (unit-resolution (def-axiom (or $x62073 (not $x62068))) @x62466 $x62073) @x62462 $x62092)))
 (let ((?x48759 (* (- 1) ?x7830)))
 (let ((?x48765 (+ pmemlog!logimpl_v.header_crc_offset.? ?x48759)))
 (let (($x48780 (>= ?x48765 (- 8))))
 (let (($x48766 (= ?x48765 (- 8))))
 (let (($x48770 (or $x48769 $x48766)))
 (let (($x48763 (= (+ 8 pmemlog!logimpl_v.header_crc_offset.? ?x48759) 0)))
 (let (($x48771 (or $x48769 $x48763)))
 (let (($x48773 (= $x48771 $x48770)))
 (let ((@x48777 (trans (monotonicity (rewrite (= $x48763 $x48766)) $x48773) (rewrite (= $x48770 $x48770)) $x48773)))
 (let ((@x48778 (mp ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.? 8) $x48771) @x48777 $x48770)))
 (let ((@x58595 (unit-resolution @x48778 @x10850 $x48766)))
 (let ((@x58599 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48766) $x48780)) @x58595 $x48780)))
 (let (($x50286 (<= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7263 (= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7261 (fuel_bool fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x7259 (fuel_bool_default fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x50257 (= $x7261 $x7259)))
 (let ((@x50287 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_crc_offset.) (or (not $x30) $x50257)) @x49237 (hypothesis (not $x50257)) false)))
 (let ((@x50300 (lemma @x50287 $x50257)))
 (let ((@x7260 (asserted $x7259)))
 (let ((@x50278 (def-axiom (or (not $x50257) $x7261 (not $x7259)))))
 (let ((@x58605 (unit-resolution (unit-resolution @x50278 @x7260 (or (not $x50257) $x7261)) @x50300 $x7261)))
 (let (($x7266 (not $x7261)))
 (let (($x7267 (or $x7266 $x7263)))
 (let ((@x7270 (mp (asserted (=> $x7261 $x7263)) (rewrite (= (=> $x7261 $x7263) $x7267)) $x7267)))
 (let ((@x58606 (unit-resolution @x7270 @x58605 $x7263)))
 (let ((@x58607 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7263) $x50286)) @x58606 $x50286)))
 (let (($x62332 (>= (+ ?x7830 (* (- 1) (Add 0 ?x62067))) 0)))
 (let ((?x62060 (Add 0 ?x62067)))
 (let (($x62329 (= ?x7830 ?x62060)))
 (let ((@x62412 (monotonicity (symm @x58606 (= 0 pmemlog!logimpl_v.header_crc_offset.?)) (trans* @x62464 @x62463 (= ?x62067 8)) (= ?x62060 ?x7830))))
 (let ((@x62426 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x62329) $x62332)) (symm @x62412 $x62329) $x62332)))
 (let ((@x62428 ((_ th-lemma arith farkas 1 1 1 1 1 1 1 1 1 1 1) @x58887 @x61442 @x58879 @x58857 @x58848 @x58852 @x62426 @x58607 @x58599 (unit-resolution (def-axiom (or $x62090 $x62306)) @x62471 $x62306) @x47689 false)))
 (let ((@x62438 (lemma @x62428 (or $x47931 (not $x61836) $x48013 $x48047))))
 (let ((@x69024 (unit-resolution @x62438 (mp (unit-resolution (def-axiom (or $x64482 $x64477)) @x69127 $x64477) @x69155 $x61836) @x69209 @x69208 $x47931)))
 (let ((@x48388 (def-axiom (or $x48001 (not $x47931)))))
 (let ((@x48534 (def-axiom (or $x48158 $x48012 $x48147))))
 (let ((@x69026 (unit-resolution @x48534 (unit-resolution @x48388 @x69024 $x48001) @x69264 $x48147)))
 (let ((@x48526 (def-axiom (or $x48146 $x48136))))
 (let ((@x48522 (def-axiom (or $x48145 $x48126 $x48133))))
 (let ((@x69028 (unit-resolution @x48522 (unit-resolution @x48526 @x69026 $x48136) (unit-resolution @x48505 @x69309 $x48128) $x48133)))
 (let ((@x48511 (def-axiom (or $x48130 $x48034))))
 (let ((@x69029 (unit-resolution @x48511 @x69028 $x48034)))
 (let (($x2011 (forall ((x Poly) )(! (let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x2002))))) :pattern ( (has_type x (TYPE%vstd!set.Set. $ INT)) ) :qid internal_vstd__set__Set<int.>_unbox_axiom_definition))
 ))
 (let ((?x11226 (lambda ((x Poly) )(let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (let (($x2007 (not $x1999)))
 (let (($x2008 (or $x2007 $x2002)))
 (refl (~ $x2008 $x2008))))))))
 ))
 (let (($x2005 (forall ((x Poly) )(! (let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (=> $x1999 $x2002)))) :pattern ( (has_type x (TYPE%vstd!set.Set. $ INT)) ) :qid internal_vstd__set__Set<int.>_unbox_axiom_definition))
 ))
 (let ((?x2012 (lambda ((x Poly) )(let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (let (($x2007 (not $x1999)))
 (let (($x2008 (or $x2007 $x2002)))
 (let (($x2003 (=> $x1999 $x2002)))
 (rewrite (= $x2003 $x2008)))))))))
 ))
 (let ((@x2016 (mp (asserted $x2005) (quant-intro (proof-bind ?x2012) (= $x2005 $x2011)) $x2011)))
 (let ((@x11230 (mp~ @x2016 (nnf-pos (proof-bind ?x11226) (~ $x2011 $x2011)) $x2011)))
 (let (($x65851 (not $x2011)))
 (let (($x65852 (or $x65851 $x48035 $x47479)))
 (let ((@x65853 (mp ((_ quant-inst chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28) (or $x65851 (or $x48035 $x47479))) (rewrite (= (or $x65851 (or $x48035 $x47479)) $x65852)) $x65852)))
 (let ((@x69030 (unit-resolution @x65853 @x11230 @x69029 $x47479)))
 (let ((?x60128 (%Poly%vstd!seq.Seq<u8.>. ?x62112)))
 (let ((?x64744 (Poly%vstd!seq.Seq<u8.>. ?x60128)))
 (let ((?x64745 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x55990 ?x7131 ?x64744)))
 (let ((?x64759 (Poly%vstd!seq.Seq<u8.>. ?x64745)))
 (let ((?x65506 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x55990 ?x7131 ?x64744 ?x47547)))
 (let ((?x65507 (Poly%vstd!seq.Seq<u8.>. ?x65506)))
 (let (($x65509 (ext_eq false ?x1968 ?x65507 ?x64759)))
 (let (($x65508 (ext_eq false ?x1968 ?x65507 ?x55990)))
 (let (($x69198 (not $x65508)))
 (let (($x69053 (= ?x63187 ?x47674)))
 (let (($x69066 (not $x69053)))
 (let (($x64848 (= ?x64841 ?x47691)))
 (let (($x66968 (not $x64848)))
 (let (($x64850 (or $x64848 $x64849)))
 (let (($x66942 (not $x64850)))
 (let (($x64840 (%B ?x64784)))
 (let (($x64851 (= $x64840 $x64850)))
 (let (($x64852 (or $x63201 $x64851)))
 (let (($x47913 (forall ((pm_state$ Poly) )(! (let ((?x47745 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47691 (pmemlog!logimpl_v.impl&%0.recover.? ?x47674)))
 (let ((?x47897 (Poly%core!option.Option. ?x47691)))
 (let ((?x47898 (%Poly%core!option.Option. ?x47897)))
 (let ((?x47899 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47898)))
 (let ((?x47900 (pmemlog!infinitelog_t.impl&%0.append.? ?x47899 ?x47745)))
 (let ((?x47901 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47900)))
 (let ((?x47902 (core!option.Option./Some ?x47901)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47894 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x47895 (%B ?x47894)))
 (let (($x47905 (= $x47895 (or (= ?x7629 ?x47691) (= ?x7629 ?x47902)))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x47905)))))))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_56))
 ))
 (let ((?x48046 (lambda ((pm_state$ Poly) )(let ((?x47745 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47691 (pmemlog!logimpl_v.impl&%0.recover.? ?x47674)))
 (let ((?x47897 (Poly%core!option.Option. ?x47691)))
 (let ((?x47898 (%Poly%core!option.Option. ?x47897)))
 (let ((?x47899 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47898)))
 (let ((?x47900 (pmemlog!infinitelog_t.impl&%0.append.? ?x47899 ?x47745)))
 (let ((?x47901 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47900)))
 (let ((?x47902 (core!option.Option./Some ?x47901)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47894 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x47895 (%B ?x47894)))
 (let (($x47905 (= $x47895 (or (= ?x7629 ?x47691) (= ?x7629 ?x47902)))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x47910 (or $x1977 $x47905)))
 (refl (~ $x47910 $x47910)))))))))))))))))))))
 ))
 (let (($x47908 (forall ((pm_state$ Poly) )(! (let ((?x47745 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47691 (pmemlog!logimpl_v.impl&%0.recover.? ?x47674)))
 (let ((?x47897 (Poly%core!option.Option. ?x47691)))
 (let ((?x47898 (%Poly%core!option.Option. ?x47897)))
 (let ((?x47899 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47898)))
 (let ((?x47900 (pmemlog!infinitelog_t.impl&%0.append.? ?x47899 ?x47745)))
 (let ((?x47901 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47900)))
 (let ((?x47902 (core!option.Option./Some ?x47901)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47894 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x47895 (%B ?x47894)))
 (let (($x47905 (= $x47895 (or (= ?x7629 ?x47691) (= ?x7629 ?x47902)))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (=> $x1969 $x47905))))))))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! pm_state$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_56))
 ))
 (let ((?x47914 (lambda ((pm_state$ Poly) )(let ((?x47745 (Poly%vstd!seq.Seq<u8.>. bytes_to_append!)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47691 (pmemlog!logimpl_v.impl&%0.recover.? ?x47674)))
 (let ((?x47897 (Poly%core!option.Option. ?x47691)))
 (let ((?x47898 (%Poly%core!option.Option. ?x47897)))
 (let ((?x47899 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47898)))
 (let ((?x47900 (pmemlog!infinitelog_t.impl&%0.append.? ?x47899 ?x47745)))
 (let ((?x47901 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47900)))
 (let ((?x47902 (core!option.Option./Some ?x47901)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm_state$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47894 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! pm_state$)))
 (let (($x47895 (%B ?x47894)))
 (let (($x47905 (= $x47895 (or (= ?x7629 ?x47691) (= ?x7629 ?x47902)))))
 (let (($x1969 (has_type pm_state$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x47910 (or $x1977 $x47905)))
 (let (($x47906 (=> $x1969 $x47905)))
 (rewrite (= $x47906 $x47910))))))))))))))))))))))
 ))
 (let ((@x47918 (mp (asserted $x47908) (quant-intro (proof-bind ?x47914) (= $x47908 $x47913)) $x47913)))
 (let ((@x48054 (mp~ @x47918 (nnf-pos (proof-bind ?x48046) (~ $x47913 $x47913)) $x47913)))
 (let (($x60688 (not $x47913)))
 (let (($x66821 (or $x60688 $x63201 $x64851)))
 (let ((@x66949 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x47486)) (or $x60688 $x64852)) (rewrite (= (or $x60688 $x64852) $x66821)) $x66821)))
 (let (($x67102 (not $x64840)))
 (let ((@x69270 (monotonicity (symm (monotonicity @x65665 (= ?x48038 ?x64784)) (= ?x64784 ?x48038)) (= $x64840 $x48042))))
 (let ((@x69251 (monotonicity (symm @x69270 (= $x48042 $x64840)) (= (not $x48042) $x67102))))
 (let (($x48512 (not $x48042)))
 (let ((@x48514 (def-axiom (or $x48130 $x48512))))
 (let ((@x69148 (unit-resolution @x48514 @x69028 $x48512)))
 (let ((@x67101 (def-axiom (or (not $x64851) $x64840 $x66942))))
 (let ((@x69260 (unit-resolution @x67101 (mp @x69148 @x69251 $x67102) (unit-resolution (unit-resolution @x66949 @x48054 $x64852) @x65630 $x64851) $x66942)))
 (let ((@x66087 (def-axiom (or $x64850 $x66968))))
 (let ((@x69360 (unit-resolution (hypothesis $x66968) (monotonicity (hypothesis $x69053) $x64848) false)))
 (let ((@x69362 (lemma @x69360 (or $x69066 $x64848))))
 (let (($x69054 (ext_eq false ?x1968 ?x63187 ?x47674)))
 (let (($x68682 (= ?x47547 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_55!28)))
 (let ((@x68683 (symm (hypothesis $x47479) $x68682)))
 (let (($x60670 (= ?x62114 ?x60128)))
 (let (($x46964 (or $x48673 $x60670)))
 (let ((@x61080 ((_ quant-inst (vstd!bytes.spec_u64_to_le_bytes.? ?x47601)) $x46964)))
 (let ((@x69125 (symm (unit-resolution @x61080 @x11202 $x60670) (= ?x60128 ?x62114))))
 (let ((@x69176 (monotonicity @x69125 (= ?x64744 ?x62112))))
 (let ((@x69180 (monotonicity @x56802 @x58900 (trans* @x69176 (symm @x68691 $x62605) (= ?x64744 ?x47935)) @x68683 (= ?x65506 ?x47998))))
 (let ((@x69186 (symm (monotonicity (trans* @x69180 @x63190 (= ?x65506 ?x47486)) (= ?x65507 ?x63187)) (= ?x63187 ?x65507))))
 (let ((@x69191 (mp (hypothesis $x65508) (symm (monotonicity @x69186 @x69062 (= $x69054 $x65508)) (= $x65508 $x69054)) $x69054)))
 (let (($x69063 (not $x69054)))
 (let (($x69057 (= $x69053 $x69054)))
 (let ((@x69195 (unit-resolution (def-axiom (or (not $x69057) $x69053 $x69063)) (hypothesis $x69066) (or (not $x69057) $x69063))))
 (let ((@x69196 (unit-resolution @x69195 (unit-resolution ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. ?x47486) (Poly%vstd!seq.Seq<u8.>. pm!)) (or $x60866 $x69057)) @x10696 $x69057) $x69063)))
 (let ((@x69200 (lemma (unit-resolution @x69196 @x69191 false) (or $x69198 (not $x47479) $x47708 $x69053))))
 (let ((@x69252 (unit-resolution @x69200 (unit-resolution @x69362 (unit-resolution @x66087 @x69260 $x66968) $x69066) @x61101 @x69030 $x69198)))
 (let (($x64778 (forall ((chunks_flushed$ Poly) )(! (let ((?x47601 (I 11756720295082287198)))
 (let ((?x62114 (vstd!bytes.spec_u64_to_le_bytes.? ?x47601)))
 (let ((?x62112 (Poly%vstd!seq.Seq<u8.>. ?x62114)))
 (let ((?x60128 (%Poly%vstd!seq.Seq<u8.>. ?x62112)))
 (let ((?x64744 (Poly%vstd!seq.Seq<u8.>. ?x60128)))
 (let ((?x7131 (I 0)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x48663 (%Poly%vstd!seq.Seq<u8.>. ?x47674)))
 (let ((?x55990 (Poly%vstd!seq.Seq<u8.>. ?x48663)))
 (let ((?x64745 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x55990 ?x7131 ?x64744)))
 (let ((?x64759 (Poly%vstd!seq.Seq<u8.>. ?x64745)))
 (let ((?x64772 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x55990 ?x7131 ?x64744 chunks_flushed$)))
 (let ((?x64774 (Poly%vstd!seq.Seq<u8.>. ?x64772)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 (ext_eq false ?x1968 ?x64774 ?x55990) (ext_eq false ?x1968 ?x64774 ?x64759)))))))))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. pm!))) (I 0) (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I 11756720295082287198))))) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x64769 (ens%pmemlog!logimpl_v.lemma_single_write_crash. ?x48663 0 ?x60128)))
 (let (($x64779 (not $x64769)))
 (let (($x64780 (or $x64779 $x64778)))
 (let ((?x64760 (chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 ?x60128 0 ?x48663)))
 (let ((?x64761 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x55990 ?x7131 ?x64744 ?x64760)))
 (let ((?x64762 (Poly%vstd!seq.Seq<u8.>. ?x64761)))
 (let (($x64767 (or (not (has_type ?x64760 ?x1998)) (ext_eq false ?x1968 ?x64762 ?x55990) (ext_eq false ?x1968 ?x64762 ?x64759))))
 (let (($x64781 (not $x64780)))
 (let (($x64782 (or $x64781 (not (or $x64769 (not $x64767))))))
 (let (($x64783 (not $x64782)))
 (let (($x19625 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6202 (I write_addr!)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x15097 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6680 ?x6202 ?x1962))))
 (let ((?x15090 (chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 bytes_to_write! write_addr! pm!)))
 (let ((?x15093 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x6680 ?x6202 ?x1962 ?x15090)))
 (let ((?x15094 (Poly%vstd!seq.Seq<u8.>. ?x15093)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x15099 (or (not (has_type ?x15090 (TYPE%vstd!set.Set. $ INT))) (ext_eq false ?x1968 ?x15094 ?x6680) (ext_eq false ?x1968 ?x15094 ?x15097))))
 (let (($x15100 (not $x15099)))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x15104 (or $x10208 $x15100)))
 (let (($x10206 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x15081 (not $x10208)))
 (let (($x15105 (or $x15081 $x10206)))
 (not (or (not $x15105) (not $x15104))))))))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let (($x15109 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6202 (I write_addr!)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x15097 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6680 ?x6202 ?x1962))))
 (let ((?x15090 (chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 bytes_to_write! write_addr! pm!)))
 (let ((?x15093 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x6680 ?x6202 ?x1962 ?x15090)))
 (let ((?x15094 (Poly%vstd!seq.Seq<u8.>. ?x15093)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x15099 (or (not (has_type ?x15090 (TYPE%vstd!set.Set. $ INT))) (ext_eq false ?x1968 ?x15094 ?x6680) (ext_eq false ?x1968 ?x15094 ?x15097))))
 (let (($x15100 (not $x15099)))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x15104 (or $x10208 $x15100)))
 (let (($x10206 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x15081 (not $x10208)))
 (let (($x15105 (or $x15081 $x10206)))
 (and $x15105 $x15104))))))))))))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let ((?x19626 (lambda ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6202 (I write_addr!)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x15097 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6680 ?x6202 ?x1962))))
 (let ((?x15090 (chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 bytes_to_write! write_addr! pm!)))
 (let ((?x15093 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x6680 ?x6202 ?x1962 ?x15090)))
 (let ((?x15094 (Poly%vstd!seq.Seq<u8.>. ?x15093)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x15099 (or (not (has_type ?x15090 (TYPE%vstd!set.Set. $ INT))) (ext_eq false ?x1968 ?x15094 ?x6680) (ext_eq false ?x1968 ?x15094 ?x15097))))
 (let (($x15100 (not $x15099)))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x15104 (or $x10208 $x15100)))
 (let (($x10206 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x15081 (not $x10208)))
 (let (($x15105 (or $x15081 $x10206)))
 (let (($x19621 (not (or (not $x15105) (not $x15104)))))
 (let (($x15106 (and $x15105 $x15104)))
 (let (($x19622 (= $x15106 $x19621)))
 (let ((@x19617 (monotonicity (rewrite (= $x15105 $x15105)) (rewrite (= $x15104 $x15104)) (= $x15106 $x15106))))
 (trans @x19617 (rewrite $x19622) $x19622))))))))))))))))))))))
 ))
 (let (($x10176 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let (($x10206 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (= $x10208 $x10206))) :pattern ( (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let ((?x15110 (lambda ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(let ((?x1962 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6202 (I write_addr!)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x15097 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x6680 ?x6202 ?x1962))))
 (let ((?x15090 (chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 bytes_to_write! write_addr! pm!)))
 (let ((?x15093 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x6680 ?x6202 ?x1962 ?x15090)))
 (let ((?x15094 (Poly%vstd!seq.Seq<u8.>. ?x15093)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x15099 (or (not (has_type ?x15090 (TYPE%vstd!set.Set. $ INT))) (ext_eq false ?x1968 ?x15094 ?x6680) (ext_eq false ?x1968 ?x15094 ?x15097))))
 (let (($x15100 (not $x15099)))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x15104 (or $x10208 $x15100)))
 (let (($x10206 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x15081 (not $x10208)))
 (let (($x15105 (or $x15081 $x10206)))
 (let (($x15106 (and $x15105 $x15104)))
 (let (($x10345 (= $x10208 $x10206)))
 (let ((?x15086 (lambda ((chunks_flushed$ Poly) )(let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (let (($x10175 (or $x2007 $x10199 $x10166)))
 (refl (~ $x10175 $x10175)))))))))))))))))
 ))
 (nnf-pos (refl (~ $x10208 $x10208)) (refl (~ $x15081 $x15081)) (nnf-pos (proof-bind ?x15086) (~ $x10206 $x10206)) (sk (~ (not $x10206) $x15100)) (~ $x10345 $x15106))))))))))))))))))))))
 ))
 (let (($x10188 (forall ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(! (let (($x10213 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (=> $x1999 (or $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (= $x10208 $x10213))) :pattern ( (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_single_write_crash._definition))
 ))
 (let ((?x10205 (lambda ((pm! vstd!seq.Seq<u8.>.) (write_addr! Int) (bytes_to_write! vstd!seq.Seq<u8.>.) )(let (($x10206 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x10208 (ens%pmemlog!logimpl_v.lemma_single_write_crash. pm! write_addr! bytes_to_write!)))
 (let (($x10345 (= $x10208 $x10206)))
 (let (($x10213 (forall ((chunks_flushed$ Poly) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x6237 (I write_addr!)))
 (let ((?x9341 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x10165 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x9341 ?x6237 ?x6683))))
 (let ((?x10211 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x9341 ?x6237 ?x6683 chunks_flushed$)))
 (let ((?x10195 (Poly%vstd!seq.Seq<u8.>. ?x10211)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x10166 (ext_eq false ?x1968 ?x10195 ?x10165)))
 (let (($x10199 (ext_eq false ?x1968 ?x10195 ?x9341)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (=> $x1999 (or $x10199 $x10166)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x10214 (= $x10208 $x10213)))
 (rewrite (= $x10214 $x10345))))))))
 ))
 (let ((@x10344 (mp (asserted $x10188) (quant-intro (proof-bind ?x10205) (= $x10188 $x10176)) $x10176)))
 (let ((@x19630 (mp (mp~ @x10344 (nnf-pos (proof-bind ?x15110) (~ $x10176 $x15109)) $x15109) (quant-intro (proof-bind ?x19626) (= $x15109 $x19625)) $x19625)))
 (let ((@x69278 (unit-resolution (def-axiom (or $x64782 $x64780)) (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47674) 0 (%Poly%vstd!seq.Seq<u8.>. ?x62112)) (or (not $x19625) $x64783)) @x19630 $x64783) $x64780)))
 (let (($x62339 (= ?x47925 ib_bytes@)))
 (let ((@x69274 (symm @x69209 $x62339)))
 (let ((@x69325 (trans* @x62445 (symm @x69208 $x62423) $x62455)))
 (let ((@x69312 (monotonicity @x56800 @x69325 (trans* @x69125 (symm @x68689 (= ?x62114 ?x47925)) @x69274 (= ?x60128 ib_bytes@)) (= $x64769 $x47933))))
 (let ((@x69311 (mp (unit-resolution (def-axiom (or $x48146 $x47933)) @x69026 $x47933) (symm @x69312 (= $x47933 $x64769)) $x64769)))
 (let (($x65076 (has_type ?x47547 ?x1998)))
 (let (($x65077 (not $x65076)))
 (let (($x66000 (not $x64778)))
 (let (($x65899 (or $x66000 $x65077 $x65508 $x65509)))
 (let ((@x65912 (mp ((_ quant-inst (Poly%vstd!set.Set<int.>. ?x47546)) (or $x66000 (or $x65077 $x65508 $x65509))) (rewrite (= (or $x66000 (or $x65077 $x65508 $x65509)) $x65899)) $x65899)))
 (let ((@x69317 (unit-resolution @x65912 (mp @x69029 (monotonicity @x69030 (= $x48034 $x65076)) $x65076) (unit-resolution (def-axiom (or $x64781 $x64779 $x64778)) @x69311 @x69278 $x64778) (or $x65508 $x65509))))
 (let (($x69149 (ext_eq false ?x1968 ?x63187 ?x57826)))
 (let ((@x69136 (symm (monotonicity (monotonicity @x58900 @x69176 (= ?x64745 ?x62116)) (= ?x64759 ?x62109)) (= ?x62109 ?x64759))))
 (let ((@x69202 (monotonicity @x69186 (trans* @x68997 (symm @x69141 (= ?x47937 ?x62109)) @x69136 (= ?x57826 ?x64759)) (= $x69149 $x65509))))
 (let (($x69203 (not $x69149)))
 (let (($x69071 (= $x69145 $x69149)))
 (let ((@x69266 (unit-resolution ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. ?x47486) (Poly%vstd!seq.Seq<u8.>. ?x49732)) (or $x60866 $x69071)) @x10696 $x69071)))
 (let ((@x69163 (def-axiom (or (not $x69071) $x69145 $x69203))))
 (let ((@x69019 (unit-resolution (unit-resolution @x69163 (hypothesis (not $x69145)) (or (not $x69071) $x69203)) @x69266 $x69203)))
 (let ((@x69020 (unit-resolution @x69019 (mp (hypothesis $x65509) (symm @x69202 (= $x65509 $x69149)) $x69149) false)))
 (let ((@x69319 (unit-resolution (lemma @x69020 (or (not $x65509) $x47708 (not $x47479) $x69145)) (unit-resolution @x69317 @x69252 $x65509) @x69030 @x61101 $x69145)))
 (let ((@x69246 (unit-resolution (hypothesis (not $x64830)) (symm (monotonicity (hypothesis $x69145) (= ?x64787 ?x61933)) $x64830) false)))
 (let ((@x69248 (lemma @x69246 (or (not $x69145) $x64830))))
 (let (($x55330 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47894 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x55326 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (let (($x1969 (has_type s2$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7766 (has_type s1$ ?x1968)))
 (let (($x17956 (not $x7766)))
 (or $x17956 $x1977 $x7784 (= ?x55326 ?x47894)))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x55331 (not $x47792)))
 (let (($x55332 (or $x55331 $x55330)))
 (let ((?x55306 (s2$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!11 perm! Perm& Perm&.)))
 (let ((?x55280 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x55306)))
 (let ((?x55295 (s1$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!12 perm! Perm& Perm&.)))
 (let ((?x55311 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x55295)))
 (let (($x55312 (= ?x55311 ?x55280)))
 (let ((?x55313 (%%apply%%0 ?x7768 ?x55306)))
 (let ((?x55314 (%%apply%%0 ?x7768 ?x55295)))
 (let (($x55315 (= ?x55314 ?x55313)))
 (let (($x55316 (not $x55315)))
 (let (($x55317 (has_type ?x55306 ?x1968)))
 (let (($x55318 (not $x55317)))
 (let (($x55319 (has_type ?x55295 ?x1968)))
 (let (($x55321 (not $x55319)))
 (let (($x55322 (or $x55321 $x55318 $x55316 $x55312)))
 (let (($x55323 (not $x55322)))
 (let (($x55324 (or $x47792 $x55323)))
 (let (($x55325 (not $x55324)))
 (let (($x55333 (not $x55332)))
 (let (($x55334 (or $x55333 $x55325)))
 (let (($x55335 (not $x55334)))
 (let (($x18004 (forall ((Perm&. Dcr) (Perm& Type) (perm! Poly) )(! (let ((?x14043 (s2$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!11 perm! Perm& Perm&.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x14054 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x14043)))
 (let ((?x14044 (s1$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!12 perm! Perm& Perm&.)))
 (let ((?x14053 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x14044)))
 (let (($x14055 (= ?x14053 ?x14054)))
 (let (($x14051 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) ?x14044) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) ?x14043))))
 (let (($x14052 (not $x14051)))
 (let (($x18005 (not (or (not (has_type ?x14044 ?x1968)) (not (has_type ?x14043 ?x1968)) $x14052 $x14055))))
 (let (($x7765 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x17976 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (let (($x1969 (has_type s2$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7766 (has_type s1$ ?x1968)))
 (let (($x17956 (not $x7766)))
 (or $x17956 $x1977 $x7784 $x7774)))))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x14034 (not $x7765)))
 (not (or (not (or $x14034 $x17976)) (not (or $x7765 $x18005))))))))))))))))) :pattern ( (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!) ) :qid internal_pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.?_definition))
 ))
 (let (($x7764 (fuel_bool fuel%pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.)))
 (let (($x7762 (fuel_bool_default fuel%pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.)))
 (let (($x55290 (= $x7764 $x7762)))
 (let ((@x55307 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.) (or (not $x30) $x55290)) @x49237 (hypothesis (not $x55290)) false)))
 (let ((@x55320 (lemma @x55307 $x55290)))
 (let ((@x7763 (asserted $x7762)))
 (let ((@x55298 (def-axiom (or (not $x55290) $x7764 (not $x7762)))))
 (let ((@x69327 (unit-resolution (unit-resolution @x55298 @x7763 (or (not $x55290) $x7764)) @x55320 $x7764)))
 (let (($x7795 (not $x7764)))
 (let (($x17957 (or $x7795 $x18004)))
 (let (($x14066 (forall ((Perm&. Dcr) (Perm& Type) (perm! Poly) )(! (let ((?x14043 (s2$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!11 perm! Perm& Perm&.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x14054 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x14043)))
 (let ((?x14044 (s1$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!12 perm! Perm& Perm&.)))
 (let ((?x14053 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x14044)))
 (let (($x14055 (= ?x14053 ?x14054)))
 (let (($x14051 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) ?x14044) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) ?x14043))))
 (let (($x14052 (not $x14051)))
 (let (($x14057 (not (or (not (and (has_type ?x14044 ?x1968) (has_type ?x14043 ?x1968))) $x14052 $x14055))))
 (let (($x7765 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x7797 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (or (not (and (has_type s1$ ?x1968) (has_type s2$ ?x1968))) $x7784 $x7774)))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x14034 (not $x7765)))
 (and (or $x14034 $x7797) (or $x7765 $x14057))))))))))))))) :pattern ( (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!) ) :qid internal_pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.?_definition))
 ))
 (let (($x14071 (or $x7795 $x14066)))
 (let (($x7785 (forall ((Perm&. Dcr) (Perm& Type) (perm! Poly) )(! (let (($x7797 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (or (not (and (has_type s1$ ?x1968) (has_type s2$ ?x1968))) $x7784 $x7774)))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x7765 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (= $x7765 $x7797))) :pattern ( (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!) ) :qid internal_pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.?_definition))
 ))
 (let (($x7796 (or $x7795 $x7785)))
 (let ((?x14067 (lambda ((Perm&. Dcr) (Perm& Type) (perm! Poly) )(let ((?x14043 (s2$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!11 perm! Perm& Perm&.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x14054 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x14043)))
 (let ((?x14044 (s1$!skolem_user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33!12 perm! Perm& Perm&.)))
 (let ((?x14053 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x14044)))
 (let (($x14055 (= ?x14053 ?x14054)))
 (let (($x14051 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) ?x14044) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) ?x14043))))
 (let (($x14052 (not $x14051)))
 (let (($x14057 (not (or (not (and (has_type ?x14044 ?x1968) (has_type ?x14043 ?x1968))) $x14052 $x14055))))
 (let (($x7765 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x7797 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (or (not (and (has_type s1$ ?x1968) (has_type s2$ ?x1968))) $x7784 $x7774)))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x14034 (not $x7765)))
 (let (($x14063 (and (or $x14034 $x7797) (or $x7765 $x14057))))
 (let (($x7802 (= $x7765 $x7797)))
 (let ((?x14039 (lambda ((s1$ Poly) (s2$ Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (let (($x7792 (or (not (and (has_type s1$ ?x1968) (has_type s2$ ?x1968))) $x7784 $x7774)))
 (refl (~ $x7792 $x7792)))))))))))
 ))
 (nnf-pos (refl (~ $x7765 $x7765)) (refl (~ $x14034 $x14034)) (nnf-pos (proof-bind ?x14039) (~ $x7797 $x7797)) (sk (~ (not $x7797) $x14057)) (~ $x7802 $x14063)))))))))))))))))))
 ))
 (let ((@x14073 (monotonicity (refl (~ $x7795 $x7795)) (nnf-pos (proof-bind ?x14067) (~ $x7785 $x14066)) (~ $x7796 $x14071))))
 (let (($x7781 (forall ((Perm&. Dcr) (Perm& Type) (perm! Poly) )(! (let (($x7778 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x1969 (has_type s2$ ?x1968)))
 (let (($x7766 (has_type s1$ ?x1968)))
 (let (($x7767 (and $x7766 $x1969)))
 (=> (and $x7767 $x7771) $x7774)))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x7765 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (= $x7765 $x7778))) :pattern ( (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!) ) :qid internal_pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.?_definition))
 ))
 (let (($x7782 (=> $x7764 $x7781)))
 (let ((?x7786 (lambda ((Perm&. Dcr) (Perm& Type) (perm! Poly) )(let (($x7797 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x7784 (not $x7771)))
 (or (not (and (has_type s1$ ?x1968) (has_type s2$ ?x1968))) $x7784 $x7774)))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x7765 (pmemlog!logimpl_v.permissions_depend_only_on_recovery_view.? Perm&. Perm& perm!)))
 (let (($x7802 (= $x7765 $x7797)))
 (let (($x7778 (forall ((s1$ Poly) (s2$ Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x7773 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s2$)))
 (let ((?x7772 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! s1$)))
 (let (($x7774 (= ?x7772 ?x7773)))
 (let (($x7771 (= (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s1$) (%%apply%%0 (pmemlog!main_t.recovery_view.? (I 0)) s2$))))
 (let (($x1969 (has_type s2$ ?x1968)))
 (let (($x7766 (has_type s1$ ?x1968)))
 (let (($x7767 (and $x7766 $x1969)))
 (=> (and $x7767 $x7771) $x7774)))))))))) :pattern ( (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s1$) (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ (TYPE%vstd!seq.Seq. $ (UINT 8)) perm! s2$) ) :qid user_pmemlog__logimpl_v__permissions_depend_only_on_recovery_view_33))
 ))
 (let (($x7779 (= $x7765 $x7778)))
 (rewrite (= $x7779 $x7802))))))))
 ))
 (let ((@x7794 (monotonicity (quant-intro (proof-bind ?x7786) (= $x7781 $x7785)) (= $x7782 (=> $x7764 $x7785)))))
 (let ((@x7804 (mp (asserted $x7782) (trans @x7794 (rewrite (= (=> $x7764 $x7785) $x7796)) (= $x7782 $x7796)) $x7796)))
 (let ((@x17959 (mp (mp (mp~ @x7804 @x14073 $x14071) (rewrite (= $x14071 $x14071)) $x14071) (rewrite (= $x14071 $x17957)) $x17957)))
 (let (($x55347 (or (not $x18004) $x55335)))
 (let ((@x55348 ((_ quant-inst Perm&. Perm& perm!) $x55347)))
 (let ((@x55374 (def-axiom (or $x55334 $x55332))))
 (let ((@x69330 (unit-resolution @x55374 (unit-resolution @x55348 (unit-resolution @x17959 @x69327 $x18004) $x55335) $x55332)))
 (let ((@x47793 (asserted $x47792)))
 (let ((@x55355 (def-axiom (or $x55333 $x55331 $x55330))))
 (let (($x64831 (not $x64830)))
 (let (($x55351 (not $x55330)))
 (let (($x67007 (or $x55351 $x61235 $x63201 $x64831 $x64838)))
 (let ((@x67029 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x49732) (Poly%vstd!seq.Seq<u8.>. ?x47486)) (or $x55351 (or $x61235 $x63201 $x64831 $x64838))) (rewrite (= (or $x55351 (or $x61235 $x63201 $x64831 $x64838)) $x67007)) $x67007)))
 (let ((@x69348 (unit-resolution @x67029 (unit-resolution (unit-resolution @x55355 @x47793 (or $x55333 $x55330)) @x69330 $x55330) @x65677 (or $x63201 $x64831 $x64838))))
 (let ((@x69345 (symm (unit-resolution @x69348 (unit-resolution @x69248 @x69319 $x64830) @x65630 $x64838) $x64890)))
 (let ((@x69144 (monotonicity @x65665 (= ?x48038 ?x64784))))
 (let ((@x69351 (trans* @x69144 @x69345 @x65684 @x65680 (monotonicity @x65652 (= ?x62063 ?x55926)) (symm (unit-resolution @x56264 @x10626 @x65494 $x55911) (= ?x55926 ?x47789)) $x61147)))
 (let ((@x65789 (trans* (symm (iff-false @x69148 (= $x48042 false)) (= false $x48042)) (monotonicity @x69351 (= $x48042 $x47790)) @x48572 $x65729)))
 (let ((@x66662 (unit-resolution (lemma (mp @x65789 (rewrite (= $x65729 false)) false) (or $x48159 $x47708)) @x61101 $x48159)))
 (let (($x48165 (or $x48055 $x48160)))
 (let (($x48195 (not (or (or $x48056 $x48035) $x48042))))
 (let (($x48184 (or $x48039 (not (or (or (or $x48118 $x48119) (or $x48120 $x48121)) (or $x48122 $x48123))))))
 (let (($x48187 (not $x48184)))
 (let (($x48193 (or $x48187 $x48195)))
 (let (($x48200 (not (or $x48050 (not $x48193)))))
 (let (($x48203 (or $x48012 $x48200)))
 (let (($x48204 (not $x48203)))
 (let (($x48214 (or $x48024 $x48047)))
 (let (($x48213 (or $x48029 $x48013)))
 (let (($x48215 (or $x48213 $x48214)))
 (let (($x48221 (not (or $x48215 $x48204))))
 (let (($x48208 (or $x48055 $x48221)))
 (let (($x48044 (not (or $x48035 $x48042))))
 (let (($x48068 (and %%location_label%%3 $x48044)))
 (let (($x48040 (or $x48039 (and $x48011 $x48021 $x47966 $x47968 $x47972 $x47974))))
 (let (($x48019 (not $x48040)))
 (let (($x48072 (or $x48019 $x48068)))
 (let (($x48076 (and $x47933 $x48072)))
 (let (($x48080 (or $x48012 $x48076)))
 (let (($x48084 (and $x47922 $x47926 $x47927 $x47929 $x48080)))
 (let (($x48088 (or $x48055 $x48084)))
 (let (($x48048 (forall ((chunks_flushed$ Poly) )(! (let ((?x47924 (I new_ib!)))
 (let ((?x47925 (vstd!bytes.spec_u64_to_le_bytes.? ?x47924)))
 (let ((?x47935 (Poly%vstd!seq.Seq<u8.>. ?x47925)))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47978 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47674 ?x7427 ?x47935 chunks_flushed$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47980 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! (Poly%vstd!seq.Seq<u8.>. ?x47978))))
 (let (($x47981 (%B ?x47980)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x47981)))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.incorruptible_bool_pos.?) (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!))) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_55))
 ))
 (let (($x48057 (or $x48056 $x48048)))
 (let (($x48062 (and $x48040 $x48057)))
 (let (($x48051 (or $x48050 $x48062)))
 (let (($x48058 (and $x48001 $x48051)))
 (let (($x48030 (or $x48029 $x48013 $x48024 $x48047 $x48058)))
 (let (($x48059 (not (and $x47997 $x48030))))
 (let ((@x48071 (nnf-neg (refl (~ %%location_label%%3 %%location_label%%3)) (sk (~ (not $x48048) $x48044)) (~ (not $x48057) $x48068))))
 (let ((@x48079 (nnf-neg (refl (~ $x47933 $x47933)) (nnf-neg (refl (~ $x48019 $x48019)) @x48071 (~ (not $x48062) $x48072)) (~ (not $x48051) $x48076))))
 (let ((@x48087 (nnf-neg (refl (~ $x47922 $x47922)) (refl (~ $x47926 $x47926)) (refl (~ $x47927 $x47927)) (refl (~ $x47929 $x47929)) (nnf-neg (refl (~ $x48012 $x48012)) @x48079 (~ (not $x48058) $x48080)) (~ (not $x48030) $x48084))))
 (let (($x47984 (forall ((chunks_flushed$ Poly) )(! (let ((?x47924 (I new_ib!)))
 (let ((?x47925 (vstd!bytes.spec_u64_to_le_bytes.? ?x47924)))
 (let ((?x47935 (Poly%vstd!seq.Seq<u8.>. ?x47925)))
 (let ((?x7427 (I pmemlog!logimpl_v.incorruptible_bool_pos.?)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47978 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47674 ?x7427 ?x47935 chunks_flushed$)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x47980 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! (Poly%vstd!seq.Seq<u8.>. ?x47978))))
 (let (($x47981 (%B ?x47980)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (=> $x1999 $x47981))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.incorruptible_bool_pos.?) (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!))) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_append_ib_update_55))
 ))
 (let (($x47957 (and (and ((_ is-tuple%2./tuple%2 tuple%2./tuple%2  is-tuple%2./tuple%2) ?x47946) ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x47951)) ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) ?x47955))))
 (let (($x47976 (=> %%location_label%%2 (and (and (and $x47957 (and $x47966 $x47968)) $x47972) $x47974))))
 (let (($x47988 (and (=> %%location_label%%1 $x47931) (=> $x47933 (and $x47976 (=> %%location_label%%3 $x47984))))))
 (let (($x47993 (and (=> %%location_label%%0 $x47920) (=> (and $x47922 $x47926 $x47927 $x47929) $x47988))))
 (let (($x47994 (not $x47993)))
 (let ((@x48091 (mp~ (mp (asserted $x47994) (rewrite (= $x47994 $x48059)) $x48059) (nnf-neg (refl (~ $x48055 $x48055)) @x48087 (~ $x48059 $x48088)) $x48088)))
 (let ((@x48209 (mp (mp @x48091 (rewrite (= $x48088 $x48165)) $x48165) (rewrite (= $x48165 $x48208)) $x48208)))
 (let ((@x48252 (mp @x48209 (rewrite (= $x48208 $x48165)) $x48165)))
 (let ((@x48381 (def-axiom (or $x47997 $x48379))))
 (let ((@x66655 (unit-resolution @x48381 (unit-resolution @x48252 @x66662 $x48055) $x48379)))
 (let ((@x67053 (mp @x66655 @x60771 $x56151)))
 (let ((@x61546 (monotonicity @x61544 (= ?x56019 ?x47743))))
 (let ((@x61573 (symm (monotonicity @x61546 @x61514 (= ?x56098 (Add ?x47743 ?x47746))) (= (Add ?x47743 ?x47746) ?x56098))))
 (let ((?x47747 (Add ?x47743 ?x47746)))
 (let ((?x47733 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x47732)))
 (let ((?x47734 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x47733)))
 (let ((?x47735 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x47734)))
 (let ((?x47736 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x47735)))
 (let ((?x47737 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x47736)))
 (let (($x47748 (= ?x47737 ?x47747)))
 (let ((?x47749 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x47736)))
 (let ((?x47757 (Sub ?x47737 ?x47749)))
 (let ((?x47768 (* (- 1) ?x47757)))
 (let ((?x47753 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x47736)))
 (let ((?x47769 (+ ?x47753 ?x47768)))
 (let (($x47770 (<= ?x47769 0)))
 (let (($x47773 (not $x47770)))
 (let (($x47755 (= ?x47753 ?x47754)))
 (let (($x47751 (= ?x47749 ?x47750)))
 (let (($x47779 (and $x47748 $x47751 $x47755 $x47773)))
 (let (($x47761 (and $x47748 $x47751 $x47755)))
 (let (($x47775 (and $x47761 $x47773)))
 (let (($x47758 (< ?x47757 ?x47753)))
 (let (($x47756 (and (and $x47748 $x47751) $x47755)))
 (let (($x47759 (and $x47756 $x47758)))
 (let ((@x47772 (trans (rewrite (= $x47758 (not (<= ?x47753 ?x47757)))) (rewrite (= (not (<= ?x47753 ?x47757)) $x47773)) (= $x47758 $x47773))))
 (let ((@x47783 (trans (monotonicity (rewrite (= $x47756 $x47761)) @x47772 (= $x47759 $x47775)) (rewrite (= $x47775 $x47779)) (= $x47759 $x47779))))
 (let ((@x47784 (mp (asserted $x47759) @x47783 $x47779)))
 (let ((@x47785 (and-elim @x47784 $x47748)))
 (let ((@x61540 (monotonicity (monotonicity (monotonicity @x58473 $x61547) (= ?x56082 ?x47732)) (= ?x56083 ?x47733))))
 (let ((@x61569 (monotonicity (monotonicity (monotonicity @x61540 (= ?x56084 ?x47734)) (= ?x56085 ?x47735)) (= ?x56086 ?x47736))))
 (let ((@x61552 (monotonicity @x61569 (= ?x56088 ?x47737))))
 (let ((@x47787 (and-elim @x47784 $x47755)))
 (let ((@x61581 (monotonicity @x61569 (= ?x56091 ?x47753))))
 (let ((@x47786 (and-elim @x47784 $x47751)))
 (let ((@x61575 (monotonicity @x61569 (= ?x56087 ?x47749))))
 (let ((@x60622 (trans* @x61575 @x47786 (symm (monotonicity @x61544 (= ?x56029 ?x47750)) (= ?x47750 ?x56029)) $x56096)))
 (let (($x61142 (not $x56183)))
 (let ((@x47788 (and-elim @x47784 $x47773)))
 (let ((?x60749 (+ ?x47753 ?x56181)))
 (let (($x60750 (<= ?x60749 0)))
 (let ((@x60926 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x47753 ?x56091)) $x60750)) (symm @x61581 (= ?x47753 ?x56091)) $x60750)))
 (let ((?x56090 (* (- 1) ?x56089)))
 (let ((?x60753 (+ ?x47757 ?x56090)))
 (let (($x60755 (>= ?x60753 0)))
 (let ((@x61589 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x47757 ?x56089)) $x60755)) (symm (monotonicity @x61552 @x61575 (= ?x56089 ?x47757)) (= ?x47757 ?x56089)) $x60755)))
 (let ((@x60973 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 1) (or $x61142 (not $x60750) $x47770 (not $x60755))) @x61589 @x60926 @x47788 $x61142)))
 (let ((@x60992 (def-axiom (or $x56194 $x56100 $x56097 $x56095 $x56183))))
 (let ((@x47140 (unit-resolution @x60992 @x60973 @x60622 (trans* @x61581 @x47787 (symm @x60976 (= ?x47754 ?x56017)) $x56094) (or $x56194 $x56100))))
 (let ((@x60971 (def-axiom (or $x56174 $x56188))))
 (let ((@x60546 (unit-resolution @x60971 (unit-resolution @x47140 (trans* @x61552 @x47785 @x61573 $x56099) $x56194) $x56174)))
 (let ((@x61383 (def-axiom (or $x56074 $x55331))))
 (let ((@x61509 (unit-resolution @x61383 @x47793 $x56074)))
 (let ((@x61445 (unit-resolution (def-axiom (or $x56161 $x56162)) @x61320 $x56161)))
 (let ((@x60946 (def-axiom (or $x56136 $x56134))))
 (let ((@x60548 (unit-resolution @x60946 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1) (or $x56135 (not $x56650) $x47682)) @x61442 @x47689 $x56135) $x56136)))
 (let (($x60915 (not $x56005)))
 (let ((@x60459 (hypothesis $x56009)))
 (let ((@x60999 (def-axiom (or $x56008 $x60915))))
 (let ((@x60536 (unit-resolution @x60999 @x60459 $x60915)))
 (let (($x60903 (= ?x55999 ?x47902)))
 (let (($x60902 (= ?x55999 ?x47691)))
 (let (($x60910 (or $x60902 $x60903)))
 (let (($x60911 (= $x56004 $x60910)))
 (let (($x60763 (or $x60688 $x56007 $x60911)))
 (let ((@x60768 (mp ((_ quant-inst (pm_state$!skolem_user_pmemlog__logimpl_v__lemma_append_ib_update_effect_on_committed_49!24 perm! ?x48676 ?x48663 Perm& Perm&.)) (or $x60688 (or $x56007 $x60911))) (rewrite (= (or $x60688 (or $x56007 $x60911)) $x60763)) $x60763)))
 (let ((@x61790 (unit-resolution @x60768 @x48054 (unit-resolution (def-axiom (or $x56008 $x56006)) @x60459 $x56006) $x60911)))
 (let (($x60841 (not $x56002)))
 (let ((@x62136 (hypothesis $x60841)))
 (let ((@x46957 (def-axiom (or $x56005 $x56004 $x56002))))
 (let ((@x61436 (def-axiom (or (not $x60911) (not $x56004) $x60910))))
 (let ((@x62138 (unit-resolution @x61436 (unit-resolution @x46957 @x62136 (hypothesis $x60915) $x56004) (hypothesis $x60911) $x60910)))
 (let (($x61370 (not $x60903)))
 (let (($x62270 (= $x56000 $x60903)))
 (let (($x62268 (= $x60903 $x56000)))
 (let ((?x56694 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x48585)))
 (let ((?x56845 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x56694)))
 (let ((?x49139 (core!option.Option./Some/?0 ?x47951)))
 (let (($x49140 (= ?x47958 ?x49139)))
 (let (($x49148 (or $x48118 $x49140)))
 (let (($x2150 (forall ((V&. Dcr) (V& Type) (x core!option.Option.) )(! (let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2138 ((_ is core!option.Option./Some ) x)))
 (let (($x2144 (not $x2138)))
 (or $x2144 $x2133))))) :pattern ( (core!option.Option./Some/0 V&. V& x) ) :qid internal_core!option.Option./Some/0_accessor_definition))
 ))
 (let ((?x11310 (lambda ((V&. Dcr) (V& Type) (x core!option.Option.) )(let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2138 ((_ is core!option.Option./Some ) x)))
 (let (($x2144 (not $x2138)))
 (let (($x2145 (or $x2144 $x2133)))
 (refl (~ $x2145 $x2145))))))))
 ))
 (let (($x2136 (forall ((V&. Dcr) (V& Type) (x core!option.Option.) )(! (let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2130 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) x)))
 (=> $x2130 $x2133)))) :pattern ( (core!option.Option./Some/0 V&. V& x) ) :qid internal_core!option.Option./Some/0_accessor_definition))
 ))
 (let ((?x2151 (lambda ((V&. Dcr) (V& Type) (x core!option.Option.) )(let ((?x2131 (core!option.Option./Some/0 V&. V& x)))
 (let (($x2133 (= ?x2131 (core!option.Option./Some/?0 x))))
 (let (($x2138 ((_ is core!option.Option./Some ) x)))
 (let (($x2144 (not $x2138)))
 (let (($x2145 (or $x2144 $x2133)))
 (let (($x2130 ((_ is-core!option.Option./Some core!option.Option./Some  is-core!option.Option./Some) x)))
 (let (($x2134 (=> $x2130 $x2133)))
 (trans (monotonicity (rewrite (= $x2130 $x2138)) (= $x2134 (=> $x2138 $x2133))) (rewrite (= (=> $x2138 $x2133) $x2145)) (= $x2134 $x2145))))))))))
 ))
 (let ((@x2155 (mp (asserted $x2136) (quant-intro (proof-bind ?x2151) (= $x2136 $x2150)) $x2150)))
 (let ((@x11314 (mp~ @x2155 (nnf-pos (proof-bind ?x11310) (~ $x2150 $x2150)) $x2150)))
 (let (($x49141 (not $x2150)))
 (let (($x49151 (or $x49141 $x48118 $x49140)))
 (let ((@x49156 (mp ((_ quant-inst $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x47950)) (or $x49141 $x49148)) (rewrite (= (or $x49141 $x49148) $x49151)) $x49151)))
 (let ((@x62193 (unit-resolution (unit-resolution @x49156 @x11314 $x49148) @x62192 $x49140)))
 (let ((@x62209 (symm @x62193 (= ?x49139 ?x47958))))
 (let ((@x62205 (monotonicity (trans* @x62178 @x62180 (= ?x47951 ?x48586)) (= ?x49139 (core!option.Option./Some/?0 ?x48586)))))
 (let ((@x62207 (symm @x62205 (= (core!option.Option./Some/?0 ?x48586) ?x49139))))
 (let ((?x48588 (core!option.Option./Some/?0 ?x48586)))
 (let (($x48589 (= ?x48585 ?x48588)))
 (let ((@x62140 ((_ th-lemma datatype) $x48589)))
 (let ((@x62225 (symm (monotonicity (trans* @x62140 @x62207 @x62209 (= ?x48585 ?x47958)) (= ?x56694 ?x47959)) (= ?x47959 ?x56694))))
 (let ((@x62243 (symm (monotonicity @x62225 (= ?x47963 ?x56845)) (= ?x56845 ?x47963))))
 (let (($x56848 (= ?x48585 ?x56845)))
 (let (($x56840 (has_type ?x48585 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((?x55796 (%Poly%core!option.Option. ?x48395)))
 (let ((?x55853 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x55796)))
 (let (($x55876 (has_type ?x55853 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((@x62197 (symm @x62170 (= ?x49172 ?x47950))))
 (let ((@x62195 (symm @x62168 (= ?x48395 ?x49172))))
 (let ((@x62203 (monotonicity (monotonicity (trans* @x62195 @x62197 (= ?x48395 ?x47950)) (= ?x55796 ?x47951)) (= ?x55853 ?x47958))))
 (let ((@x62215 (monotonicity (trans* @x62140 @x62207 @x62209 (symm @x62203 (= ?x47958 ?x55853)) (= ?x48585 ?x55853)) (= $x56840 $x55876))))
 (let ((?x7704 (TYPE%core!option.Option. $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x55798 (has_type ?x48395 ?x7704)))
 (let ((@x62156 (monotonicity (trans* @x62146 @x62150 @x62152 (= ?x48395 ?x47897)) (= $x55798 (has_type ?x47897 ?x7704)))))
 (let (($x48688 (has_type ?x47897 ?x7704)))
 (let (($x48689 (or $x48649 $x48688)))
 (let (($x7717 (forall ((pm! Poly) )(! (let ((?x7704 (TYPE%core!option.Option. $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let ((?x7703 (Poly%core!option.Option. ?x7629)))
 (let (($x7706 (has_type ?x7703 ?x7704)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type pm! ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x7706))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.recover.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.recover.?_pre_post_definition))
 ))
 (let ((?x13997 (lambda ((pm! Poly) )(let ((?x7704 (TYPE%core!option.Option. $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let ((?x7703 (Poly%core!option.Option. ?x7629)))
 (let (($x7706 (has_type ?x7703 ?x7704)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type pm! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7714 (or $x1977 $x7706)))
 (refl (~ $x7714 $x7714))))))))))))
 ))
 (let (($x7710 (forall ((pm! Poly) )(! (let ((?x7704 (TYPE%core!option.Option. $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let ((?x7703 (Poly%core!option.Option. ?x7629)))
 (let (($x7706 (has_type ?x7703 ?x7704)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type pm! ?x1968)))
 (=> $x1969 $x7706)))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.recover.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.recover.?_pre_post_definition))
 ))
 (let ((?x7720 (lambda ((pm! Poly) )(let ((?x7704 (TYPE%core!option.Option. $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let ((?x7703 (Poly%core!option.Option. ?x7629)))
 (let (($x7706 (has_type ?x7703 ?x7704)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type pm! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7714 (or $x1977 $x7706)))
 (let (($x7707 (=> $x1969 $x7706)))
 (rewrite (= $x7707 $x7714)))))))))))))
 ))
 (let ((@x7725 (mp (asserted $x7710) (quant-intro (proof-bind ?x7720) (= $x7710 $x7717)) $x7717)))
 (let ((@x14001 (mp~ @x7725 (nnf-pos (proof-bind ?x13997) (~ $x7717 $x7717)) $x7717)))
 (let (($x48694 (not $x7717)))
 (let (($x48695 (or $x48694 $x48649 $x48688)))
 (let ((@x48700 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) (or $x48694 $x48689)) (rewrite (= (or $x48694 $x48689) $x48695)) $x48695)))
 (let ((@x62159 (mp (unit-resolution (unit-resolution @x48700 @x14001 $x48689) @x56813 $x48688) (symm @x62156 (= $x48688 $x55798)) $x55798)))
 (let (($x55850 (not $x55798)))
 (let (($x55885 (or $x55850 $x55876)))
 (let (($x2165 (forall ((V&. Dcr) (V& Type) (x Poly) )(! (let ((?x2089 (%Poly%core!option.Option. x)))
 (let ((?x2156 (core!option.Option./Some/0 V&. V& ?x2089)))
 (let (($x2157 (has_type ?x2156 V&)))
 (let ((?x2087 (TYPE%core!option.Option. V&. V&)))
 (let (($x2088 (has_type x ?x2087)))
 (let (($x2096 (not $x2088)))
 (or $x2096 $x2157))))))) :pattern ( (core!option.Option./Some/0 V&. V& (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&)) ) :qid internal_core!option.Option./Some/0_invariant_definition))
 ))
 (let ((?x11317 (lambda ((V&. Dcr) (V& Type) (x Poly) )(let ((?x2089 (%Poly%core!option.Option. x)))
 (let ((?x2156 (core!option.Option./Some/0 V&. V& ?x2089)))
 (let (($x2157 (has_type ?x2156 V&)))
 (let ((?x2087 (TYPE%core!option.Option. V&. V&)))
 (let (($x2088 (has_type x ?x2087)))
 (let (($x2096 (not $x2088)))
 (let (($x2162 (or $x2096 $x2157)))
 (refl (~ $x2162 $x2162))))))))))
 ))
 (let (($x2160 (forall ((V&. Dcr) (V& Type) (x Poly) )(! (let ((?x2089 (%Poly%core!option.Option. x)))
 (let ((?x2156 (core!option.Option./Some/0 V&. V& ?x2089)))
 (let (($x2157 (has_type ?x2156 V&)))
 (let ((?x2087 (TYPE%core!option.Option. V&. V&)))
 (let (($x2088 (has_type x ?x2087)))
 (=> $x2088 $x2157)))))) :pattern ( (core!option.Option./Some/0 V&. V& (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&)) ) :qid internal_core!option.Option./Some/0_invariant_definition))
 ))
 (let ((?x2166 (lambda ((V&. Dcr) (V& Type) (x Poly) )(let ((?x2089 (%Poly%core!option.Option. x)))
 (let ((?x2156 (core!option.Option./Some/0 V&. V& ?x2089)))
 (let (($x2157 (has_type ?x2156 V&)))
 (let ((?x2087 (TYPE%core!option.Option. V&. V&)))
 (let (($x2088 (has_type x ?x2087)))
 (let (($x2096 (not $x2088)))
 (let (($x2162 (or $x2096 $x2157)))
 (let (($x2158 (=> $x2088 $x2157)))
 (rewrite (= $x2158 $x2162)))))))))))
 ))
 (let ((@x2170 (mp (asserted $x2160) (quant-intro (proof-bind ?x2166) (= $x2160 $x2165)) $x2165)))
 (let ((@x11321 (mp~ @x2170 (nnf-pos (proof-bind ?x11317) (~ $x2165 $x2165)) $x2165)))
 (let (($x55886 (not $x2165)))
 (let (($x55888 (or $x55886 $x55850 $x55876)))
 (let ((?x55786 (%Poly%core!option.Option. ?x48399)))
 (let ((?x55787 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x55786)))
 (let (($x55788 (has_type ?x55787 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x55806 (has_type ?x48399 ?x7704)))
 (let (($x55782 (not $x55806)))
 (let (($x55789 (or $x55782 $x55788)))
 (let (($x55896 (or $x55886 $x55789)))
 (let ((@x55902 (trans (monotonicity (rewrite (= $x55789 $x55885)) (= $x55896 (or $x55886 $x55885))) (rewrite (= (or $x55886 $x55885) $x55888)) (= $x55896 $x55888))))
 (let ((@x55907 (mp ((_ quant-inst $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (tuple%2./tuple%2/?0 ?x48397)) $x55896) @x55902 $x55888)))
 (let ((@x62218 (mp (unit-resolution (unit-resolution @x55907 @x11321 $x55885) @x62159 $x55876) (symm @x62215 (= $x55876 $x56840)) $x56840)))
 (let (($x56842 (not $x56840)))
 (let (($x56847 (or $x56842 $x56848)))
 (let (($x2554 (forall ((x Poly) )(! (let ((?x2543 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x)))
 (let (($x2545 (= x (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x2543))))
 (let (($x2542 (has_type x TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x2550 (not $x2542)))
 (or $x2550 $x2545))))) :pattern ( (has_type x TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.) ) :qid internal_pmemlog__infinitelog_t__AbstractInfiniteLogState_unbox_axiom_definition))
 ))
 (let ((?x11478 (lambda ((x Poly) )(let ((?x2543 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x)))
 (let (($x2545 (= x (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x2543))))
 (let (($x2542 (has_type x TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x2550 (not $x2542)))
 (let (($x2551 (or $x2550 $x2545)))
 (refl (~ $x2551 $x2551))))))))
 ))
 (let (($x2548 (forall ((x Poly) )(! (let ((?x2543 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x)))
 (let (($x2545 (= x (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x2543))))
 (let (($x2542 (has_type x TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (=> $x2542 $x2545)))) :pattern ( (has_type x TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.) ) :qid internal_pmemlog__infinitelog_t__AbstractInfiniteLogState_unbox_axiom_definition))
 ))
 (let ((?x2555 (lambda ((x Poly) )(let ((?x2543 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. x)))
 (let (($x2545 (= x (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x2543))))
 (let (($x2542 (has_type x TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x2550 (not $x2542)))
 (let (($x2551 (or $x2550 $x2545)))
 (let (($x2546 (=> $x2542 $x2545)))
 (rewrite (= $x2546 $x2551)))))))))
 ))
 (let ((@x2559 (mp (asserted $x2548) (quant-intro (proof-bind ?x2555) (= $x2548 $x2554)) $x2554)))
 (let ((@x11482 (mp~ @x2559 (nnf-pos (proof-bind ?x11478) (~ $x2554 $x2554)) $x2554)))
 (let (($x56851 (not $x2554)))
 (let (($x56854 (or $x56851 $x56842 $x56848)))
 (let ((?x56677 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x48588)))
 (let (($x56838 (= ?x48588 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x56677))))
 (let (($x56835 (has_type ?x48588 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x56836 (not $x56835)))
 (let (($x56839 (or $x56836 $x56838)))
 (let (($x56855 (or $x56851 $x56839)))
 (let ((@x56863 (trans (monotonicity (rewrite (= $x56839 $x56847)) (= $x56855 (or $x56851 $x56847))) (rewrite (= (or $x56851 $x56847) $x56854)) (= $x56855 $x56854))))
 (let ((@x56864 (mp ((_ quant-inst (core!option.Option./Some/?0 ?x48586)) $x56855) @x56863 $x56854)))
 (let ((@x62219 (unit-resolution (unit-resolution @x56864 @x11482 $x56847) @x62218 $x56848)))
 (let (($x56690 (= ?x48588 ?x48585)))
 (let ((@x62241 (symm @x62140 $x56690)))
 (let ((@x62234 (monotonicity (trans* @x62229 @x62145 @x62148 @x62230 @x62195 @x62197 (= ?x55992 ?x47950)) (= ?x55993 ?x47951))))
 (let ((@x62245 (trans* (monotonicity @x62234 (= ?x55994 ?x47958)) @x62193 @x62205 @x62241 @x62219 @x62243 (= ?x55994 ?x47963))))
 (let ((@x62247 (monotonicity @x62245 @x56782 (= ?x55995 ?x47964))))
 (let (($x62260 (= ?x47901 ?x47965)))
 (let ((@x62253 (monotonicity (trans* @x62145 @x62148 @x62230 @x62195 @x62197 (= ?x47897 ?x47950)) (= ?x47898 ?x47951))))
 (let ((@x62257 (trans* (monotonicity @x62253 (= ?x47899 ?x47958)) @x62193 @x62205 @x62241 @x62219 @x62243 (= ?x47899 ?x47963))))
 (let ((@x62259 (monotonicity @x62257 (= ?x47900 ?x47964))))
 (let ((@x62265 (trans* (monotonicity @x62259 $x62260) (monotonicity (symm @x62247 (= ?x47964 ?x55995)) (= ?x47965 ?x55996)) (= ?x47901 ?x55996))))
 (let ((@x62273 (monotonicity (symm (monotonicity (monotonicity @x62265 (= ?x47902 ?x55997)) $x62268) $x62270) (= (not $x56000) $x61370))))
 (let ((@x62274 (mp (unit-resolution (def-axiom (or $x56002 (not $x56000))) @x62136 (not $x56000)) @x62273 $x61370)))
 (let (($x61426 (not $x60902)))
 (let (($x62280 (= $x56001 $x60902)))
 (let ((@x62283 (monotonicity (symm (monotonicity (symm @x62227 (= ?x47691 ?x55991)) (= $x60902 $x56001)) $x62280) (= (not $x56001) $x61426))))
 (let ((@x62284 (mp (unit-resolution (def-axiom (or $x56002 (not $x56001))) @x62136 (not $x56001)) @x62283 $x61426)))
 (let ((@x61430 (def-axiom (or (not $x60910) $x60902 $x60903))))
 (let ((@x62287 (lemma (unit-resolution @x61430 @x62284 @x62274 @x62138 false) (or $x56002 (not $x60911) $x56005))))
 (let ((@x61791 (unit-resolution @x62287 @x61790 @x60536 $x56002)))
 (let (($x60875 (not $x56000)))
 (let ((@x47428 (monotonicity (symm @x62259 (= ?x47964 ?x47900)) (= ?x47965 ?x47901))))
 (let ((@x61806 (monotonicity (trans* (monotonicity @x62247 (= ?x55996 ?x47965)) @x47428 (= ?x55996 ?x47901)) (= ?x55997 ?x47902))))
 (let (($x61425 (not $x60910)))
 (let (($x61104 (not $x56004)))
 (let ((@x60607 (def-axiom (or $x56005 $x61104 $x60841))))
 (let ((@x60242 (def-axiom (or (not $x60911) $x56004 $x61425))))
 (let ((@x61794 (unit-resolution @x60242 (unit-resolution @x60607 @x61791 @x60536 $x61104) @x61790 $x61425)))
 (let ((@x60183 (def-axiom (or $x60910 $x61370))))
 (let ((@x61812 (mp (unit-resolution @x60183 @x61794 $x61370) (monotonicity (symm (monotonicity @x61806 $x62270) $x62268) (= $x61370 $x60875)) $x60875)))
 (let (($x61005 (not $x56001)))
 (let ((@x61810 (monotonicity (symm (monotonicity @x62227 $x62280) (= $x60902 $x56001)) (= $x61426 $x61005))))
 (let ((@x60120 (def-axiom (or $x60841 $x56001 $x56000))))
 (let ((@x61817 (unit-resolution @x60120 (mp (unit-resolution (def-axiom (or $x60910 $x61426)) @x61794 $x61426) @x61810 $x61005) @x61812 @x61791 false)))
 (let ((@x61818 (lemma @x61817 $x56008)))
 (let (($x60530 (or $x60784 $x56138 $x56137 $x56130 $x56163 $x56164 $x56171 $x56111 $x56195 $x56079 $x56075 $x56230 $x56009)))
 (let ((@x60515 (def-axiom $x60530)))
 (let ((@x67575 (unit-resolution @x60515 @x61818 @x60548 @x61445 @x61509 (or $x60784 $x56138 $x56130 $x56164 $x56171 $x56111 $x56195 $x56079 $x56230))))
 (let ((@x67576 (unit-resolution @x67575 @x60546 @x67053 @x61317 @x61225 @x61774 @x61767 (unit-resolution @x46963 @x67559 $x56166) @x60930 $x56230)))
 (let ((?x47800 (Sub ?x47799 ?x47798)))
 (let ((?x47807 (I ?x47800)))
 (let ((?x47808 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47745 ?x7131 ?x47807)))
 (let ((?x47805 (I ?x47799)))
 (let ((?x47806 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x47804 ?x47805)))
 (let (($x47809 (ext_eq false ?x1968 ?x47806 ?x47808)))
 (let ((@x67543 (monotonicity @x67157 @x61591 (= ?x56047 ?x47800))))
 (let ((@x67572 (monotonicity @x67543 (= ?x56058 ?x47807))))
 (let ((?x51776 (pmemlog!logimpl_v.pm_to_views.? ?x47674)))
 (let ((?x51765 (Poly%tuple%3. ?x51776)))
 (let ((?x51766 (%Poly%tuple%3. ?x51765)))
 (let ((?x51784 (tuple%3./tuple%3/1 ?x51766)))
 (let ((?x51785 (%Poly%pmemlog!logimpl_v.HeaderView. ?x51784)))
 (let ((?x51786 (Poly%pmemlog!logimpl_v.HeaderView. ?x51785)))
 (let ((?x51787 (%Poly%pmemlog!logimpl_v.HeaderView. ?x51786)))
 (let ((?x51789 (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x51787)))
 (let ((?x51788 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x51787)))
 (let ((?x51781 (tuple%3./tuple%3/0 ?x51766)))
 (let ((?x51782 (%I ?x51781)))
 (let (($x51783 (= ?x51782 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x51791 (ite $x51783 ?x51788 ?x51789)))
 (let ((?x53738 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x51791)))
 (let ((?x53754 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x53738)))
 (let ((?x53770 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x53754)))
 (let ((?x53771 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x53770)))
 (let ((?x53772 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x53771)))
 (let ((?x53776 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x53772)))
 (let ((?x53788 (Add ?x53776 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x54369 (= ?x53788 ?x47675)))
 (let ((?x53780 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x53772)))
 (let ((?x54399 (* (- 1) ?x53780)))
 (let ((?x53773 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x53772)))
 (let ((?x54400 (+ ?x53773 ?x54399)))
 (let (($x54401 (<= ?x54400 0)))
 (let (($x54402 (not $x54401)))
 (let ((?x52501 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x7451 ?x7453)))
 (let ((?x54388 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x52501)))
 (let ((?x54389 (Poly%vstd!seq.Seq<u8.>. ?x54388)))
 (let ((?x52497 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x7439 ?x7441)))
 (let (($x54393 (ext_eq false ?x1968 ?x52497 ?x54389)))
 (let (($x54394 (not $x54393)))
 (let ((?x54390 (vstd!bytes.spec_u64_from_le_bytes.? ?x54389)))
 (let ((?x54375 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x53754)))
 (let (($x54391 (= ?x54375 ?x54390)))
 (let (($x54392 (not $x54391)))
 (let (($x54395 (or $x54392 $x54394)))
 (let (($x54396 (not $x54395)))
 (let (($x54350 (= ?x51782 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x54387 (not $x54350)))
 (let (($x54397 (or $x54387 $x54396)))
 (let (($x54398 (not $x54397)))
 (let ((?x52490 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x7445 ?x7447)))
 (let ((?x54376 (pmemlog!pmemspec_t.spec_crc_bytes.? ?x52490)))
 (let ((?x54377 (Poly%vstd!seq.Seq<u8.>. ?x54376)))
 (let ((?x52486 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x7433 ?x7435)))
 (let (($x54381 (ext_eq false ?x1968 ?x52486 ?x54377)))
 (let (($x54382 (not $x54381)))
 (let ((?x54378 (vstd!bytes.spec_u64_from_le_bytes.? ?x54377)))
 (let (($x54379 (= ?x54375 ?x54378)))
 (let (($x54380 (not $x54379)))
 (let (($x54383 (or $x54380 $x54382)))
 (let (($x54384 (not $x54383)))
 (let (($x52138 (not $x51783)))
 (let (($x54385 (or $x52138 $x54384)))
 (let (($x54386 (not $x54385)))
 (let ((?x54371 (Sub ?x53780 ?x53773)))
 (let ((?x54372 (* (- 1) ?x54371)))
 (let ((?x54373 (+ ?x53776 ?x54372)))
 (let (($x54374 (<= ?x54373 0)))
 (let (($x54370 (not $x54369)))
 (let (($x54368 (<= ?x53776 0)))
 (let (($x54366 (<= ?x53788 18446744073709551615)))
 (let (($x54367 (not $x54366)))
 (let (($x54351 (or $x51783 $x54350)))
 (let (($x54365 (not $x54351)))
 (let (($x54403 (or $x54365 $x54367 $x54368 $x54370 $x54374 $x54386 $x54398 $x54402)))
 (let (($x54468 (not $x54403)))
 (let (($x53765 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? ?x47674)))
 (let ((?x53804 (Sub ?x53776 1)))
 (let ((?x53805 (I ?x53804)))
 (let ((?x53806 (%I ?x53805)))
 (let ((?x53777 (I ?x53776)))
 (let ((?x53781 (I ?x53780)))
 (let ((?x53782 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x53781 ?x53777)))
 (let ((?x53793 (I ?x53782)))
 (let ((?x53774 (I ?x53773)))
 (let ((?x53778 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x53774 ?x53777)))
 (let ((?x53787 (I ?x53778)))
 (let ((?x53799 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x53787 ?x53793)))
 (let ((?x53794 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x7471 ?x53793)))
 (let ((?x53795 (%Poly%vstd!seq.Seq<u8.>. ?x53794)))
 (let ((?x53796 (Poly%vstd!seq.Seq<u8.>. ?x53795)))
 (let ((?x53789 (I ?x53788)))
 (let ((?x53790 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x53787 ?x53789)))
 (let ((?x53791 (%Poly%vstd!seq.Seq<u8.>. ?x53790)))
 (let ((?x53792 (Poly%vstd!seq.Seq<u8.>. ?x53791)))
 (let ((?x53797 (vstd!seq.Seq.add.? $ ?x1876 ?x53792 ?x53796)))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x53783 (* (- 1) ?x53782)))
 (let ((?x53784 (+ ?x53778 ?x53783)))
 (let (($x53786 (<= ?x53784 0)))
 (let ((?x53798 (ite $x53786 ?x7133 ?x53797)))
 (let (($x53785 (>= ?x53784 0)))
 (let ((?x53800 (ite $x53785 ?x53798 ?x53799)))
 (let ((?x53801 (%Poly%vstd!seq.Seq<u8.>. ?x53800)))
 (let ((?x53802 (Poly%vstd!seq.Seq<u8.>. ?x53801)))
 (let ((?x53803 (%Poly%vstd!seq.Seq<u8.>. ?x53802)))
 (let ((?x53775 (%I ?x53774)))
 (let ((?x53807 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x53775 ?x53803 ?x53806)))
 (let ((?x53808 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x53807)))
 (let ((?x53809 (core!option.Option./Some ?x53808)))
 (let ((?x53810 (ite $x53765 ?x53809 core!option.Option./None)))
 (let (($x53818 (= core!option.Option./None ?x53810)))
 (let (($x53811 (= ?x47691 ?x53810)))
 (let (($x7695 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7713 (ite (>= (+ ?x7637 (* (- 1) ?x7640)) 0) (ite (<= (+ ?x7637 (* (- 1) ?x7640)) 0) ?x7133 ?x7659) ?x7646)))
 (let ((?x7719 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7713)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 ?x7719 ?x7672)))
 (let ((?x7688 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7683))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (= ?x7629 (ite $x7546 ?x7688 core!option.Option./None))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.recover.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.recover.?_definition))
 ))
 (let (($x7628 (fuel_bool fuel%pmemlog!logimpl_v.impl&%0.recover.)))
 (let (($x7625 (fuel_bool_default fuel%pmemlog!logimpl_v.impl&%0.recover.)))
 (let (($x53749 (= $x7628 $x7625)))
 (let ((@x53766 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.impl&%0.recover.) (or (not $x30) $x53749)) @x49237 (hypothesis (not $x53749)) false)))
 (let ((@x53779 (lemma @x53766 $x53749)))
 (let ((@x7627 (asserted $x7625)))
 (let ((@x53757 (def-axiom (or (not $x53749) $x7628 (not $x7625)))))
 (let ((@x60852 (unit-resolution (unit-resolution @x53757 @x7627 (or (not $x53749) $x7628)) @x53779 $x7628)))
 (let (($x7690 (not $x7628)))
 (let (($x7692 (or $x7690 $x7695)))
 (let ((?x13985 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7713 (ite (>= (+ ?x7637 (* (- 1) ?x7640)) 0) (ite (<= (+ ?x7637 (* (- 1) ?x7640)) 0) ?x7133 ?x7659) ?x7646)))
 (let ((?x7719 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7713)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 ?x7719 ?x7672)))
 (let ((?x7688 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7683))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let (($x7708 (= ?x7629 (ite $x7546 ?x7688 core!option.Option./None))))
 (refl (~ $x7708 $x7708)))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x13990 (monotonicity (refl (~ $x7690 $x7690)) (nnf-pos (proof-bind ?x13985) (~ $x7695 $x7695)) (~ $x7692 $x7692))))
 (let (($x7677 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7662 (%Poly%vstd!seq.Seq<u8.>. (ite (< ?x7637 ?x7640) ?x7646 (ite (< ?x7640 ?x7637) ?x7659 ?x7133)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7673 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. ?x7662)) ?x7672)))
 (let ((?x7675 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7673))))
 (let ((?x7676 (ite (not (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)) core!option.Option./None ?x7675)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (= ?x7629 ?x7676))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.recover.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.recover.?_definition))
 ))
 (let (($x7678 (=> $x7628 $x7677)))
 (let ((?x7698 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7672 (%I (I (Sub ?x7556 1)))))
 (let ((?x7636 (I ?x7556)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7640 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? (I ?x7555) ?x7636)))
 (let ((?x7645 (I ?x7640)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7635 (I ?x7554)))
 (let ((?x7637 (pmemlog!logimpl_v.spec_addr_logical_to_physical.? ?x7635 ?x7636)))
 (let ((?x7642 (I ?x7637)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7646 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 ?x7645)))
 (let ((?x7471 (I pmemlog!logimpl_v.contents_offset.?)))
 (let ((?x7653 (%Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7471 ?x7645))))
 (let ((?x7649 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7642 (I (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))))
 (let ((?x7659 (vstd!seq.Seq.add.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7649)) (Poly%vstd!seq.Seq<u8.>. ?x7653))))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x7713 (ite (>= (+ ?x7637 (* (- 1) ?x7640)) 0) (ite (<= (+ ?x7637 (* (- 1) ?x7640)) 0) ?x7133 ?x7659) ?x7646)))
 (let ((?x7719 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. ?x7713)))))
 (let ((?x7664 (%I ?x7635)))
 (let ((?x7683 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 ?x7719 ?x7672)))
 (let ((?x7688 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7683))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7629 (pmemlog!logimpl_v.impl&%0.recover.? pm!)))
 (let (($x7708 (= ?x7629 (ite $x7546 ?x7688 core!option.Option./None))))
 (let ((?x7662 (%Poly%vstd!seq.Seq<u8.>. (ite (< ?x7637 ?x7640) ?x7646 (ite (< ?x7640 ?x7637) ?x7659 ?x7133)))))
 (let ((?x7673 (pmemlog!infinitelog_t.AbstractInfiniteLogState./AbstractInfiniteLogState ?x7664 (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. ?x7662)) ?x7672)))
 (let ((?x7675 (core!option.Option./Some (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x7673))))
 (let (($x7630 (= ?x7629 (ite (not $x7546) core!option.Option./None ?x7675))))
 (rewrite (= $x7630 $x7708)))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x7689 (monotonicity (quant-intro (proof-bind ?x7698) (= $x7677 $x7695)) (= $x7678 (=> $x7628 $x7695)))))
 (let ((@x7702 (mp (asserted $x7678) (trans @x7689 (rewrite (= (=> $x7628 $x7695) $x7692)) (= $x7678 $x7692)) $x7692)))
 (let ((@x13994 (mp (mp~ @x7702 @x13990 $x7692) (rewrite (= $x7692 $x7692)) $x7692)))
 (let ((@x60853 (unit-resolution @x13994 @x60852 $x7695)))
 (let (($x53814 (not $x7695)))
 (let (($x53815 (or $x53814 $x53811)))
 (let ((@x53816 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) $x53815)))
 (let ((@x60854 (unit-resolution @x53816 @x60853 $x53811)))
 (let ((@x62429 (trans* @x62167 @x60854 (symm (hypothesis $x53818) (= ?x53810 core!option.Option./None)) (= ?x48586 core!option.Option./None))))
 (let ((@x62453 (lemma ((_ th-lemma datatype) @x62429 false) (not $x53818))))
 (let ((@x53897 (def-axiom (or $x53765 $x53818))))
 (let (($x54404 (= $x54403 $x53765)))
 (let (($x54405 (not $x54404)))
 (let (($x17951 (forall ((pm! Poly) )(! (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x17908 (or (not (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))) (not $x7574))))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7591 (<= ?x7556 0)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x17927 (not $x7558)))
 (let (($x17933 (or $x17927 (not (<= ?x7559 18446744073709551615)) $x7591 (not $x7564) $x7617 (not (or $x7631 (not $x17908))) (not (or $x7643 (not (or (not $x7581) (not $x7582))))) (not $x7657))))
 (not (= $x17933 $x7546)))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.log_state_is_valid.?_definition))
 ))
 (let (($x7545 (fuel_bool fuel%pmemlog!logimpl_v.impl&%0.log_state_is_valid.)))
 (let (($x7543 (fuel_bool_default fuel%pmemlog!logimpl_v.impl&%0.log_state_is_valid.)))
 (let (($x53714 (= $x7545 $x7543)))
 (let ((@x53734 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.impl&%0.log_state_is_valid.) (or (not $x30) $x53714)) @x49237 (hypothesis (not $x53714)) false)))
 (let ((@x53747 (lemma @x53734 $x53714)))
 (let ((@x7544 (asserted $x7543)))
 (let ((@x53726 (def-axiom (or (not $x53714) $x7545 (not $x7543)))))
 (let ((@x67655 (unit-resolution (unit-resolution @x53726 @x7544 (or (not $x53714) $x7545)) @x53747 $x7545)))
 (let (($x7638 (not $x7545)))
 (let (($x17919 (or $x7638 $x17951)))
 (let (($x7593 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7560 (<= ?x7559 18446744073709551615)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x7663 (and $x7558 $x7560 (not (<= ?x7556 0)) $x7564 (not $x7617) (or $x7631 $x7575) (or $x7643 $x7583) $x7657)))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (= $x7546 $x7663)))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.log_state_is_valid.?_definition))
 ))
 (let (($x7626 (or $x7638 $x7593)))
 (let ((?x13957 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7560 (<= ?x7559 18446744073709551615)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x7663 (and $x7558 $x7560 (not (<= ?x7556 0)) $x7564 (not $x7617) (or $x7631 $x7575) (or $x7643 $x7583) $x7657)))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let (($x7668 (= $x7546 $x7663)))
 (refl (~ $x7668 $x7668)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x13962 (monotonicity (refl (~ $x7638 $x7638)) (nnf-pos (proof-bind ?x13957) (~ $x7593 $x7593)) (~ $x7626 $x7626))))
 (let (($x7588 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let ((?x7566 (Sub ?x7555 ?x7554)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7565 (and (and (and (or $x7513 $x7557) (<= ?x7559 18446744073709551615)) (> ?x7556 0)) $x7564)))
 (let (($x7587 (and (and (and (and $x7565 (< ?x7566 ?x7556)) (=> $x7513 $x7575)) (=> $x7557 $x7583)) (<= ?x7554 ?x7555))))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (= $x7546 $x7587)))))))))))))))))))))))))))))))))))))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!) ) :qid internal_pmemlog!logimpl_v.impl&__0.log_state_is_valid.?_definition))
 ))
 (let (($x7589 (=> $x7545 $x7588)))
 (let ((?x7594 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7550 (%Poly%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7518))))
 (let ((?x7552 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x7550))))
 (let ((?x7553 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7552)))
 (let ((?x7555 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x7553)))
 (let ((?x7554 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x7553)))
 (let (($x7657 (<= (+ ?x7554 (* (- 1) ?x7555)) 0)))
 (let ((?x7452 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7453 (I ?x7452)))
 (let ((?x7450 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7451 (I ?x7450)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7454 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7451 ?x7453)))
 (let ((?x7579 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7454))))
 (let ((?x7438 (Add pmemlog!logimpl_v.header2_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7440 (Add ?x7438 8)))
 (let ((?x7441 (I ?x7440)))
 (let ((?x7439 (I ?x7438)))
 (let ((?x7442 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7439 ?x7441)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7582 (ext_eq false ?x1968 ?x7442 ?x7579)))
 (let ((?x7569 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x7550)))
 (let (($x7581 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7579))))
 (let (($x7583 (and $x7581 $x7582)))
 (let (($x7557 (= ?x7510 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x7643 (not $x7557)))
 (let ((?x7446 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_size.?)))
 (let ((?x7447 (I ?x7446)))
 (let ((?x7444 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x7445 (I ?x7444)))
 (let ((?x7448 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7445 ?x7447)))
 (let ((?x7571 (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.spec_crc_bytes.? ?x7448))))
 (let ((?x7432 (Add pmemlog!logimpl_v.header1_pos.? pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7434 (Add ?x7432 8)))
 (let ((?x7435 (I ?x7434)))
 (let ((?x7433 (I ?x7432)))
 (let ((?x7436 (vstd!seq.Seq.subrange.? $ ?x1876 pm! ?x7433 ?x7435)))
 (let (($x7574 (ext_eq false ?x1968 ?x7436 ?x7571)))
 (let (($x7573 (= ?x7569 (vstd!bytes.spec_u64_from_le_bytes.? ?x7571))))
 (let (($x7575 (and $x7573 $x7574)))
 (let (($x7631 (not $x7513)))
 (let ((?x7556 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x7553)))
 (let (($x7617 (<= (+ ?x7556 (* (- 1) (Sub ?x7555 ?x7554))) 0)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 pm!)))
 (let ((?x7559 (Add ?x7556 pmemlog!logimpl_v.contents_offset.?)))
 (let (($x7564 (= ?x7559 ?x6094)))
 (let (($x7560 (<= ?x7559 18446744073709551615)))
 (let (($x7558 (or $x7513 $x7557)))
 (let (($x7663 (and $x7558 $x7560 (not (<= ?x7556 0)) $x7564 (not $x7617) (or $x7631 $x7575) (or $x7643 $x7583) $x7657)))
 (let (($x7546 (pmemlog!logimpl_v.impl&%0.log_state_is_valid.? pm!)))
 (let (($x7668 (= $x7546 $x7663)))
 (let (($x7568 (and (and (and (and $x7558 $x7560) (> ?x7556 0)) $x7564) (< (Sub ?x7555 ?x7554) ?x7556))))
 (let (($x7547 (= $x7546 (and (and (and $x7568 (=> $x7513 $x7575)) (=> $x7557 $x7583)) (<= ?x7554 ?x7555)))))
 (rewrite (= $x7547 $x7668)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x7606 (monotonicity (quant-intro (proof-bind ?x7594) (= $x7588 $x7593)) (= $x7589 (=> $x7545 $x7593)))))
 (let ((@x7599 (mp (asserted $x7589) (trans @x7606 (rewrite (= (=> $x7545 $x7593) $x7626)) (= $x7589 $x7626)) $x7626)))
 (let ((@x17910 (mp (mp (mp~ @x7599 @x13962 $x7626) (rewrite (= $x7626 $x7626)) $x7626) (rewrite (= $x7626 $x17919)) $x17919)))
 (let (($x54409 (not $x17951)))
 (let (($x54411 (or $x54409 $x54405)))
 (let ((@x54414 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) $x54411)))
 (let ((@x54478 (def-axiom (or $x54404 $x54468 (not $x53765)))))
 (let ((@x67636 (unit-resolution @x54478 (unit-resolution @x54414 (unit-resolution @x17910 @x67655 $x17951) $x54405) (or $x54468 (not $x53765)))))
 (let ((@x54458 (def-axiom (or $x54403 $x54369))))
 (let ((@x67656 (unit-resolution @x54458 (unit-resolution @x67636 (unit-resolution @x53897 @x62453 $x53765) $x54468) $x54369)))
 (let (($x54516 (= ?x47799 ?x53788)))
 (let (($x51792 (= ?x47731 ?x51791)))
 (let (($x7521 (forall ((pm! Poly) )(! (let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7507 (pmemlog!logimpl_v.spec_get_live_header.? pm!)))
 (= ?x7507 ?x7518)))))))))) :pattern ( (pmemlog!logimpl_v.spec_get_live_header.? pm!) ) :qid internal_pmemlog!logimpl_v.spec_get_live_header.?_definition))
 ))
 (let (($x7506 (fuel_bool fuel%pmemlog!logimpl_v.spec_get_live_header.)))
 (let (($x7504 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_get_live_header.)))
 (let (($x51763 (= $x7506 $x7504)))
 (let ((@x51777 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_get_live_header.) (or (not $x30) $x51763)) @x49237 (hypothesis (not $x51763)) false)))
 (let ((@x51790 (lemma @x51777 $x51763)))
 (let ((@x7505 (asserted $x7504)))
 (let ((@x51769 (def-axiom (or (not $x51763) $x7506 (not $x7504)))))
 (let ((@x61275 (unit-resolution (unit-resolution @x51769 @x7505 (or (not $x51763) $x7506)) @x51790 $x7506)))
 (let (($x7524 (not $x7506)))
 (let (($x7525 (or $x7524 $x7521)))
 (let ((?x13936 (lambda ((pm! Poly) )(let ((?x7426 (pmemlog!logimpl_v.pm_to_views.? pm!)))
 (let ((?x7489 (Poly%tuple%3. ?x7426)))
 (let ((?x7508 (%Poly%tuple%3. ?x7489)))
 (let ((?x7514 (Poly%pmemlog!logimpl_v.HeaderView. (%Poly%pmemlog!logimpl_v.HeaderView. (tuple%3./tuple%3/1 ?x7508)))))
 (let ((?x7515 (%Poly%pmemlog!logimpl_v.HeaderView. ?x7514)))
 (let ((?x7510 (%I (tuple%3./tuple%3/0 ?x7508))))
 (let (($x7513 (= ?x7510 pmemlog!pmemspec_t.cdb0_val.?)))
 (let ((?x7518 (ite $x7513 (pmemlog!logimpl_v.HeaderView./HeaderView/header1 ?x7515) (pmemlog!logimpl_v.HeaderView./HeaderView/header2 ?x7515))))
 (let ((?x7507 (pmemlog!logimpl_v.spec_get_live_header.? pm!)))
 (let (($x7519 (= ?x7507 ?x7518)))
 (refl (~ $x7519 $x7519)))))))))))))
 ))
 (let ((@x13941 (monotonicity (refl (~ $x7524 $x7524)) (nnf-pos (proof-bind ?x13936) (~ $x7521 $x7521)) (~ $x7525 $x7525))))
 (let ((@x7528 (mp (asserted (=> $x7506 $x7521)) (rewrite (= (=> $x7506 $x7521) $x7525)) $x7525)))
 (let ((@x13945 (mp (mp~ @x7528 @x13941 $x7525) (rewrite (= $x7525 $x7525)) $x7525)))
 (let (($x51795 (not $x7521)))
 (let (($x51796 (or $x51795 $x51792)))
 (let ((@x51797 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!)) $x51796)))
 (let ((@x61279 (symm (unit-resolution @x51797 (unit-resolution @x13945 @x61275 $x7521) $x51792) (= ?x51791 ?x47731))))
 (let ((@x61285 (monotonicity (monotonicity (monotonicity @x61279 (= ?x53738 ?x47738)) (= ?x53754 ?x47739)) (= ?x53770 ?x47740))))
 (let ((@x61289 (monotonicity (monotonicity @x61285 (= ?x53771 ?x47741)) (= ?x53772 ?x47742))))
 (let ((@x61291 (monotonicity @x61289 (= ?x53776 ?x47754))))
 (let ((@x65774 (monotonicity (symm @x61291 (= ?x47754 ?x53776)) $x54516)))
 (let ((@x69281 (symm (monotonicity (trans* @x65774 @x67656 (= ?x47799 ?x47675)) (= ?x47805 ?x49725)) (= ?x49725 ?x47805))))
 (let ((@x69333 (trans* (monotonicity (trans* @x67157 @x65774 @x67656 (= ?x56041 ?x47675)) (= ?x56052 ?x49725)) @x69281 (= ?x56052 ?x47805))))
 (let ((@x69357 (monotonicity @x56802 @x60325 @x69333 (= ?x56053 ?x47806))))
 (let ((@x69364 (monotonicity @x69357 (monotonicity @x56782 @x67572 (= ?x56062 ?x47808)) (= $x56063 $x47809))))
 (let ((@x69366 (symm @x69364 (= $x47809 $x56063))))
 (let ((?x47801 (Sub ?x47746 ?x47800)))
 (let ((?x47810 (Add pmemlog!logimpl_v.contents_offset.? ?x47801)))
 (let ((?x47811 (I ?x47810)))
 (let ((?x47812 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x7471 ?x47811)))
 (let ((?x47817 (vstd!seq.Seq.add.? $ ?x1876 ?x47806 ?x47812)))
 (let (($x47818 (ext_eq false ?x1968 ?x47745 ?x47817)))
 (let (($x48007 (not $x47818)))
 (let ((?x47813 (I ?x47746)))
 (let ((?x47814 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47745 ?x47807 ?x47813)))
 (let (($x47815 (ext_eq false ?x1968 ?x47812 ?x47814)))
 (let (($x48004 (not $x47815)))
 (let (($x48006 (not $x47809)))
 (let (($x48008 (or $x48006 $x48004 $x48007)))
 (let (($x47857 (not $x48008)))
 (let ((?x59381 (Poly%vstd!seq.Seq<u8.>. ?x47703)))
 (let (($x59371 (= ?x47702 ?x59381)))
 (let (($x59398 (has_type ?x47702 ?x1968)))
 (let ((?x55702 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x9030 ?x9036)))
 (let (($x55703 (has_type ?x55702 ?x1968)))
 (let ((@x59506 (symm @x58832 (= 40 pmemlog!logimpl_v.header2_pos.?))))
 (let ((?x51047 (Add 8 32)))
 (let (($x51060 (= ?x51047 40)))
 (let (($x51064 (or $x48769 $x51060)))
 (let ((?x51048 (* (- 1) ?x51047)))
 (let ((?x51051 (+ 32 8 ?x51048)))
 (let (($x51052 (= ?x51051 0)))
 (let (($x51065 (or $x48769 $x51052)))
 (let (($x51067 (= $x51065 $x51064)))
 (let ((@x51058 (monotonicity (rewrite (= ?x51051 (+ 40 ?x51048))) (= $x51052 (= (+ 40 ?x51048) 0)))))
 (let ((@x51063 (trans @x51058 (rewrite (= (= (+ 40 ?x51048) 0) $x51060)) (= $x51052 $x51060))))
 (let ((@x51072 (mp ((_ quant-inst 8 32) $x51065) (trans (monotonicity @x51063 $x51067) (rewrite (= $x51064 $x51064)) $x51067) $x51064)))
 (let (($x7320 (= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7318 (fuel_bool fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x7316 (fuel_bool_default fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x50328 (= $x7318 $x7316)))
 (let ((@x50358 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_size.) (or (not $x30) $x50328)) @x49237 (hypothesis (not $x50328)) false)))
 (let ((@x50371 (lemma @x50358 $x50328)))
 (let ((@x7317 (asserted $x7316)))
 (let ((@x50349 (def-axiom (or (not $x50328) $x7318 (not $x7316)))))
 (let ((@x58645 (unit-resolution (unit-resolution @x50349 @x7317 (or (not $x50328) $x7318)) @x50371 $x7318)))
 (let (($x7323 (not $x7318)))
 (let (($x7324 (or $x7323 $x7320)))
 (let ((@x7327 (mp (asserted (=> $x7318 $x7320)) (rewrite (= (=> $x7318 $x7320) $x7324)) $x7324)))
 (let ((@x58646 (unit-resolution @x7327 @x58645 $x7320)))
 (let (($x7234 (= pmemlog!logimpl_v.header1_pos.? 8)))
 (let (($x7232 (fuel_bool fuel%pmemlog!logimpl_v.header1_pos.)))
 (let (($x7230 (fuel_bool_default fuel%pmemlog!logimpl_v.header1_pos.)))
 (let (($x50207 (= $x7232 $x7230)))
 (let ((@x50251 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header1_pos.) (or (not $x30) $x50207)) @x49237 (hypothesis (not $x50207)) false)))
 (let ((@x50264 (lemma @x50251 $x50207)))
 (let ((@x7231 (asserted $x7230)))
 (let ((@x50242 (def-axiom (or (not $x50207) $x7232 (not $x7230)))))
 (let ((@x58590 (unit-resolution (unit-resolution @x50242 @x7231 (or (not $x50207) $x7232)) @x50264 $x7232)))
 (let (($x7237 (not $x7232)))
 (let (($x7238 (or $x7237 $x7234)))
 (let ((@x7241 (mp (asserted (=> $x7232 $x7234)) (rewrite (= (=> $x7232 $x7234) $x7238)) $x7238)))
 (let ((@x58591 (unit-resolution @x7241 @x58590 $x7234)))
 (let ((@x59508 (trans* (monotonicity @x58591 @x58646 (= ?x7446 ?x51047)) (unit-resolution @x51072 @x10850 $x51060) @x59506 (= ?x7446 pmemlog!logimpl_v.header2_pos.?))))
 (let ((@x59514 (symm (monotonicity @x59508 (= ?x7447 ?x9036)) (= ?x9036 ?x7447))))
 (let ((@x60524 (monotonicity (symm (monotonicity @x59514 (= ?x55702 ?x47702)) (= ?x47702 ?x55702)) (= $x59398 $x55703))))
 (let (($x53311 (has_type ?x9036 INT)))
 (let ((@x60517 (symm (monotonicity @x59514 (= $x53311 (has_type ?x7447 INT))) (= (has_type ?x7447 INT) $x53311))))
 (let (($x50929 (has_type ?x7447 INT)))
 (let ((?x59491 (I 40)))
 (let (($x59498 (has_type ?x59491 INT)))
 (let (($x59521 (not $x59498)))
 (let ((@x59518 (monotonicity (trans* (monotonicity @x59506 (= ?x59491 ?x9036)) @x59514 (= ?x59491 ?x7447)) (= $x59498 $x50929))))
 (let ((@x59524 (mp (hypothesis (not $x50929)) (monotonicity (symm @x59518 (= $x50929 $x59498)) (= (not $x50929) $x59521)) $x59521)))
 (let ((@x59526 (unit-resolution (unit-resolution ((_ quant-inst 40) (or (not $x698) $x59498)) @x10752 $x59498) @x59524 false)))
 (let ((@x59527 (lemma @x59526 $x50929)))
 (let ((@x60582 (mp @x59527 @x60517 $x53311)))
 (let (($x50975 (has_type ?x9030 INT)))
 (let ((@x58616 (symm @x58591 (= 8 pmemlog!logimpl_v.header1_pos.?))))
 (let (($x48779 (<= ?x48765 (- 8))))
 (let (($x47296 (>= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let ((?x47309 (* (- 1) pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x47310 (+ ?x441 ?x47309)))
 (let (($x47311 (<= ?x47310 0)))
 (let (($x47297 (not $x47296)))
 (let (($x47316 (or $x47297 $x47311)))
 (let (($x47342 (not $x47316)))
 (let (($x7271 (uInv 64 pmemlog!logimpl_v.header_crc_offset.?)))
 (let (($x47318 (= $x47316 $x7271)))
 (let (($x47321 (not $x47318)))
 (let (($x15434 (forall ((bits Int) (i Int) )(! (let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x15308 (or $x540 $x578)))
 (not (= $x15308 $x648))))))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let (($x669 (forall ((bits Int) (i Int) )(! (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x584)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x15435 (lambda ((bits Int) (i Int) )(let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x15308 (or $x540 $x578)))
 (let (($x15426 (not (= $x15308 $x648))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x667 (= $x648 $x584)))
 (let (($x15429 (= $x667 $x15426)))
 (let ((@x15312 (rewrite (= $x584 (not $x15308)))))
 (let ((@x15430 (trans (monotonicity @x15312 (= $x667 (= $x648 (not $x15308)))) (rewrite (= (= $x648 (not $x15308)) $x15426)) $x15429)))
 (trans @x15430 (rewrite (= $x15426 $x15426)) $x15429)))))))))))))
 ))
 (let ((?x10727 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (refl (~ $x667 $x667)))))))
 ))
 (let (($x660 (forall ((bits Int) (i Int) )(! (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x548)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x674 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x658 (= $x648 $x548)))
 (rewrite (= $x658 $x667))))))))))
 ))
 (let ((@x640 (mp (asserted $x660) (quant-intro (proof-bind ?x674) (= $x660 $x669)) $x669)))
 (let ((@x15439 (mp (mp~ @x640 (nnf-pos (proof-bind ?x10727) (~ $x669 $x669)) $x669) (quant-intro (proof-bind ?x15435) (= $x669 $x15434)) $x15434)))
 (let (($x46979 (not $x15434)))
 (let (($x47328 (or $x46979 $x47321)))
 (let (($x47300 (or $x47297 (>= (+ pmemlog!logimpl_v.header_crc_offset.? (* (- 1) ?x441)) 0))))
 (let (($x47301 (= $x47300 $x7271)))
 (let (($x47302 (not $x47301)))
 (let (($x47329 (or $x46979 $x47302)))
 (let (($x47331 (= $x47329 $x47328)))
 (let (($x47323 (= $x47302 $x47321)))
 (let ((@x47327 (trans (monotonicity (rewrite (= $x47301 $x47318)) $x47323) (rewrite (= $x47321 $x47321)) $x47323)))
 (let ((@x47336 (mp ((_ quant-inst 64 pmemlog!logimpl_v.header_crc_offset.?) $x47329) (trans (monotonicity @x47327 $x47331) (rewrite (= $x47328 $x47328)) $x47331) $x47328)))
 (let ((@x7272 (asserted $x7271)))
 (let ((@x47353 (def-axiom (or $x47318 $x47342 (not $x7271)))))
 (let ((@x58611 (unit-resolution (unit-resolution @x47353 @x7272 (or $x47318 $x47342)) (unit-resolution @x47336 @x15439 $x47321) $x47342)))
 (let ((@x47338 (def-axiom (or $x47316 $x47296))))
 (let ((@x58614 ((_ th-lemma arith eq-propagate -1 -1 1 1) (unit-resolution @x47338 @x58611 $x47296) @x58607 @x58599 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48766) $x48779)) @x58595 $x48779) (= ?x7830 8))))
 (let ((@x58622 (monotonicity (trans* @x58614 @x58616 (= ?x7830 pmemlog!logimpl_v.header1_pos.?)) (= ?x7831 ?x9030))))
 (let ((@x58624 (symm @x58622 (= ?x9030 ?x7831))))
 (let ((@x61073 (symm (monotonicity @x58624 (= $x50975 (has_type ?x7831 INT))) (= (has_type ?x7831 INT) $x50975))))
 (let (($x48726 (has_type ?x7831 INT)))
 (let ((?x58582 (I 8)))
 (let (($x58583 (has_type ?x58582 INT)))
 (let (($x58631 (not $x58583)))
 (let ((@x58628 (monotonicity (trans* (monotonicity @x58616 (= ?x58582 ?x9030)) @x58624 (= ?x58582 ?x7831)) (= $x58583 $x48726))))
 (let ((@x58634 (mp (hypothesis (not $x48726)) (monotonicity (symm @x58628 (= $x48726 $x58583)) (= (not $x48726) $x58631)) $x58631)))
 (let ((@x58636 (unit-resolution (unit-resolution ((_ quant-inst 8) (or (not $x698) $x58583)) @x10752 $x58583) @x58634 false)))
 (let ((@x58637 (lemma @x58636 $x48726)))
 (let (($x16483 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x16463 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x16453 (not $x4256)))
 (or $x16453 $x16463 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x16484 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x16463 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x16453 (not $x4256)))
 (let (($x16478 (or $x16453 $x16463 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x16470 (monotonicity (rewrite (= $x4258 (not (or $x16453 $x16463 $x271)))) (= $x4266 (not (not (or $x16453 $x16463 $x271)))))))
 (let ((@x16474 (trans @x16470 (rewrite (= (not (not (or $x16453 $x16463 $x271))) (or $x16453 $x16463 $x271))) (= $x4266 (or $x16453 $x16463 $x271)))))
 (trans (monotonicity @x16474 (= $x4269 (or (or $x16453 $x16463 $x271) $x4261))) (rewrite (= (or (or $x16453 $x16463 $x271) $x4261) $x16478)) (= $x4269 $x16478))))))))))))))))))
 ))
 (let ((?x12402 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x16488 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x12402) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x16484) (= $x4272 $x16483)) $x16483)))
 (let (($x53312 (not $x53311)))
 (let (($x50976 (not $x50975)))
 (let (($x48719 (not $x16483)))
 (let (($x60938 (or $x48719 $x48649 $x50976 $x53312 $x55703)))
 (let ((@x60632 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.header1_pos.?) (I pmemlog!logimpl_v.header2_pos.?)) (or $x48719 (or $x48649 $x50976 $x53312 $x55703))) (rewrite (= (or $x48719 (or $x48649 $x50976 $x53312 $x55703)) $x60938)) $x60938)))
 (let ((@x60754 (mp (unit-resolution @x60632 @x16488 @x56813 (mp @x58637 @x61073 $x50975) @x60582 $x55703) (symm @x60524 (= $x55703 $x59398)) $x59398)))
 (let (($x59399 (not $x59398)))
 (let (($x59373 (or $x59399 $x59371)))
 (let (($x60940 (or $x57707 $x59399 $x59371)))
 (let ((@x60919 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x9030 ?x7447)) (or $x57707 $x59373)) (rewrite (= (or $x57707 $x59373) $x60940)) $x60940)))
 (let ((@x60761 (monotonicity @x56802 (= ?x56119 ?x47702))))
 (let ((@x60781 (trans* @x60761 (unit-resolution (unit-resolution @x60919 @x11209 $x59373) @x60754 $x59371) (monotonicity @x60947 (= ?x59381 ?x47723)) (= ?x56119 ?x47723))))
 (let ((@x60772 (unit-resolution @x46963 (monotonicity @x60781 $x56121) $x56166)))
 (let ((@x61074 (unit-resolution @x60515 @x61818 @x60548 @x61445 @x61317 @x61509 (or $x60784 $x56138 $x56130 $x56164 $x56111 $x56195 $x56079 $x56230))))
 (let ((@x61459 (def-axiom (or $x56200 $x56239))))
 (let ((@x67055 (unit-resolution @x61459 (unit-resolution @x61074 @x60546 @x67053 @x61225 @x61774 @x61767 @x60772 @x60930 $x56230) $x56239)))
 (let ((@x47377 (def-axiom (or $x56199 $x56189))))
 (let ((@x67154 (unit-resolution @x47377 @x67134 $x56199)))
 (let ((@x61613 (hypothesis $x56196)))
 (let (($x47856 (not $x47854)))
 (let ((@x66646 (hypothesis $x47856)))
 (let ((?x56669 (+ ?x47796 ?x56208)))
 (let (($x56670 (<= ?x56669 0)))
 (let (($x55777 (= ?x47796 ?x56031)))
 (let ((@x66682 (monotonicity (monotonicity (monotonicity @x61544 (= ?x56029 ?x47750)) (= ?x56030 ?x47794)) @x61114 (= ?x56031 ?x47796))))
 (let ((@x66678 (symm @x66682 $x55777)))
 (let ((@x66683 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55777) $x56670)) @x66678 $x56670)))
 (let ((?x56665 (+ ?x47798 ?x56036)))
 (let (($x56667 (>= ?x56665 0)))
 (let (($x55775 (= ?x47798 ?x56021)))
 (let ((@x66627 (symm @x61591 $x55775)))
 (let ((@x66679 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 1) (or $x56215 (not $x56667) (not $x56670) $x47854)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55775) $x56667)) @x66627 $x56667) @x66683 (or $x56215 $x47854))))
 (let (($x48106 (not $x47826)))
 (let ((?x47844 (+ ?x47796 ?x47837)))
 (let (($x47845 (<= ?x47844 0)))
 (let (($x48107 (or $x47845 $x48106)))
 (let (($x48108 (not $x48107)))
 (let (($x48111 (or $x47854 $x48108)))
 (let (($x47850 (not $x47845)))
 (let (($x47873 (and $x47850 $x47826)))
 (let (($x47849 (or $x47854 $x47873)))
 (let (($x48112 (= $x47849 $x48111)))
 (let ((@x48116 (trans (monotonicity (rewrite (= $x47873 $x48108)) $x48112) (rewrite (= $x48111 $x48111)) $x48112)))
 (let (($x47864 (and $x47854 $x47846)))
 (let (($x47862 (not $x47864)))
 (let (($x47855 (or $x47862 $x47826)))
 (let (($x47847 (or $x47846 (and $x47809 $x47815 $x47818))))
 (let (($x47885 (and $x47847 $x47855 $x47849)))
 (let (($x47831 (and (< ?x47802 ?x47796) $x47826)))
 (let (($x47829 (< ?x47798 ?x47796)))
 (let (($x47832 (=> $x47829 $x47831)))
 (let (($x47828 (and (=> (>= ?x47802 ?x47799) (and (and $x47809 $x47815) $x47818)) (=> (and (<= ?x47796 ?x47798) (< ?x47802 ?x47799)) $x47826))))
 (let (($x47833 (and $x47828 $x47832)))
 (let ((@x47836 (trans (rewrite (= $x47829 (not (<= ?x47796 ?x47798)))) (rewrite (= (not (<= ?x47796 ?x47798)) $x47856)) (= $x47829 $x47856))))
 (let ((@x47881 (trans (monotonicity @x47836 (rewrite (= $x47831 $x47873)) (= $x47832 (=> $x47856 $x47873))) (rewrite (= (=> $x47856 $x47873) $x47849)) (= $x47832 $x47849))))
 (let ((@x47884 (monotonicity (rewrite (= $x47828 (and $x47847 $x47855))) @x47881 (= $x47833 (and (and $x47847 $x47855) $x47849)))))
 (let ((@x47889 (trans @x47884 (rewrite (= (and (and $x47847 $x47855) $x47849) $x47885)) (= $x47833 $x47885))))
 (let ((@x47890 (mp (asserted $x47833) @x47889 $x47885)))
 (let ((@x48117 (mp (and-elim @x47890 $x47849) @x48116 $x48111)))
 (let ((@x66561 (unit-resolution @x48117 @x66646 $x48108)))
 (let ((@x48374 (def-axiom (or $x48107 $x47826))))
 (let (($x61372 (not $x56227)))
 (let ((@x66666 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 1) (or $x61372 (not $x56670) (not $x58168) $x47845)) @x66775 @x66683 (or $x61372 $x47845))))
 (let ((@x66667 (unit-resolution @x66666 (unit-resolution (def-axiom (or $x48107 $x47850)) @x66561 $x47850) $x61372)))
 (let ((@x61085 (unit-resolution @x61074 @x60546 (mp (hypothesis $x48379) @x60771 $x56151) @x61225 @x61774 @x61767 @x60772 @x60930 $x56230)))
 (let ((@x60540 (def-axiom (or $x56238 $x56227 $x56027))))
 (let ((@x61593 (unit-resolution (unit-resolution @x60540 (hypothesis $x61372) (or $x56238 $x56027)) (mp (hypothesis $x47826) @x61607 $x56026) $x56238)))
 (let ((@x61453 (def-axiom (or $x56219 $x56232))))
 (let ((@x61432 (def-axiom (or $x56217 $x56210))))
 (let ((@x60643 (unit-resolution @x61432 (hypothesis $x56215) $x56217)))
 (let ((@x61611 (unit-resolution @x47377 @x61613 $x56199)))
 (let ((@x61464 (def-axiom (or $x56225 $x56198 $x56216 $x56228))))
 (let ((@x61615 (unit-resolution (unit-resolution @x61464 @x61611 @x60643 (or $x56225 $x56228)) (unit-resolution @x61453 @x61593 $x56219) $x56225)))
 (let ((@x61617 (lemma (unit-resolution @x61459 @x61615 @x61085 false) (or $x47920 $x56227 $x48106 $x47708 $x56210 $x56189))))
 (let ((@x66668 (unit-resolution @x61617 @x66667 (unit-resolution @x48374 @x66561 $x47826) @x66655 @x61101 (unit-resolution @x66679 @x66646 $x56215) @x61613 false)))
 (let ((@x67056 (unit-resolution (lemma @x66668 (or $x47854 $x47708 $x56189)) @x67134 @x61101 $x47854)))
 (let (($x48100 (or $x47856 $x47835 $x47826)))
 (let ((@x48102 (rewrite (= (or (or $x47856 $x47835) $x47826) $x48100))))
 (let (($x47863 (or $x47856 $x47835)))
 (let (($x48097 (or $x47863 $x47826)))
 (let ((@x48092 (monotonicity (rewrite (= $x47864 (not $x47863))) (= $x47862 (not (not $x47863))))))
 (let ((@x48099 (monotonicity (trans @x48092 (rewrite (= (not (not $x47863)) $x47863)) (= $x47862 $x47863)) (= $x47855 $x48097))))
 (let ((@x48178 (mp (mp (and-elim @x47890 $x47855) (trans @x48099 @x48102 (= $x47855 $x48100)) $x48100) (rewrite (= $x48100 $x48097)) $x48097)))
 (let ((@x48220 (mp @x48178 @x48102 $x48100)))
 (let ((@x66440 (def-axiom (or $x56217 $x56027))))
 (let ((@x67190 (unit-resolution @x66440 (mp (unit-resolution @x48220 @x67056 @x67151 $x47826) @x61607 $x56026) $x56217)))
 (let (($x55778 (>= ?x56669 0)))
 (let ((@x67226 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55777) $x55778)) @x66678 $x55778)))
 (let (($x55776 (<= ?x56665 0)))
 (let ((@x67230 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x55775) $x55776)) @x66627 $x55776)))
 (let ((@x67109 ((_ th-lemma arith assign-bounds 1 -1 1) (or $x56210 (not $x55776) (not $x55778) $x47856))))
 (let ((@x66543 (def-axiom (or $x56219 $x56215))))
 (let ((@x67225 (unit-resolution @x61464 (unit-resolution @x66543 (unit-resolution @x67109 @x67056 @x67230 @x67226 $x56210) $x56219) @x67190 @x67154 @x67055 false)))
 (let ((@x67577 (unit-resolution (lemma @x67225 (or $x47835 $x47708)) @x61101 $x47835)))
 (let (($x47865 (or $x47846 $x47857)))
 (let (($x48171 (or $x47846 (not (or (or $x48006 $x48004) $x48007)))))
 (let ((@x48174 (mp (mp (and-elim @x47890 $x47847) (rewrite (= $x47847 $x47865)) $x47865) (rewrite (= $x47865 $x48171)) $x48171)))
 (let ((@x48218 (mp @x48174 (rewrite (= $x48171 $x47865)) $x47865)))
 (let ((@x67581 (unit-resolution @x48218 @x67577 $x47857)))
 (let ((@x48364 (def-axiom (or $x48008 $x47809))))
 (let ((@x69374 (monotonicity (monotonicity (monotonicity @x61514 @x67543 (= ?x56048 ?x47801)) (= ?x56049 ?x47810)) (= ?x56050 ?x47811))))
 (let ((@x69376 (monotonicity @x56802 @x69374 (= ?x56051 ?x47812))))
 (let ((@x69380 (monotonicity @x56782 (monotonicity @x69357 @x69376 (= ?x56054 ?x47817)) (= $x56055 $x47818))))
 (let ((@x69382 (symm @x69380 (= $x47818 $x56055))))
 (let ((@x69388 (monotonicity @x56782 @x67572 (monotonicity @x61514 (= ?x56057 ?x47813)) (= ?x56059 ?x47814))))
 (let ((@x69392 (symm (monotonicity @x69376 @x69388 (= $x56060 $x47815)) (= $x47815 $x56060))))
 (let ((@x67971 (def-axiom (or $x56066 $x56064 $x56061 $x56056))))
 (let ((@x69394 (unit-resolution @x67971 (mp (unit-resolution (def-axiom (or $x48008 $x47815)) @x67581 $x47815) @x69392 $x56060) (mp (unit-resolution (def-axiom (or $x48008 $x47818)) @x67581 $x47818) @x69382 $x56055) (mp (unit-resolution @x48364 @x67581 $x47809) @x69366 $x56063) $x56066)))
 (let ((@x68022 (def-axiom (or $x56199 $x56065))))
 (let (($x58558 (<= ?x58029 0)))
 (let (($x57923 (>= ?x57851 0)))
 (let ((@x69407 (unit-resolution ((_ th-lemma arith assign-bounds -1 1 1) (or $x56189 (not $x57923) (not $x58558) $x47846)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x57943) $x57923)) @x67159 $x57923) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x57950) $x58558)) @x66661 $x58558) (or $x56189 $x47846))))
 (let ((@x68052 (def-axiom (or $x56217 $x56196))))
 (let ((@x67451 (unit-resolution @x67109 (unit-resolution @x66543 (hypothesis $x56228) $x56215) @x67230 @x67226 $x47856)))
 (let ((@x67487 (unit-resolution @x48117 @x67451 $x48108)))
 (let ((@x67498 (unit-resolution @x66666 (unit-resolution (def-axiom (or $x48107 $x47850)) @x67487 $x47850) $x61372)))
 (let ((@x67496 (unit-resolution @x60540 @x67498 (unit-resolution @x61453 (hypothesis $x56228) $x56232) $x56027)))
 (let ((@x67501 (unit-resolution @x67496 (mp (unit-resolution @x48374 @x67487 $x47826) @x61607 $x56026) false)))
 (let ((@x67506 (lemma @x67501 $x56219)))
 (let ((@x69411 (unit-resolution @x61464 @x67506 (unit-resolution @x68052 (unit-resolution @x69407 @x67577 $x56189) $x56217) (or $x56225 $x56198))))
 (let ((@x69413 (unit-resolution @x61459 (unit-resolution @x69411 (unit-resolution @x68022 @x69394 $x56199) $x56225) @x67576 false)))
 (let ((@x69414 (lemma @x69413 $x47708)))
 (let (($x47700 (or $x47698 $x47699)))
 (let ((@x47701 (asserted $x47700)))
 (let ((@x67295 (unit-resolution @x47701 @x69414 $x47699)))
 (let (($x65277 (= 12331324665725530551 pmemlog!pmemspec_t.cdb1_val.?)))
 (let ((@x67300 (symm @x60927 $x65277)))
 (let ((@x67297 (trans* @x67300 (symm @x67295 $x60641) (= 12331324665725530551 new_ib!))))
 (let ((@x69901 (monotonicity (monotonicity (monotonicity @x67297 (= ?x69445 ?x47924)) (= ?x69486 ?x47925)) (= ?x69487 ?x47935))))
 (let ((@x69905 (monotonicity (monotonicity @x56802 @x69901 (= ?x69488 ?x47936)) (= ?x69489 ?x47937))))
 (let ((@x70195 (trans* (monotonicity (monotonicity @x69905 (= ?x69490 ?x47938)) (= ?x69491 ?x47945)) @x62866 @x62872 @x62883 (= ?x69491 ?x48396))))
 (let ((@x70197 (monotonicity (trans* @x62229 @x62145 @x62148 @x62230 (= ?x55992 ?x48395)) @x70195 (= ?x69492 ?x48397))))
 (let ((@x70201 (monotonicity (trans* @x70197 @x62891 (symm @x60823 (= ?x47949 ?x47946)) (= ?x69492 ?x47946)) (= ?x69493 ?x47948))))
 (let ((@x70203 (monotonicity @x70201 (= ?x69494 ?x47949))))
 (let ((@x70210 (monotonicity (monotonicity @x70203 (= ?x69499 ?x47954)) (= ?x69500 ?x47955))))
 (let ((@x71646 (symm (monotonicity @x70210 (= ?x69682 (core!option.Option./Some/?0 ?x47955))) (= (core!option.Option./Some/?0 ?x47955) ?x69682))))
 (let ((?x49131 (core!option.Option./Some/?0 ?x47955)))
 (let (($x49134 (= ?x47960 ?x49131)))
 (let (($x69501 ((_ is core!option.Option./Some ) ?x69500)))
 (let ((?x69519 (pmemlog!logimpl_v.pm_to_views.? ?x69489)))
 (let ((?x69520 (Poly%tuple%3. ?x69519)))
 (let ((?x69521 (%Poly%tuple%3. ?x69520)))
 (let ((?x69522 (tuple%3./tuple%3/0 ?x69521)))
 (let ((?x69523 (%I ?x69522)))
 (let (($x69532 (= ?x69523 12331324665725530551)))
 (let (($x69533 (not $x69532)))
 (let ((?x69516 (pmemlog!logimpl_v.spec_get_live_header.? ?x69489)))
 (let (($x69517 (= ?x69516 ?x56081)))
 (let (($x69518 (not $x69517)))
 (let ((?x69513 (pmemlog!sccf.CheckPermission.check_permission.? Perm&. Perm& $ ?x1968 perm! ?x69489)))
 (let (($x69514 (%B ?x69513)))
 (let (($x69515 (not $x69514)))
 (let ((?x69495 (tuple%2./tuple%2/0 ?x69494)))
 (let ((?x69496 (%Poly%core!option.Option. ?x69495)))
 (let ((?x69506 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69496)))
 (let ((?x69507 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69506)))
 (let ((?x69508 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69507)))
 (let ((?x69509 (pmemlog!infinitelog_t.impl&%0.append.? ?x69508 ?x55989)))
 (let ((?x69510 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69509)))
 (let ((?x69503 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69500)))
 (let ((?x69504 (%Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69503)))
 (let ((?x69505 (Poly%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69504)))
 (let (($x69511 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x69505 ?x69510)))
 (let (($x69512 (not $x69511)))
 (let (($x69502 (not $x69501)))
 (let (($x69497 ((_ is core!option.Option./Some ) ?x69496)))
 (let (($x69498 (not $x69497)))
 (let (($x69535 (or $x69498 $x69502 $x69512 $x69515 $x69518 $x69533)))
 (let (($x71306 (not $x69535)))
 (let (($x69527 (ens%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& ?x48663 12331324665725530551 ?x48676 ?x48671 perm!)))
 (let (($x68728 (= $x69535 $x69527)))
 (let (($x71111 (not $x68728)))
 (let (($x71104 (or $x64578 $x71111)))
 (let (($x69524 (= 12331324665725530551 ?x69523)))
 (let (($x69525 (not $x69524)))
 (let (($x69526 (or $x69498 $x69502 $x69512 $x69515 $x69518 $x69525)))
 (let (($x69528 (= $x69526 $x69527)))
 (let (($x69529 (not $x69528)))
 (let (($x71109 (or $x64578 $x69529)))
 (let (($x71071 (= $x71109 $x71104)))
 (let (($x71038 (= $x69529 $x71111)))
 (let ((@x71069 (trans (monotonicity (rewrite (= $x69528 $x68728)) $x71038) (rewrite (= $x71111 $x71111)) $x71038)))
 (let ((@x68644 (mp ((_ quant-inst Perm&. Perm& (%Poly%vstd!seq.Seq<u8.>. ?x47674) 12331324665725530551 (%Poly%vstd!seq.Seq<u8.>. ?x47745) (%Poly%vstd!seq.Seq<u8.>. ?x47723) perm!) $x71109) (trans (monotonicity @x71069 $x71071) (rewrite (= $x71104 $x71104)) $x71071) $x71104)))
 (let ((@x71020 (symm (monotonicity @x56800 @x67297 @x56780 @x58471 (= $x69527 $x47922)) (= $x47922 $x69527))))
 (let ((@x70982 (unit-resolution (def-axiom (or $x68728 $x71306 (not $x69527))) (mp @x65559 @x71020 $x69527) (unit-resolution @x68644 @x19518 $x71111) $x71306)))
 (let ((@x70983 (unit-resolution (def-axiom (or $x69535 $x69501)) @x70982 $x69501)))
 (let ((@x71017 (trans* (monotonicity (symm @x70210 (= ?x47955 ?x69500)) (= $x48021 $x69501)) (iff-true @x70983 (= $x69501 true)) $x65705)))
 (let ((@x70987 (mp @x71017 @x65711 $x48021)))
 (let (($x49138 (or $x48119 $x49134)))
 (let (($x49142 (or $x49141 $x48119 $x49134)))
 (let ((@x49147 (mp ((_ quant-inst $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (%Poly%core!option.Option. ?x47954)) (or $x49141 $x49138)) (rewrite (= (or $x49141 $x49138) $x49142)) $x49142)))
 (let (($x61901 (= ?x47960 ?x47901)))
 (let (($x61928 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47960 ?x47901)))
 (let (($x68727 (= $x61901 $x61928)))
 (let (($x71451 (or $x60866 $x68727)))
 (let ((?x60113 (core!option.Option./Some/?0 ?x47902)))
 (let (($x61926 (ext_eq false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47960 ?x60113)))
 (let (($x47596 (= ?x47960 ?x60113)))
 (let (($x61927 (= $x47596 $x61926)))
 (let (($x71462 (or $x60866 $x61927)))
 (let (($x71411 (= $x71462 $x71451)))
 (let ((@x71482 (trans (monotonicity (rewrite (= $x61927 $x68727)) $x71411) (rewrite (= $x71451 $x71451)) $x71411)))
 (let (($x57110 (= ?x47960 ?x47962)))
 (let (($x57090 (has_type ?x47960 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((?x56938 (%Poly%core!option.Option. ?x48396)))
 (let ((?x56951 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x56938)))
 (let (($x56956 (has_type ?x56951 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let ((@x71339 (trans* (symm @x62868 (= ?x48396 ?x49149)) (symm @x62870 (= ?x49149 ?x47954)) (= ?x48396 ?x47954))))
 (let ((@x71922 (symm (monotonicity (monotonicity @x71339 (= ?x56938 ?x47955)) (= ?x56951 ?x47960)) (= ?x47960 ?x56951))))
 (let (($x56945 (has_type ?x48396 ?x7704)))
 (let ((@x71216 (monotonicity (trans* @x62867 @x62874 @x62876 (= ?x48396 ?x47945)) (= $x56945 (has_type ?x47945 ?x7704)))))
 (let (($x48701 (has_type ?x47945 ?x7704)))
 (let (($x48702 (or $x48693 $x48701)))
 (let (($x48705 (or $x48694 $x48693 $x48701)))
 (let ((@x48710 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. ?x47936)) (or $x48694 $x48702)) (rewrite (= (or $x48694 $x48702) $x48705)) $x48705)))
 (let ((@x71343 (mp (unit-resolution (unit-resolution @x48710 @x14001 $x48702) @x57501 $x48701) (symm @x71216 (= $x48701 $x56945)) $x56945)))
 (let (($x56947 (not $x56945)))
 (let (($x56963 (or $x56947 $x56956)))
 (let (($x56965 (or $x55886 $x56947 $x56956)))
 (let ((?x56941 (%Poly%core!option.Option. ?x48401)))
 (let ((?x56942 (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x56941)))
 (let (($x56943 (has_type ?x56942 TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState.)))
 (let (($x56939 (has_type ?x48401 ?x7704)))
 (let (($x56940 (not $x56939)))
 (let (($x56944 (or $x56940 $x56943)))
 (let (($x56967 (or $x55886 $x56944)))
 (let ((@x56976 (trans (monotonicity (rewrite (= $x56944 $x56963)) (= $x56967 (or $x55886 $x56963))) (rewrite (= (or $x55886 $x56963) $x56965)) (= $x56967 $x56965))))
 (let ((@x56974 (mp ((_ quant-inst $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (tuple%2./tuple%2/?1 ?x48397)) $x56967) @x56976 $x56965)))
 (let ((@x71471 (mp (unit-resolution (unit-resolution @x56974 @x11321 $x56963) @x71343 $x56956) (symm (monotonicity @x71922 (= $x57090 $x56956)) (= $x56956 $x57090)) $x57090)))
 (let (($x57109 (not $x57090)))
 (let (($x57111 (or $x57109 $x57110)))
 (let (($x57114 (or $x56851 $x57109 $x57110)))
 (let ((@x57187 (mp ((_ quant-inst (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47955)) (or $x56851 $x57111)) (rewrite (= (or $x56851 $x57111) $x57114)) $x57114)))
 (let ((@x71495 (monotonicity (unit-resolution (unit-resolution @x57187 @x11482 $x57111) @x71471 $x57110) (symm @x47428 $x62260) (= $x61928 $x47966))))
 (let ((@x70778 (monotonicity (monotonicity (monotonicity @x70203 (= ?x69495 ?x47950)) (= ?x69496 ?x47951)) (= ?x69506 ?x47958))))
 (let ((@x71367 (monotonicity (monotonicity (monotonicity @x70778 (= ?x69507 ?x47959)) (= ?x69508 ?x47963)) @x56782 (= ?x69509 ?x47964))))
 (let ((@x68739 (monotonicity (monotonicity (monotonicity @x70210 (= ?x69503 ?x47960)) (= ?x69504 ?x47961)) (= ?x69505 ?x47962))))
 (let ((@x68480 (mp (unit-resolution (def-axiom (or $x69535 $x69511)) @x70982 $x69511) (monotonicity @x68739 (monotonicity @x71367 (= ?x69510 ?x47965)) (= $x69511 $x47966)) $x47966)))
 (let ((@x71500 (unit-resolution (def-axiom (or (not $x68727) $x61901 (not $x61928))) (mp @x68480 (symm @x71495 (= $x47966 $x61928)) $x61928) (unit-resolution (mp ((_ quant-inst false TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. (core!option.Option./Some/0 $ TYPE%pmemlog!infinitelog_t.AbstractInfiniteLogState. ?x47955) (core!option.Option./Some/?0 ?x47902)) $x71462) @x71482 $x71451) @x10696 $x68727) $x61901)))
 (let ((@x71650 (trans* (symm @x71500 (= ?x47901 ?x47960)) (unit-resolution (unit-resolution @x49147 @x11314 $x49138) @x70987 $x49134) @x71646 (= ?x47901 ?x69682))))
 (let (($x69703 (= ?x69500 ?x69698)))
 (let ((@x70988 (symm @x70210 (= ?x47955 ?x69500))))
 (let ((?x62331 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x55990 ?x7131 ?x59165)))
 (let ((?x62418 (Poly%vstd!seq.Seq<u8.>. ?x62331)))
 (let ((?x71246 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x55990 ?x7131 ?x59165 ?x47547)))
 (let ((?x71247 (Poly%vstd!seq.Seq<u8.>. ?x71246)))
 (let (($x71274 (ext_eq false ?x1968 ?x71247 ?x62418)))
 (let ((@x71427 (monotonicity (monotonicity @x56802 @x58900 @x59174 (= ?x62331 ?x47936)) (= ?x62418 ?x47937))))
 (let (($x72024 (= ?x63187 ?x71247)))
 (let (($x71972 (= ?x71247 ?x63187)))
 (let (($x71478 (= ?x71246 ?x47486)))
 (let (($x71986 (= ?x71246 ?x47998)))
 (let (($x54422 (= ?x47944 pmemlog!pmemspec_t.cdb1_val.?)))
 (let (($x71958 (= pmemlog!pmemspec_t.cdb1_val.? ?x47944)))
 (let ((@x71964 (trans (monotonicity @x67295 (= $x47974 $x71958)) (commutativity (= $x71958 $x54422)) (= $x47974 $x54422))))
 (let ((@x71944 (monotonicity (monotonicity (monotonicity @x69905 (= ?x69519 ?x47940)) (= ?x69520 ?x47941)) (= ?x69521 ?x47942))))
 (let ((@x71949 (trans* @x65746 @x65768 @x69045 @x69050 @x69055 (symm (monotonicity @x71944 (= ?x69522 ?x47943)) (= ?x47943 ?x69522)) (= ?x50607 ?x69522))))
 (let ((@x71953 (symm (monotonicity @x71949 (= ?x51034 ?x69523)) (= ?x69523 ?x51034))))
 (let ((@x71968 (trans* (monotonicity (trans* @x71953 @x65764 (= ?x69523 ?x47944)) @x67300 (= $x69532 $x54422)) (symm @x71964 (= $x54422 $x47974)) (= $x69532 $x47974))))
 (let ((@x71655 (unit-resolution (def-axiom (or $x69535 $x69532)) @x70982 $x69532)))
 (let ((@x69913 (trans* (symm (monotonicity @x69905 (= ?x69516 ?x47939)) (= ?x47939 ?x69516)) (hypothesis $x69517) @x62625 $x62620)))
 (let ((@x69918 (monotonicity (symm (monotonicity (symm (monotonicity @x69913 $x62627) $x62629) $x62682) $x62684) $x62687)))
 (let ((@x69922 (lemma (unit-resolution @x62675 (mp @x62600 @x69918 $x62686) false) (or $x47972 $x69518))))
 (let ((@x71979 (unit-resolution @x69922 (unit-resolution (def-axiom (or $x69535 $x69517)) @x70982 $x69517) $x47972)))
 (let ((@x71991 (mp (unit-resolution (def-axiom (or $x69535 $x69514)) @x70982 $x69514) (monotonicity (monotonicity @x69905 (= ?x69513 ?x47967)) (= $x69514 $x47968)) $x47968)))
 (let ((@x71993 (unit-resolution @x48505 (unit-resolution @x69308 @x71991 @x71979 @x68480 (mp @x71655 @x71968 $x47974) @x70987 $x48125) $x48128)))
 (let (($x61849 (not $x61836)))
 (let (($x61854 (or $x61849 (not (= (vstd!bytes.spec_u64_from_le_bytes.? ?x47935) (%I ?x47924))))))
 (let (($x61855 (not $x61854)))
 (let (($x61848 (has_type ?x47924 ?x4023)))
 (let ((@x71998 (trans* @x67295 @x60927 (symm @x71655 $x69524) @x71953 (symm @x65745 (= ?x51034 ?x50606)) (= new_ib! ?x50606))))
 (let ((@x72002 (trans* (monotonicity @x71998 (= ?x47924 ?x50607)) @x65746 @x65768 @x69045 @x69050 @x69055 (= ?x47924 ?x47943))))
 (let ((@x72007 (mp @x69211 (symm (monotonicity @x72002 (= $x61848 $x57052)) (= $x57052 $x61848)) $x61848)))
 (let (($x61842 (not $x61848)))
 (let (($x61856 (or $x61842 $x61855)))
 (let (($x71355 (or $x17380 $x61842 $x61855)))
 (let ((@x71364 (mp ((_ quant-inst (I new_ib!)) (or $x17380 $x61856)) (rewrite (= (or $x17380 $x61856) $x71355)) $x71355)))
 (let ((@x72010 (unit-resolution (def-axiom (or $x61854 $x61836)) (unit-resolution (unit-resolution @x71364 @x69115 $x61856) @x72007 $x61855) $x61836)))
 (let ((@x72013 (unit-resolution @x48534 (unit-resolution @x48388 (unit-resolution @x62438 @x72010 @x69209 @x69208 $x47931) $x48001) @x69264 $x48147)))
 (let ((@x72015 (unit-resolution @x48522 (unit-resolution @x48526 @x72013 $x48136) @x71993 $x48133)))
 (let ((@x72021 (unit-resolution @x48511 @x72015 $x48034)))
 (let ((@x72022 (unit-resolution @x65853 @x11230 @x72021 $x47479)))
 (let ((@x71911 (trans* (monotonicity @x56802 @x58900 @x59174 (symm @x72022 $x68682) $x71986) @x63190 $x71478)))
 (let ((@x71904 (monotonicity (symm (monotonicity @x71911 $x71972) $x72024) (trans* @x68997 (symm @x71427 (= ?x47937 ?x62418)) (= ?x57826 ?x62418)) (= $x69149 $x71274))))
 (let (($x71273 (ext_eq false ?x1968 ?x71247 ?x55990)))
 (let (($x72032 (not $x71273)))
 (let ((@x72018 (unit-resolution @x67101 (mp (unit-resolution @x48514 @x72015 $x48512) @x69251 $x67102) (unit-resolution @x66949 @x48054 @x65630 $x64851) $x66942)))
 (let ((@x72023 (monotonicity (trans* (monotonicity @x56802 @x58900 @x59174 @x68683 $x71986) @x63190 $x71478) $x71972)))
 (let ((@x72029 (symm (monotonicity (symm @x72023 $x72024) @x69062 (= $x69054 $x71273)) (= $x71273 $x69054))))
 (let ((@x72034 (lemma (unit-resolution @x69196 (mp (hypothesis $x71273) @x72029 $x69054) false) (or $x72032 (not $x47479) $x69053))))
 (let ((@x71974 (unit-resolution @x72034 @x72022 (unit-resolution @x69362 (unit-resolution @x66087 @x72018 $x66968) $x69066) $x72032)))
 (let (($x62487 (forall ((chunks_flushed$ Poly) )(! (let ((?x47924 (I new_ib!)))
 (let ((?x47925 (vstd!bytes.spec_u64_to_le_bytes.? ?x47924)))
 (let ((?x47935 (Poly%vstd!seq.Seq<u8.>. ?x47925)))
 (let ((?x48684 (%Poly%vstd!seq.Seq<u8.>. ?x47935)))
 (let ((?x59165 (Poly%vstd!seq.Seq<u8.>. ?x48684)))
 (let ((?x7131 (I 0)))
 (let ((?x47674 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x48663 (%Poly%vstd!seq.Seq<u8.>. ?x47674)))
 (let ((?x55990 (Poly%vstd!seq.Seq<u8.>. ?x48663)))
 (let ((?x62331 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x55990 ?x7131 ?x59165)))
 (let ((?x62418 (Poly%vstd!seq.Seq<u8.>. ?x62331)))
 (let ((?x62485 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x55990 ?x7131 ?x59165 chunks_flushed$)))
 (let ((?x62472 (Poly%vstd!seq.Seq<u8.>. ?x62485)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 (ext_eq false ?x1968 ?x62472 ?x55990) (ext_eq false ?x1968 ?x62472 ?x62418)))))))))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. pm!))) (I 0) (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. (vstd!bytes.spec_u64_to_le_bytes.? (I new_ib!))))) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_51))
 ))
 (let (($x62480 (ens%pmemlog!logimpl_v.lemma_single_write_crash. ?x48663 0 ?x48684)))
 (let (($x62488 (not $x62480)))
 (let (($x62489 (or $x62488 $x62487)))
 (let ((?x62419 (chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_51!25 ?x48684 0 ?x48663)))
 (let ((?x62420 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x55990 ?x7131 ?x59165 ?x62419)))
 (let ((?x62421 (Poly%vstd!seq.Seq<u8.>. ?x62420)))
 (let (($x62476 (or (not (has_type ?x62419 ?x1998)) (ext_eq false ?x1968 ?x62421 ?x55990) (ext_eq false ?x1968 ?x62421 ?x62418))))
 (let (($x62490 (not $x62489)))
 (let (($x62491 (or $x62490 (not (or $x62480 (not $x62476))))))
 (let (($x62492 (not $x62491)))
 (let ((@x71977 (unit-resolution (def-axiom (or $x62491 $x62489)) (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47674) 0 (%Poly%vstd!seq.Seq<u8.>. ?x47935)) (or (not $x19625) $x62492)) @x19630 $x62492) $x62489)))
 (let ((@x71762 (symm (monotonicity @x56800 @x69325 (trans* @x59172 @x69274 $x62341) (= $x62480 $x47933)) (= $x47933 $x62480))))
 (let ((@x71895 (unit-resolution (def-axiom (or $x62490 $x62488 $x62487)) (mp (unit-resolution (def-axiom (or $x48146 $x47933)) @x72013 $x47933) @x71762 $x62480) @x71977 $x62487)))
 (let (($x68741 (not $x62487)))
 (let (($x70907 (or $x68741 $x65077 $x71273 $x71274)))
 (let ((@x70775 (mp ((_ quant-inst (Poly%vstd!set.Set<int.>. ?x47546)) (or $x68741 (or $x65077 $x71273 $x71274))) (rewrite (= (or $x68741 (or $x65077 $x71273 $x71274)) $x70907)) $x70907)))
 (let ((@x71901 (unit-resolution @x70775 (mp @x72021 (monotonicity @x72022 (= $x48034 $x65076)) $x65076) @x71895 (or $x71273 $x71274))))
 (let ((@x71908 (unit-resolution @x69163 (mp (unit-resolution @x71901 @x71974 $x71274) (symm @x71904 (= $x71274 $x69149)) $x69149) @x69266 $x69145)))
 (let ((@x71985 (trans* (monotonicity (trans* @x71908 @x68997 (= ?x63187 ?x47937)) (= ?x64841 ?x47938)) @x62865 @x69294 @x70988 (unit-resolution ((_ th-lemma datatype) (or $x69703 $x69502)) @x70983 $x69703) (symm (monotonicity @x71650 (= ?x47902 ?x69698)) (= ?x69698 ?x47902)) $x64849)))
 (let ((@x71981 (unit-resolution (unit-resolution (def-axiom (or $x64850 (not $x64849))) @x72018 (not $x64849)) @x71985 false)))
 (let ((@x71983 (lemma @x71981 $x48159)))
 (let ((@x68665 (unit-resolution @x48381 (unit-resolution @x48252 @x71983 $x48055) $x48379)))
 (let (($x47025 (not $x6751)))
 (let (($x68423 (or $x10209 $x47025 $x56114)))
 (let (($x68419 (not $x68423)))
 (let (($x68321 (= pmemlog!pmemspec_t.cdb0_val.? 12331324665725530551)))
 (let (($x68424 (not $x68321)))
 (let (($x68407 (or $x10196 $x68424 $x56121)))
 (let (($x68414 (not $x68407)))
 (let (($x68305 (or $x10185 $x68321 $x6751)))
 (let (($x68421 (not $x68305)))
 (let (($x65278 (req%pmemlog!logimpl_v.lemma_append_ib_update_effect_on_committed. Perm&. Perm& ?x48663 12331324665725530551 ?x48676 ?x48671 perm!)))
 (let (($x68437 (or $x65278 $x56137 $x56130 $x68421 $x68414 $x68419 $x56111 $x56195 $x56079 $x56075 $x56230 $x56009)))
 (let (($x68440 (not $x68437)))
 (let (($x68387 (or $x56137 $x56130 $x68421 $x68414 $x68419 $x56111 $x56195 $x56079 $x56075 $x56230 $x56148)))
 (let (($x68436 (not $x68387)))
 (let (($x65201 (not $x65278)))
 (let (($x68439 (or $x65201 $x68436)))
 (let (($x54647 (not $x68439)))
 (let (($x68385 (or $x54647 $x68440)))
 (let (($x68333 (not $x68385)))
 (let (($x68392 (or $x60997 $x68333)))
 (let (($x68288 (not (or $x10209 (not $x65277) $x56114))))
 (let (($x64515 (not (or $x10196 (not (= 12331324665725530551 pmemlog!pmemspec_t.cdb0_val.?)) $x56121))))
 (let (($x65204 (not (or $x10185 (= 12331324665725530551 pmemlog!pmemspec_t.cdb0_val.?) $x65277))))
 (let (($x65292 (not (or $x65278 $x56137 $x56130 $x65204 $x64515 $x68288 $x56111 $x56104 $x56079 $x56075 $x56073 $x56009))))
 (let (($x65275 (or $x65201 (not (or $x56137 $x56130 $x65204 $x64515 $x68288 $x56111 $x56104 $x56079 $x56075 $x56073 $x56148)))))
 (let (($x68312 (not (or (not $x65275) $x65292))))
 (let (($x68420 (or $x60997 $x68312)))
 (let (($x55134 (= $x68420 $x68392)))
 (let ((@x68560 (trans (monotonicity (rewrite (= $x68312 $x68333)) $x55134) (rewrite (= $x68392 $x68392)) $x55134)))
 (let ((@x68562 (mp ((_ quant-inst Perm&. Perm& (%Poly%vstd!seq.Seq<u8.>. ?x47674) 12331324665725530551 (%Poly%vstd!seq.Seq<u8.>. ?x47745) (%Poly%vstd!seq.Seq<u8.>. ?x47723) perm!) $x68420) @x68560 $x68392)))
 (let ((@x67252 (def-axiom (or $x68385 $x68437))))
 (let ((@x67292 (unit-resolution @x67252 (unit-resolution @x68562 @x19500 $x68333) $x68437)))
 (let ((@x67291 (symm (monotonicity @x56800 @x67297 @x56780 @x58471 (= $x65278 $x47920)) (= $x47920 $x65278))))
 (let ((@x67257 (monotonicity @x67291 (= $x48379 $x65201))))
 (let ((@x47188 (hypothesis $x48379)))
 (let ((?x47713 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x9036 ?x7453)))
 (let ((?x47714 (%Poly%vstd!seq.Seq<u8.>. ?x47713)))
 (let ((?x67217 (Poly%vstd!seq.Seq<u8.>. ?x47714)))
 (let (($x47715 (= ?x47714 new_header_bytes!)))
 (let (($x47719 (or (not $x47699) $x47715)))
 (let ((@x47722 (mp (asserted (=> $x47699 $x47715)) (rewrite (= (=> $x47699 $x47715) $x47719)) $x47719)))
 (let (($x68866 (= ?x47713 ?x67217)))
 (let (($x67210 (has_type ?x47713 ?x1968)))
 (let ((?x67191 (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x9036 ?x7471)))
 (let (($x67186 (has_type ?x67191 ?x1968)))
 (let ((@x60420 (symm @x58886 (= ?x7412 pmemlog!logimpl_v.contents_offset.?))))
 (let ((?x51042 (I ?x7412)))
 (let ((?x51043 (%I ?x51042)))
 (let (($x51046 (= ?x7412 ?x51043)))
 (let (($x51049 (or $x48740 $x51046)))
 (let ((@x51050 ((_ quant-inst (uClip 64 ?x7411)) $x51049)))
 (let ((@x55255 (unit-resolution @x51050 @x10612 $x51046)))
 (let ((@x60422 (monotonicity @x60420 (= ?x51042 ?x7471))))
 (let ((@x68855 (monotonicity @x60422 (= ?x51043 (%I ?x7471)))))
 (let (($x50456 (>= ?x50454 0)))
 (let ((?x61389 (%I ?x7471)))
 (let ((?x61379 (* (- 1) ?x61389)))
 (let ((?x61491 (+ ?x7412 ?x61379)))
 (let (($x61473 (<= ?x61491 0)))
 (let (($x60316 (= ?x7412 ?x61389)))
 (let ((@x68856 (trans* @x55255 @x68855 $x60316)))
 (let (($x61474 (>= ?x61491 0)))
 (let ((@x68656 ((_ th-lemma arith eq-propagate 1 1 1 1 1 1 -1 -1 1 1) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x60316) $x61474)) @x68856 $x61474) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x60316) $x61473)) @x68856 $x61473) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50401) $x50456)) @x58878 $x50456) @x58879 @x58869 @x58857 @x58847 @x58836 @x58866 @x58852 (= ?x61389 72))))
 (let ((?x51139 (Add 40 32)))
 (let (($x51151 (= ?x51139 72)))
 (let (($x51155 (or $x48769 $x51151)))
 (let ((?x51140 (* (- 1) ?x51139)))
 (let ((?x51141 (+ 32 40 ?x51140)))
 (let (($x51142 (= ?x51141 0)))
 (let (($x51156 (or $x48769 $x51142)))
 (let (($x51158 (= $x51156 $x51155)))
 (let ((@x51149 (monotonicity (rewrite (= ?x51141 (+ 72 ?x51140))) (= $x51142 (= (+ 72 ?x51140) 0)))))
 (let ((@x51154 (trans @x51149 (rewrite (= (= (+ 72 ?x51140) 0) $x51151)) (= $x51142 $x51151))))
 (let ((@x51163 (mp ((_ quant-inst 40 32) $x51156) (trans (monotonicity @x51154 $x51158) (rewrite (= $x51155 $x51155)) $x51158) $x51155)))
 (let ((@x60159 (unit-resolution @x51163 @x10850 $x51151)))
 (let ((@x60163 (monotonicity @x58832 @x58646 (= ?x7452 ?x51139))))
 (let ((@x68868 (trans* @x60163 @x60159 (symm @x68656 (= 72 ?x61389)) (symm @x68855 (= ?x61389 ?x51043)) (symm @x55255 (= ?x51043 ?x7412)) @x60420 (= ?x7452 pmemlog!logimpl_v.contents_offset.?))))
 (let ((@x64418 (monotonicity (symm (monotonicity @x68868 (= ?x7453 ?x7471)) (= ?x7471 ?x7453)) (= ?x67191 ?x47713))))
 (let ((@x65222 (symm (monotonicity (symm @x64418 (= ?x47713 ?x67191)) (= $x67210 $x67186)) (= $x67186 $x67210))))
 (let (($x50980 (has_type ?x7471 INT)))
 (let (($x60409 (has_type ?x51042 INT)))
 (let (($x60427 (not $x60409)))
 (let ((@x60429 (monotonicity (symm (monotonicity @x60422 (= $x60409 $x50980)) (= $x50980 $x60409)) (= (not $x50980) $x60427))))
 (let ((@x60432 (unit-resolution (unit-resolution ((_ quant-inst (uClip 64 ?x7411)) (or (not $x698) $x60409)) @x10752 $x60409) (mp (hypothesis (not $x50980)) @x60429 $x60427) false)))
 (let ((@x60433 (lemma @x60432 $x50980)))
 (let (($x50981 (not $x50980)))
 (let (($x67212 (or $x48719 $x48649 $x53312 $x50981 $x67186)))
 (let ((@x67201 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I pmemlog!logimpl_v.header2_pos.?) (I pmemlog!logimpl_v.contents_offset.?)) (or $x48719 (or $x48649 $x53312 $x50981 $x67186))) (rewrite (= (or $x48719 (or $x48649 $x53312 $x50981 $x67186)) $x67212)) $x67212)))
 (let (($x67231 (not $x67210)))
 (let (($x68858 (or $x67231 $x68866)))
 (let (($x68926 (or $x57707 $x67231 $x68866)))
 (let ((@x68948 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x47674 ?x9036 ?x7453)) (or $x57707 $x68858)) (rewrite (= (or $x57707 $x68858) $x68926)) $x68926)))
 (let ((@x65238 (unit-resolution (unit-resolution @x68948 @x11209 $x68858) (mp (unit-resolution @x67201 @x16488 @x56813 @x60433 @x60582 $x67186) @x65222 $x67210) $x68866)))
 (let ((@x67562 (trans* (monotonicity @x56802 (= ?x56112 ?x47713)) @x65238 (monotonicity (unit-resolution @x47722 @x67295 $x47715) (= ?x67217 ?x47723)) (= ?x56112 ?x47723))))
 (let ((@x68353 (def-axiom (or $x68423 (not $x56114)))))
 (let ((@x69416 (unit-resolution @x68353 (monotonicity @x67562 $x56114) $x68423)))
 (let (($x68497 (>= pmemlog!pmemspec_t.cdb0_val.? 12331324665725530551)))
 (let (($x69424 (not $x68497)))
 (let ((@x69428 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x68424 $x68497)) (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x69424 (not $x49811))) @x60787 $x69424) $x68424)))
 (let ((@x68427 (def-axiom (or $x68407 $x68321))))
 (let ((@x69429 (unit-resolution @x68427 @x69428 $x68407)))
 (let ((@x68357 (def-axiom (or $x68305 $x47025))))
 (let ((@x69421 (unit-resolution @x68357 @x60927 $x68305)))
 (let (($x67197 (or $x68440 $x65278 $x56137 $x56130 $x68421 $x68414 $x68419 $x56111 $x56195 $x56079 $x56075 $x56230 $x56009)))
 (let ((@x67195 (def-axiom $x67197)))
 (let ((@x69433 (unit-resolution @x67195 @x61818 @x60548 @x69421 @x69429 @x61509 (unit-resolution @x61459 (unit-resolution @x61464 @x67506 @x61611 @x60643 $x56225) $x56200) (or $x68440 $x65278 $x56130 $x68419 $x56111 $x56195 $x56079))))
 (let ((@x69434 (unit-resolution @x69433 @x60546 @x69416 (mp @x47188 @x67257 $x65201) @x61225 @x61774 @x61767 @x67292 false)))
 (let ((@x69436 (lemma @x69434 (or $x47920 $x56210 $x56189))))
 (let ((@x71302 (unit-resolution @x66679 (unit-resolution (unit-resolution @x69436 @x68665 (or $x56210 $x56189)) @x67134 $x56210) $x47854)))
 (let ((@x71329 (unit-resolution @x67195 @x61818 @x60548 @x69421 @x69429 @x61509 (or $x68440 $x65278 $x56130 $x68419 $x56111 $x56195 $x56079 $x56230))))
 (let ((@x71301 (unit-resolution @x71329 @x60546 (mp @x68665 @x67257 $x65201) @x61225 @x61774 @x61767 @x69416 @x67292 $x56230)))
 (let ((@x71235 (unit-resolution (unit-resolution @x61464 @x67506 (or $x56225 $x56198 $x56216)) (unit-resolution @x61459 @x71301 $x56239) (or $x56198 $x56216))))
 (let ((@x71261 (unit-resolution (unit-resolution @x66440 (unit-resolution @x71235 @x67154 $x56216) $x56027) (mp (unit-resolution @x48220 @x71302 @x67151 $x47826) @x61607 $x56026) false)))
 (let ((@x71320 (lemma @x71261 $x47835)))
 (let ((@x70677 (unit-resolution @x71235 (unit-resolution @x68052 (unit-resolution @x69407 @x71320 $x56189) $x56217) $x56198)))
 (let ((@x70709 (unit-resolution @x48218 @x71320 $x47857)))
 (let ((@x48368 (def-axiom (or $x48008 $x47818))))
 (unit-resolution @x67971 (mp (unit-resolution @x48364 @x70709 $x47809) @x69366 $x56063) (mp (unit-resolution (def-axiom (or $x48008 $x47815)) @x70709 $x47815) @x69392 $x56060) (mp (unit-resolution @x48368 @x70709 $x47818) @x69382 $x56055) (unit-resolution @x68022 @x70677 $x56065) false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

