(:max-memory   21.76
 :memory       21.76
 :num-allocs   790268
 :rlimit-count 12989)
(:version "4.12.5")
unsat
((declare-fun i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 (Poly Poly Type Dcr) Poly)
(declare-fun chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26 () Poly)
(declare-fun T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 (%%Function%% Type Type) Poly)
(proof
(let ((?x1876 (UINT 8)))
 (let ((?x47321 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x47361 (I write_addr!)))
 (let ((?x47331 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47384 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)))
 (let ((?x47385 (Poly%vstd!seq.Seq<u8.>. ?x47384)))
 (let ((?x47363 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47331 ?x47361 ?x47321)))
 (let ((?x47366 (Poly%vstd!seq.Seq<u8.>. ?x47363)))
 (let ((?x47829 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47366 ?x47385 ?x1876 $)))
 (let ((?x47833 (%I ?x47829)))
 (let ((?x50375 (I ?x47833)))
 (let ((?x50682 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x50375)))
 (let ((?x50798 (%I ?x50682)))
 (let ((?x50683 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x50375 ?x50682 ?x47361 ?x47321)))
 (let ((?x50718 (%I ?x50375)))
 (let ((?x50789 (EucDiv ?x50718 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((?x50790 (I ?x50789)))
 (let ((?x47555 (%Poly%vstd!set.Set<int.>. chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)))
 (let ((?x47556 (Poly%vstd!set.Set<int.>. ?x47555)))
 (let (($x50797 (vstd!set.Set.contains.? $ INT ?x47556 ?x50790)))
 (let ((?x50799 (ite $x50797 ?x50683 ?x50798)))
 (let (($x50805 (= ?x50683 ?x50799)))
 (let ((?x50687 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x50375 ?x50682 ?x47361 ?x47321 ?x47556)))
 (let (($x50800 (= ?x50687 ?x50799)))
 (let (($x8242 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(! (let ((?x4792 (%I prewrite_byte!)))
 (let (($x8237 (vstd!set.Set.contains.? $ INT chunks_flushed! (I (EucDiv (%I addr!) pmemlog!pmemspec_t.persistence_chunk_size.?)))))
 (let ((?x8239 (ite $x8237 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ?x4792)))
 (let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (= ?x8233 ?x8239))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.?_definition))
 ))
 (let (($x8232 (fuel_bool fuel%pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.)))
 (let (($x8230 (fuel_bool_default fuel%pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.)))
 (let (($x49268 (= $x8232 $x8230)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x47319 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x10352 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x10357 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x10352) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x10361 (mp (mp~ @x37 @x10357 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x47616 (unit-resolution @x10361 @x47319 $x30)))
 (let ((@x49283 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.) (or (not $x30) $x49268)) @x47616 (hypothesis (not $x49268)) false)))
 (let ((@x49296 (lemma @x49283 $x49268)))
 (let ((@x8231 (asserted $x8230)))
 (let ((@x49275 (def-axiom (or (not $x49268) $x8232 (not $x8230)))))
 (let ((@x51129 (unit-resolution (unit-resolution @x49275 @x8231 (or (not $x49268) $x8232)) @x49296 $x8232)))
 (let (($x8245 (not $x8232)))
 (let (($x8246 (or $x8245 $x8242)))
 (let ((?x14135 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(let ((?x4792 (%I prewrite_byte!)))
 (let (($x8237 (vstd!set.Set.contains.? $ INT chunks_flushed! (I (EucDiv (%I addr!) pmemlog!pmemspec_t.persistence_chunk_size.?)))))
 (let ((?x8239 (ite $x8237 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ?x4792)))
 (let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8240 (= ?x8233 ?x8239)))
 (refl (~ $x8240 $x8240))))))))
 ))
 (let ((@x14142 (monotonicity (refl (~ $x8245 $x8245)) (nnf-pos (proof-bind ?x14135) (~ $x8242 $x8242)) (~ $x8246 $x8246))))
 (let ((@x8249 (mp (asserted (=> $x8232 $x8242)) (rewrite (= (=> $x8232 $x8242) $x8246)) $x8246)))
 (let ((@x14146 (mp (mp~ @x8249 @x14142 $x8246) (rewrite (= $x8246 $x8246)) $x8246)))
 (let ((@x51130 (unit-resolution @x14146 @x51129 $x8242)))
 (let (($x50609 (not $x8242)))
 (let (($x50803 (or $x50609 $x50800)))
 (let ((@x50804 ((_ quant-inst (I ?x47833) (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x50375) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555)) $x50803)))
 (let ((@x51394 (unit-resolution @x50804 @x51130 $x50800)))
 (let ((?x50690 (I ?x50687)))
 (let ((?x50706 (%I ?x50690)))
 (let (($x50707 (= ?x50687 ?x50706)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x10518 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x10522 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x10518) (~ $x237 $x237)) $x237)))
 (let (($x47604 (not $x237)))
 (let (($x50712 (or $x47604 $x50707)))
 (let ((@x50713 ((_ quant-inst (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x50375 ?x50682 ?x47361 ?x47321 ?x47556)) $x50712)))
 (let ((?x47831 (vstd!seq.Seq.index.? $ ?x1876 ?x47385 ?x47829)))
 (let ((?x50397 (%I ?x47831)))
 (let (($x51002 (= ?x50397 ?x50706)))
 (let ((?x49271 (%%lambda%%3 $ ?x1876 ?x47331 ?x47361 ?x47321 ?x47556)))
 (let ((?x50686 (%%apply%%0 ?x49271 ?x50375)))
 (let (($x50679 (= ?x50686 ?x50690)))
 (let (($x8288 (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Poly) (%%hole%%5 Poly) (addr$ Poly) )(! (let ((?x8281 (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 addr$)))
 (let ((?x8282 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr$ ?x8281 %%hole%%3 %%hole%%4 %%hole%%5)))
 (let ((?x8303 (%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) addr$)))
 (= ?x8303 (I ?x8282))))) :pattern ( (%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) addr$) ) :qid k!7409))
 ))
 (let ((?x14163 (lambda ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Poly) (%%hole%%5 Poly) (addr$ Poly) )(let ((?x8281 (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 addr$)))
 (let ((?x8282 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr$ ?x8281 %%hole%%3 %%hole%%4 %%hole%%5)))
 (let ((?x8303 (%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) addr$)))
 (let (($x8286 (= ?x8303 (I ?x8282))))
 (refl (~ $x8286 $x8286)))))))
 ))
 (let ((@x14167 (mp~ (asserted $x8288) (nnf-pos (proof-bind ?x14163) (~ $x8288 $x8288)) $x8288)))
 (let (($x49710 (not $x8288)))
 (let (($x50704 (or $x49710 $x50679)))
 (let ((@x50705 ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555) (I ?x47833)) $x50704)))
 (let ((@x51393 (unit-resolution @x50705 @x14167 $x50679)))
 (let (($x50376 (= ?x47829 ?x50375)))
 (let (($x47839 (has_type ?x47829 INT)))
 (let ((?x47830 (vstd!seq.Seq.index.? $ ?x1876 ?x47366 ?x47829)))
 (let (($x47832 (= ?x47831 ?x47830)))
 (let ((?x47834 (* (- 1) ?x47833)))
 (let ((?x47729 (vstd!seq.Seq.len.? $ ?x1876 ?x47385)))
 (let ((?x47835 (+ ?x47729 ?x47834)))
 (let (($x47836 (<= ?x47835 0)))
 (let (($x47837 (>= ?x47833 0)))
 (let (($x47838 (not $x47837)))
 (let (($x47840 (not $x47839)))
 (let (($x47841 (or $x47840 $x47838 $x47836 $x47832)))
 (let (($x47842 (not $x47841)))
 (let ((?x47843 (vstd!seq.Seq.len.? $ ?x1876 ?x47366)))
 (let (($x47844 (= ?x47729 ?x47843)))
 (let ((?x48261 (%%lambda%%1 $ ?x1876 ?x47331 ?x47361 ?x47321)))
 (let ((?x48277 (mk_fun ?x48261)))
 (let ((?x48293 (Poly%fun%1. ?x48277)))
 (let ((?x47332 (vstd!seq.Seq.len.? $ ?x1876 ?x47331)))
 (let ((?x48288 (I ?x47332)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x48294 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 ?x48288 ?x48293)))
 (let ((?x50311 (vstd!seq.Seq.len.? $ ?x1876 ?x48294)))
 (let ((?x48295 (%Poly%vstd!seq.Seq<u8.>. ?x48294)))
 (let ((?x49459 (Poly%vstd!seq.Seq<u8.>. ?x48295)))
 (let (($x49480 (= ?x48294 ?x49459)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x48305 (has_type ?x48294 ?x1968)))
 (let (($x48303 (has_type ?x48293 ?x6520)))
 (let ((?x48307 (%Poly%fun%1. ?x48293)))
 (let ((?x49471 (mk_fun ?x48307)))
 (let ((?x49472 (Poly%fun%1. ?x49471)))
 (let (($x49473 (has_type ?x49472 ?x6520)))
 (let (($x49554 (not $x49473)))
 (let (($x48321 (= ?x48277 ?x48261)))
 (let (($x226 (forall ((x %%Function%%) )(! (let ((?x223 (mk_fun x)))
 (= ?x223 x)) :pattern ( (mk_fun x) ) :qid prelude_mk_fun))
 ))
 (let ((?x10504 (lambda ((x %%Function%%) )(refl (~ (= (mk_fun x) x) (= (mk_fun x) x))))
 ))
 (let ((@x10508 (mp~ (asserted $x226) (nnf-pos (proof-bind ?x10504) (~ $x226 $x226)) $x226)))
 (let (($x48326 (not $x226)))
 (let (($x48327 (or $x48326 $x48321)))
 (let ((@x48328 ((_ quant-inst (%%lambda%%1 $ ?x1876 ?x47331 ?x47361 ?x47321)) $x48327)))
 (let (($x48308 (= ?x48277 ?x48307)))
 (let (($x1726 (forall ((x %%Function%%) )(! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ( (Poly%fun%1. x) ) :qid internal_crate__fun__1_box_axiom_definition))
 ))
 (let ((?x10952 (lambda ((x %%Function%%) )(let (($x1724 (= x (%Poly%fun%1. (Poly%fun%1. x)))))
 (refl (~ $x1724 $x1724))))
 ))
 (let ((@x10956 (mp~ (asserted $x1726) (nnf-pos (proof-bind ?x10952) (~ $x1726 $x1726)) $x1726)))
 (let (($x48318 (not $x1726)))
 (let (($x48319 (or $x48318 $x48308)))
 (let ((@x48320 ((_ quant-inst (mk_fun ?x48261)) $x48319)))
 (let ((@x49456 (trans* (symm (unit-resolution @x48320 @x10956 $x48308) (= ?x48307 ?x48277)) (unit-resolution @x48328 @x10508 $x48321) (= ?x48307 ?x48261))))
 (let ((@x49568 (monotonicity (monotonicity (monotonicity @x49456 (= ?x49471 ?x48277)) (= ?x49472 ?x48293)) (= $x49473 $x48303))))
 (let ((@x49569 (mp (hypothesis (not $x48303)) (monotonicity (symm @x49568 (= $x48303 $x49473)) (= (not $x48303) $x49554)) $x49554)))
 (let ((?x49334 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x48307 ?x1876 INT)))
 (let ((?x49467 (%%apply%%0 ?x48307 ?x49334)))
 (let (($x49468 (has_type ?x49467 ?x1876)))
 (let (($x49330 (has_type ?x49334 INT)))
 (let (($x49466 (not $x49330)))
 (let (($x49469 (or $x49466 $x49468)))
 (let ((?x49475 (%I ?x49334)))
 (let ((?x49476 (I ?x49475)))
 (let (($x49510 (has_type ?x49476 INT)))
 (let (($x49491 (= ?x49334 ?x49476)))
 (let (($x49470 (not $x49469)))
 (let ((@x49721 (hypothesis $x49470)))
 (let ((@x49487 (def-axiom (or $x49469 $x49330))))
 (let ((@x49723 (unit-resolution @x49487 @x49721 $x49330)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x10539 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x10543 (mp~ @x280 (nnf-pos (proof-bind ?x10539) (~ $x275 $x275)) $x275)))
 (let (($x49500 (not $x275)))
 (let (($x49496 (or $x49500 $x49466 $x49491)))
 (let ((@x49512 (mp ((_ quant-inst (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x48307 ?x1876 INT)) (or $x49500 (or $x49466 $x49491))) (rewrite (= (or $x49500 (or $x49466 $x49491)) $x49496)) $x49496)))
 (let ((@x49752 (symm (unit-resolution @x49512 @x10543 @x49723 $x49491) (= ?x49476 ?x49334))))
 (let ((@x49745 (mp @x49723 (symm (monotonicity @x49752 (= $x49510 $x49330)) (= $x49330 $x49510)) $x49510)))
 (let ((?x49494 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49334)))
 (let (($x49514 (has_type ?x49494 ?x1876)))
 (let ((@x49726 (monotonicity (monotonicity @x49752 (= (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49476) ?x49494)) (= (has_type (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49476) ?x1876) $x49514))))
 (let ((?x49544 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49476)))
 (let (($x49545 (has_type ?x49544 ?x1876)))
 (let (($x47419 (has_type ?x47331 ?x1968)))
 (let ((?x47438 (%Poly%vstd!seq.Seq<u8.>. ?x47331)))
 (let ((?x49332 (Poly%vstd!seq.Seq<u8.>. ?x47438)))
 (let (($x49333 (has_type ?x49332 ?x1968)))
 (let (($x49376 (not $x49333)))
 (let (($x47439 (= pm! ?x47438)))
 (let (($x1966 (forall ((x vstd!seq.Seq<u8.>.) )(! (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x))) :pattern ( (Poly%vstd!seq.Seq<u8.>. x) ) :qid internal_vstd__seq__Seq<u8.>_box_axiom_definition))
 ))
 (let ((?x11108 (lambda ((x vstd!seq.Seq<u8.>.) )(let (($x1964 (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x)))))
 (refl (~ $x1964 $x1964))))
 ))
 (let ((@x11112 (mp~ (asserted $x1966) (nnf-pos (proof-bind ?x11108) (~ $x1966 $x1966)) $x1966)))
 (let (($x47440 (not $x1966)))
 (let (($x47445 (or $x47440 $x47439)))
 (let ((@x47446 ((_ quant-inst pm!) $x47445)))
 (let ((@x49371 (monotonicity (symm (unit-resolution @x47446 @x11112 $x47439) (= ?x47438 pm!)) (= ?x49332 ?x47331))))
 (let ((@x49378 (monotonicity (symm (monotonicity @x49371 (= $x49333 $x47419)) (= $x47419 $x49333)) (= (not $x47419) $x49376))))
 (let (($x1989 (forall ((x vstd!seq.Seq<u8.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (has_type ?x1962 ?x1968)))) :pattern ( (has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_has_type_always_definition))
 ))
 (let ((?x11122 (lambda ((x vstd!seq.Seq<u8.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (let (($x1987 (has_type ?x1962 ?x1968)))
 (refl (~ $x1987 $x1987)))))))
 ))
 (let ((@x11126 (mp~ (asserted $x1989) (nnf-pos (proof-bind ?x11122) (~ $x1989 $x1989)) $x1989)))
 (let ((@x49381 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47331)) (or (not $x1989) $x49333)) @x11126 $x49333) (mp (hypothesis (not $x47419)) @x49378 $x49376) false)))
 (let ((@x49382 (lemma @x49381 $x47419)))
 (let (($x16111 (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(! (let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x16082 (not $x4101)))
 (or $x16082 $x271 $x4116)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& self! i!) ) :qid internal_vstd!seq.Seq.index.?_pre_post_definition))
 ))
 (let (($x4128 (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(! (let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (or $x4124 $x4116)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& self! i!) ) :qid internal_vstd!seq.Seq.index.?_pre_post_definition))
 ))
 (let ((?x16112 (lambda ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x16082 (not $x4101)))
 (let (($x16106 (or $x16082 $x271 $x4116)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (let (($x4125 (or $x4124 $x4116)))
 (let ((@x16098 (monotonicity (rewrite (= $x4110 (not (or $x16082 $x271)))) (= $x4124 (not (not (or $x16082 $x271)))))))
 (let ((@x16102 (trans @x16098 (rewrite (= (not (not (or $x16082 $x271))) (or $x16082 $x271))) (= $x4124 (or $x16082 $x271)))))
 (trans (monotonicity @x16102 (= $x4125 (or (or $x16082 $x271) $x4116))) (rewrite (= (or (or $x16082 $x271) $x4116) $x16106)) (= $x4125 $x16106))))))))))))))))
 ))
 (let ((?x12256 (lambda ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (let (($x4125 (or $x4124 $x4116)))
 (refl (~ $x4125 $x4125)))))))))))
 ))
 (let (($x4119 (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(! (let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (=> $x4110 $x4116))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& self! i!) ) :qid internal_vstd!seq.Seq.index.?_pre_post_definition))
 ))
 (let ((?x4129 (lambda ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) )(let ((?x4112 (vstd!seq.Seq.index.? A&. A& self! i!)))
 (let (($x4116 (has_type ?x4112 A&)))
 (let (($x263 (has_type i! INT)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4110 (and $x4101 $x263)))
 (let (($x4124 (not $x4110)))
 (let (($x4125 (or $x4124 $x4116)))
 (let (($x4117 (=> $x4110 $x4116)))
 (rewrite (= $x4117 $x4125))))))))))))
 ))
 (let ((@x4133 (mp (asserted $x4119) (quant-intro (proof-bind ?x4129) (= $x4119 $x4128)) $x4128)))
 (let ((@x16116 (mp (mp~ @x4133 (nnf-pos (proof-bind ?x12256) (~ $x4128 $x4128)) $x4128) (quant-intro (proof-bind ?x16112) (= $x4128 $x16111)) $x16111)))
 (let (($x49511 (not $x49510)))
 (let (($x47420 (not $x47419)))
 (let (($x49571 (not $x16111)))
 (let (($x49567 (or $x49571 $x47420 $x49511 $x49545)))
 (let ((@x49581 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x49475)) (or $x49571 (or $x47420 $x49511 $x49545))) (rewrite (= (or $x49571 (or $x47420 $x49511 $x49545)) $x49567)) $x49567)))
 (let ((@x49696 (unit-resolution (unit-resolution @x49581 @x16116 @x49382 (or $x49511 $x49545)) @x49745 $x49545)))
 (let ((?x49518 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x49476 ?x49494 ?x47361 ?x47321)))
 (let (($x49519 (uInv 8 ?x49518)))
 (let (($x49820 (not $x49519)))
 (let ((?x49502 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x49334 ?x49494 ?x47361 ?x47321)))
 (let (($x49564 (uInv 8 ?x49502)))
 (let (($x49565 (not $x49564)))
 (let ((@x49819 (symm (monotonicity (monotonicity @x49752 (= ?x49518 ?x49502)) (= $x49519 $x49564)) (= $x49564 $x49519))))
 (let ((?x49503 (I ?x49502)))
 (let (($x49573 (has_type ?x49503 ?x1876)))
 (let (($x49809 (not $x49573)))
 (let ((@x49601 (symm (monotonicity @x49456 (= ?x49467 (%%apply%%0 ?x48261 ?x49334))) (= (%%apply%%0 ?x48261 ?x49334) ?x49467))))
 (let ((?x49493 (%%apply%%0 ?x48261 ?x49334)))
 (let (($x49504 (= ?x49493 ?x49503)))
 (let (($x6500 (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Poly) (addr$ Poly) )(! (let ((?x6494 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr$ (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 addr$) %%hole%%3 %%hole%%4)))
 (let ((?x6514 (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) addr$)))
 (= ?x6514 (I ?x6494)))) :pattern ( (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) addr$) ) :qid k!5591))
 ))
 (let ((?x13415 (lambda ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Poly) (addr$ Poly) )(let ((?x6494 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr$ (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 addr$) %%hole%%3 %%hole%%4)))
 (let ((?x6514 (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) addr$)))
 (let (($x6498 (= ?x6514 (I ?x6494))))
 (refl (~ $x6498 $x6498))))))
 ))
 (let ((@x13419 (mp~ (asserted $x6500) (nnf-pos (proof-bind ?x13415) (~ $x6500 $x6500)) $x6500)))
 (let ((@x49599 (symm (unit-resolution ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x48307 ?x1876 INT)) (or (not $x6500) $x49504)) @x13419 $x49504) (= ?x49503 ?x49493))))
 (let ((@x49808 (symm (monotonicity (trans* @x49599 @x49601 (= ?x49503 ?x49467)) (= $x49573 $x49468)) (= $x49468 $x49573))))
 (let ((@x49811 (mp (unit-resolution (def-axiom (or $x49469 (not $x49468))) @x49721 (not $x49468)) (monotonicity @x49808 (= (not $x49468) $x49809)) $x49809)))
 (let (($x49574 (or $x49565 $x49573)))
 (let (($x766 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (or $x762 $x757)))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x10686 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (refl (~ $x763 $x763)))))))))
 ))
 (let (($x760 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (=> $x648 $x757))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x767 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (let (($x758 (=> $x648 $x757)))
 (rewrite (= $x758 $x763))))))))))
 ))
 (let ((@x771 (mp (asserted $x760) (quant-intro (proof-bind ?x767) (= $x760 $x766)) $x766)))
 (let ((@x10690 (mp~ @x771 (nnf-pos (proof-bind ?x10686) (~ $x766 $x766)) $x766)))
 (let (($x49582 (not $x766)))
 (let (($x49578 (or $x49582 $x49565 $x49573)))
 (let ((@x49610 (mp ((_ quant-inst 8 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x49334 ?x49494 ?x47361 ?x47321)) (or $x49582 $x49574)) (rewrite (= (or $x49582 $x49574) $x49578)) $x49578)))
 (let ((@x49825 (mp (unit-resolution (unit-resolution @x49610 @x10690 $x49574) @x49811 $x49565) (monotonicity @x49819 (= $x49565 $x49820)) $x49820)))
 (let (($x49516 (has_type ?x47361 INT)))
 (let ((?x47588 (%I ?x47361)))
 (let ((?x50083 (I ?x47588)))
 (let (($x50084 (has_type ?x50083 INT)))
 (let (($x50098 (not $x50084)))
 (let (($x47589 (= write_addr! ?x47588)))
 (let (($x47605 (or $x47604 $x47589)))
 (let ((@x47606 ((_ quant-inst write_addr!) $x47605)))
 (let ((@x50086 (unit-resolution @x47606 @x10522 $x47589)))
 (let ((@x50091 (symm @x50086 (= ?x47588 write_addr!))))
 (let ((@x50097 (symm (monotonicity (monotonicity @x50091 (= ?x50083 ?x47361)) (= $x50084 $x49516)) (= $x49516 $x50084))))
 (let ((@x50101 (mp (hypothesis (not $x49516)) (monotonicity @x50097 (= (not $x49516) $x50098)) $x50098)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x10658 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x10662 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x10658) (~ $x698 $x698)) $x698)))
 (let ((@x50103 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x47361)) (or (not $x698) $x50084)) @x10662 $x50084) @x50101 false)))
 (let ((@x50104 (lemma @x50103 $x49516)))
 (let (($x47415 (has_type ?x47321 ?x1968)))
 (let ((?x47430 (%Poly%vstd!seq.Seq<u8.>. ?x47321)))
 (let ((?x49746 (Poly%vstd!seq.Seq<u8.>. ?x47430)))
 (let (($x49747 (has_type ?x49746 ?x1968)))
 (let (($x49787 (not $x49747)))
 (let (($x47431 (= bytes_to_write! ?x47430)))
 (let (($x47441 (or $x47440 $x47431)))
 (let ((@x47442 ((_ quant-inst bytes_to_write!) $x47441)))
 (let ((@x49771 (monotonicity (symm (unit-resolution @x47442 @x11112 $x47431) (= ?x47430 bytes_to_write!)) (= ?x49746 ?x47321))))
 (let ((@x49790 (monotonicity (symm (monotonicity @x49771 (= $x49747 $x47415)) (= $x47415 $x49747)) (= (not $x47415) $x49787))))
 (let ((@x49792 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47321)) (or (not $x1989) $x49747)) @x11126 $x49747) (mp (hypothesis (not $x47415)) @x49790 $x49787) false)))
 (let ((@x49793 (lemma @x49792 $x47415)))
 (let (($x17317 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x16184 (not $x4257)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x17296 (not $x6464)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x16450 (not $x4789)))
 (or $x16450 $x17296 $x16184 $x1977 $x6466))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_pre_post_definition))
 ))
 (let (($x6474 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (or $x6470 $x6466))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_pre_post_definition))
 ))
 (let ((?x17318 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x16184 (not $x4257)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x17296 (not $x6464)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x16450 (not $x4789)))
 (let (($x17312 (or $x16450 $x17296 $x16184 $x1977 $x6466)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (let (($x6471 (or $x6470 $x6466)))
 (let ((@x17306 (rewrite (= (not (not (or $x16450 $x17296 $x16184 $x1977))) (or $x16450 $x17296 $x16184 $x1977)))))
 (let ((@x17304 (monotonicity (rewrite (= $x6465 (not (or $x16450 $x17296 $x16184 $x1977)))) (= $x6470 (not (not (or $x16450 $x17296 $x16184 $x1977)))))))
 (let ((@x17311 (monotonicity (trans @x17304 @x17306 (= $x6470 (or $x16450 $x17296 $x16184 $x1977))) (= $x6471 (or (or $x16450 $x17296 $x16184 $x1977) $x6466)))))
 (trans @x17311 (rewrite (= (or (or $x16450 $x17296 $x16184 $x1977) $x6466) $x17312)) (= $x6471 $x17312))))))))))))))))))))))
 ))
 (let ((?x13401 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (let (($x6471 (or $x6470 $x6466)))
 (refl (~ $x6471 $x6471))))))))))))))
 ))
 (let (($x6468 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (=> $x6465 $x6466)))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_pre_post_definition))
 ))
 (let ((?x6475 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6466 (uInv 8 ?x6423)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type write_bytes! ?x1968)))
 (let (($x4257 (has_type write_addr! INT)))
 (let (($x6464 (has_type prewrite_byte! ?x1876)))
 (let (($x4789 (has_type addr! INT)))
 (let (($x6465 (and $x4789 $x6464 $x4257 $x1969)))
 (let (($x6470 (not $x6465)))
 (let (($x6471 (or $x6470 $x6466)))
 (let (($x6467 (=> $x6465 $x6466)))
 (rewrite (= $x6467 $x6471)))))))))))))))
 ))
 (let ((@x6479 (mp (asserted $x6468) (quant-intro (proof-bind ?x6475) (= $x6468 $x6474)) $x6474)))
 (let ((@x17322 (mp (mp~ @x6479 (nnf-pos (proof-bind ?x13401) (~ $x6474 $x6474)) $x6474) (quant-intro (proof-bind ?x17318) (= $x6474 $x17317)) $x17317)))
 (let (($x47416 (not $x47415)))
 (let (($x49517 (not $x49516)))
 (let (($x49515 (not $x49514)))
 (let (($x49528 (not $x17317)))
 (let (($x49524 (or $x49528 $x49511 $x49515 $x49517 $x47416 $x49519)))
 (let ((@x49549 (mp ((_ quant-inst (I ?x49475) (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49334) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)) (or $x49528 (or $x49511 $x49515 $x49517 $x47416 $x49519))) (rewrite (= (or $x49528 (or $x49511 $x49515 $x49517 $x47416 $x49519)) $x49524)) $x49524)))
 (let ((@x49830 (unit-resolution (unit-resolution @x49549 @x17322 @x49793 @x50104 (or $x49511 $x49515 $x49519)) @x49825 (mp @x49696 @x49726 $x49514) @x49745 false)))
 (let ((@x49833 (lemma @x49830 $x49469)))
 (let (($x10978 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(! (let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let ((?x10964 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 x T%1& T%0&)))
 (let (($x10970 (not (or (not (has_type ?x10964 T%0&)) (has_type (%%apply%%0 x ?x10964) T%1&)))))
 (or $x10970 $x1758))))))) :pattern ( (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) ) :qid internal_crate__fun__1_constructor_definition))
 ))
 (let (($x1781 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(! (let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let (($x1767 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (or (not (has_type T%0 T%0&)) $x1753)) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1775 (not $x1767)))
 (or $x1775 $x1758))))))) :pattern ( (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) ) :qid internal_crate__fun__1_constructor_definition))
 ))
 (let ((?x10979 (lambda ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let ((?x10964 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 x T%1& T%0&)))
 (let (($x10970 (not (or (not (has_type ?x10964 T%0&)) (has_type (%%apply%%0 x ?x10964) T%1&)))))
 (let (($x10975 (or $x10970 $x1758)))
 (let (($x1767 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (or (not (has_type T%0 T%0&)) $x1753)) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1775 (not $x1767)))
 (let (($x1776 (or $x1775 $x1758)))
 (monotonicity (sk (~ $x1775 $x10970)) (refl (~ $x1758 $x1758)) (~ $x1776 $x10975)))))))))))))
 ))
 (let (($x1761 (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(! (let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let (($x1756 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (let (($x1750 (has_type T%0 T%0&)))
 (=> $x1750 $x1753))) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (=> $x1756 $x1758)))))) :pattern ( (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) ) :qid internal_crate__fun__1_constructor_definition))
 ))
 (let ((?x1782 (lambda ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%) )(let ((?x1730 (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)))
 (let ((?x223 (mk_fun x)))
 (let ((?x1757 (Poly%fun%1. ?x223)))
 (let (($x1758 (has_type ?x1757 ?x1730)))
 (let (($x1767 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (or (not (has_type T%0 T%0&)) $x1753)) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1775 (not $x1767)))
 (let (($x1776 (or $x1775 $x1758)))
 (let (($x1756 (forall ((T%0 Poly) )(! (let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (let (($x1750 (has_type T%0 T%0&)))
 (=> $x1750 $x1753))) :pattern ( (has_type (%%apply%%0 x T%0) T%1&) ) :qid internal_crate__fun__1_constructor_inner_definition))
 ))
 (let (($x1759 (=> $x1756 $x1758)))
 (let ((?x1768 (lambda ((T%0 Poly) )(let (($x1753 (has_type (%%apply%%0 x T%0) T%1&)))
 (let (($x1764 (or (not (has_type T%0 T%0&)) $x1753)))
 (let (($x1750 (has_type T%0 T%0&)))
 (let (($x1754 (=> $x1750 $x1753)))
 (rewrite (= $x1754 $x1764)))))))
 ))
 (let ((@x1774 (monotonicity (quant-intro (proof-bind ?x1768) (= $x1756 $x1767)) (= $x1759 (=> $x1767 $x1758)))))
 (trans @x1774 (rewrite (= (=> $x1767 $x1758) $x1776)) (= $x1759 $x1776))))))))))))))
 ))
 (let ((@x1786 (mp (asserted $x1761) (quant-intro (proof-bind ?x1782) (= $x1761 $x1781)) $x1781)))
 (let ((@x10983 (mp~ @x1786 (nnf-pos (proof-bind ?x10979) (~ $x1781 $x10978)) $x10978)))
 (let (($x49495 (not $x10978)))
 (let (($x49482 (or $x49495 $x49470 $x49473)))
 (let ((@x49527 (mp ((_ quant-inst $ INT $ (UINT 8) (%Poly%fun%1. ?x48293)) (or $x49495 (or $x49470 $x49473))) (rewrite (= (or $x49495 (or $x49470 $x49473)) $x49482)) $x49482)))
 (let ((@x49560 (lemma (unit-resolution (unit-resolution @x49527 @x10983 @x49833 $x49473) @x49569 false) $x48303)))
 (let (($x48297 (has_type ?x48288 NAT)))
 (let ((?x48316 (%I ?x48288)))
 (let (($x48317 (= ?x47332 ?x48316)))
 (let (($x48323 (or $x47604 $x48317)))
 (let ((@x48324 ((_ quant-inst (vstd!seq.Seq.len.? $ ?x1876 ?x47331)) $x48323)))
 (let ((@x49423 (unit-resolution @x48324 @x10522 $x48317)))
 (let ((@x50044 (symm @x49423 (= ?x48316 ?x47332))))
 (let ((@x50048 (monotonicity (monotonicity @x50044 (= (I ?x48316) ?x48288)) (= (has_type (I ?x48316) NAT) $x48297))))
 (let ((?x49406 (I ?x48316)))
 (let (($x49407 (has_type ?x49406 NAT)))
 (let ((?x49409 (* (- 1) ?x48316)))
 (let ((?x49410 (+ ?x47332 ?x49409)))
 (let (($x49418 (<= ?x49410 0)))
 (let ((@x49424 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48317) $x49418)) @x49423 $x49418)))
 (let ((?x47529 (Add write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((?x47530 (* (- 1) ?x47529)))
 (let ((?x47553 (+ pmemlog!pmemspec_t.persistence_chunk_size.? write_addr! ?x47530)))
 (let (($x47560 (<= ?x47553 0)))
 (let (($x47554 (= ?x47553 0)))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x10756 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x10760 (mp~ @x925 (nnf-pos (proof-bind ?x10756) (~ $x920 $x920)) $x920)))
 (let (($x47557 (not $x920)))
 (let (($x47558 (or $x47557 $x47554)))
 (let ((@x47559 ((_ quant-inst write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) $x47558)))
 (let ((@x49428 (unit-resolution @x47559 @x10760 $x47554)))
 (let (($x47481 (>= pmemlog!pmemspec_t.persistence_chunk_size.? 0)))
 (let (($x49232 (>= pmemlog!pmemspec_t.persistence_chunk_size.? 8)))
 (let (($x8219 (= pmemlog!pmemspec_t.persistence_chunk_size.? 8)))
 (let (($x8217 (fuel_bool fuel%pmemlog!pmemspec_t.persistence_chunk_size.)))
 (let (($x8211 (fuel_bool_default fuel%pmemlog!pmemspec_t.persistence_chunk_size.)))
 (let (($x49243 (= $x8217 $x8211)))
 (let ((@x49260 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.persistence_chunk_size.) (or (not $x30) $x49243)) @x47616 (hypothesis (not $x49243)) false)))
 (let ((@x49273 (lemma @x49260 $x49243)))
 (let ((@x8214 (asserted $x8211)))
 (let ((@x49251 (def-axiom (or (not $x49243) $x8217 (not $x8211)))))
 (let ((@x49438 (unit-resolution (unit-resolution @x49251 @x8214 (or (not $x49243) $x8217)) @x49273 $x8217)))
 (let (($x8225 (not $x8217)))
 (let (($x8226 (or $x8225 $x8219)))
 (let ((@x8229 (mp (asserted (=> $x8217 $x8219)) (rewrite (= (=> $x8217 $x8219) $x8226)) $x8226)))
 (let ((@x49439 (unit-resolution @x8229 @x49438 $x8219)))
 (let ((@x49440 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x8219) $x49232)) @x49439 $x49232)))
 (let ((?x47322 (vstd!seq.Seq.len.? $ ?x1876 ?x47321)))
 (let ((?x47347 (Add write_addr! ?x47322)))
 (let ((?x47612 (+ ?x47347 ?x47530)))
 (let (($x47614 (>= ?x47612 0)))
 (let (($x47611 (= ?x47347 ?x47529)))
 (let (($x47603 (= pmemlog!pmemspec_t.persistence_chunk_size.? ?x47322)))
 (let (($x47323 (= ?x47322 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((@x47324 (asserted $x47323)))
 (let ((@x49448 (symm (monotonicity (symm @x47324 $x47603) (= ?x47529 ?x47347)) $x47611)))
 (let ((?x47355 (* (- 1) ?x47347)))
 (let ((?x47356 (+ ?x47332 ?x47355)))
 (let (($x47353 (>= ?x47356 0)))
 (let ((@x47359 (mp (asserted (<= ?x47347 ?x47332)) (rewrite (= (<= ?x47347 ?x47332) $x47353)) $x47353)))
 (let (($x47337 (>= write_addr! 0)))
 (let ((?x47345 (* (- 1) ?x47332)))
 (let ((?x47346 (+ write_addr! ?x47345)))
 (let (($x47343 (>= ?x47346 0)))
 (let (($x47348 (not $x47343)))
 (let (($x47350 (and $x47337 $x47348)))
 (let ((@x47354 (rewrite (= (and (<= 0 write_addr!) (< write_addr! ?x47332)) $x47350))))
 (let ((@x47341 (mp (asserted (and (<= 0 write_addr!) (< write_addr! ?x47332))) @x47354 $x47350)))
 (let ((@x47342 (and-elim @x47341 $x47337)))
 (let (($x49340 (>= ?x48316 0)))
 (let (($x49341 (not $x49340)))
 (let (($x49408 (or $x49341 $x49407)))
 (let (($x719 (forall ((x Int) )(! (let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x536 (>= x 0)))
 (let (($x540 (not $x536)))
 (or $x540 $x704))))) :pattern ( (has_type (I x) NAT) ) :qid prelude_has_type_nat))
 ))
 (let ((?x10665 (lambda ((x Int) )(let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x536 (>= x 0)))
 (let (($x540 (not $x536)))
 (let (($x714 (or $x540 $x704)))
 (refl (~ $x714 $x714))))))))
 ))
 (let (($x707 (forall ((x Int) )(! (let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x524 (<= 0 x)))
 (=> $x524 $x704)))) :pattern ( (has_type (I x) NAT) ) :qid prelude_has_type_nat))
 ))
 (let ((?x720 (lambda ((x Int) )(let ((?x233 (I x)))
 (let (($x704 (has_type ?x233 NAT)))
 (let (($x536 (>= x 0)))
 (let (($x540 (not $x536)))
 (let (($x714 (or $x540 $x704)))
 (let (($x524 (<= 0 x)))
 (let (($x705 (=> $x524 $x704)))
 (trans (monotonicity (rewrite (= $x524 $x536)) (= $x705 (=> $x536 $x704))) (rewrite (= (=> $x536 $x704) $x714)) (= $x705 $x714))))))))))
 ))
 (let ((@x724 (mp (asserted $x707) (quant-intro (proof-bind ?x720) (= $x707 $x719)) $x719)))
 (let ((@x10669 (mp~ @x724 (nnf-pos (proof-bind ?x10665) (~ $x719 $x719)) $x719)))
 (let (($x49411 (not $x719)))
 (let (($x49412 (or $x49411 $x49341 $x49407)))
 (let ((@x49417 (mp ((_ quant-inst (%I ?x48288)) (or $x49411 $x49408)) (rewrite (= (or $x49411 $x49408) $x49412)) $x49412)))
 (let ((@x49453 (unit-resolution (unit-resolution @x49417 @x10669 $x49408) (hypothesis (not $x49407)) $x49341)))
 (let ((@x49454 ((_ th-lemma arith farkas 1 1 1 1 1 1 1) @x49453 @x47342 @x47359 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47611) $x47614)) @x49448 $x47614) (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x49232) $x47481)) @x49440 $x47481) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47554) $x47560)) @x49428 $x47560) @x49424 false)))
 (let ((@x49455 (lemma @x49454 $x49407)))
 (let ((@x49986 (mp @x49455 @x50048 $x48297)))
 (let (($x48304 (not $x48303)))
 (let (($x48298 (not $x48297)))
 (let (($x48306 (or $x48298 $x48304 $x48305)))
 (let (($x16259 (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(! (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x15941 (not $x3469)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x16239 (not $x4399)))
 (or $x16239 $x15941 $x4403)))))))) :pattern ( (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) ) :qid internal_vstd!seq.Seq.new.?_pre_post_definition))
 ))
 (let (($x4412 (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(! (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (or $x4408 $x4403)))))))) :pattern ( (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) ) :qid internal_vstd!seq.Seq.new.?_pre_post_definition))
 ))
 (let ((?x16260 (lambda ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x15941 (not $x3469)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x16239 (not $x4399)))
 (let (($x16254 (or $x16239 $x15941 $x4403)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (let (($x4409 (or $x4408 $x4403)))
 (let ((@x16246 (monotonicity (rewrite (= $x4400 (not (or $x16239 $x15941)))) (= $x4408 (not (not (or $x16239 $x15941)))))))
 (let ((@x16250 (trans @x16246 (rewrite (= (not (not (or $x16239 $x15941))) (or $x16239 $x15941))) (= $x4408 (or $x16239 $x15941)))))
 (trans (monotonicity @x16250 (= $x4409 (or (or $x16239 $x15941) $x4403))) (rewrite (= (or (or $x16239 $x15941) $x4403) $x16254)) (= $x4409 $x16254))))))))))))))))
 ))
 (let ((?x12354 (lambda ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (let (($x4409 (or $x4408 $x4403)))
 (refl (~ $x4409 $x4409)))))))))))
 ))
 (let (($x4406 (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(! (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (=> $x4400 $x4403))))))) :pattern ( (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) ) :qid internal_vstd!seq.Seq.new.?_pre_post_definition))
 ))
 (let ((?x4413 (lambda ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly) )(let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4401 (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))
 (let (($x4403 (has_type ?x4401 ?x4402)))
 (let (($x3469 (has_type f! impl%1&)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4400 (and $x4399 $x3469)))
 (let (($x4408 (not $x4400)))
 (let (($x4409 (or $x4408 $x4403)))
 (let (($x4404 (=> $x4400 $x4403)))
 (rewrite (= $x4404 $x4409))))))))))))
 ))
 (let ((@x4417 (mp (asserted $x4406) (quant-intro (proof-bind ?x4413) (= $x4406 $x4412)) $x4412)))
 (let ((@x16264 (mp (mp~ @x4417 (nnf-pos (proof-bind ?x12354) (~ $x4412 $x4412)) $x4412) (quant-intro (proof-bind ?x16260) (= $x4412 $x16259)) $x16259)))
 (let (($x48309 (not $x16259)))
 (let (($x48310 (or $x48309 $x48298 $x48304 $x48305)))
 (let ((@x48315 (mp ((_ quant-inst $ (UINT 8) $ (TYPE%fun%1. $ INT $ ?x1876) (I ?x47332) (Poly%fun%1. ?x48277)) (or $x48309 $x48306)) (rewrite (= (or $x48309 $x48306) $x48310)) $x48310)))
 (let ((@x50330 (unit-resolution (unit-resolution (unit-resolution @x48315 @x16264 $x48306) @x49986 (or $x48304 $x48305)) @x49560 $x48305)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x11115 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x11119 (mp~ @x1986 (nnf-pos (proof-bind ?x11115) (~ $x1981 $x1981)) $x1981)))
 (let (($x49458 (not $x48305)))
 (let (($x49498 (not $x1981)))
 (let (($x49499 (or $x49498 $x49458 $x49480)))
 (let ((@x49419 (mp ((_ quant-inst (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 ?x48288 ?x48293)) (or $x49498 (or $x49458 $x49480))) (rewrite (= (or $x49498 (or $x49458 $x49480)) $x49499)) $x49499)))
 (let (($x48296 (= ?x47363 ?x48295)))
 (let (($x6529 (forall ((prewrite_contents! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x6525 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 (I (vstd!seq.Seq.len.? $ ?x1876 prewrite_contents!)) (Poly%fun%1. (mk_fun (%%lambda%%1 $ ?x1876 prewrite_contents! write_addr! write_bytes!))))))
 (let ((?x6519 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? prewrite_contents! write_addr! write_bytes!)))
 (= ?x6519 (%Poly%vstd!seq.Seq<u8.>. ?x6525)))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_write.? prewrite_contents! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_contents_to_reflect_write.?_definition))
 ))
 (let (($x6517 (fuel_bool fuel%pmemlog!pmemspec_t.update_contents_to_reflect_write.)))
 (let (($x6492 (fuel_bool_default fuel%pmemlog!pmemspec_t.update_contents_to_reflect_write.)))
 (let (($x48272 (= $x6517 $x6492)))
 (let ((@x48289 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.update_contents_to_reflect_write.) (or (not $x30) $x48272)) @x47616 (hypothesis (not $x48272)) false)))
 (let ((@x48302 (lemma @x48289 $x48272)))
 (let ((@x6512 (asserted $x6492)))
 (let ((@x48280 (def-axiom (or (not $x48272) $x6517 (not $x6492)))))
 (let ((@x50334 (unit-resolution (unit-resolution @x48280 @x6512 (or (not $x48272) $x6517)) @x48302 $x6517)))
 (let (($x6532 (not $x6517)))
 (let (($x6533 (or $x6532 $x6529)))
 (let ((?x13424 (lambda ((prewrite_contents! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x6525 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 (I (vstd!seq.Seq.len.? $ ?x1876 prewrite_contents!)) (Poly%fun%1. (mk_fun (%%lambda%%1 $ ?x1876 prewrite_contents! write_addr! write_bytes!))))))
 (let ((?x6519 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? prewrite_contents! write_addr! write_bytes!)))
 (let (($x6527 (= ?x6519 (%Poly%vstd!seq.Seq<u8.>. ?x6525))))
 (refl (~ $x6527 $x6527))))))))
 ))
 (let ((@x13429 (monotonicity (refl (~ $x6532 $x6532)) (nnf-pos (proof-bind ?x13424) (~ $x6529 $x6529)) (~ $x6533 $x6533))))
 (let ((@x6536 (mp (asserted (=> $x6517 $x6529)) (rewrite (= (=> $x6517 $x6529) $x6533)) $x6533)))
 (let ((@x13433 (mp (mp~ @x6536 @x13429 $x6533) (rewrite (= $x6533 $x6533)) $x6533)))
 (let (($x48300 (or (not $x6529) $x48296)))
 (let ((@x48301 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)) $x48300)))
 (let ((@x50340 (monotonicity (unit-resolution @x48301 (unit-resolution @x13433 @x50334 $x6529) $x48296) (= ?x47366 ?x49459))))
 (let ((@x50344 (trans* @x50340 (symm (unit-resolution @x49419 @x11119 @x50330 $x49480) (= ?x49459 ?x48294)) (= ?x47366 ?x48294))))
 (let (($x50312 (= ?x50311 ?x48316)))
 (let (($x16285 (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) )(! (let ((?x1191 (%I len!)))
 (let ((?x4419 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4423 (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4419 len! f!))))
 (let (($x4424 (= ?x4423 ?x1191)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x16239 (not $x4399)))
 (or $x16239 (not (has_type f! ?x4419)) $x4431 $x4424))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)) ) :qid user_vstd__seq__axiom_seq_new_len_3))
 ))
 (let (($x4418 (fuel_bool fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x47678 (= $x4418 $x1585)))
 (let ((@x47680 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_new_len.) (or (not $x30) $x47678)) @x47616 (hypothesis (not $x47678)) false)))
 (let ((@x47692 (lemma @x47680 $x47678)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x15521 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x15520 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x15519 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x15518 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x15517 (not $x1590)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x15516 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x15515 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x15514 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x15513 (not $x1586)))
 (let (($x15512 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x15511 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x15510 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x15509 (not $x1582)))
 (let (($x15522 (or $x15509 $x15510 $x15511 $x15512 $x15513 $x15514 $x15515 $x15516 $x15517 $x15518 $x15519 $x15520 $x15521)))
 (let (($x15523 (not $x15522)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x15586 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x15585 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x15584 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x15583 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x15582 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x15581 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x15580 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x15579 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x15578 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x15577 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x15576 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x15575 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x15574 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x15573 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x15572 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x15587 (or $x1598 $x1610 $x15572 $x1621 $x15573 $x15574 $x15575 $x1565 $x15576 $x1633 $x15577 $x15578 $x1576 $x15579 $x15580 $x15581 $x15582 $x15583 $x15584 $x1644 $x15585 $x15586)))
 (let (($x15588 (not $x15587)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x15591 (or $x1669 $x15588)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x15593 (mp @x1673 (rewrite (= $x1670 $x15591)) $x15591)))
 (let ((@x45432 (def-axiom (or $x15587 $x1581))))
 (let (($x15526 (or $x1598 $x15523)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x15528 (mp @x1602 (rewrite (= $x1599 $x15526)) $x15526)))
 (let ((@x49994 (unit-resolution @x15528 (unit-resolution @x45432 (unit-resolution @x15593 @x1650 $x15588) $x1581) $x15523)))
 (let ((@x45382 (def-axiom (or $x15522 $x1585))))
 (let ((@x47685 (def-axiom (or (not $x47678) $x4418 $x15512))))
 (let ((@x49999 (unit-resolution @x47685 (unit-resolution @x45382 @x49994 $x1585) (or (not $x47678) $x4418))))
 (let (($x4452 (not $x4418)))
 (let (($x16290 (or $x4452 $x16285)))
 (let (($x4444 (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) )(! (let ((?x1191 (%I len!)))
 (let ((?x4419 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4423 (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4419 len! f!))))
 (let (($x4424 (= ?x4423 ?x1191)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (or (not (and (has_type len! NAT) (has_type f! ?x4419))) $x4431 $x4424))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)) ) :qid user_vstd__seq__axiom_seq_new_len_3))
 ))
 (let (($x4453 (or $x4452 $x4444)))
 (let ((?x12363 (lambda ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) )(let ((?x1191 (%I len!)))
 (let ((?x4419 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4423 (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4419 len! f!))))
 (let (($x4424 (= ?x4423 ?x1191)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4439 (or (not (and (has_type len! NAT) (has_type f! ?x4419))) $x4431 $x4424)))
 (refl (~ $x4439 $x4439))))))))))
 ))
 (let ((@x12368 (monotonicity (refl (~ $x4452 $x4452)) (nnf-pos (proof-bind ?x12363) (~ $x4444 $x4444)) (~ $x4453 $x4453))))
 (let (($x4428 (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) )(! (let ((?x1191 (%I len!)))
 (let ((?x4419 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4423 (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4419 len! f!))))
 (let (($x4424 (= ?x4423 ?x1191)))
 (let (($x3858 (sized A&.)))
 (let (($x4425 (=> $x3858 $x4424)))
 (let (($x4420 (has_type f! ?x4419)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4421 (and $x4399 $x4420)))
 (=> (and $x4421 $x3858) $x4424)))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)) ) :qid user_vstd__seq__axiom_seq_new_len_3))
 ))
 (let (($x4429 (=> $x4418 $x4428)))
 (let ((?x4445 (lambda ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) )(let ((?x1191 (%I len!)))
 (let ((?x4419 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4423 (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4419 len! f!))))
 (let (($x4424 (= ?x4423 ?x1191)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4439 (or (not (and (has_type len! NAT) (has_type f! ?x4419))) $x4431 $x4424)))
 (let (($x4425 (=> $x3858 $x4424)))
 (let (($x4420 (has_type f! ?x4419)))
 (let (($x4399 (has_type len! NAT)))
 (let (($x4421 (and $x4399 $x4420)))
 (let (($x4426 (=> (and $x4421 $x3858) $x4424)))
 (let ((@x4437 (monotonicity (rewrite (= $x4425 (or $x4431 $x4424))) (= $x4426 (=> $x4421 (or $x4431 $x4424))))))
 (trans @x4437 (rewrite (= (=> $x4421 (or $x4431 $x4424)) $x4439)) (= $x4426 $x4439))))))))))))))))
 ))
 (let ((@x4451 (monotonicity (quant-intro (proof-bind ?x4445) (= $x4428 $x4444)) (= $x4429 (=> $x4418 $x4444)))))
 (let ((@x4458 (mp (asserted $x4429) (trans @x4451 (rewrite (= (=> $x4418 $x4444) $x4453)) (= $x4429 $x4453)) $x4453)))
 (let ((@x16292 (mp (mp (mp~ @x4458 @x12368 $x4453) (rewrite (= $x4453 $x4453)) $x4453) (rewrite (= $x4453 $x16290)) $x16290)))
 (let ((@x50042 (unit-resolution @x16292 (unit-resolution @x49999 @x47692 $x4418) $x16285)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x47759 (not $x174)))
 (let (($x49989 (not $x16285)))
 (let (($x50322 (or $x49989 $x48298 $x48304 $x47759 $x50312)))
 (let ((@x50327 (mp ((_ quant-inst $ (UINT 8) (I ?x47332) (Poly%fun%1. ?x48277)) (or $x49989 (or $x48298 $x48304 $x47759 $x50312))) (rewrite (= (or $x49989 (or $x48298 $x48304 $x47759 $x50312)) $x50322)) $x50322)))
 (let (($x47738 (= ?x47729 ?x47332)))
 (let ((?x49287 (mk_fun ?x49271)))
 (let ((?x49303 (Poly%fun%1. ?x49287)))
 (let ((?x49304 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 ?x48288 ?x49303)))
 (let ((?x49916 (vstd!seq.Seq.len.? $ ?x1876 ?x49304)))
 (let (($x49917 (= ?x49916 ?x48316)))
 (let (($x49307 (has_type ?x49303 ?x6520)))
 (let ((?x49315 (%Poly%fun%1. ?x49303)))
 (let ((?x49737 (mk_fun ?x49315)))
 (let ((?x49738 (Poly%fun%1. ?x49737)))
 (let (($x49739 (has_type ?x49738 ?x6520)))
 (let (($x49645 (not $x49739)))
 (let (($x49323 (= ?x49287 ?x49271)))
 (let (($x49328 (or $x48326 $x49323)))
 (let ((@x49329 ((_ quant-inst (%%lambda%%3 $ ?x1876 ?x47331 ?x47361 ?x47321 ?x47556)) $x49328)))
 (let ((@x50079 (unit-resolution @x49329 @x10508 $x49323)))
 (let (($x49316 (= ?x49287 ?x49315)))
 (let (($x49325 (or $x48318 $x49316)))
 (let ((@x49326 ((_ quant-inst (mk_fun ?x49271)) $x49325)))
 (let ((@x50078 (unit-resolution @x49326 @x10956 $x49316)))
 (let ((@x49586 (trans* (symm @x50078 (= ?x49315 ?x49287)) @x50079 (= ?x49315 ?x49271))))
 (let ((@x49461 (monotonicity (monotonicity (monotonicity @x49586 (= ?x49737 ?x49287)) (= ?x49738 ?x49303)) (= $x49739 $x49307))))
 (let ((@x49921 (mp (hypothesis (not $x49307)) (monotonicity (symm @x49461 (= $x49307 $x49739)) (= (not $x49307) $x49645)) $x49645)))
 (let ((?x49730 (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x49315 ?x1876 INT)))
 (let ((?x49733 (%%apply%%0 ?x49315 ?x49730)))
 (let (($x49734 (has_type ?x49733 ?x1876)))
 (let (($x49731 (has_type ?x49730 INT)))
 (let (($x49732 (not $x49731)))
 (let (($x49735 (or $x49732 $x49734)))
 (let ((?x49741 (%I ?x49730)))
 (let ((?x49742 (I ?x49741)))
 (let (($x49774 (has_type ?x49742 INT)))
 (let (($x49756 (= ?x49730 ?x49742)))
 (let (($x49736 (not $x49735)))
 (let ((@x50056 (hypothesis $x49736)))
 (let ((@x49646 (def-axiom (or $x49735 $x49731))))
 (let ((@x50057 (unit-resolution @x49646 @x50056 $x49731)))
 (let (($x49652 (or $x49500 $x49732 $x49756)))
 (let ((@x49709 (mp ((_ quant-inst (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x49315 ?x1876 INT)) (or $x49500 (or $x49732 $x49756))) (rewrite (= (or $x49500 (or $x49732 $x49756)) $x49652)) $x49652)))
 (let ((@x50035 (symm (unit-resolution @x49709 @x10543 @x50057 $x49756) (= ?x49742 ?x49730))))
 (let ((@x50030 (mp @x50057 (symm (monotonicity @x50035 (= $x49774 $x49731)) (= $x49731 $x49774)) $x49774)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x49780 (has_type ?x47556 ?x1998)))
 (let (($x47382 (has_type chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26 ?x1998)))
 (let (($x50032 (= ?x47556 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)))
 (let (($x47562 (= chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26 ?x47556)))
 (let (($x47389 (ext_eq false ?x1968 ?x47385 ?x47366)))
 (let (($x47388 (ext_eq false ?x1968 ?x47385 ?x47331)))
 (let (($x47383 (not $x47382)))
 (let (($x47391 (not (or $x47383 $x47388 $x47389))))
 (let (($x47378 (forall ((chunks_flushed$ Poly) )(! (let ((?x47321 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x47361 (I write_addr!)))
 (let ((?x47331 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47363 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47331 ?x47361 ?x47321)))
 (let ((?x47366 (Poly%vstd!seq.Seq<u8.>. ?x47363)))
 (let ((?x47362 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 chunks_flushed$)))
 (let ((?x47364 (Poly%vstd!seq.Seq<u8.>. ?x47362)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x47367 (ext_eq false ?x1968 ?x47364 ?x47366)))
 (let (($x47365 (ext_eq false ?x1968 ?x47364 ?x47331)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x47365 $x47367))))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_52))
 ))
 (let (($x47379 (not $x47378)))
 (let (($x47392 (not (or (not %%location_label%%0) $x47378))))
 (let (($x47371 (forall ((chunks_flushed$ Poly) )(! (let ((?x47321 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x47361 (I write_addr!)))
 (let ((?x47331 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47363 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47331 ?x47361 ?x47321)))
 (let ((?x47366 (Poly%vstd!seq.Seq<u8.>. ?x47363)))
 (let ((?x47362 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 chunks_flushed$)))
 (let ((?x47364 (Poly%vstd!seq.Seq<u8.>. ?x47362)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x47367 (ext_eq false ?x1968 ?x47364 ?x47366)))
 (let (($x47365 (ext_eq false ?x1968 ?x47364 ?x47331)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed$ ?x1998)))
 (=> $x1999 (or $x47365 $x47367))))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$) ) :qid user_pmemlog__logimpl_v__lemma_single_write_crash_52))
 ))
 (let (($x47373 (not (=> %%location_label%%0 $x47371))))
 (let ((@x47376 (mp (asserted $x47373) (rewrite (= $x47373 $x47392)) $x47392)))
 (let ((@x47397 (mp~ (not-or-elim @x47376 $x47379) (sk (~ $x47379 $x47391)) $x47391)))
 (let ((@x47400 (not-or-elim @x47397 $x47382)))
 (let (($x2011 (forall ((x Poly) )(! (let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (let (($x2007 (not $x1999)))
 (or $x2007 $x2002))))) :pattern ( (has_type x (TYPE%vstd!set.Set. $ INT)) ) :qid internal_vstd__set__Set<int.>_unbox_axiom_definition))
 ))
 (let ((?x11136 (lambda ((x Poly) )(let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (let (($x2007 (not $x1999)))
 (let (($x2008 (or $x2007 $x2002)))
 (refl (~ $x2008 $x2008))))))))
 ))
 (let (($x2005 (forall ((x Poly) )(! (let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (=> $x1999 $x2002)))) :pattern ( (has_type x (TYPE%vstd!set.Set. $ INT)) ) :qid internal_vstd__set__Set<int.>_unbox_axiom_definition))
 ))
 (let ((?x2012 (lambda ((x Poly) )(let (($x2002 (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type x ?x1998)))
 (let (($x2007 (not $x1999)))
 (let (($x2008 (or $x2007 $x2002)))
 (let (($x2003 (=> $x1999 $x2002)))
 (rewrite (= $x2003 $x2008)))))))))
 ))
 (let ((@x2016 (mp (asserted $x2005) (quant-intro (proof-bind ?x2012) (= $x2005 $x2011)) $x2011)))
 (let ((@x11140 (mp~ @x2016 (nnf-pos (proof-bind ?x11136) (~ $x2011 $x2011)) $x2011)))
 (let (($x47566 (not $x2011)))
 (let (($x47567 (or $x47566 $x47383 $x47562)))
 (let ((@x47572 (mp ((_ quant-inst chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26) (or $x47566 (or $x47383 $x47562))) (rewrite (= (or $x47566 (or $x47383 $x47562)) $x47567)) $x47567)))
 (let ((@x50033 (symm (unit-resolution @x47572 @x11140 @x47400 $x47562) $x50032)))
 (let ((@x50040 (mp @x47400 (symm (monotonicity @x50033 (= $x49780 $x47382)) (= $x47382 $x49780)) $x49780)))
 (let ((?x49759 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49730)))
 (let (($x49778 (has_type ?x49759 ?x1876)))
 (let ((@x50072 (monotonicity (monotonicity @x50035 (= (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49742) ?x49759)) (= (has_type (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49742) ?x1876) $x49778))))
 (let ((?x49800 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49742)))
 (let (($x49801 (has_type ?x49800 ?x1876)))
 (let (($x49775 (not $x49774)))
 (let (($x49611 (or $x49571 $x47420 $x49775 $x49801)))
 (let ((@x49656 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x49741)) (or $x49571 (or $x47420 $x49775 $x49801))) (rewrite (= (or $x49571 (or $x47420 $x49775 $x49801)) $x49611)) $x49611)))
 (let ((@x50069 (unit-resolution (unit-resolution @x49656 @x16116 @x49382 (or $x49775 $x49801)) @x50030 $x49801)))
 (let ((?x49782 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x49742 ?x49759 ?x47361 ?x47321 ?x47556)))
 (let (($x49783 (uInv 8 ?x49782)))
 (let (($x50105 (not $x49783)))
 (let ((?x49766 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x49730 ?x49759 ?x47361 ?x47321 ?x47556)))
 (let (($x49813 (uInv 8 ?x49766)))
 (let (($x49814 (not $x49813)))
 (let ((@x50082 (symm (monotonicity (monotonicity @x50035 (= ?x49782 ?x49766)) (= $x49783 $x49813)) (= $x49813 $x49783))))
 (let ((?x49767 (I ?x49766)))
 (let (($x49821 (has_type ?x49767 ?x1876)))
 (let (($x49863 (not $x49821)))
 (let ((@x49844 (symm (monotonicity @x49586 (= ?x49733 (%%apply%%0 ?x49271 ?x49730))) (= (%%apply%%0 ?x49271 ?x49730) ?x49733))))
 (let ((?x49758 (%%apply%%0 ?x49271 ?x49730)))
 (let (($x49768 (= ?x49758 ?x49767)))
 (let ((@x49670 (symm (unit-resolution ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555) (T%0!skolem_internal_crate__fun__1_constructor_inner_definition!0 ?x49315 ?x1876 INT)) (or $x49710 $x49768)) @x14167 $x49768) (= ?x49767 ?x49758))))
 (let ((@x49853 (symm (monotonicity (trans* @x49670 @x49844 (= ?x49767 ?x49733)) (= $x49821 $x49734)) (= $x49734 $x49821))))
 (let ((@x49867 (mp (unit-resolution (def-axiom (or $x49735 (not $x49734))) @x50056 (not $x49734)) (monotonicity @x49853 (= (not $x49734) $x49863)) $x49863)))
 (let (($x49822 (or $x49814 $x49821)))
 (let (($x49699 (or $x49582 $x49814 $x49821)))
 (let ((@x49842 (mp ((_ quant-inst 8 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x49730 ?x49759 ?x47361 ?x47321 ?x47556)) (or $x49582 $x49822)) (rewrite (= (or $x49582 $x49822) $x49699)) $x49699)))
 (let ((@x50108 (mp (unit-resolution (unit-resolution @x49842 @x10690 $x49822) @x49867 $x49814) (monotonicity @x50082 (= $x49814 $x50105)) $x50105)))
 (let (($x17951 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(! (let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8253 (uInv 8 ?x8233)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed! ?x1998)))
 (let (($x2007 (not $x1999)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7766 (has_type write_bytes! ?x1968)))
 (let (($x17677 (not $x7766)))
 (let (($x4684 (has_type write_addr! INT)))
 (let (($x16430 (not $x4684)))
 (let (($x8251 (has_type prewrite_byte! ?x1876)))
 (let (($x17885 (not $x8251)))
 (let (($x8250 (has_type addr! INT)))
 (let (($x17883 (not $x8250)))
 (or $x17883 $x17885 $x16430 $x17677 $x2007 $x8253)))))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.?_pre_post_definition))
 ))
 (let (($x8261 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(! (let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8253 (uInv 8 ?x8233)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed! ?x1998)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7766 (has_type write_bytes! ?x1968)))
 (let (($x4684 (has_type write_addr! INT)))
 (let (($x8251 (has_type prewrite_byte! ?x1876)))
 (let (($x8250 (has_type addr! INT)))
 (let (($x8252 (and $x8250 $x8251 $x4684 $x7766 $x1999)))
 (let (($x8257 (not $x8252)))
 (or $x8257 $x8253))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.?_pre_post_definition))
 ))
 (let ((?x17952 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8253 (uInv 8 ?x8233)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed! ?x1998)))
 (let (($x2007 (not $x1999)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7766 (has_type write_bytes! ?x1968)))
 (let (($x17677 (not $x7766)))
 (let (($x4684 (has_type write_addr! INT)))
 (let (($x16430 (not $x4684)))
 (let (($x8251 (has_type prewrite_byte! ?x1876)))
 (let (($x17885 (not $x8251)))
 (let (($x8250 (has_type addr! INT)))
 (let (($x17883 (not $x8250)))
 (let (($x17909 (or $x17883 $x17885 $x16430 $x17677 $x2007 $x8253)))
 (let (($x8252 (and $x8250 $x8251 $x4684 $x7766 $x1999)))
 (let (($x8257 (not $x8252)))
 (let (($x8258 (or $x8257 $x8253)))
 (let (($x17886 (or $x17883 $x17885 $x16430 $x17677 $x2007)))
 (let (($x17891 (not $x17886)))
 (let (($x17894 (not $x17891)))
 (let ((@x17905 (trans (monotonicity (rewrite (= $x8252 $x17891)) (= $x8257 $x17894)) (rewrite (= $x17894 $x17886)) (= $x8257 $x17886))))
 (trans (monotonicity @x17905 (= $x8258 (or $x17886 $x8253))) (rewrite (= (or $x17886 $x8253) $x17909)) (= $x8258 $x17909))))))))))))))))))))))))))
 ))
 (let ((?x14149 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8253 (uInv 8 ?x8233)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed! ?x1998)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7766 (has_type write_bytes! ?x1968)))
 (let (($x4684 (has_type write_addr! INT)))
 (let (($x8251 (has_type prewrite_byte! ?x1876)))
 (let (($x8250 (has_type addr! INT)))
 (let (($x8252 (and $x8250 $x8251 $x4684 $x7766 $x1999)))
 (let (($x8257 (not $x8252)))
 (let (($x8258 (or $x8257 $x8253)))
 (refl (~ $x8258 $x8258))))))))))))))))
 ))
 (let (($x8255 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(! (let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8253 (uInv 8 ?x8233)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed! ?x1998)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7766 (has_type write_bytes! ?x1968)))
 (let (($x4684 (has_type write_addr! INT)))
 (let (($x8251 (has_type prewrite_byte! ?x1876)))
 (let (($x8250 (has_type addr! INT)))
 (let (($x8252 (and $x8250 $x8251 $x4684 $x7766 $x1999)))
 (=> $x8252 $x8253)))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.?_pre_post_definition))
 ))
 (let ((?x8262 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(let ((?x8233 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? addr! prewrite_byte! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8253 (uInv 8 ?x8233)))
 (let ((?x1998 (TYPE%vstd!set.Set. $ INT)))
 (let (($x1999 (has_type chunks_flushed! ?x1998)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x7766 (has_type write_bytes! ?x1968)))
 (let (($x4684 (has_type write_addr! INT)))
 (let (($x8251 (has_type prewrite_byte! ?x1876)))
 (let (($x8250 (has_type addr! INT)))
 (let (($x8252 (and $x8250 $x8251 $x4684 $x7766 $x1999)))
 (let (($x8257 (not $x8252)))
 (let (($x8258 (or $x8257 $x8253)))
 (let (($x8254 (=> $x8252 $x8253)))
 (rewrite (= $x8254 $x8258)))))))))))))))))
 ))
 (let ((@x8266 (mp (asserted $x8255) (quant-intro (proof-bind ?x8262) (= $x8255 $x8261)) $x8261)))
 (let ((@x17956 (mp (mp~ @x8266 (nnf-pos (proof-bind ?x14149) (~ $x8261 $x8261)) $x8261) (quant-intro (proof-bind ?x17952) (= $x8261 $x17951)) $x17951)))
 (let (($x49781 (not $x49780)))
 (let (($x49779 (not $x49778)))
 (let (($x49669 (not $x17951)))
 (let (($x49659 (or $x49669 $x49775 $x49779 $x49517 $x47416 $x49781 $x49783)))
 (let ((@x49717 (mp ((_ quant-inst (I ?x49741) (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x49730) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555)) (or $x49669 (or $x49775 $x49779 $x49517 $x47416 $x49781 $x49783))) (rewrite (= (or $x49669 (or $x49775 $x49779 $x49517 $x47416 $x49781 $x49783)) $x49659)) $x49659)))
 (let ((@x50111 (unit-resolution (unit-resolution @x49717 @x17956 @x49793 @x50104 (or $x49775 $x49779 $x49781 $x49783)) @x50108 (mp @x50069 @x50072 $x49778) @x50040 @x50030 false)))
 (let ((@x50112 (lemma @x50111 $x49735)))
 (let (($x49648 (or $x49495 $x49736 $x49739)))
 (let ((@x49720 (mp ((_ quant-inst $ INT $ (UINT 8) (%Poly%fun%1. ?x49303)) (or $x49495 (or $x49736 $x49739))) (rewrite (= (or $x49495 (or $x49736 $x49739)) $x49648)) $x49648)))
 (let ((@x49932 (lemma (unit-resolution (unit-resolution @x49720 @x10983 @x50112 $x49739) @x49921 false) $x49307)))
 (let (($x49308 (not $x49307)))
 (let (($x49965 (or $x49989 $x48298 $x49308 $x47759 $x49917)))
 (let ((@x49996 (mp ((_ quant-inst $ (UINT 8) (I ?x47332) (Poly%fun%1. ?x49287)) (or $x49989 (or $x48298 $x49308 $x47759 $x49917))) (rewrite (= (or $x49989 (or $x48298 $x49308 $x47759 $x49917)) $x49965)) $x49965)))
 (let ((?x49305 (%Poly%vstd!seq.Seq<u8.>. ?x49304)))
 (let ((?x49647 (Poly%vstd!seq.Seq<u8.>. ?x49305)))
 (let (($x49649 (= ?x49304 ?x49647)))
 (let (($x49313 (has_type ?x49304 ?x1968)))
 (let (($x49314 (or $x48298 $x49308 $x49313)))
 (let (($x49317 (or $x48309 $x48298 $x49308 $x49313)))
 (let ((@x49322 (mp ((_ quant-inst $ (UINT 8) $ (TYPE%fun%1. $ INT $ ?x1876) (I ?x47332) (Poly%fun%1. ?x49287)) (or $x48309 $x49314)) (rewrite (= (or $x48309 $x49314) $x49317)) $x49317)))
 (let ((@x50050 (unit-resolution (unit-resolution (unit-resolution @x49322 @x16264 $x49314) @x49986 (or $x49308 $x49313)) @x49932 $x49313)))
 (let (($x49644 (not $x49313)))
 (let (($x49640 (or $x49498 $x49644 $x49649)))
 (let ((@x49643 (mp ((_ quant-inst (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 ?x48288 ?x49303)) (or $x49498 (or $x49644 $x49649))) (rewrite (= (or $x49498 (or $x49644 $x49649)) $x49640)) $x49640)))
 (let ((@x50051 (unit-resolution @x49643 @x11119 @x50050 $x49649)))
 (let ((?x49298 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 ?x47556)))
 (let (($x49306 (= ?x49298 ?x49305)))
 (let (($x8317 (forall ((contents! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(! (let ((?x8312 (Poly%fun%1. (mk_fun (%%lambda%%3 $ (UINT 8) contents! write_addr! write_bytes! chunks_flushed!)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x8313 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 (I (vstd!seq.Seq.len.? $ ?x1876 contents!)) ?x8312)))
 (let ((?x8308 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? contents! write_addr! write_bytes! chunks_flushed!)))
 (= ?x8308 (%Poly%vstd!seq.Seq<u8.>. ?x8313))))))) :pattern ( (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? contents! write_addr! write_bytes! chunks_flushed!) ) :qid internal_pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.?_definition))
 ))
 (let (($x8306 (fuel_bool fuel%pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.)))
 (let (($x8280 (fuel_bool_default fuel%pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.)))
 (let (($x49282 (= $x8306 $x8280)))
 (let ((@x49299 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.) (or (not $x30) $x49282)) @x47616 (hypothesis (not $x49282)) false)))
 (let ((@x49312 (lemma @x49299 $x49282)))
 (let ((@x8301 (asserted $x8280)))
 (let ((@x49290 (def-axiom (or (not $x49282) $x8306 (not $x8280)))))
 (let ((@x50054 (unit-resolution (unit-resolution @x49290 @x8301 (or (not $x49282) $x8306)) @x49312 $x8306)))
 (let (($x8320 (not $x8306)))
 (let (($x8321 (or $x8320 $x8317)))
 (let ((?x14172 (lambda ((contents! Poly) (write_addr! Poly) (write_bytes! Poly) (chunks_flushed! Poly) )(let ((?x8312 (Poly%fun%1. (mk_fun (%%lambda%%3 $ (UINT 8) contents! write_addr! write_bytes! chunks_flushed!)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x6520 (TYPE%fun%1. $ INT $ ?x1876)))
 (let ((?x8313 (vstd!seq.Seq.new.? $ ?x1876 $ ?x6520 (I (vstd!seq.Seq.len.? $ ?x1876 contents!)) ?x8312)))
 (let ((?x8308 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? contents! write_addr! write_bytes! chunks_flushed!)))
 (let (($x8315 (= ?x8308 (%Poly%vstd!seq.Seq<u8.>. ?x8313))))
 (refl (~ $x8315 $x8315)))))))))
 ))
 (let ((@x14177 (monotonicity (refl (~ $x8320 $x8320)) (nnf-pos (proof-bind ?x14172) (~ $x8317 $x8317)) (~ $x8321 $x8321))))
 (let ((@x8324 (mp (asserted (=> $x8306 $x8317)) (rewrite (= (=> $x8306 $x8317) $x8321)) $x8321)))
 (let ((@x14181 (mp (mp~ @x8324 @x14177 $x8321) (rewrite (= $x8321 $x8321)) $x8321)))
 (let (($x49310 (or (not $x8317) $x49306)))
 (let ((@x49311 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555)) $x49310)))
 (let ((@x49971 (trans* (symm (monotonicity @x50033 (= ?x49298 ?x47384)) (= ?x47384 ?x49298)) (unit-resolution @x49311 (unit-resolution @x14181 @x50054 $x8317) $x49306) (= ?x47384 ?x49305))))
 (let ((@x49975 (monotonicity @x49971 (= ?x47385 ?x49647))))
 (let ((@x49924 (monotonicity (trans* @x49975 (symm @x50051 (= ?x49647 ?x49304)) (= ?x47385 ?x49304)) (= ?x47729 ?x49916))))
 (let ((@x49893 (trans* @x49924 (unit-resolution @x49996 @x175 @x50042 @x49986 @x49932 $x49917) @x50044 $x47738)))
 (let ((@x49984 (lemma (unit-resolution (hypothesis (not $x47738)) @x49893 false) $x47738)))
 (let ((@x50351 (trans* @x49984 @x49423 (symm (unit-resolution @x50327 @x175 @x50042 @x49986 @x49560 $x50312) (= ?x48316 ?x50311)) (symm (monotonicity @x50344 (= ?x47843 ?x50311)) (= ?x50311 ?x47843)) $x47844)))
 (let ((@x50354 (lemma (unit-resolution (hypothesis (not $x47844)) @x50351 false) $x47844)))
 (let (($x47845 (not $x47844)))
 (let (($x47846 (or $x47389 $x47845 $x47842)))
 (let (($x47847 (not $x47846)))
 (let (($x47852 (forall ((i$ Poly) )(! (let ((?x47321 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x47361 (I write_addr!)))
 (let ((?x47331 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x47363 (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47331 ?x47361 ?x47321)))
 (let ((?x47366 (Poly%vstd!seq.Seq<u8.>. ?x47363)))
 (let ((?x1876 (UINT 8)))
 (let ((?x47848 (vstd!seq.Seq.index.? $ ?x1876 ?x47366 i$)))
 (let ((?x47384 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)))
 (let ((?x47385 (Poly%vstd!seq.Seq<u8.>. ?x47384)))
 (let ((?x47742 (vstd!seq.Seq.index.? $ ?x1876 ?x47385 i$)))
 (let (($x47749 (>= (+ (%I i$) (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x47385))) 0)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16070 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x16070 $x47749 (= ?x47742 ?x47848)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!))) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x47853 (not $x47852)))
 (let (($x47854 (or $x47845 $x47853)))
 (let (($x47855 (not $x47854)))
 (let (($x47403 (not $x47389)))
 (let (($x47856 (or $x47403 $x47855)))
 (let (($x47857 (not $x47856)))
 (let (($x47858 (or $x47857 $x47847)))
 (let (($x47859 (not $x47858)))
 (let (($x47760 (has_type ?x47385 ?x1968)))
 (let ((?x47443 (%Poly%vstd!seq.Seq<u8.>. ?x47385)))
 (let ((?x49324 (Poly%vstd!seq.Seq<u8.>. ?x47443)))
 (let (($x49327 (has_type ?x49324 ?x1968)))
 (let (($x49355 (not $x49327)))
 (let (($x47444 (= ?x47384 ?x47443)))
 (let (($x47449 (or $x47440 $x47444)))
 (let ((@x47450 ((_ quant-inst (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)) $x47449)))
 (let ((@x49350 (monotonicity (symm (unit-resolution @x47450 @x11112 $x47444) (= ?x47443 ?x47384)) (= ?x49324 ?x47385))))
 (let ((@x49357 (monotonicity (symm (monotonicity @x49350 (= $x49327 $x47760)) (= $x47760 $x49327)) (= (not $x47760) $x49355))))
 (let ((@x49360 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47385)) (or (not $x1989) $x49327)) @x11126 $x49327) (mp (hypothesis (not $x47760)) @x49357 $x49355) false)))
 (let ((@x49361 (lemma @x49360 $x47760)))
 (let (($x47860 (has_type ?x47366 ?x1968)))
 (let ((?x47447 (%Poly%vstd!seq.Seq<u8.>. ?x47366)))
 (let ((?x49336 (Poly%vstd!seq.Seq<u8.>. ?x47447)))
 (let (($x49337 (has_type ?x49336 ?x1968)))
 (let (($x49397 (not $x49337)))
 (let (($x47448 (= ?x47363 ?x47447)))
 (let (($x47453 (or $x47440 $x47448)))
 (let ((@x47454 ((_ quant-inst (pmemlog!pmemspec_t.update_contents_to_reflect_write.? ?x47331 ?x47361 ?x47321)) $x47453)))
 (let ((@x49392 (monotonicity (symm (unit-resolution @x47454 @x11112 $x47448) (= ?x47447 ?x47363)) (= ?x49336 ?x47366))))
 (let ((@x49399 (monotonicity (symm (monotonicity @x49392 (= $x49337 $x47860)) (= $x47860 $x49337)) (= (not $x47860) $x49397))))
 (let ((@x49402 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x47366)) (or (not $x1989) $x49337)) @x11126 $x49337) (mp (hypothesis (not $x47860)) @x49399 $x49397) false)))
 (let ((@x49403 (lemma @x49402 $x47860)))
 (let (($x16414 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x12411 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12423 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12411) (vstd!seq.Seq.index.? A&. A& s2! ?x12411))))
 (let (($x12462 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x12411))) 0)))
 (let (($x12413 (not (has_type ?x12411 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12408 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x16395 (not (or $x4527 $x12408 (not (or $x12413 (not (>= (%I ?x12411) 0)) $x12462 $x12423))))))
 (let (($x16366 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16070 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x16070 $x4552 $x4534))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x12395 (not $x4527)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x16335 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x16082 (not $x4101)))
 (or $x16082 $x16335 $x4431 (not (or (not (or $x12395 (not (or $x12408 (not $x16366))))) $x16395)))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4524 (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x47708 (= $x4524 $x1587)))
 (let ((@x47710 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_ext_equal.) (or (not $x30) $x47708)) @x47616 (hypothesis (not $x47708)) false)))
 (let ((@x47722 (lemma @x47710 $x47708)))
 (let ((@x47715 (def-axiom (or (not $x47708) $x4524 $x15514))))
 (let ((@x50567 (unit-resolution @x47715 (unit-resolution (def-axiom (or $x15522 $x1587)) @x49994 $x1587) (or (not $x47708) $x4524))))
 (let (($x4583 (not $x4524)))
 (let (($x16347 (or $x4583 $x16414)))
 (let (($x12476 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x12411 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12423 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12411) (vstd!seq.Seq.index.? A&. A& s2! ?x12411))))
 (let (($x12462 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x12411))) 0)))
 (let ((?x12414 (%I ?x12411)))
 (let (($x12415 (>= ?x12414 0)))
 (let (($x12413 (not (has_type ?x12411 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12408 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x12395 (not $x4527)))
 (let (($x12434 (or $x12395 $x4548)))
 (let (($x12477 (and $x12434 (or $x4527 $x12408 (not (or $x12413 (not (and $x12415 (not $x12462))) $x12423))))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x12477)))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x12450 (or $x4583 $x12476)))
 (let (($x12441 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x12411 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12423 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12411) (vstd!seq.Seq.index.? A&. A& s2! ?x12411))))
 (let (($x12417 (>= (+ (%I ?x12411) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x12414 (%I ?x12411)))
 (let (($x12415 (>= ?x12414 0)))
 (let (($x12413 (not (has_type ?x12411 INT))))
 (let (($x12425 (not (or $x12413 (not (and $x12415 (not $x12417))) $x12423))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12408 (not $x4529)))
 (let (($x12429 (or $x12408 $x12425)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x12395 (not $x4527)))
 (let (($x12434 (or $x12395 $x4548)))
 (let (($x12435 (and $x12434 (or $x4527 $x12429))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x12435)))))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x12446 (or $x4583 $x12441)))
 (let (($x4576 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4559))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4584 (or $x4583 $x4576)))
 (let ((?x12442 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x12411 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x12423 (= (vstd!seq.Seq.index.? A&. A& s1! ?x12411) (vstd!seq.Seq.index.? A&. A& s2! ?x12411))))
 (let (($x12417 (>= (+ (%I ?x12411) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x12414 (%I ?x12411)))
 (let (($x12415 (>= ?x12414 0)))
 (let (($x12413 (not (has_type ?x12411 INT))))
 (let (($x12425 (not (or $x12413 (not (and $x12415 (not $x12417))) $x12423))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x12408 (not $x4529)))
 (let (($x12429 (or $x12408 $x12425)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x12395 (not $x4527)))
 (let (($x12434 (or $x12395 $x4548)))
 (let (($x12435 (and $x12434 (or $x4527 $x12429))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x12438 (or $x4568 $x4431 $x12435)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let ((@x12410 (refl (~ $x12408 $x12408))))
 (let ((?x12402 (lambda ((i$ Poly) )(let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4569 (or $x271 $x4554 $x4534)))
 (refl (~ $x4569 $x4569))))))))))))))))
 ))
 (let ((@x12399 (refl (~ $x4529 $x4529))))
 (let ((@x12407 (monotonicity @x12399 (nnf-pos (proof-bind ?x12402) (~ $x4574 $x4574)) (~ $x4548 $x4548))))
 (let ((@x12437 (nnf-pos (refl (~ $x4527 $x4527)) (refl (~ $x12395 $x12395)) @x12407 (nnf-neg @x12410 (sk (~ (not $x4574) $x12425)) (~ (not $x4548) $x12429)) (~ $x4559 $x12435))))
 (let ((@x12392 (refl (~ $x4431 $x4431))))
 (let ((@x12390 (refl (~ $x4568 $x4568))))
 (monotonicity @x12390 @x12392 @x12437 (~ $x4570 $x12438))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x12448 (monotonicity (refl (~ $x4583 $x4583)) (nnf-pos (proof-bind ?x12442) (~ $x4576 $x12441)) (~ $x4584 $x12446))))
 (let (($x4545 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x3858 (sized A&.)))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4541))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4546 (=> $x4524 $x4545)))
 (let ((?x4577 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4543 (=> (and $x4526 $x3858) $x4541)))
 (let ((@x4564 (trans (monotonicity (rewrite (= $x4541 $x4559)) (= $x4542 (=> $x3858 $x4559))) (rewrite (= (=> $x3858 $x4559) (or $x4431 $x4559))) (= $x4542 (or $x4431 $x4559)))))
 (trans (monotonicity @x4564 (= $x4543 (=> $x4526 (or $x4431 $x4559)))) (rewrite (= (=> $x4526 (or $x4431 $x4559)) $x4570)) (= $x4543 $x4570)))))))))))))))))))))))
 ))
 (let ((@x4582 (monotonicity (quant-intro (proof-bind ?x4577) (= $x4545 $x4576)) (= $x4546 (=> $x4524 $x4576)))))
 (let ((@x4589 (mp (asserted $x4546) (trans @x4582 (rewrite (= (=> $x4524 $x4576) $x4584)) (= $x4546 $x4584)) $x4584)))
 (let ((@x16336 (mp (mp (mp~ @x4589 @x12448 $x12446) (rewrite (= $x12446 $x12450)) $x12450) (rewrite (= $x12450 $x16347)) $x16347)))
 (let ((@x50569 (unit-resolution @x16336 (unit-resolution @x50567 @x47722 $x4524) $x16414)))
 (let (($x47861 (not $x47860)))
 (let (($x47761 (not $x47760)))
 (let (($x47769 (not $x16414)))
 (let (($x47867 (or $x47769 $x47761 $x47861 $x47759 $x47859)))
 (let ((@x47872 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x47384) (Poly%vstd!seq.Seq<u8.>. ?x47363)) (or $x47769 (or $x47761 $x47861 $x47759 $x47859))) (rewrite (= (or $x47769 (or $x47761 $x47861 $x47759 $x47859)) $x47867)) $x47867)))
 (let ((@x50693 (unit-resolution (unit-resolution @x47872 @x175 @x50569 (or $x47761 $x47861 $x47859)) @x49403 @x49361 $x47859)))
 (let ((@x47910 (def-axiom (or $x47858 $x47846))))
 (let ((@x47404 (not-or-elim @x47397 $x47403)))
 (let ((@x47906 (def-axiom (or $x47847 $x47389 $x47845 $x47842))))
 (let ((@x50696 (unit-resolution (unit-resolution @x47906 @x47404 (or $x47847 $x47845 $x47842)) (unit-resolution @x47910 @x50693 $x47846) (or $x47845 $x47842))))
 (let ((@x50697 (unit-resolution @x50696 @x50354 $x47842)))
 (let ((@x47888 (def-axiom (or $x47841 $x47839))))
 (let ((@x51377 (unit-resolution @x47888 @x50697 $x47839)))
 (let (($x50386 (or $x49500 $x47840 $x50376)))
 (let ((@x50391 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47366 ?x47385 ?x1876 $)) (or $x49500 (or $x47840 $x50376))) (rewrite (= (or $x49500 (or $x47840 $x50376)) $x50386)) $x50386)))
 (let ((@x51378 (unit-resolution @x50391 @x10543 @x51377 $x50376)))
 (let ((@x51392 (symm @x51378 (= ?x50375 ?x47829))))
 (let ((@x51115 (trans* (symm @x50079 (= ?x49271 ?x49287)) @x50078 (= ?x49271 ?x49315))))
 (let ((@x51422 (monotonicity @x51115 @x51392 (= ?x50686 (%%apply%%0 ?x49315 ?x47829)))))
 (let ((@x51434 (symm @x51422 (= (%%apply%%0 ?x49315 ?x47829) ?x50686))))
 (let ((?x50366 (%%apply%%0 ?x49315 ?x47829)))
 (let ((?x50365 (vstd!seq.Seq.index.? $ ?x1876 ?x49304 ?x47829)))
 (let (($x50373 (= ?x50365 ?x50366)))
 (let ((?x47747 (* (- 1) ?x47729)))
 (let ((?x49934 (+ ?x47332 ?x47747)))
 (let (($x49940 (>= ?x49934 0)))
 (let ((@x50583 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x47332 ?x47729)) $x49940)) (symm @x49984 (= ?x47332 ?x47729)) $x49940)))
 (let ((@x50700 ((_ th-lemma arith farkas 1 1 -1 1) @x50583 (hypothesis (>= (+ ?x47833 ?x49409) 0)) @x49424 (unit-resolution (def-axiom (or $x47841 (not $x47836))) @x50697 (not $x47836)) false)))
 (let ((@x50702 (lemma @x50700 (not (>= (+ ?x47833 ?x49409) 0)))))
 (let ((@x47890 (def-axiom (or $x47841 $x47837))))
 (let ((@x51387 (unit-resolution @x47890 @x50697 $x47837)))
 (let (($x16326 (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly) )(! (let ((?x1836 (%Poly%fun%1. f!)))
 (let ((?x1837 (%%apply%%0 ?x1836 i!)))
 (let ((?x4461 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4468 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4461 len! f!) i!)))
 (let (($x4469 (= ?x4468 ?x1837)))
 (let ((?x264 (%I i!)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I len!)))))
 (let (($x4480 (>= ?x4483 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16070 (not $x821)))
 (let (($x4282 (sized A&.)))
 (let (($x16210 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (or (not (has_type len! NAT)) (not (has_type f! ?x4461)) $x271 $x16210 $x16070 $x4480 $x4469))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!) ) :qid user_vstd__seq__axiom_seq_new_index_4))
 ))
 (let (($x4459 (fuel_bool fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x47693 (= $x4459 $x1586)))
 (let ((@x47695 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_new_index.) (or (not $x30) $x47693)) @x47616 (hypothesis (not $x47693)) false)))
 (let ((@x47707 (lemma @x47695 $x47693)))
 (let ((@x47700 (def-axiom (or (not $x47693) $x4459 $x15513))))
 (let ((@x51101 (unit-resolution @x47700 (unit-resolution (def-axiom (or $x15522 $x1586)) @x49994 $x1586) (or (not $x47693) $x4459))))
 (let (($x4488 (not $x4459)))
 (let (($x16331 (or $x4488 $x16326)))
 (let (($x4513 (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly) )(! (let ((?x1836 (%Poly%fun%1. f!)))
 (let ((?x1837 (%%apply%%0 ?x1836 i!)))
 (let ((?x4461 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4468 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4461 len! f!) i!)))
 (let (($x4469 (= ?x4468 ?x1837)))
 (let ((?x264 (%I i!)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I len!)))))
 (let (($x4480 (>= ?x4483 0)))
 (let (($x4485 (not $x4480)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4484 (and $x4282 $x821 $x4485)))
 (let (($x4498 (not $x4484)))
 (let (($x263 (has_type i! INT)))
 (let (($x4462 (has_type f! ?x4461)))
 (let (($x4460 (has_type len! NAT)))
 (let (($x4463 (and $x4460 $x4462 $x263)))
 (or (not $x4463) $x4498 $x4469)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!) ) :qid user_vstd__seq__axiom_seq_new_index_4))
 ))
 (let (($x4518 (or $x4488 $x4513)))
 (let ((?x12377 (lambda ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly) )(let ((?x1836 (%Poly%fun%1. f!)))
 (let ((?x1837 (%%apply%%0 ?x1836 i!)))
 (let ((?x4461 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4468 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4461 len! f!) i!)))
 (let (($x4469 (= ?x4468 ?x1837)))
 (let ((?x264 (%I i!)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I len!)))))
 (let (($x4480 (>= ?x4483 0)))
 (let (($x4485 (not $x4480)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4484 (and $x4282 $x821 $x4485)))
 (let (($x4498 (not $x4484)))
 (let (($x263 (has_type i! INT)))
 (let (($x4462 (has_type f! ?x4461)))
 (let (($x4460 (has_type len! NAT)))
 (let (($x4463 (and $x4460 $x4462 $x263)))
 (let (($x4508 (or (not $x4463) $x4498 $x4469)))
 (refl (~ $x4508 $x4508)))))))))))))))))))))
 ))
 (let ((@x12382 (monotonicity (refl (~ $x4488 $x4488)) (nnf-pos (proof-bind ?x12377) (~ $x4513 $x4513)) (~ $x4518 $x4518))))
 (let (($x4473 (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly) )(! (let ((?x1836 (%Poly%fun%1. f!)))
 (let ((?x1837 (%%apply%%0 ?x1836 i!)))
 (let ((?x4461 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4468 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4461 len! f!) i!)))
 (let (($x4469 (= ?x4468 ?x1837)))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4465 (and $x816 (< ?x264 (%I len!)))))
 (let (($x4282 (sized A&.)))
 (let (($x4466 (and $x4282 $x4465)))
 (let (($x4470 (=> $x4466 $x4469)))
 (let (($x263 (has_type i! INT)))
 (let (($x4462 (has_type f! ?x4461)))
 (let (($x4460 (has_type len! NAT)))
 (let (($x4463 (and $x4460 $x4462 $x263)))
 (=> (and $x4463 $x4466) $x4469)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!) ) :qid user_vstd__seq__axiom_seq_new_index_4))
 ))
 (let (($x4474 (=> $x4459 $x4473)))
 (let ((?x4514 (lambda ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly) )(let ((?x1836 (%Poly%fun%1. f!)))
 (let ((?x1837 (%%apply%%0 ?x1836 i!)))
 (let ((?x4461 (TYPE%fun%1. $ INT A&. A&)))
 (let ((?x4468 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ ?x4461 len! f!) i!)))
 (let (($x4469 (= ?x4468 ?x1837)))
 (let ((?x264 (%I i!)))
 (let ((?x4483 (+ ?x264 (* (- 1) (%I len!)))))
 (let (($x4480 (>= ?x4483 0)))
 (let (($x4485 (not $x4480)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4484 (and $x4282 $x821 $x4485)))
 (let (($x4498 (not $x4484)))
 (let (($x263 (has_type i! INT)))
 (let (($x4462 (has_type f! ?x4461)))
 (let (($x4460 (has_type len! NAT)))
 (let (($x4463 (and $x4460 $x4462 $x263)))
 (let (($x4508 (or (not $x4463) $x4498 $x4469)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4465 (and $x816 (< ?x264 (%I len!)))))
 (let (($x4466 (and $x4282 $x4465)))
 (let (($x4470 (=> $x4466 $x4469)))
 (let (($x4471 (=> (and $x4463 $x4466) $x4469)))
 (let ((@x4481 (monotonicity (rewrite (= $x4465 (and $x821 $x4485))) (= $x4466 (and $x4282 (and $x821 $x4485))))))
 (let ((@x4494 (trans @x4481 (rewrite (= (and $x4282 (and $x821 $x4485)) $x4484)) (= $x4466 $x4484))))
 (let ((@x4503 (trans (monotonicity @x4494 (= $x4470 (=> $x4484 $x4469))) (rewrite (= (=> $x4484 $x4469) (or $x4498 $x4469))) (= $x4470 (or $x4498 $x4469)))))
 (trans (monotonicity @x4503 (= $x4471 (=> $x4463 (or $x4498 $x4469)))) (rewrite (= (=> $x4463 (or $x4498 $x4469)) $x4508)) (= $x4471 $x4508)))))))))))))))))))))))))))))
 ))
 (let ((@x4486 (monotonicity (quant-intro (proof-bind ?x4514) (= $x4473 $x4513)) (= $x4474 (=> $x4459 $x4513)))))
 (let ((@x4523 (mp (asserted $x4474) (trans @x4486 (rewrite (= (=> $x4459 $x4513) $x4518)) (= $x4474 $x4518)) $x4518)))
 (let ((@x16333 (mp (mp (mp~ @x4523 @x12382 $x4518) (rewrite (= $x4518 $x4518)) $x4518) (rewrite (= $x4518 $x16331)) $x16331)))
 (let ((@x51103 (unit-resolution @x16333 (unit-resolution @x51101 @x47707 $x4459) $x16326)))
 (let ((?x50307 (+ ?x47833 ?x49409)))
 (let (($x50296 (>= ?x50307 0)))
 (let (($x50116 (not $x16326)))
 (let (($x50377 (or $x50116 $x48298 $x49308 $x47840 $x47759 $x47838 $x50296 $x50373)))
 (let ((@x50381 (rewrite (= (or $x50116 (or $x48298 $x49308 $x47840 $x47759 $x47838 $x50296 $x50373)) $x50377))))
 (let ((@x50382 (mp ((_ quant-inst $ (UINT 8) (I ?x47332) (Poly%fun%1. ?x49287) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47366 ?x47385 ?x1876 $)) (or $x50116 (or $x48298 $x49308 $x47840 $x47759 $x47838 $x50296 $x50373))) @x50381 $x50377)))
 (let ((@x51390 (unit-resolution (unit-resolution @x50382 @x175 @x51103 @x51377 @x51387 @x49986 @x49932 (or $x50296 $x50373)) @x50702 $x50373)))
 (let ((@x51098 (trans* @x50051 (symm @x49975 (= ?x49647 ?x47385)) (= ?x49304 ?x47385))))
 (let ((@x51426 (monotonicity @x51098 (= ?x50365 ?x47831))))
 (let ((@x51432 (symm @x51426 (= ?x47831 ?x50365))))
 (let ((?x50732 (Sub ?x50718 ?x47588)))
 (let ((?x50733 (I ?x50732)))
 (let ((?x50734 (vstd!seq.Seq.index.? $ ?x1876 ?x47321 ?x50733)))
 (let ((?x50719 (* (- 1) ?x50718)))
 (let ((?x49533 (Add ?x47588 ?x47322)))
 (let ((?x50744 (+ ?x49533 ?x50719)))
 (let (($x50745 (<= ?x50744 0)))
 (let ((?x50726 (+ ?x47588 ?x50719)))
 (let (($x50727 (<= ?x50726 0)))
 (let (($x50728 (not $x50727)))
 (let (($x50750 (or $x50728 $x50745)))
 (let ((?x50752 (ite $x50750 ?x50682 ?x50734)))
 (let ((?x50751 (%I ?x50752)))
 (let ((?x51008 (I ?x50798)))
 (let (($x51417 (= ?x51008 ?x50690)))
 (let (($x51398 (= ?x50798 ?x50687)))
 (let ((@x51397 (symm @x51394 (= ?x50799 ?x50687))))
 (let (($x50806 (= ?x50798 ?x50799)))
 (let (($x50807 (not $x50797)))
 (let ((@x51785 (symm (monotonicity @x50344 (= ?x47830 (vstd!seq.Seq.index.? $ ?x1876 ?x48294 ?x47829))) (= (vstd!seq.Seq.index.? $ ?x1876 ?x48294 ?x47829) ?x47830))))
 (let ((?x50337 (%%apply%%0 ?x48307 ?x47829)))
 (let ((?x50318 (vstd!seq.Seq.index.? $ ?x1876 ?x48294 ?x47829)))
 (let (($x50338 (= ?x50318 ?x50337)))
 (let (($x50358 (or $x50116 $x48298 $x48304 $x47840 $x47759 $x47838 $x50296 $x50338)))
 (let ((@x50362 (rewrite (= (or $x50116 (or $x48298 $x48304 $x47840 $x47759 $x47838 $x50296 $x50338)) $x50358))))
 (let ((@x50363 (mp ((_ quant-inst $ (UINT 8) (I ?x47332) (Poly%fun%1. ?x48277) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47366 ?x47385 ?x1876 $)) (or $x50116 (or $x48298 $x48304 $x47840 $x47759 $x47838 $x50296 $x50338))) @x50362 $x50358)))
 (let ((@x51763 (unit-resolution (unit-resolution @x50363 @x175 @x51103 @x51377 @x51387 @x49986 @x49560 (or $x50296 $x50338)) @x50702 $x50338)))
 (let ((@x51781 (symm (monotonicity @x49456 @x51378 (= ?x50337 (%%apply%%0 ?x48261 ?x50375))) (= (%%apply%%0 ?x48261 ?x50375) ?x50337))))
 (let ((?x50684 (I ?x50683)))
 (let ((?x50681 (%%apply%%0 ?x48261 ?x50375)))
 (let (($x50685 (= ?x50681 ?x50684)))
 (let (($x49513 (not $x6500)))
 (let (($x50688 (or $x49513 $x50685)))
 (let ((@x50689 ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (I ?x47833)) $x50688)))
 (let ((@x51771 (monotonicity (trans* (hypothesis $x50805) @x51397 (= ?x50683 ?x50687)) (= ?x50684 ?x50690))))
 (let ((@x51786 (trans* @x51432 @x51390 @x51434 @x51393 (symm @x51771 (= ?x50690 ?x50684)) (symm (unit-resolution @x50689 @x13419 $x50685) (= ?x50684 ?x50681)) @x51781 (symm @x51763 (= ?x50337 ?x50318)) @x51785 $x47832)))
 (let ((@x51788 (unit-resolution (unit-resolution (def-axiom (or $x47841 (not $x47832))) @x50697 (not $x47832)) @x51786 false)))
 (let ((@x51790 (lemma @x51788 (not $x50805))))
 (let ((@x50809 (def-axiom (or $x50807 $x50805))))
 (let ((@x51663 (unit-resolution @x50809 @x51790 $x50807)))
 (let ((@x50811 (def-axiom (or $x50797 $x50806))))
 (let (($x51009 (= ?x50682 ?x51008)))
 (let (($x50714 (has_type ?x50682 ?x1876)))
 (let (($x50710 (has_type ?x50375 INT)))
 (let ((@x51406 (mp @x51377 (symm (monotonicity @x51392 (= $x50710 $x47839)) (= $x47839 $x50710)) $x50710)))
 (let (($x50711 (not $x50710)))
 (let (($x50783 (or $x49571 $x47420 $x50711 $x50714)))
 (let ((@x50788 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I ?x47833)) (or $x49571 (or $x47420 $x50711 $x50714))) (rewrite (= (or $x49571 (or $x47420 $x50711 $x50714)) $x50783)) $x50783)))
 (let ((@x51407 (unit-resolution (unit-resolution @x50788 @x16116 @x49382 (or $x50711 $x50714)) @x51406 $x50714)))
 (let (($x340 (forall ((bits Int) (x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let ((?x330 (UINT bits)))
 (let (($x331 (has_type x ?x330)))
 (let (($x336 (not $x331)))
 (or $x336 $x266))))) :pattern ( (has_type x (UINT bits)) ) :qid prelude_box_unbox_uint))
 ))
 (let ((?x10567 (lambda ((bits Int) (x Poly) )(let (($x266 (= x (I (%I x)))))
 (let ((?x330 (UINT bits)))
 (let (($x331 (has_type x ?x330)))
 (let (($x336 (not $x331)))
 (let (($x337 (or $x336 $x266)))
 (refl (~ $x337 $x337))))))))
 ))
 (let (($x334 (forall ((bits Int) (x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let ((?x330 (UINT bits)))
 (let (($x331 (has_type x ?x330)))
 (=> $x331 $x266)))) :pattern ( (has_type x (UINT bits)) ) :qid prelude_box_unbox_uint))
 ))
 (let ((?x341 (lambda ((bits Int) (x Poly) )(let (($x266 (= x (I (%I x)))))
 (let ((?x330 (UINT bits)))
 (let (($x331 (has_type x ?x330)))
 (let (($x336 (not $x331)))
 (let (($x337 (or $x336 $x266)))
 (let (($x332 (=> $x331 $x266)))
 (rewrite (= $x332 $x337)))))))))
 ))
 (let ((@x345 (mp (asserted $x334) (quant-intro (proof-bind ?x341) (= $x334 $x340)) $x340)))
 (let ((@x10571 (mp~ @x345 (nnf-pos (proof-bind ?x10567) (~ $x340 $x340)) $x340)))
 (let (($x50715 (not $x50714)))
 (let (($x50151 (not $x340)))
 (let (($x51019 (or $x50151 $x50715 $x51009)))
 (let ((@x51024 (mp ((_ quant-inst 8 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x50375)) (or $x50151 (or $x50715 $x51009))) (rewrite (= (or $x50151 (or $x50715 $x51009)) $x51019)) $x51019)))
 (let ((@x51408 (unit-resolution @x51024 @x10571 @x51407 $x51009)))
 (let (($x50766 (= ?x50682 ?x50752)))
 (let ((?x50824 (EucDiv ?x47833 8)))
 (let ((?x47723 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47331 ?x47385 ?x1876 $)))
 (let ((?x47727 (%I ?x47723)))
 (let ((?x50619 (EucDiv ?x47727 8)))
 (let (($x51593 (= ?x50619 ?x50824)))
 (let (($x51612 (not $x51593)))
 (let ((?x50114 (I ?x47727)))
 (let ((?x50593 (%I ?x50114)))
 (let ((?x50594 (EucDiv ?x50593 pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((?x50601 (I ?x50594)))
 (let (($x50602 (vstd!set.Set.contains.? $ INT ?x47556 ?x50601)))
 (let (($x50614 (not $x50602)))
 (let (($x51470 (= $x50797 $x50602)))
 (let (($x51472 (= $x50602 $x50797)))
 (let (($x50814 (= ?x47833 ?x50718)))
 (let ((@x51457 (monotonicity @x51392 (= ?x50718 ?x47833))))
 (let ((@x51520 (symm @x51457 $x50814)))
 (let ((@x51601 (monotonicity @x51520 (symm @x49439 (= 8 pmemlog!pmemspec_t.persistence_chunk_size.?)) (= ?x50824 ?x50789))))
 (let (($x50115 (= ?x47723 ?x50114)))
 (let (($x47734 (has_type ?x47723 INT)))
 (let ((?x47724 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x47723)))
 (let ((?x47725 (vstd!seq.Seq.index.? $ ?x1876 ?x47385 ?x47723)))
 (let (($x47726 (= ?x47725 ?x47724)))
 (let ((?x47779 (+ ?x47727 ?x47747)))
 (let (($x47780 (>= ?x47779 0)))
 (let (($x47732 (>= ?x47727 0)))
 (let (($x47733 (not $x47732)))
 (let (($x47735 (not $x47734)))
 (let (($x47785 (or $x47735 $x47733 $x47780 $x47726)))
 (let (($x47791 (not $x47785)))
 (let (($x47739 (not $x47738)))
 (let (($x47773 (or $x47388 $x47739 $x47791)))
 (let (($x47781 (not $x47773)))
 (let (($x47751 (forall ((i$ Poly) )(! (let ((?x47331 (Poly%vstd!seq.Seq<u8.>. pm!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x47744 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 i$)))
 (let ((?x47321 (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)))
 (let ((?x47361 (I write_addr!)))
 (let ((?x47384 (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? ?x47331 ?x47361 ?x47321 chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)))
 (let ((?x47385 (Poly%vstd!seq.Seq<u8.>. ?x47384)))
 (let ((?x47742 (vstd!seq.Seq.index.? $ ?x1876 ?x47385 i$)))
 (let (($x47749 (>= (+ (%I i$) (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x47385))) 0)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x16070 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x16070 $x47749 (= ?x47742 ?x47744)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. (pmemlog!pmemspec_t.update_contents_to_reflect_partially_flushed_write.? (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) chunks_flushed$!skolem_user_pmemlog__logimpl_v__lemma_single_write_crash_52!26)) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x47752 (not $x47751)))
 (let (($x47753 (or $x47739 $x47752)))
 (let (($x47754 (not $x47753)))
 (let (($x47401 (not $x47388)))
 (let (($x47755 (or $x47401 $x47754)))
 (let (($x47756 (not $x47755)))
 (let (($x47792 (or $x47756 $x47781)))
 (let (($x47778 (not $x47792)))
 (let (($x47770 (or $x47769 $x47761 $x47420 $x47759 $x47778)))
 (let (($x47740 (or $x47388 $x47739 (not (or $x47735 $x47733 (<= (+ ?x47729 (* (- 1) ?x47727)) 0) $x47726)))))
 (let (($x47758 (not (or $x47756 (not $x47740)))))
 (let (($x47762 (or $x47761 $x47420 $x47759 $x47758)))
 (let (($x47771 (or $x47769 $x47762)))
 (let (($x47763 (or $x47761 $x47420 $x47759 $x47778)))
 (let (($x47764 (= $x47762 $x47763)))
 (let ((@x47768 (trans (monotonicity (rewrite (= $x47758 $x47778)) $x47764) (rewrite (= $x47763 $x47763)) $x47764)))
 (let ((@x47777 (trans (monotonicity @x47768 (= $x47771 (or $x47769 $x47763))) (rewrite (= (or $x47769 $x47763) $x47770)) (= $x47771 $x47770))))
 (let ((@x47786 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x47384) (Poly%vstd!seq.Seq<u8.>. pm!)) $x47771) @x47777 $x47770)))
 (let ((@x50572 (unit-resolution (unit-resolution @x47786 @x175 @x50569 (or $x47761 $x47420 $x47778)) @x49382 @x49361 $x47778)))
 (let ((@x47826 (def-axiom (or $x47792 $x47773))))
 (let ((@x47402 (not-or-elim @x47397 $x47401)))
 (let ((@x47822 (def-axiom (or $x47781 $x47388 $x47739 $x47791))))
 (let ((@x50575 (unit-resolution (unit-resolution @x47822 @x47402 (or $x47781 $x47739 $x47791)) (unit-resolution @x47826 @x50572 $x47773) (or $x47739 $x47791))))
 (let ((@x50576 (unit-resolution @x50575 @x49984 $x47791)))
 (let ((@x47804 (def-axiom (or $x47785 $x47734))))
 (let ((@x51104 (unit-resolution @x47804 @x50576 $x47734)))
 (let (($x50126 (or $x49500 $x47735 $x50115)))
 (let ((@x50131 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47331 ?x47385 ?x1876 $)) (or $x49500 (or $x47735 $x50115))) (rewrite (= (or $x49500 (or $x47735 $x50115)) $x50126)) $x50126)))
 (let ((@x51109 (unit-resolution @x50131 @x10543 @x51104 $x50115)))
 (let ((@x51111 (symm @x51109 (= ?x50114 ?x47723))))
 (let ((@x51450 (monotonicity @x51111 (= ?x50593 ?x47727))))
 (let ((@x51452 (monotonicity @x51450 @x49439 (= ?x50594 ?x50619))))
 (let ((@x51605 (monotonicity (trans* @x51452 (hypothesis $x51593) @x51601 (= ?x50594 ?x50789)) (= ?x50601 ?x50790))))
 (let ((@x51475 (hypothesis $x50807)))
 (let ((@x51610 (mp @x51475 (monotonicity (symm (monotonicity @x51605 $x51472) $x51470) (= $x50807 $x50614)) $x50614)))
 (let ((?x50136 (%I ?x47724)))
 (let ((?x50139 (I ?x50136)))
 (let ((?x50604 (%I ?x50139)))
 (let ((?x50603 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? ?x50114 ?x50139 ?x47361 ?x47321)))
 (let ((?x50605 (ite $x50602 ?x50603 ?x50604)))
 (let (($x50613 (= ?x50604 ?x50605)))
 (let (($x50140 (= ?x47724 ?x50139)))
 (let (($x49938 (has_type ?x47724 ?x1876)))
 (let (($x49913 (or $x49571 $x47420 $x47735 $x49938)))
 (let ((@x49550 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47331 ?x47385 ?x1876 $)) (or $x49571 (or $x47420 $x47735 $x49938))) (rewrite (= (or $x49571 (or $x47420 $x47735 $x49938)) $x49913)) $x49913)))
 (let (($x50135 (not $x49938)))
 (let (($x50152 (or $x50151 $x50135 $x50140)))
 (let ((@x50157 (mp ((_ quant-inst 8 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x47723)) (or $x50151 (or $x50135 $x50140))) (rewrite (= (or $x50151 (or $x50135 $x50140)) $x50152)) $x50152)))
 (let ((@x51118 (unit-resolution @x50157 @x10571 (unit-resolution @x49550 @x16116 @x49382 @x51104 $x49938) $x50140)))
 (let ((@x51122 (symm @x51118 (= ?x50139 ?x47724))))
 (let ((?x50556 (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x50114)))
 (let ((?x50557 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x50114 ?x50556 ?x47361 ?x47321 ?x47556)))
 (let ((?x50558 (I ?x50557)))
 (let ((?x50590 (pmemlog!pmemspec_t.update_byte_to_reflect_partially_flushed_write.? ?x50114 ?x50139 ?x47361 ?x47321 ?x47556)))
 (let ((@x51126 (trans* @x51122 (symm (monotonicity @x51111 (= ?x50556 ?x47724)) (= ?x47724 ?x50556)) (= ?x50139 ?x50556))))
 (let (($x50606 (= ?x50590 ?x50605)))
 (let (($x50610 (or $x50609 $x50606)))
 (let ((@x50611 ((_ quant-inst (I ?x47727) (I ?x50136) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555)) $x50610)))
 (let ((@x51140 (trans* (monotonicity @x51118 (= ?x50136 ?x50604)) (hypothesis $x50613) (symm (unit-resolution @x50611 @x51130 $x50606) (= ?x50605 ?x50590)) (monotonicity @x51126 (= ?x50590 ?x50557)) (= ?x50136 ?x50557))))
 (let ((?x50555 (%%apply%%0 ?x49271 ?x50114)))
 (let (($x50559 (= ?x50555 ?x50558)))
 (let (($x50562 (or $x49710 $x50559)))
 (let ((@x50563 ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. pm!) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!) (Poly%vstd!set.Set<int.>. ?x47555) (I ?x47727)) $x50562)))
 (let ((@x51154 (symm (monotonicity @x51115 @x51111 (= ?x50555 (%%apply%%0 ?x49315 ?x47723))) (= (%%apply%%0 ?x49315 ?x47723) ?x50555))))
 (let ((?x50080 (%%apply%%0 ?x49315 ?x47723)))
 (let ((?x49891 (vstd!seq.Seq.index.? $ ?x1876 ?x49304 ?x47723)))
 (let (($x49575 (= ?x49891 ?x50080)))
 (let ((@x50584 ((_ th-lemma arith farkas -1 -1 1 1) @x50583 (hypothesis (>= (+ ?x47727 ?x49409) 0)) @x49424 (unit-resolution (def-axiom (or $x47785 (not $x47780))) @x50576 (not $x47780)) false)))
 (let ((@x50586 (lemma @x50584 (not (>= (+ ?x47727 ?x49409) 0)))))
 (let ((@x47806 (def-axiom (or $x47785 $x47732))))
 (let ((@x51105 (unit-resolution @x47806 @x50576 $x47732)))
 (let ((?x49904 (+ ?x47727 ?x49409)))
 (let (($x49974 (>= ?x49904 0)))
 (let (($x50117 (or $x50116 $x48298 $x49308 $x47735 $x47759 $x47733 $x49974 $x49575)))
 (let ((@x50121 (rewrite (= (or $x50116 (or $x48298 $x49308 $x47735 $x47759 $x47733 $x49974 $x49575)) $x50117))))
 (let ((@x50122 (mp ((_ quant-inst $ (UINT 8) (I ?x47332) (Poly%fun%1. ?x49287) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x47331 ?x47385 ?x1876 $)) (or $x50116 (or $x48298 $x49308 $x47735 $x47759 $x47733 $x49974 $x49575))) @x50121 $x50117)))
 (let ((@x51108 (unit-resolution (unit-resolution @x50122 @x175 @x51103 @x51104 @x51105 @x49986 @x49932 (or $x49974 $x49575)) @x50586 $x49575)))
 (let ((@x51157 (trans* (symm (monotonicity @x51098 (= ?x49891 ?x47725)) (= ?x47725 ?x49891)) @x51108 @x51154 (unit-resolution @x50563 @x14167 $x50559) (symm (monotonicity @x51140 (= ?x50139 ?x50558)) (= ?x50558 ?x50139)) @x51122 $x47726)))
 (let (($x47810 (not $x47726)))
 (let ((@x47812 (def-axiom (or $x47785 $x47810))))
 (let ((@x51158 (unit-resolution @x47812 @x50576 $x47810)))
 (let ((@x51161 (lemma (unit-resolution @x51158 @x51157 false) (not $x50613))))
 (let ((@x50618 (def-axiom (or $x50602 $x50613))))
 (let ((@x51385 (unit-resolution @x50618 @x51161 $x50602)))
 (let ((@x51614 (lemma (unit-resolution @x51385 @x51610 false) (or $x51612 $x50797))))
 (let ((?x51089 (* (- 1) ?x50593)))
 (let ((?x51167 (+ ?x49533 ?x51089)))
 (let (($x51168 (<= ?x51167 0)))
 (let ((?x51090 (+ ?x47588 ?x51089)))
 (let (($x51091 (<= ?x51090 0)))
 (let (($x51092 (not $x51091)))
 (let (($x51173 (or $x51092 $x51168)))
 (let (($x51195 (not $x51173)))
 (let ((?x51084 (Sub ?x50593 ?x47588)))
 (let ((?x51147 (I ?x51084)))
 (let ((?x51148 (vstd!seq.Seq.index.? $ ?x1876 ?x47321 ?x51147)))
 (let ((?x51175 (ite $x51173 ?x50139 ?x51148)))
 (let (($x51188 (= ?x50139 ?x51175)))
 (let (($x50612 (= ?x50603 ?x50605)))
 (let ((@x50616 (def-axiom (or $x50614 $x50612))))
 (let ((?x51174 (%I ?x51175)))
 (let (($x51177 (= ?x50603 ?x51174)))
 (let (($x17295 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x6430 (vstd!seq.Seq.index.? $ ?x1876 write_bytes! (I (Sub (%I addr!) (%I write_addr!))))))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 write_bytes!)))
 (let ((?x1191 (%I write_addr!)))
 (let ((?x6425 (Add ?x1191 ?x6094)))
 (let ((?x6446 (* (- 1) ?x6425)))
 (let ((?x4792 (%I addr!)))
 (let (($x6445 (>= (+ ?x4792 ?x6446) 0)))
 (let ((?x17294 (%I (ite (or (not (<= (+ ?x1191 (* (- 1) ?x4792)) 0)) $x6445) prewrite_byte! ?x6430))))
 (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (= ?x6423 ?x17294))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_definition))
 ))
 (let (($x6422 (fuel_bool fuel%pmemlog!pmemspec_t.update_byte_to_reflect_write.)))
 (let (($x6420 (fuel_bool_default fuel%pmemlog!pmemspec_t.update_byte_to_reflect_write.)))
 (let (($x48256 (= $x6422 $x6420)))
 (let ((@x48273 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.update_byte_to_reflect_write.) (or (not $x30) $x48256)) @x47616 (hypothesis (not $x48256)) false)))
 (let ((@x48286 (lemma @x48273 $x48256)))
 (let ((@x6421 (asserted $x6420)))
 (let ((@x48264 (def-axiom (or (not $x48256) $x6422 (not $x6420)))))
 (let ((@x51672 (unit-resolution (unit-resolution @x48264 @x6421 (or (not $x48256) $x6422)) @x48286 $x6422)))
 (let (($x6453 (not $x6422)))
 (let (($x17290 (or $x6453 $x17295)))
 (let (($x6456 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x6430 (vstd!seq.Seq.index.? $ ?x1876 write_bytes! (I (Sub (%I addr!) (%I write_addr!))))))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 write_bytes!)))
 (let ((?x1191 (%I write_addr!)))
 (let ((?x6425 (Add ?x1191 ?x6094)))
 (let ((?x6446 (* (- 1) ?x6425)))
 (let ((?x4792 (%I addr!)))
 (let (($x6445 (>= (+ ?x4792 ?x6446) 0)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x6438 (<= ?x4855 0)))
 (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (= ?x6423 (%I (ite (and $x6438 (not $x6445)) ?x6430 prewrite_byte!))))))))))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_definition))
 ))
 (let (($x6458 (or $x6453 $x6456)))
 (let ((?x13389 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x6430 (vstd!seq.Seq.index.? $ ?x1876 write_bytes! (I (Sub (%I addr!) (%I write_addr!))))))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 write_bytes!)))
 (let ((?x1191 (%I write_addr!)))
 (let ((?x6425 (Add ?x1191 ?x6094)))
 (let ((?x6446 (* (- 1) ?x6425)))
 (let ((?x4792 (%I addr!)))
 (let (($x6445 (>= (+ ?x4792 ?x6446) 0)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x6438 (<= ?x4855 0)))
 (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6444 (= ?x6423 (%I (ite (and $x6438 (not $x6445)) ?x6430 prewrite_byte!)))))
 (refl (~ $x6444 $x6444))))))))))))))))
 ))
 (let ((@x13394 (monotonicity (refl (~ $x6453 $x6453)) (nnf-pos (proof-bind ?x13389) (~ $x6456 $x6456)) (~ $x6458 $x6458))))
 (let (($x6435 (forall ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(! (let ((?x1876 (UINT 8)))
 (let ((?x6430 (vstd!seq.Seq.index.? $ ?x1876 write_bytes! (I (Sub (%I addr!) (%I write_addr!))))))
 (let (($x6427 (and (<= (%I write_addr!) (%I addr!)) (< (%I addr!) (Add (%I write_addr!) (vstd!seq.Seq.len.? $ ?x1876 write_bytes!))))))
 (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (= ?x6423 (%I (ite $x6427 ?x6430 prewrite_byte!))))))) :pattern ( (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!) ) :qid internal_pmemlog!pmemspec_t.update_byte_to_reflect_write.?_definition))
 ))
 (let (($x6436 (=> $x6422 $x6435)))
 (let ((?x6439 (lambda ((addr! Poly) (prewrite_byte! Poly) (write_addr! Poly) (write_bytes! Poly) )(let ((?x1876 (UINT 8)))
 (let ((?x6430 (vstd!seq.Seq.index.? $ ?x1876 write_bytes! (I (Sub (%I addr!) (%I write_addr!))))))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 write_bytes!)))
 (let ((?x1191 (%I write_addr!)))
 (let ((?x6425 (Add ?x1191 ?x6094)))
 (let ((?x6446 (* (- 1) ?x6425)))
 (let ((?x4792 (%I addr!)))
 (let (($x6445 (>= (+ ?x4792 ?x6446) 0)))
 (let ((?x4828 (* (- 1) ?x4792)))
 (let ((?x4855 (+ ?x1191 ?x4828)))
 (let (($x6438 (<= ?x4855 0)))
 (let ((?x6423 (pmemlog!pmemspec_t.update_byte_to_reflect_write.? addr! prewrite_byte! write_addr! write_bytes!)))
 (let (($x6444 (= ?x6423 (%I (ite (and $x6438 (not $x6445)) ?x6430 prewrite_byte!)))))
 (let (($x6433 (= ?x6423 (%I (ite (and (<= ?x1191 ?x4792) (< ?x4792 ?x6425)) ?x6430 prewrite_byte!)))))
 (rewrite (= $x6433 $x6444)))))))))))))))))
 ))
 (let ((@x6451 (monotonicity (quant-intro (proof-bind ?x6439) (= $x6435 $x6456)) (= $x6436 (=> $x6422 $x6456)))))
 (let ((@x6463 (mp (asserted $x6436) (trans @x6451 (rewrite (= (=> $x6422 $x6456) $x6458)) (= $x6436 $x6458)) $x6458)))
 (let ((@x17292 (mp (mp (mp~ @x6463 @x13394 $x6458) (rewrite (= $x6458 $x6458)) $x6458) (rewrite (= $x6458 $x17290)) $x17290)))
 (let ((@x51673 (unit-resolution @x17292 @x51672 $x17295)))
 (let (($x50753 (not $x17295)))
 (let (($x51176 (or $x50753 $x51177)))
 (let (($x51081 (= ?x50603 (%I (ite (or $x51092 (>= (+ ?x50593 (* (- 1) ?x49533)) 0)) ?x50139 ?x51148)))))
 (let (($x51180 (or $x50753 $x51081)))
 (let (($x51182 (= $x51180 $x51176)))
 (let ((@x51186 (trans (monotonicity (rewrite (= $x51081 $x51177)) $x51182) (rewrite (= $x51176 $x51176)) $x51182)))
 (let ((@x51187 (mp ((_ quant-inst (I ?x47727) (I ?x50136) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)) $x51180) @x51186 $x51176)))
 (let ((@x51748 (monotonicity (trans* @x51118 (hypothesis $x51188) (= ?x47724 ?x51175)) (= ?x50136 ?x51174))))
 (let ((@x51751 (trans* (monotonicity @x51122 (= ?x50604 ?x50136)) @x51748 (symm (unit-resolution @x51187 @x51673 $x51177) (= ?x51174 ?x50603)) (unit-resolution @x50616 @x51385 $x50612) $x50613)))
 (let ((@x51754 (lemma (unit-resolution @x51161 @x51751 false) (not $x51188))))
 (let ((@x51199 (def-axiom (or $x51195 $x51188))))
 (let (($x50773 (not $x50750)))
 (let ((@x51760 (hypothesis $x50773)))
 (let ((@x50769 (def-axiom (or $x50750 $x50727))))
 (let (($x50770 (not $x50745)))
 (let ((@x51529 (hypothesis $x50770)))
 (let (($x49259 (<= pmemlog!pmemspec_t.persistence_chunk_size.? 8)))
 (let ((@x51513 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x8219) $x49259)) @x49439 $x49259)))
 (let ((?x47451 (mod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((?x47452 (* (- 1) ?x47451)))
 (let ((?x47326 (EucMod write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((?x47455 (+ ?x47326 ?x47452)))
 (let (($x47470 (>= ?x47455 0)))
 (let (($x47456 (= ?x47455 0)))
 (let (($x1010 (forall ((x Int) (y Int) )(! (= (+ (EucMod x y) (* (- 1) (mod x y))) 0) :pattern ( (EucMod x y) ) :qid prelude_eucmod))
 ))
 (let ((?x10784 (lambda ((x Int) (y Int) )(let (($x1007 (= (+ (EucMod x y) (* (- 1) (mod x y))) 0)))
 (refl (~ $x1007 $x1007))))
 ))
 (let (($x1003 (forall ((x Int) (y Int) )(! (let ((?x1000 (mod x y)))
 (let ((?x999 (EucMod x y)))
 (= ?x999 ?x1000))) :pattern ( (EucMod x y) ) :qid prelude_eucmod))
 ))
 (let ((?x1011 (lambda ((x Int) (y Int) )(let (($x1007 (= (+ (EucMod x y) (* (- 1) (mod x y))) 0)))
 (let ((?x1000 (mod x y)))
 (let ((?x999 (EucMod x y)))
 (let (($x1001 (= ?x999 ?x1000)))
 (rewrite (= $x1001 $x1007)))))))
 ))
 (let ((@x1015 (mp (asserted $x1003) (quant-intro (proof-bind ?x1011) (= $x1003 $x1010)) $x1010)))
 (let ((@x10788 (mp~ @x1015 (nnf-pos (proof-bind ?x10784) (~ $x1010 $x1010)) $x1010)))
 (let (($x47460 (or (not $x1010) $x47456)))
 (let ((@x47461 ((_ quant-inst write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?) $x47460)))
 (let ((@x51596 (unit-resolution @x47461 @x10788 $x47456)))
 (let ((@x51615 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47456) $x47470)) @x51596 $x47470)))
 (let (($x47602 (<= ?x47326 0)))
 (let (($x47327 (= ?x47326 0)))
 (let ((@x47328 (asserted $x47327)))
 (let ((@x51619 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47327) $x47602)) @x47328 $x47602)))
 (let ((?x47471 (div write_addr! pmemlog!pmemspec_t.persistence_chunk_size.?)))
 (let ((?x47524 (* pmemlog!pmemspec_t.persistence_chunk_size.? ?x47471)))
 (let ((?x47525 (+ ?x47524 ?x47451)))
 (let ((?x47474 (* (- 1) ?x47525)))
 (let ((?x47494 (+ write_addr! ?x47474)))
 (let (($x47495 (<= ?x47494 0)))
 (let (($x47493 (= write_addr! ?x47525)))
 (let (($x51638 (= $x47493 true)))
 (let (($x47526 (= ?x47525 write_addr!)))
 (let (($x47523 (= pmemlog!pmemspec_t.persistence_chunk_size.? 0)))
 (let (($x51625 (not $x47523)))
 (let (($x47479 (<= pmemlog!pmemspec_t.persistence_chunk_size.? 0)))
 (let (($x51628 (not $x47479)))
 (let ((@x51632 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x51625 $x47479)) (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x49232) $x51628)) @x49440 $x51628) $x51625)))
 (let ((@x51637 (iff-true (unit-resolution ((_ th-lemma arith) (or $x47523 $x47526)) @x51632 $x47526) (= $x47526 true))))
 (let ((@x51642 (mp (trans* (commutativity (= $x47493 $x47526)) @x51637 $x51638) (rewrite (= $x51638 $x47493)) $x47493)))
 (let ((@x51643 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47493) $x47495)) @x51642 $x47495)))
 (let ((?x50620 (div ?x47727 8)))
 (let ((?x50623 (* (- 1) ?x50620)))
 (let ((?x51301 (+ ?x47471 ?x50623)))
 (let (($x51302 (<= ?x51301 0)))
 (let ((?x50631 (mod ?x47727 8)))
 (let (($x50667 (<= ?x50631 7)))
 (let ((@x23 (true-axiom true)))
 (let ((?x50663 (* 8 ?x50620)))
 (let ((?x50664 (+ ?x50663 ?x50631)))
 (let ((?x50640 (* (- 1) ?x50664)))
 (let ((?x50641 (+ ?x47727 ?x50640)))
 (let (($x50634 (<= ?x50641 0)))
 (let (($x50639 (= ?x47727 ?x50664)))
 (let (($x51563 (= $x50639 true)))
 (let (($x50665 (= ?x50664 ?x47727)))
 (let ((@x51562 (iff-true (unit-resolution ((_ th-lemma arith) (or false $x50665)) @x23 $x50665) (= $x50665 true))))
 (let ((@x51567 (mp (trans* (commutativity (= $x50639 $x50665)) @x51562 $x51563) (rewrite (= $x51563 $x50639)) $x50639)))
 (let ((?x51203 (+ ?x47727 ?x51089)))
 (let (($x51205 (>= ?x51203 0)))
 (let (($x51202 (= ?x47727 ?x50593)))
 (let ((@x51572 (symm @x51450 $x51202)))
 (let (($x47469 (<= ?x47455 0)))
 (let ((@x51690 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47456) $x47469)) @x51596 $x47469)))
 (let (($x47458 (>= ?x47326 0)))
 (let ((@x51693 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47327) $x47458)) @x47328 $x47458)))
 (let (($x47496 (>= ?x47494 0)))
 (let ((@x51696 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47493) $x47496)) @x51642 $x47496)))
 (let ((?x50801 (* (- 1) ?x47588)))
 (let ((?x50802 (+ write_addr! ?x50801)))
 (let (($x50812 (<= ?x50802 0)))
 (let ((@x51702 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47589) $x50812)) @x50086 $x50812)))
 (let ((@x51704 ((_ th-lemma arith farkas 1 1 -8 -1 -1 1 -1 -1 -1 1 1) (hypothesis $x51091) @x51702 (hypothesis (not $x51302)) @x51696 @x51693 @x51690 @x49440 @x51513 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51202) $x51205)) @x51572 $x51205) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50639) $x50634)) @x51567 $x50634) (unit-resolution ((_ th-lemma arith) (or false $x50667)) @x23 $x50667) false)))
 (let ((@x51706 (lemma @x51704 (or $x51302 $x51092))))
 (let ((@x51731 (unit-resolution @x51706 (unit-resolution (def-axiom (or $x51173 $x51091)) (hypothesis $x51195) $x51091) $x51302)))
 (let ((?x50624 (+ ?x50619 ?x50623)))
 (let (($x50633 (>= ?x50624 0)))
 (let (($x50625 (= ?x50624 0)))
 (let (($x993 (forall ((x Int) (y Int) )(! (= (+ (EucDiv x y) (* (- 1) (div x y))) 0) :pattern ( (EucDiv x y) ) :qid prelude_eucdiv))
 ))
 (let ((?x10777 (lambda ((x Int) (y Int) )(let (($x990 (= (+ (EucDiv x y) (* (- 1) (div x y))) 0)))
 (refl (~ $x990 $x990))))
 ))
 (let (($x986 (forall ((x Int) (y Int) )(! (let ((?x983 (div x y)))
 (let ((?x982 (EucDiv x y)))
 (= ?x982 ?x983))) :pattern ( (EucDiv x y) ) :qid prelude_eucdiv))
 ))
 (let ((?x994 (lambda ((x Int) (y Int) )(let (($x990 (= (+ (EucDiv x y) (* (- 1) (div x y))) 0)))
 (let ((?x983 (div x y)))
 (let ((?x982 (EucDiv x y)))
 (let (($x984 (= ?x982 ?x983)))
 (rewrite (= $x984 $x990)))))))
 ))
 (let ((@x998 (mp (asserted $x986) (quant-intro (proof-bind ?x994) (= $x986 $x993)) $x993)))
 (let ((@x10781 (mp~ @x998 (nnf-pos (proof-bind ?x10777) (~ $x993 $x993)) $x993)))
 (let (($x50628 (not $x993)))
 (let (($x50629 (or $x50628 $x50625)))
 (let ((@x50630 ((_ quant-inst (%I ?x47723) 8) $x50629)))
 (let ((@x51363 (unit-resolution @x50630 @x10781 $x50625)))
 (let ((?x50825 (div ?x47833 8)))
 (let ((?x50828 (* (- 1) ?x50825)))
 (let ((?x50829 (+ ?x50824 ?x50828)))
 (let (($x50836 (<= ?x50829 0)))
 (let (($x50830 (= ?x50829 0)))
 (let (($x50833 (or $x50628 $x50830)))
 (let ((@x50834 ((_ quant-inst (%I ?x47829) 8) $x50833)))
 (let ((@x51485 (unit-resolution @x50834 @x10781 $x50830)))
 (let ((@x51486 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50830) $x50836)) @x51485 $x50836)))
 (let ((?x50835 (mod ?x47833 8)))
 (let (($x50870 (>= ?x50835 0)))
 (let ((@x51491 (unit-resolution ((_ th-lemma arith) (or false $x50870)) @x23 $x50870)))
 (let ((?x50867 (* 8 ?x50825)))
 (let ((?x50868 (+ ?x50867 ?x50835)))
 (let ((?x50844 (* (- 1) ?x50868)))
 (let ((?x50845 (+ ?x47833 ?x50844)))
 (let (($x50846 (>= ?x50845 0)))
 (let (($x50843 (= ?x47833 ?x50868)))
 (let (($x51502 (= $x50843 true)))
 (let (($x50869 (= ?x50868 ?x47833)))
 (let ((@x51501 (iff-true (unit-resolution ((_ th-lemma arith) (or false $x50869)) @x23 $x50869) (= $x50869 true))))
 (let ((@x51506 (mp (trans* (commutativity (= $x50843 $x50869)) @x51501 $x51502) (rewrite (= $x51502 $x50843)) $x50843)))
 (let ((@x51507 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50843) $x50846)) @x51506 $x50846)))
 (let ((?x50815 (+ ?x47833 ?x50719)))
 (let (($x50816 (<= ?x50815 0)))
 (let ((@x51521 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50814) $x50816)) @x51520 $x50816)))
 (let ((?x50866 (* (- 1) ?x50824)))
 (let ((?x51336 (+ ?x50619 ?x50866)))
 (let (($x51289 (>= ?x51336 0)))
 (let (($x51739 (not $x51289)))
 (let (($x51339 (<= ?x51336 0)))
 (let ((@x51725 (hypothesis $x50727)))
 (let (($x51298 (>= ?x51301 0)))
 (let (($x51192 (not $x51168)))
 (let ((@x51729 (hypothesis $x51195)))
 (let ((@x51194 (def-axiom (or $x51173 $x51192))))
 (let ((@x51574 (hypothesis $x51192)))
 (let (($x50666 (>= ?x50631 0)))
 (let ((@x51552 (unit-resolution ((_ th-lemma arith) (or false $x50666)) @x23 $x50666)))
 (let (($x50642 (>= ?x50641 0)))
 (let ((@x51568 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50639) $x50642)) @x51567 $x50642)))
 (let (($x51204 (<= ?x51203 0)))
 (let ((@x51573 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51202) $x51204)) @x51572 $x51204)))
 (let (($x47561 (>= ?x47553 0)))
 (let ((@x51510 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47554) $x47561)) @x49428 $x47561)))
 (let (($x47613 (<= ?x47612 0)))
 (let ((@x51516 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47611) $x47613)) @x49448 $x47613)))
 (let ((?x49534 (* (- 1) ?x49533)))
 (let ((?x50819 (+ ?x47347 ?x49534)))
 (let (($x50821 (>= ?x50819 0)))
 (let ((@x51528 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x47347 ?x49533)) $x50821)) (symm (monotonicity @x50091 (= ?x49533 ?x47347)) (= ?x47347 ?x49533)) $x50821)))
 (let ((@x51709 ((_ th-lemma arith farkas 1 -1 -1 1 -8 -1 -1 1 -1 -1 -1 1 1 1) @x51528 @x51516 @x51513 @x51510 (hypothesis (not $x51298)) @x51643 @x51619 @x51615 @x49440 @x51513 @x51573 @x51568 @x51552 @x51574 false)))
 (let ((@x51711 (lemma @x51709 (or $x51298 $x51168))))
 (let (($x51585 (not $x51339)))
 (let ((@x51586 (hypothesis $x51585)))
 (let (($x50632 (<= ?x50624 0)))
 (let ((@x51365 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50625) $x50632)) @x51363 $x50632)))
 (let (($x50837 (>= ?x50829 0)))
 (let (($x50871 (<= ?x50835 7)))
 (let (($x50838 (<= ?x50845 0)))
 (let (($x50817 (>= ?x50815 0)))
 (let ((@x51726 ((_ th-lemma arith farkas -1/8 -1/8 1/8 -1/8 -1/8 1 -1 1 1/8 1/8 -1/8 1/8 1/8 1) @x51725 @x51702 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50814) $x50817)) @x51520 $x50817) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50843) $x50838)) @x51506 $x50838) (unit-resolution ((_ th-lemma arith) (or false $x50871)) @x23 $x50871) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50830) $x50837)) @x51485 $x50837) @x51365 (hypothesis $x51298) @x51696 @x51693 @x51690 @x49440 @x51513 @x51586 false)))
 (let ((@x51728 (lemma @x51726 (or $x51339 $x50728 (not $x51298)))))
 (let ((@x51738 (unit-resolution @x51728 (unit-resolution @x51711 (unit-resolution @x51194 @x51729 $x51192) $x51298) @x51725 $x51339)))
 (let ((@x51742 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x51593 $x51585 $x51739)) @x51738 (hypothesis $x51612) $x51739)))
 (let ((@x51743 ((_ th-lemma arith farkas 1 -1 -1 1 -8 -1 1 1 -8 8 -8 -1 -1 1 -1 -1 1) @x51528 @x51516 @x51513 @x51510 @x51742 @x51521 @x51507 @x51491 @x51486 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50625) $x50633)) @x51363 $x50633) @x51731 @x51643 @x51619 @x51615 @x49440 @x51513 @x51529 false)))
 (let ((@x51745 (lemma @x51743 (or $x51173 $x50745 $x51593 $x50728))))
 (let ((@x51791 (unit-resolution @x51745 (unit-resolution (def-axiom (or $x50750 $x50770)) @x51760 $x50770) (unit-resolution @x50769 @x51760 $x50727) (unit-resolution @x51199 @x51754 $x51195) (unit-resolution @x51614 @x51663 $x51612) false)))
 (let ((@x51792 (lemma @x51791 $x50750)))
 (let ((@x50777 (def-axiom (or $x50773 $x50766))))
 (let ((@x51797 (trans* (symm (unit-resolution @x50777 @x51792 $x50766) (= ?x50752 ?x50682)) @x51408 (monotonicity (trans* (unit-resolution @x50811 @x51663 $x50806) @x51397 $x51398) $x51417) (symm @x51393 (= ?x50690 ?x50686)) @x51422 (symm @x51390 (= ?x50366 ?x50365)) @x51426 (= ?x50752 ?x47831))))
 (let (($x50754 (= ?x50683 ?x50751)))
 (let (($x50757 (or $x50753 $x50754)))
 (let (($x50737 (= ?x50683 (%I (ite (or $x50728 (>= (+ ?x50718 ?x49534) 0)) ?x50682 ?x50734)))))
 (let (($x50755 (or $x50753 $x50737)))
 (let (($x50760 (= $x50755 $x50757)))
 (let ((@x50764 (trans (monotonicity (rewrite (= $x50737 $x50754)) $x50760) (rewrite (= $x50757 $x50757)) $x50760)))
 (let ((@x50765 (mp ((_ quant-inst (I ?x47833) (vstd!seq.Seq.index.? $ ?x1876 ?x47331 ?x50375) (I write_addr!) (Poly%vstd!seq.Seq<u8.>. bytes_to_write!)) $x50755) @x50764 $x50757)))
 (let ((@x51804 (trans* (unit-resolution @x50765 @x51673 $x50754) (monotonicity @x51797 (= ?x50751 ?x50397)) (monotonicity (trans* @x51432 @x51390 @x51434 @x51393 (= ?x47831 ?x50690)) $x51002) (symm (unit-resolution @x50713 @x10522 $x50707) (= ?x50706 ?x50687)) @x51394 $x50805)))
 (unit-resolution @x51790 @x51804 false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

