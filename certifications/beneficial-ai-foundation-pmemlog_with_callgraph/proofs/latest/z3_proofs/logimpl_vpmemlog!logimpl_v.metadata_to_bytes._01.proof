(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10331)
(:version "4.12.5")
unsat
((declare-fun i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 (Poly Poly Type Dcr) Poly)
(declare-fun s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 () Poly)
(declare-fun x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 () Poly)
(proof
(let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x44080 (Poly%alloc!vec.Vec<u8./allocator_global%.>. out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44081 (vstd!view.View.view.? $ ?x1878 ?x44080)))
 (let ((?x44086 (vstd!seq.Seq.len.? $ ?x1876 ?x44081)))
 (let (($x44087 (= ?x44086 ?x8522)))
 (let (($x7320 (= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7318 (fuel_bool fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x7316 (fuel_bool_default fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x46812 (= $x7318 $x7316)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x43971 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x8789 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x8794 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x8789) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x8798 (mp (mp~ @x37 @x8794 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x45572 (unit-resolution @x8798 @x43971 $x30)))
 (let ((@x46842 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_size.) (or (not $x30) $x46812)) @x45572 (hypothesis (not $x46812)) false)))
 (let ((@x46855 (lemma @x46842 $x46812)))
 (let ((@x7317 (asserted $x7316)))
 (let ((@x46833 (def-axiom (or (not $x46812) $x7318 (not $x7316)))))
 (let ((@x51013 (unit-resolution (unit-resolution @x46833 @x7317 (or (not $x46812) $x7318)) @x46855 $x7318)))
 (let (($x7323 (not $x7318)))
 (let (($x7324 (or $x7323 $x7320)))
 (let ((@x7327 (mp (asserted (=> $x7318 $x7320)) (rewrite (= (=> $x7318 $x7320) $x7324)) $x7324)))
 (let ((@x51483 (monotonicity (unit-resolution @x7327 @x51013 $x7320) (= ?x8522 (Sub 32 8)))))
 (let ((?x50882 (Sub 32 8)))
 (let (($x50955 (= ?x50882 24)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x9200 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x9204 (mp~ @x956 (nnf-pos (proof-bind ?x9200) (~ $x951 $x951)) $x951)))
 (let (($x45535 (not $x951)))
 (let (($x50962 (or $x45535 $x50955)))
 (let ((?x50881 (* (- 1) 32)))
 (let ((?x50918 (+ 8 ?x50881 ?x50882)))
 (let (($x50925 (= ?x50918 0)))
 (let (($x50963 (or $x45535 $x50925)))
 (let (($x50966 (= $x50963 $x50962)))
 (let ((@x50951 (trans (monotonicity (rewrite (= ?x50881 (- 32))) (= ?x50918 (+ 8 (- 32) ?x50882))) (rewrite (= (+ 8 (- 32) ?x50882) (+ (- 24) ?x50882))) (= ?x50918 (+ (- 24) ?x50882)))))
 (let ((@x50957 (trans (monotonicity @x50951 (= $x50925 (= (+ (- 24) ?x50882) 0))) (rewrite (= (= (+ (- 24) ?x50882) 0) $x50955)) (= $x50925 $x50955))))
 (let ((@x51028 (mp ((_ quant-inst 32 8) $x50963) (trans (monotonicity @x50957 $x50966) (rewrite (= $x50962 $x50962)) $x50966) $x50962)))
 (let ((?x7368 (Sub pmemlog!logimpl_v.header_log_size_offset.? 8)))
 (let ((?x7370 (Add ?x7368 8)))
 (let ((?x46964 (* (- 1) ?x7370)))
 (let ((?x46973 (+ ?x7368 ?x46964)))
 (let (($x46986 (<= ?x46973 (- 8))))
 (let (($x46974 (= ?x46973 (- 8))))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x9193 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x9197 (mp~ @x925 (nnf-pos (proof-bind ?x9193) (~ $x920 $x920)) $x920)))
 (let (($x45516 (not $x920)))
 (let (($x46977 (or $x45516 $x46974)))
 (let (($x46972 (= (+ 8 ?x7368 ?x46964) 0)))
 (let (($x46978 (or $x45516 $x46972)))
 (let (($x46980 (= $x46978 $x46977)))
 (let ((@x46984 (trans (monotonicity (rewrite (= $x46972 $x46974)) $x46980) (rewrite (= $x46977 $x46977)) $x46980)))
 (let ((@x46985 (mp ((_ quant-inst (Sub pmemlog!logimpl_v.header_log_size_offset.? 8) 8) $x46978) @x46984 $x46977)))
 (let ((@x48358 (unit-resolution @x46985 @x9197 $x46974)))
 (let ((@x48359 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46974) $x46986)) @x48358 $x46986)))
 (let (($x46987 (>= ?x46973 (- 8))))
 (let ((@x48362 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46974) $x46987)) @x48358 $x46987)))
 (let (($x47071 (<= ?x7368 16)))
 (let (($x47070 (= ?x7368 16)))
 (let ((?x47007 (Sub 24 8)))
 (let (($x47025 (= ?x47007 16)))
 (let (($x47030 (or $x45535 $x47025)))
 (let ((?x47006 (* (- 1) 24)))
 (let ((?x47008 (+ 8 ?x47006 ?x47007)))
 (let (($x47009 (= ?x47008 0)))
 (let (($x47031 (or $x45535 $x47009)))
 (let (($x47033 (= $x47031 $x47030)))
 (let ((@x47021 (trans (monotonicity (rewrite (= ?x47006 (- 24))) (= ?x47008 (+ 8 (- 24) ?x47007))) (rewrite (= (+ 8 (- 24) ?x47007) (+ (- 16) ?x47007))) (= ?x47008 (+ (- 16) ?x47007)))))
 (let ((@x47029 (trans (monotonicity @x47021 (= $x47009 (= (+ (- 16) ?x47007) 0))) (rewrite (= (= (+ (- 16) ?x47007) 0) $x47025)) (= $x47009 $x47025))))
 (let ((@x47038 (mp ((_ quant-inst 24 8) $x47031) (trans (monotonicity @x47029 $x47033) (rewrite (= $x47030 $x47030)) $x47033) $x47030)))
 (let ((@x48237 (unit-resolution @x47038 @x9204 $x47025)))
 (let (($x7306 (= pmemlog!logimpl_v.header_log_size_offset.? 24)))
 (let (($x7303 (fuel_bool fuel%pmemlog!logimpl_v.header_log_size_offset.)))
 (let (($x7301 (fuel_bool_default fuel%pmemlog!logimpl_v.header_log_size_offset.)))
 (let (($x46794 (= $x7303 $x7301)))
 (let ((@x46824 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_log_size_offset.) (or (not $x30) $x46794)) @x45572 (hypothesis (not $x46794)) false)))
 (let ((@x46837 (lemma @x46824 $x46794)))
 (let ((@x7302 (asserted $x7301)))
 (let ((@x46815 (def-axiom (or (not $x46794) $x7303 (not $x7301)))))
 (let ((@x48242 (unit-resolution (unit-resolution @x46815 @x7302 (or (not $x46794) $x7303)) @x46837 $x7303)))
 (let (($x7309 (not $x7303)))
 (let (($x7310 (or $x7309 $x7306)))
 (let ((@x7313 (mp (asserted (=> $x7303 $x7306)) (rewrite (= (=> $x7303 $x7306) $x7310)) $x7310)))
 (let ((@x48245 (monotonicity (unit-resolution @x7313 @x48242 $x7306) (= ?x7368 ?x47007))))
 (let ((@x48366 (trans* @x48245 @x48237 $x47070)))
 (let ((@x48367 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47070) $x47071)) @x48366 $x47071)))
 (let (($x47072 (>= ?x7368 16)))
 (let ((@x48370 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47070) $x47072)) @x48366 $x47072)))
 (let ((@x48372 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x48370 @x48367 @x48362 @x48359 (= ?x7370 24))))
 (let ((?x44071 (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1)))
 (let ((?x47649 (vstd!seq.Seq.len.? $ ?x1876 ?x44071)))
 (let ((?x44011 (Poly%alloc!vec.Vec<u8./allocator_global%.>. tail_bytes@0)))
 (let ((?x44012 (vstd!view.View.view.? $ ?x1878 ?x44011)))
 (let ((?x44034 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@1)))
 (let ((?x44834 (vstd!view.View.view.? $ ?x1878 ?x44034)))
 (let ((?x44851 (vstd!seq.Seq.add.? $ ?x1876 ?x44834 ?x44012)))
 (let ((?x46079 (vstd!seq.Seq.len.? $ ?x1876 ?x44851)))
 (let ((?x48537 (Add ?x46079 ?x47649)))
 (let ((?x44025 (Poly%alloc!vec.Vec<u8./allocator_global%.>. log_size_bytes@0)))
 (let ((?x44026 (vstd!view.View.view.? $ ?x1878 ?x44025)))
 (let ((?x44753 (vstd!seq.Seq.len.? $ ?x1876 ?x44026)))
 (let (($x44754 (= ?x44753 8)))
 (let (($x44773 (not $x44754)))
 (let ((?x43973 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. metadata!)))
 (let ((?x43991 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43973)))
 (let ((?x44020 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x43991)))
 (let ((?x44749 (I ?x44020)))
 (let ((?x44751 (vstd!bytes.spec_u64_to_le_bytes.? ?x44749)))
 (let ((?x44027 (%Poly%vstd!seq.Seq<u8.>. ?x44026)))
 (let (($x44750 (= ?x44027 ?x44751)))
 (let (($x44752 (not $x44750)))
 (let (($x44774 (or $x44752 $x44773)))
 (let (($x44792 (not $x44774)))
 (let (($x44775 (ens%vstd!bytes.u64_to_le_bytes. ?x44020 log_size_bytes@0)))
 (let (($x44776 (= $x44774 $x44775)))
 (let (($x44777 (not $x44776)))
 (let (($x14941 (forall ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(! (let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x14925 (or (not $x6204) (not $x6206))))
 (not (= $x14925 $x6199)))))))))))))) :pattern ( (ens%vstd!bytes.u64_to_le_bytes. x! s!) ) :qid internal_ens__vstd!bytes.u64_to_le_bytes._definition))
 ))
 (let (($x6210 (forall ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x6207 (and $x6204 $x6206)))
 (let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (= $x6199 $x6207))))))))))))) :pattern ( (ens%vstd!bytes.u64_to_le_bytes. x! s!) ) :qid internal_ens__vstd!bytes.u64_to_le_bytes._definition))
 ))
 (let ((?x14942 (lambda ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x14925 (or (not $x6204) (not $x6206))))
 (let (($x14933 (not (= $x14925 $x6199))))
 (let (($x6207 (and $x6204 $x6206)))
 (let (($x6208 (= $x6199 $x6207)))
 (let (($x14936 (= $x6208 $x14933)))
 (let ((@x14931 (monotonicity (rewrite (= $x6207 (not $x14925))) (= $x6208 (= $x6199 (not $x14925))))))
 (trans (trans @x14931 (rewrite (= (= $x6199 (not $x14925)) $x14933)) $x14936) (rewrite (= $x14933 $x14933)) $x14936)))))))))))))))))))
 ))
 (let ((?x11677 (lambda ((x! Int) (s! alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x6200 (vstd!view.View.view.? $ ?x1878 ?x1870)))
 (let ((?x6205 (vstd!seq.Seq.len.? $ ?x1876 ?x6200)))
 (let (($x6206 (= ?x6205 8)))
 (let ((?x6202 (I x!)))
 (let ((?x6203 (vstd!bytes.spec_u64_to_le_bytes.? ?x6202)))
 (let ((?x6201 (%Poly%vstd!seq.Seq<u8.>. ?x6200)))
 (let (($x6204 (= ?x6201 ?x6203)))
 (let (($x6207 (and $x6204 $x6206)))
 (let (($x6199 (ens%vstd!bytes.u64_to_le_bytes. x! s!)))
 (let (($x6208 (= $x6199 $x6207)))
 (refl (~ $x6208 $x6208))))))))))))))))
 ))
 (let ((@x14946 (mp (mp~ (asserted $x6210) (nnf-pos (proof-bind ?x11677) (~ $x6210 $x6210)) $x6210) (quant-intro (proof-bind ?x14942) (= $x6210 $x14941)) $x14941)))
 (let (($x44723 (not $x14941)))
 (let (($x44786 (or $x44723 $x44777)))
 (let ((@x44787 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x43991) log_size_bytes@0) $x44786)))
 (let (($x44021 (= tmp%4 ?x44020)))
 (let (($x44149 (not %%location_label%%5)))
 (let (($x44150 (or $x44149 $x44087)))
 (let ((?x44082 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x44081)))
 (let (($x44083 (= metadata! ?x44082)))
 (let (($x44145 (not %%location_label%%4)))
 (let (($x44146 (or $x44145 $x44083)))
 (let (($x44078 (= out! bytes@3)))
 (let (($x44148 (not $x44078)))
 (let (($x44164 (not tmp%8)))
 (let (($x44141 (not %%location_label%%3)))
 (let (($x44142 (or $x44141 tmp%8)))
 (let ((?x7371 (I ?x7370)))
 (let ((?x7369 (I ?x7368)))
 (let ((?x44044 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)))
 (let ((?x44057 (vstd!view.View.view.? $ ?x1878 ?x44044)))
 (let ((?x44072 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7369 ?x7371)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x44073 (ext_eq false ?x1968 ?x44071 ?x44072)))
 (let (($x44074 (= tmp%8 $x44073)))
 (let (($x44152 (not $x44074)))
 (let (($x44163 (not tmp%7)))
 (let (($x44137 (not %%location_label%%2)))
 (let (($x44138 (or $x44137 tmp%7)))
 (let ((?x7362 (Sub pmemlog!logimpl_v.header_tail_offset.? 8)))
 (let ((?x7364 (Add ?x7362 8)))
 (let ((?x7365 (I ?x7364)))
 (let ((?x7363 (I ?x7362)))
 (let ((?x44065 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7363 ?x7365)))
 (let ((?x44064 (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1)))
 (let (($x44066 (ext_eq false ?x1968 ?x44064 ?x44065)))
 (let (($x44067 (= tmp%7 $x44066)))
 (let (($x44156 (not $x44067)))
 (let (($x44162 (not tmp%6)))
 (let (($x44167 (or $x44162 $x44156 (and $x44138 (or $x44163 $x44152 (and $x44142 (or $x44164 $x44148 (and $x44146 $x44150))))))))
 (let (($x44133 (not %%location_label%%1)))
 (let (($x44134 (or $x44133 tmp%6)))
 (let ((?x7356 (Sub pmemlog!logimpl_v.header_head_offset.? 8)))
 (let ((?x7358 (Add ?x7356 8)))
 (let ((?x7359 (I ?x7358)))
 (let ((?x7357 (I ?x7356)))
 (let ((?x44058 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7357 ?x7359)))
 (let ((?x44056 (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1)))
 (let (($x44059 (ext_eq false ?x1968 ?x44056 ?x44058)))
 (let (($x44060 (= tmp%6 $x44059)))
 (let (($x44173 (not $x44060)))
 (let (($x44161 (not tmp%5)))
 (let (($x44168 (or $x44161 $x44173 (and $x44134 $x44167))))
 (let (($x44129 (not %%location_label%%0)))
 (let (($x44130 (or $x44129 tmp%5)))
 (let (($x44136 (and $x44130 $x44168)))
 (let ((?x7133 (vstd!seq.Seq.empty.? $ ?x1876)))
 (let ((?x44050 (Poly%vstd!seq.Seq<u8.>. old_bytes@1)))
 (let (($x44051 (ext_eq false ?x1968 ?x44050 ?x7133)))
 (let (($x44052 (= tmp%5 $x44051)))
 (let (($x44175 (not $x44052)))
 (let (($x44048 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. 0)))
 (let (($x44160 (not $x44048)))
 (let ((?x44046 (Poly%alloc!vec.Vec<u8./allocator_global%.>. log_size_bytes@1)))
 (let ((?x44039 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@2)))
 (let (($x44047 (ens%alloc!vec.impl&%1.append. $ ?x1876 $ ALLOCATOR_GLOBAL ?x44039 ?x44044 ?x44025 ?x44046)))
 (let (($x44181 (not $x44047)))
 (let ((?x44041 (Poly%alloc!vec.Vec<u8./allocator_global%.>. tail_bytes@1)))
 (let (($x44042 (ens%alloc!vec.impl&%1.append. $ ?x1876 $ ALLOCATOR_GLOBAL ?x44034 ?x44039 ?x44011 ?x44041)))
 (let (($x44190 (not $x44042)))
 (let ((?x44036 (Poly%alloc!vec.Vec<u8./allocator_global%.>. head_bytes@1)))
 (let ((?x43997 (Poly%alloc!vec.Vec<u8./allocator_global%.>. head_bytes@0)))
 (let ((?x43982 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@0)))
 (let (($x44037 (ens%alloc!vec.impl&%1.append. $ ?x1876 $ ALLOCATOR_GLOBAL ?x43982 ?x44034 ?x43997 ?x44036)))
 (let (($x44199 (not $x44037)))
 (let ((?x44006 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x43991)))
 (let (($x44007 (= tmp%3 ?x44006)))
 (let ((?x43998 (vstd!view.View.view.? $ ?x1878 ?x43997)))
 (let ((?x43999 (%Poly%vstd!seq.Seq<u8.>. ?x43998)))
 (let (($x44000 (= verus_tmp$1@1 ?x43999)))
 (let ((?x43992 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x43991)))
 (let (($x43993 (= tmp%2 ?x43992)))
 (let ((?x43983 (vstd!view.View.view.? $ ?x1878 ?x43982)))
 (let ((?x43984 (%Poly%vstd!seq.Seq<u8.>. ?x43983)))
 (let (($x43985 (= verus_tmp@1 ?x43984)))
 (let (($x43977 (ens%alloc!vec.impl&%0.new. $ ?x1876 tmp%1)))
 (let (($x44379 (not $x43977)))
 (let (($x44380 (or $x44379 (not (= bytes@0 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. tmp%1))) (not $x43985) (not (= verus_tmp_old_bytes@ verus_tmp@1)) (not (= old_bytes@1 verus_tmp_old_bytes@)) (not $x43993) (not (ens%vstd!bytes.u64_to_le_bytes. tmp%2 head_bytes@0)) (not $x44000) (not (= verus_tmp_old_head_bytes@ verus_tmp$1@1)) (not (= old_head_bytes@1 verus_tmp_old_head_bytes@)) (not $x44007) (not (ens%vstd!bytes.u64_to_le_bytes. tmp%3 tail_bytes@0)) (not (= verus_tmp$2@1 (%Poly%vstd!seq.Seq<u8.>. ?x44012))) (not (= verus_tmp_old_tail_bytes@ verus_tmp$2@1)) (not (= old_tail_bytes@1 verus_tmp_old_tail_bytes@)) (not $x44021) (not (ens%vstd!bytes.u64_to_le_bytes. tmp%4 log_size_bytes@0)) (not (= verus_tmp$3@1 ?x44027)) (not (= verus_tmp_old_log_size_bytes@ verus_tmp$3@1)) (not (= old_log_size_bytes@1 verus_tmp_old_log_size_bytes@)) $x44199 $x44190 $x44181 $x44160 $x44175 $x44136)))
 (let (($x44385 (not $x44380)))
 (let (($x44090 (=> $x44078 (and (=> %%location_label%%4 $x44083) (=> %%location_label%%5 $x44087)))))
 (let (($x44094 (=> (and tmp%7 $x44074) (and (=> %%location_label%%3 tmp%8) (=> (and tmp%8 $x44078) (and (=> %%location_label%%4 $x44083) (=> %%location_label%%5 $x44087)))))))
 (let (($x44098 (and (=> %%location_label%%1 tmp%6) (=> (and tmp%6 $x44067) (and (=> %%location_label%%2 tmp%7) $x44094)))))
 (let (($x44102 (=> $x44052 (and (=> %%location_label%%0 tmp%5) (=> (and tmp%5 $x44060) $x44098)))))
 (let (($x44032 (= old_log_size_bytes@1 verus_tmp_old_log_size_bytes@)))
 (let (($x44030 (= verus_tmp_old_log_size_bytes@ verus_tmp$3@1)))
 (let (($x44028 (= verus_tmp$3@1 ?x44027)))
 (let (($x44109 (=> (and $x44028 $x44030 $x44032 $x44037 $x44042 $x44047 $x44048 $x44052) (and (=> %%location_label%%0 tmp%5) (=> (and tmp%5 $x44060) $x44098)))))
 (let (($x44023 (ens%vstd!bytes.u64_to_le_bytes. tmp%4 log_size_bytes@0)))
 (let (($x44018 (= old_tail_bytes@1 verus_tmp_old_tail_bytes@)))
 (let (($x44016 (= verus_tmp_old_tail_bytes@ verus_tmp$2@1)))
 (let ((?x44013 (%Poly%vstd!seq.Seq<u8.>. ?x44012)))
 (let (($x44014 (= verus_tmp$2@1 ?x44013)))
 (let (($x44009 (ens%vstd!bytes.u64_to_le_bytes. tmp%3 tail_bytes@0)))
 (let (($x44116 (=> (and $x44007 $x44009 $x44014 $x44016 $x44018 $x44021 $x44023 $x44028 $x44030 $x44032 $x44037 $x44042 $x44047 $x44048 $x44052) (and (=> %%location_label%%0 tmp%5) (=> (and tmp%5 $x44060) $x44098)))))
 (let (($x44004 (= old_head_bytes@1 verus_tmp_old_head_bytes@)))
 (let (($x44002 (= verus_tmp_old_head_bytes@ verus_tmp$1@1)))
 (let (($x43995 (ens%vstd!bytes.u64_to_le_bytes. tmp%2 head_bytes@0)))
 (let (($x43989 (= old_bytes@1 verus_tmp_old_bytes@)))
 (let (($x43987 (= verus_tmp_old_bytes@ verus_tmp@1)))
 (let (($x44123 (=> (and $x43987 $x43989 $x43993 $x43995 $x44000 $x44002 $x44004 $x44007 $x44009 $x44014 $x44016 $x44018 $x44021 $x44023 $x44028 $x44030 $x44032 $x44037 $x44042 $x44047 $x44048 $x44052) (and (=> %%location_label%%0 tmp%5) (=> (and tmp%5 $x44060) $x44098)))))
 (let ((?x43979 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. tmp%1)))
 (let (($x43980 (= bytes@0 ?x43979)))
 (let (($x44127 (not (=> (and $x43977 $x43980 $x43985 $x43987 $x43989 $x43993 $x43995 $x44000 $x44002 $x44004 $x44007 $x44009 $x44014 $x44016 $x44018 $x44021 $x44023 $x44028 $x44030 $x44032 $x44037 $x44042 $x44047 $x44048 $x44052) (and (=> %%location_label%%0 tmp%5) (=> (and tmp%5 $x44060) $x44098))))))
 (let ((@x44176 (mp (asserted $x44127) (rewrite (= $x44127 $x44385)) $x44385)))
 (let ((@x44135 (not-or-elim @x44176 $x44021)))
 (let ((@x44489 (symm @x44135 (= ?x44020 tmp%4))))
 (let ((@x44131 (not-or-elim @x44176 $x44023)))
 (let ((@x48608 (mp @x44131 (symm (monotonicity @x44489 (= $x44775 $x44023)) (= $x44023 $x44775)) $x44775)))
 (let ((@x44803 (def-axiom (or $x44776 $x44792 (not $x44775)))))
 (let ((@x48610 (unit-resolution @x44803 @x48608 (unit-resolution @x44787 @x14946 $x44777) $x44792)))
 (let ((@x44791 (def-axiom (or $x44774 $x44754))))
 (let ((@x48611 (unit-resolution @x44791 @x48610 $x44754)))
 (let ((?x47650 (Poly%vstd!seq.Seq<u8.>. ?x44027)))
 (let (($x47651 (= ?x44026 ?x47650)))
 (let (($x45314 (has_type ?x44026 ?x1968)))
 (let ((?x44591 (proj%vstd!view.View./V $ ?x1878)))
 (let (($x45319 (= ?x44591 ?x1968)))
 (let (($x3993 (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. T&. T&)))
 (let ((?x3983 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let ((?x3989 (proj%vstd!view.View./V $ ?x3983)))
 (= ?x3989 ?x3990)))) :pattern ( (proj%vstd!view.View./V $ (TYPE%alloc!vec.Vec. T&. T& A&. A&)) ) :qid internal_proj__vstd!view.View./V_assoc_type_impl_false_definition))
 ))
 (let ((?x10630 (lambda ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) )(let ((?x3990 (TYPE%vstd!seq.Seq. T&. T&)))
 (let ((?x3983 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let ((?x3989 (proj%vstd!view.View./V $ ?x3983)))
 (let (($x3991 (= ?x3989 ?x3990)))
 (refl (~ $x3991 $x3991)))))))
 ))
 (let ((@x10634 (mp~ (asserted $x3993) (nnf-pos (proof-bind ?x10630) (~ $x3993 $x3993)) $x3993)))
 (let (($x45329 (or (not $x3993) $x45319)))
 (let ((@x45330 ((_ quant-inst $ (UINT 8) $ ALLOCATOR_GLOBAL) $x45329)))
 (let ((@x48618 (unit-resolution @x45330 @x10634 $x45319)))
 (let (($x44623 (has_type ?x44026 ?x44591)))
 (let (($x44615 (has_type ?x44025 ?x1878)))
 (let ((?x44653 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44025)))
 (let ((?x47646 (Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44653)))
 (let (($x47647 (has_type ?x47646 ?x1878)))
 (let (($x47672 (not $x47647)))
 (let (($x44654 (= log_size_bytes@0 ?x44653)))
 (let (($x1874 (forall ((x alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (= x (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x1870))) :pattern ( (Poly%alloc!vec.Vec<u8./allocator_global%.>. x) ) :qid internal_alloc__vec__Vec<u8./allocator_global__.>_box_axiom_definition))
 ))
 (let ((?x9482 (lambda ((x alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (let (($x1872 (= x (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x1870))))
 (refl (~ $x1872 $x1872)))))
 ))
 (let ((@x9486 (mp~ (asserted $x1874) (nnf-pos (proof-bind ?x9482) (~ $x1874 $x1874)) $x1874)))
 (let (($x44646 (not $x1874)))
 (let (($x44659 (or $x44646 $x44654)))
 (let ((@x44660 ((_ quant-inst log_size_bytes@0) $x44659)))
 (let ((@x47667 (monotonicity (symm (unit-resolution @x44660 @x9486 $x44654) (= ?x44653 log_size_bytes@0)) (= ?x47646 ?x44025))))
 (let ((@x47674 (monotonicity (symm (monotonicity @x47667 (= $x47647 $x44615)) (= $x44615 $x47647)) (= (not $x44615) $x47672))))
 (let (($x1899 (forall ((x alloc!vec.Vec<u8./allocator_global%.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (has_type ?x1870 ?x1878)))) :pattern ( (has_type (Poly%alloc!vec.Vec<u8./allocator_global%.>. x) (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL)) ) :qid internal_alloc__vec__Vec<u8./allocator_global__.>_has_type_always_definition))
 ))
 (let ((?x9496 (lambda ((x alloc!vec.Vec<u8./allocator_global%.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x1870 (Poly%alloc!vec.Vec<u8./allocator_global%.>. x)))
 (let (($x1897 (has_type ?x1870 ?x1878)))
 (refl (~ $x1897 $x1897)))))))
 ))
 (let ((@x9500 (mp~ (asserted $x1899) (nnf-pos (proof-bind ?x9496) (~ $x1899 $x1899)) $x1899)))
 (let ((@x47677 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44025)) (or (not $x1899) $x47647)) @x9500 $x47647) (mp (hypothesis (not $x44615)) @x47674 $x47672) false)))
 (let ((@x47678 (lemma @x47677 $x44615)))
 (let (($x44616 (not $x44615)))
 (let (($x44624 (or $x44616 $x44623)))
 (let (($x5331 (forall ((Self%&. Dcr) (Self%& Type) (self! Poly) )(! (let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (or $x2120 $x5323))))) :pattern ( (vstd!view.View.view.? Self%&. Self%& self!) ) :qid internal_vstd!view.View.view.?_pre_post_definition))
 ))
 (let ((?x11204 (lambda ((Self%&. Dcr) (Self%& Type) (self! Poly) )(let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (let (($x5328 (or $x2120 $x5323)))
 (refl (~ $x5328 $x5328))))))))
 ))
 (let (($x5326 (forall ((Self%&. Dcr) (Self%& Type) (self! Poly) )(! (let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (=> $x92 $x5323)))) :pattern ( (vstd!view.View.view.? Self%&. Self%& self!) ) :qid internal_vstd!view.View.view.?_pre_post_definition))
 ))
 (let ((?x5332 (lambda ((Self%&. Dcr) (Self%& Type) (self! Poly) )(let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (let (($x5328 (or $x2120 $x5323)))
 (let (($x5324 (=> $x92 $x5323)))
 (rewrite (= $x5324 $x5328)))))))))
 ))
 (let ((@x5336 (mp (asserted $x5326) (quant-intro (proof-bind ?x5332) (= $x5326 $x5331)) $x5331)))
 (let ((@x11208 (mp~ @x5336 (nnf-pos (proof-bind ?x11204) (~ $x5331 $x5331)) $x5331)))
 (let (($x44596 (not $x5331)))
 (let (($x44627 (or $x44596 $x44616 $x44623)))
 (let ((@x44632 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. log_size_bytes@0)) (or $x44596 $x44624)) (rewrite (= (or $x44596 $x44624) $x44627)) $x44627)))
 (let ((@x48621 (mp (unit-resolution (unit-resolution @x44632 @x11208 $x44624) @x47678 $x44623) (monotonicity @x48618 (= $x44623 $x45314)) $x45314)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x9552 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x9556 (mp~ @x1986 (nnf-pos (proof-bind ?x9552) (~ $x1981 $x1981)) $x1981)))
 (let (($x45315 (not $x45314)))
 (let (($x45241 (not $x1981)))
 (let (($x47655 (or $x45241 $x45315 $x47651)))
 (let ((@x47648 (mp ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x44025)) (or $x45241 (or $x45315 $x47651))) (rewrite (= (or $x45241 (or $x45315 $x47651)) $x47655)) $x47655)))
 (let ((@x48635 (symm (unit-resolution @x47648 @x9556 @x48621 $x47651) (= ?x47650 ?x44026))))
 (let ((@x44180 (not-or-elim @x44176 $x44032)))
 (let ((@x48613 (symm @x44180 (= verus_tmp_old_log_size_bytes@ old_log_size_bytes@1))))
 (let ((@x44178 (not-or-elim @x44176 $x44030)))
 (let ((@x44495 (symm @x44178 (= verus_tmp$3@1 verus_tmp_old_log_size_bytes@))))
 (let ((@x44132 (not-or-elim @x44176 $x44028)))
 (let ((@x44493 (symm @x44132 (= ?x44027 verus_tmp$3@1))))
 (let ((@x48631 (monotonicity (trans* @x44493 @x44495 @x48613 (= ?x44027 old_log_size_bytes@1)) (= ?x47650 ?x44071))))
 (let ((@x48633 (symm @x48631 (= ?x44071 ?x47650))))
 (let ((@x48625 (symm (unit-resolution (def-axiom (or $x44774 $x44750)) @x48610 $x44750) (= ?x44751 ?x44027))))
 (let ((@x48629 (monotonicity (trans* @x48625 @x44493 @x44495 @x48613 (= ?x44751 old_log_size_bytes@1)) (= (Poly%vstd!seq.Seq<u8.>. ?x44751) ?x44071))))
 (let ((@x48643 (monotonicity (trans* @x48629 @x48633 @x48635 (= (Poly%vstd!seq.Seq<u8.>. ?x44751) ?x44026)) (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44751)) ?x44753))))
 (let ((@x48639 (symm @x48629 (= ?x44071 (Poly%vstd!seq.Seq<u8.>. ?x44751)))))
 (let ((@x48641 (monotonicity @x48639 (= ?x47649 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44751))))))
 (let ((@x48249 (symm @x48245 (= ?x47007 ?x7368))))
 (let ((@x48247 (symm @x48237 (= 16 ?x47007))))
 (let ((?x48175 (nClip 16)))
 (let (($x48198 (= ?x48175 16)))
 (let (($x48439 (not $x48198)))
 (let (($x48182 (>= ?x48175 0)))
 (let (($x48183 (not $x48182)))
 (let (($x48455 (or $x48183 $x48439)))
 (let (($x48447 (not $x48455)))
 (let (($x10999 (forall ((i Int) )(! (let (($x10993 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (not $x10993)) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let (($x534 (forall ((i Int) )(! (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (and $x533 $x541))))))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x12794 (lambda ((i Int) )(let (($x10993 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (let (($x10970 (not $x10993)))
 (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (rewrite (= $x546 $x10970))))))))))))
 ))
 (let ((?x9046 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (refl (~ $x546 $x546))))))))))
 ))
 (let (($x529 (forall ((i Int) )(! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x535 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (let (($x527 (and (<= 0 ?x522) (=> (<= 0 i) $x525))))
 (rewrite (= $x527 $x546)))))))))))
 ))
 (let ((@x542 (mp (asserted $x529) (quant-intro (proof-bind ?x535) (= $x529 $x534)) $x534)))
 (let ((@x12798 (mp (mp~ @x542 (nnf-pos (proof-bind ?x9046) (~ $x534 $x534)) $x534) (quant-intro (proof-bind ?x12794) (= $x534 $x10999)) $x10999)))
 (let (($x48124 (not $x10999)))
 (let (($x48465 (or $x48124 $x48447)))
 (let (($x48190 (not (or $x48183 (not (or (not (>= 16 0)) (= 16 ?x48175)))))))
 (let (($x48466 (or $x48124 $x48190)))
 (let (($x48449 (= $x48466 $x48465)))
 (let ((@x48452 (trans (monotonicity (rewrite (= $x48190 $x48447)) $x48449) (rewrite (= $x48465 $x48465)) $x48449)))
 (let ((@x48454 (mp ((_ quant-inst 16) $x48466) @x48452 $x48465)))
 (let ((@x48480 (def-axiom (or $x48455 $x48198))))
 (let ((@x48647 (unit-resolution @x48480 (unit-resolution @x48454 @x12798 $x48447) $x48198)))
 (let ((?x47603 (vstd!seq.Seq.len.? $ ?x1876 ?x44064)))
 (let ((?x45825 (vstd!seq.Seq.len.? $ ?x1876 ?x44056)))
 (let ((?x48170 (Add ?x45825 ?x47603)))
 (let ((?x48171 (nClip ?x48170)))
 (let ((?x46988 (* (- 1) ?x7364)))
 (let ((?x46991 (+ ?x7362 ?x46988)))
 (let (($x47004 (<= ?x46991 (- 8))))
 (let (($x46992 (= ?x46991 (- 8))))
 (let (($x46995 (or $x45516 $x46992)))
 (let (($x46990 (= (+ 8 ?x7362 ?x46988) 0)))
 (let (($x46996 (or $x45516 $x46990)))
 (let (($x46998 (= $x46996 $x46995)))
 (let ((@x47002 (trans (monotonicity (rewrite (= $x46990 $x46992)) $x46998) (rewrite (= $x46995 $x46995)) $x46998)))
 (let ((@x47003 (mp ((_ quant-inst (Sub pmemlog!logimpl_v.header_tail_offset.? 8) 8) $x46996) @x47002 $x46995)))
 (let ((@x48651 (unit-resolution @x47003 @x9197 $x46992)))
 (let (($x47005 (>= ?x46991 (- 8))))
 (let (($x47074 (<= ?x7362 8)))
 (let (($x47073 (= ?x7362 8)))
 (let ((?x47040 (Sub 16 8)))
 (let (($x47056 (= ?x47040 8)))
 (let (($x47061 (or $x45535 $x47056)))
 (let ((?x47039 (* (- 1) 16)))
 (let ((?x47041 (+ 8 ?x47039 ?x47040)))
 (let (($x47042 (= ?x47041 0)))
 (let (($x47062 (or $x45535 $x47042)))
 (let (($x47064 (= $x47062 $x47061)))
 (let ((@x47052 (trans (monotonicity (rewrite (= ?x47039 (- 16))) (= ?x47041 (+ 8 (- 16) ?x47040))) (rewrite (= (+ 8 (- 16) ?x47040) (+ (- 8) ?x47040))) (= ?x47041 (+ (- 8) ?x47040)))))
 (let ((@x47060 (trans (monotonicity @x47052 (= $x47042 (= (+ (- 8) ?x47040) 0))) (rewrite (= (= (+ (- 8) ?x47040) 0) $x47056)) (= $x47042 $x47056))))
 (let ((@x47069 (mp ((_ quant-inst 16 8) $x47062) (trans (monotonicity @x47060 $x47064) (rewrite (= $x47061 $x47061)) $x47064) $x47061)))
 (let ((@x48659 (unit-resolution @x47069 @x9204 $x47056)))
 (let (($x7291 (= pmemlog!logimpl_v.header_tail_offset.? 16)))
 (let (($x7289 (fuel_bool fuel%pmemlog!logimpl_v.header_tail_offset.)))
 (let (($x7287 (fuel_bool_default fuel%pmemlog!logimpl_v.header_tail_offset.)))
 (let (($x46776 (= $x7289 $x7287)))
 (let ((@x46806 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_tail_offset.) (or (not $x30) $x46776)) @x45572 (hypothesis (not $x46776)) false)))
 (let ((@x46819 (lemma @x46806 $x46776)))
 (let ((@x7288 (asserted $x7287)))
 (let ((@x46797 (def-axiom (or (not $x46776) $x7289 (not $x7287)))))
 (let ((@x48662 (unit-resolution (unit-resolution @x46797 @x7288 (or (not $x46776) $x7289)) @x46819 $x7289)))
 (let (($x7294 (not $x7289)))
 (let (($x7295 (or $x7294 $x7291)))
 (let ((@x7298 (mp (asserted (=> $x7289 $x7291)) (rewrite (= (=> $x7289 $x7291) $x7295)) $x7295)))
 (let ((@x48663 (unit-resolution @x7298 @x48662 $x7291)))
 (let ((@x48665 (monotonicity @x48663 (= ?x7362 ?x47040))))
 (let ((@x48666 (trans* @x48665 @x48659 $x47073)))
 (let (($x47075 (>= ?x7362 8)))
 (let ((@x48670 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47073) $x47075)) @x48666 $x47075)))
 (let ((@x48672 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x48670 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47073) $x47074)) @x48666 $x47074) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46992) $x47005)) @x48651 $x47005) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46992) $x47004)) @x48651 $x47004) (= ?x7364 16))))
 (let ((?x44721 (vstd!seq.Seq.len.? $ ?x1876 ?x44012)))
 (let (($x44722 (= ?x44721 8)))
 (let (($x44742 (not $x44722)))
 (let ((?x44717 (I ?x44006)))
 (let ((?x44719 (vstd!bytes.spec_u64_to_le_bytes.? ?x44717)))
 (let (($x44718 (= ?x44013 ?x44719)))
 (let (($x44720 (not $x44718)))
 (let (($x44743 (or $x44720 $x44742)))
 (let (($x44761 (not $x44743)))
 (let (($x44744 (ens%vstd!bytes.u64_to_le_bytes. ?x44006 tail_bytes@0)))
 (let (($x44745 (= $x44743 $x44744)))
 (let (($x44746 (not $x44745)))
 (let (($x44755 (or $x44723 $x44746)))
 (let ((@x44756 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x43991) tail_bytes@0) $x44755)))
 (let ((@x44158 (not-or-elim @x44176 $x44007)))
 (let ((@x44481 (symm @x44158 (= ?x44006 tmp%3))))
 (let ((@x44159 (not-or-elim @x44176 $x44009)))
 (let ((@x48677 (mp @x44159 (symm (monotonicity @x44481 (= $x44744 $x44009)) (= $x44009 $x44744)) $x44744)))
 (let ((@x44772 (def-axiom (or $x44745 $x44761 (not $x44744)))))
 (let ((@x48679 (unit-resolution @x44772 @x48677 (unit-resolution @x44756 @x14946 $x44746) $x44761)))
 (let ((@x44760 (def-axiom (or $x44743 $x44722))))
 (let ((@x48680 (unit-resolution @x44760 @x48679 $x44722)))
 (let ((?x47604 (Poly%vstd!seq.Seq<u8.>. ?x44013)))
 (let (($x47605 (= ?x44012 ?x47604)))
 (let (($x45294 (has_type ?x44012 ?x1968)))
 (let (($x44613 (has_type ?x44012 ?x44591)))
 (let (($x44605 (has_type ?x44011 ?x1878)))
 (let ((?x44649 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44011)))
 (let ((?x47594 (Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44649)))
 (let (($x47595 (has_type ?x47594 ?x1878)))
 (let (($x47626 (not $x47595)))
 (let (($x44650 (= tail_bytes@0 ?x44649)))
 (let (($x44655 (or $x44646 $x44650)))
 (let ((@x44656 ((_ quant-inst tail_bytes@0) $x44655)))
 (let ((@x47621 (monotonicity (symm (unit-resolution @x44656 @x9486 $x44650) (= ?x44649 tail_bytes@0)) (= ?x47594 ?x44011))))
 (let ((@x47628 (monotonicity (symm (monotonicity @x47621 (= $x47595 $x44605)) (= $x44605 $x47595)) (= (not $x44605) $x47626))))
 (let ((@x47631 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44011)) (or (not $x1899) $x47595)) @x9500 $x47595) (mp (hypothesis (not $x44605)) @x47628 $x47626) false)))
 (let ((@x47632 (lemma @x47631 $x44605)))
 (let (($x44606 (not $x44605)))
 (let (($x44614 (or $x44606 $x44613)))
 (let (($x44617 (or $x44596 $x44606 $x44613)))
 (let ((@x44622 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. tail_bytes@0)) (or $x44596 $x44614)) (rewrite (= (or $x44596 $x44614) $x44617)) $x44617)))
 (let ((@x48689 (mp (unit-resolution (unit-resolution @x44622 @x11208 $x44614) @x47632 $x44613) (monotonicity @x48618 (= $x44613 $x45294)) $x45294)))
 (let (($x45302 (not $x45294)))
 (let (($x47609 (or $x45241 $x45302 $x47605)))
 (let ((@x47602 (mp ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x44011)) (or $x45241 (or $x45302 $x47605))) (rewrite (= (or $x45241 (or $x45302 $x47605)) $x47609)) $x47609)))
 (let ((@x48703 (symm (unit-resolution @x47602 @x9556 @x48689 $x47605) (= ?x47604 ?x44012))))
 (let ((@x44139 (not-or-elim @x44176 $x44018)))
 (let ((@x48682 (symm @x44139 (= verus_tmp_old_tail_bytes@ old_tail_bytes@1))))
 (let ((@x44143 (not-or-elim @x44176 $x44016)))
 (let ((@x44487 (symm @x44143 (= verus_tmp$2@1 verus_tmp_old_tail_bytes@))))
 (let ((@x44169 (not-or-elim @x44176 $x44014)))
 (let ((@x44485 (symm @x44169 (= ?x44013 verus_tmp$2@1))))
 (let ((@x48699 (monotonicity (trans* @x44485 @x44487 @x48682 (= ?x44013 old_tail_bytes@1)) (= ?x47604 ?x44064))))
 (let ((@x48701 (symm @x48699 (= ?x44064 ?x47604))))
 (let ((@x48693 (symm (unit-resolution (def-axiom (or $x44743 $x44718)) @x48679 $x44718) (= ?x44719 ?x44013))))
 (let ((@x48697 (monotonicity (trans* @x48693 @x44485 @x44487 @x48682 (= ?x44719 old_tail_bytes@1)) (= (Poly%vstd!seq.Seq<u8.>. ?x44719) ?x44064))))
 (let ((@x48711 (monotonicity (trans* @x48697 @x48701 @x48703 (= (Poly%vstd!seq.Seq<u8.>. ?x44719) ?x44012)) (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44719)) ?x44721))))
 (let ((@x48707 (symm @x48697 (= ?x44064 (Poly%vstd!seq.Seq<u8.>. ?x44719)))))
 (let ((@x48709 (monotonicity @x48707 (= ?x47603 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44719))))))
 (let ((@x48756 (symm @x48665 (= ?x47040 ?x7362))))
 (let ((@x48754 (symm @x48659 (= 8 ?x47040))))
 (let ((?x44708 (vstd!seq.Seq.len.? $ ?x1876 ?x43998)))
 (let (($x44709 (= ?x44708 8)))
 (let (($x44710 (not $x44709)))
 (let ((?x44704 (I ?x43992)))
 (let ((?x44705 (vstd!bytes.spec_u64_to_le_bytes.? ?x44704)))
 (let (($x44706 (= ?x43999 ?x44705)))
 (let (($x44707 (not $x44706)))
 (let (($x44711 (or $x44707 $x44710)))
 (let (($x44730 (not $x44711)))
 (let (($x44712 (ens%vstd!bytes.u64_to_le_bytes. ?x43992 head_bytes@0)))
 (let (($x44713 (= $x44711 $x44712)))
 (let (($x44714 (not $x44713)))
 (let (($x44724 (or $x44723 $x44714)))
 (let ((@x44725 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x43991) head_bytes@0) $x44724)))
 (let ((@x44154 (not-or-elim @x44176 $x43993)))
 (let ((@x44473 (symm @x44154 (= ?x43992 tmp%2))))
 (let ((@x44151 (not-or-elim @x44176 $x43995)))
 (let ((@x48718 (mp @x44151 (symm (monotonicity @x44473 (= $x44712 $x43995)) (= $x43995 $x44712)) $x44712)))
 (let ((@x44741 (def-axiom (or $x44713 $x44730 (not $x44712)))))
 (let ((@x48720 (unit-resolution @x44741 @x48718 (unit-resolution @x44725 @x14946 $x44714) $x44730)))
 (let ((@x44729 (def-axiom (or $x44711 $x44709))))
 (let ((@x48721 (unit-resolution @x44729 @x48720 $x44709)))
 (let ((?x45496 (Poly%vstd!seq.Seq<u8.>. ?x43999)))
 (let (($x47561 (= ?x43998 ?x45496)))
 (let (($x45289 (has_type ?x43998 ?x1968)))
 (let (($x44603 (has_type ?x43998 ?x44591)))
 (let (($x44594 (has_type ?x43997 ?x1878)))
 (let ((?x44644 (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x43997)))
 (let ((?x47555 (Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x44644)))
 (let (($x47528 (has_type ?x47555 ?x1878)))
 (let (($x47585 (not $x47528)))
 (let (($x44645 (= head_bytes@0 ?x44644)))
 (let (($x44651 (or $x44646 $x44645)))
 (let ((@x44652 ((_ quant-inst head_bytes@0) $x44651)))
 (let ((@x47580 (monotonicity (symm (unit-resolution @x44652 @x9486 $x44645) (= ?x44644 head_bytes@0)) (= ?x47555 ?x43997))))
 (let ((@x47587 (monotonicity (symm (monotonicity @x47580 (= $x47528 $x44594)) (= $x44594 $x47528)) (= (not $x44594) $x47585))))
 (let ((@x47590 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x43997)) (or (not $x1899) $x47528)) @x9500 $x47528) (mp (hypothesis (not $x44594)) @x47587 $x47585) false)))
 (let ((@x47591 (lemma @x47590 $x44594)))
 (let (($x44595 (not $x44594)))
 (let (($x44604 (or $x44595 $x44603)))
 (let (($x44607 (or $x44596 $x44595 $x44603)))
 (let ((@x44612 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. head_bytes@0)) (or $x44596 $x44604)) (rewrite (= (or $x44596 $x44604) $x44607)) $x44607)))
 (let ((@x48730 (mp (unit-resolution (unit-resolution @x44612 @x11208 $x44604) @x47591 $x44603) (monotonicity @x48618 (= $x44603 $x45289)) $x45289)))
 (let (($x45290 (not $x45289)))
 (let (($x47565 (or $x45241 $x45290 $x47561)))
 (let ((@x47571 (mp ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x43997)) (or $x45241 (or $x45290 $x47561))) (rewrite (= (or $x45241 (or $x45290 $x47561)) $x47565)) $x47565)))
 (let ((@x48744 (symm (unit-resolution @x47571 @x9556 @x48730 $x47561) (= ?x45496 ?x43998))))
 (let ((@x44157 (not-or-elim @x44176 $x44004)))
 (let ((@x48723 (symm @x44157 (= verus_tmp_old_head_bytes@ old_head_bytes@1))))
 (let ((@x44155 (not-or-elim @x44176 $x44002)))
 (let ((@x44479 (symm @x44155 (= verus_tmp$1@1 verus_tmp_old_head_bytes@))))
 (let ((@x44147 (not-or-elim @x44176 $x44000)))
 (let ((@x44477 (symm @x44147 (= ?x43999 verus_tmp$1@1))))
 (let ((@x48740 (monotonicity (trans* @x44477 @x44479 @x48723 (= ?x43999 old_head_bytes@1)) (= ?x45496 ?x44056))))
 (let ((@x48742 (symm @x48740 (= ?x44056 ?x45496))))
 (let ((@x48734 (symm (unit-resolution (def-axiom (or $x44711 $x44706)) @x48720 $x44706) (= ?x44705 ?x43999))))
 (let ((@x48738 (monotonicity (trans* @x48734 @x44477 @x44479 @x48723 (= ?x44705 old_head_bytes@1)) (= (Poly%vstd!seq.Seq<u8.>. ?x44705) ?x44056))))
 (let ((@x48752 (monotonicity (trans* @x48738 @x48742 @x48744 (= (Poly%vstd!seq.Seq<u8.>. ?x44705) ?x43998)) (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44705)) ?x44708))))
 (let ((@x48748 (symm @x48738 (= ?x44056 (Poly%vstd!seq.Seq<u8.>. ?x44705)))))
 (let ((@x48750 (monotonicity @x48748 (= ?x45825 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44705))))))
 (let ((@x48760 (monotonicity (trans* @x48750 @x48752 @x48721 @x48754 @x48756 (= ?x45825 ?x7362)) (trans* @x48709 @x48711 @x48680 (= ?x47603 8)) (= ?x48170 ?x7364))))
 (let ((@x48837 (monotonicity (trans* @x48760 @x48672 (= ?x48170 16)) (= ?x48171 ?x48175))))
 (let ((?x48162 (vstd!seq.Seq.add.? $ ?x1876 ?x44056 ?x44064)))
 (let ((?x48163 (vstd!seq.Seq.len.? $ ?x1876 ?x48162)))
 (let (($x48172 (= ?x48163 ?x48171)))
 (let (($x47607 (has_type ?x44064 ?x1968)))
 (let ((@x48780 (symm (monotonicity (trans* @x48701 @x48703 (= ?x44064 ?x44012)) (= $x47607 $x45294)) (= $x45294 $x47607))))
 (let ((@x48781 (mp @x48689 @x48780 $x47607)))
 (let (($x45858 (has_type ?x44056 ?x1968)))
 (let ((@x48773 (symm (monotonicity (trans* @x48742 @x48744 (= ?x44056 ?x43998)) (= $x45858 $x45289)) (= $x45289 $x45858))))
 (let ((@x48774 (mp @x48730 @x48773 $x45858)))
 (let (($x14298 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14104 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x13851 (not $x4101)))
 (or $x13851 $x14104 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4955 (fuel_bool fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x45986 (= $x4955 $x1592)))
 (let ((@x45988 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_len.) (or (not $x30) $x45986)) @x45572 (hypothesis (not $x45986)) false)))
 (let ((@x46000 (lemma @x45988 $x45986)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x13290 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x13289 (not $x1593)))
 (let (($x13288 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x13287 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x13286 (not $x1590)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x13285 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x13284 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x13283 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x13282 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x13281 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x13280 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x13279 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x13278 (not $x1582)))
 (let (($x13291 (or $x13278 $x13279 $x13280 $x13281 $x13282 $x13283 $x13284 $x13285 $x13286 $x13287 $x13288 $x13289 $x13290)))
 (let (($x13292 (not $x13291)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x13355 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x13354 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x13353 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x13352 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x13351 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x13350 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x13349 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x13348 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x13347 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x13346 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x13345 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x13344 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x13343 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x13342 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x13341 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x13356 (or $x1598 $x1610 $x13341 $x1621 $x13342 $x13343 $x13344 $x1565 $x13345 $x1633 $x13346 $x13347 $x1576 $x13348 $x13349 $x13350 $x13351 $x13352 $x13353 $x1644 $x13354 $x13355)))
 (let (($x13357 (not $x13356)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x13360 (or $x1669 $x13357)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x13362 (mp @x1673 (rewrite (= $x1670 $x13360)) $x13360)))
 (let ((@x48071 (unit-resolution @x13362 @x1650 $x13357)))
 (let ((@x42159 (def-axiom (or $x13356 $x1581))))
 (let (($x13295 (or $x1598 $x13292)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x13297 (mp @x1602 (rewrite (= $x1599 $x13295)) $x13295)))
 (let ((@x48086 (unit-resolution @x13297 (unit-resolution @x42159 @x48071 $x1581) $x13292)))
 (let ((@x42123 (def-axiom (or $x13291 $x1592))))
 (let ((@x45993 (def-axiom (or (not $x45986) $x4955 $x13288))))
 (let ((@x48765 (unit-resolution @x45993 (unit-resolution @x42123 @x48086 $x1592) (or (not $x45986) $x4955))))
 (let (($x4985 (not $x4955)))
 (let (($x14303 (or $x4985 $x14298)))
 (let (($x4977 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4986 (or $x4985 $x4977)))
 (let ((?x11048 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (refl (~ $x4972 $x4972))))))))))))))))
 ))
 (let ((@x11053 (monotonicity (refl (~ $x4985 $x4985)) (nnf-pos (proof-bind ?x11048) (~ $x4977 $x4977)) (~ $x4986 $x4986))))
 (let (($x4963 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4959)))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4964 (=> $x4955 $x4963)))
 (let ((?x4978 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let (($x4961 (=> (and $x4526 $x3858) $x4959)))
 (let ((@x4971 (monotonicity (rewrite (= $x4960 (or $x4431 $x4959))) (= $x4961 (=> $x4526 (or $x4431 $x4959))))))
 (trans @x4971 (rewrite (= (=> $x4526 (or $x4431 $x4959)) $x4972)) (= $x4961 $x4972)))))))))))))))))))
 ))
 (let ((@x4984 (monotonicity (quant-intro (proof-bind ?x4978) (= $x4963 $x4977)) (= $x4964 (=> $x4955 $x4977)))))
 (let ((@x4991 (mp (asserted $x4964) (trans @x4984 (rewrite (= (=> $x4955 $x4977) $x4986)) (= $x4964 $x4986)) $x4986)))
 (let ((@x14305 (mp (mp (mp~ @x4991 @x11053 $x4986) (rewrite (= $x4986 $x4986)) $x4986) (rewrite (= $x4986 $x14303)) $x14303)))
 (let ((@x48767 (unit-resolution @x14305 (unit-resolution @x48765 @x46000 $x4955) $x14298)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x45720 (not $x174)))
 (let (($x47608 (not $x47607)))
 (let (($x45859 (not $x45858)))
 (let (($x48072 (not $x14298)))
 (let (($x48446 (or $x48072 $x45859 $x47608 $x45720 $x48172)))
 (let ((@x48464 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1) (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1)) (or $x48072 (or $x45859 $x47608 $x45720 $x48172))) (rewrite (= (or $x48072 (or $x45859 $x47608 $x45720 $x48172)) $x48446)) $x48446)))
 (let ((@x48782 (unit-resolution @x48464 @x175 @x48767 @x48774 @x48781 $x48172)))
 (let ((@x48776 (trans* @x48701 @x48703 (= ?x44064 ?x44012))))
 (let ((?x44835 (vstd!seq.Seq.add.? $ ?x1876 ?x43983 ?x43998)))
 (let (($x44836 (= ?x44834 ?x44835)))
 (let ((?x44838 (vstd!view.View.view.? $ ?x1878 ?x44036)))
 (let (($x44839 (= ?x44838 ?x7133)))
 (let (($x44840 (not $x44839)))
 (let (($x44837 (not $x44836)))
 (let (($x44832 (has_type ?x44036 ?x1878)))
 (let (($x44833 (not $x44832)))
 (let (($x44830 (has_type ?x44034 ?x1878)))
 (let (($x44831 (not $x44830)))
 (let (($x44841 (or $x44831 $x44833 $x44837 $x44840)))
 (let (($x44863 (not $x44841)))
 (let (($x44842 (= $x44841 $x44037)))
 (let (($x44843 (not $x44842)))
 (let (($x14825 (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(! (let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x14809 (or (not (has_type vec! ?x6064)) (not (has_type other! ?x6064)) (not $x6071) (not $x6074))))
 (not (= $x14809 $x6063)))))))) :pattern ( (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!) ) :qid internal_ens__alloc!vec.impl&__1.append._definition))
 ))
 (let (($x6078 (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(! (let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x6066 (has_type other! ?x6064)))
 (let (($x6065 (has_type vec! ?x6064)))
 (let (($x6075 (and $x6065 $x6066 $x6071 $x6074)))
 (let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (= $x6063 $x6075))))))))) :pattern ( (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!) ) :qid internal_ens__alloc!vec.impl&__1.append._definition))
 ))
 (let ((?x14826 (lambda ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x14809 (or (not (has_type vec! ?x6064)) (not (has_type other! ?x6064)) (not $x6071) (not $x6074))))
 (let (($x14817 (not (= $x14809 $x6063))))
 (let (($x6066 (has_type other! ?x6064)))
 (let (($x6065 (has_type vec! ?x6064)))
 (let (($x6075 (and $x6065 $x6066 $x6071 $x6074)))
 (let (($x6076 (= $x6063 $x6075)))
 (let (($x14820 (= $x6076 $x14817)))
 (let ((@x14815 (monotonicity (rewrite (= $x6075 (not $x14809))) (= $x6076 (= $x6063 (not $x14809))))))
 (trans (trans @x14815 (rewrite (= (= $x6063 (not $x14809)) $x14817)) $x14820) (rewrite (= $x14817 $x14817)) $x14820)))))))))))))))
 ))
 (let ((?x11559 (lambda ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec! Poly) (vec! Poly) (pre%other! Poly) (other! Poly) )(let ((?x6064 (TYPE%alloc!vec.Vec. T&. T& A&. A&)))
 (let (($x6074 (= (vstd!view.View.view.? $ ?x6064 other!) (vstd!seq.Seq.empty.? T&. T&))))
 (let ((?x6070 (vstd!seq.Seq.add.? T&. T& (vstd!view.View.view.? $ ?x6064 pre%vec!) (vstd!view.View.view.? $ ?x6064 pre%other!))))
 (let (($x6071 (= (vstd!view.View.view.? $ ?x6064 vec!) ?x6070)))
 (let (($x6066 (has_type other! ?x6064)))
 (let (($x6065 (has_type vec! ?x6064)))
 (let (($x6075 (and $x6065 $x6066 $x6071 $x6074)))
 (let (($x6063 (ens%alloc!vec.impl&%1.append. T&. T& A&. A& pre%vec! vec! pre%other! other!)))
 (let (($x6076 (= $x6063 $x6075)))
 (refl (~ $x6076 $x6076))))))))))))
 ))
 (let ((@x14830 (mp (mp~ (asserted $x6078) (nnf-pos (proof-bind ?x11559) (~ $x6078 $x6078)) $x6078) (quant-intro (proof-bind ?x14826) (= $x6078 $x14825)) $x14825)))
 (let (($x44852 (not $x14825)))
 (let (($x44853 (or $x44852 $x44843)))
 (let ((@x44854 ((_ quant-inst $ (UINT 8) $ ALLOCATOR_GLOBAL (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@0) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@1) (Poly%alloc!vec.Vec<u8./allocator_global%.>. head_bytes@0) (Poly%alloc!vec.Vec<u8./allocator_global%.>. head_bytes@1)) $x44853)))
 (let ((@x44182 (not-or-elim @x44176 $x44037)))
 (let ((@x44873 (def-axiom (or $x44842 $x44863 $x44199))))
 (let ((@x48818 (unit-resolution (unit-resolution @x44873 @x44182 (or $x44842 $x44863)) (unit-resolution @x44854 @x14830 $x44843) $x44863)))
 (let ((@x44860 (def-axiom (or $x44841 $x44836))))
 (let ((?x44565 (vstd!view.View.view.? $ ?x1878 tmp%1)))
 (let (($x44566 (= ?x44565 ?x7133)))
 (let (($x44567 (not $x44566)))
 (let (($x44549 (has_type tmp%1 ?x1878)))
 (let (($x44550 (not $x44549)))
 (let (($x44568 (or $x44550 $x44567)))
 (let (($x44580 (not $x44568)))
 (let (($x44569 (= $x44568 $x43977)))
 (let (($x44570 (not $x44569)))
 (let (($x14799 (forall ((T&. Dcr) (T& Type) (v! Poly) )(! (let (($x6051 (ens%alloc!vec.impl&%0.new. T&. T& v!)))
 (let ((?x6052 (TYPE%alloc!vec.Vec. T&. T& $ ALLOCATOR_GLOBAL)))
 (let (($x6056 (= (vstd!view.View.view.? $ ?x6052 v!) (vstd!seq.Seq.empty.? T&. T&))))
 (let (($x14783 (or (not (has_type v! ?x6052)) (not $x6056))))
 (not (= $x14783 $x6051)))))) :pattern ( (ens%alloc!vec.impl&%0.new. T&. T& v!) ) :qid internal_ens__alloc!vec.impl&__0.new._definition))
 ))
 (let (($x6060 (forall ((T&. Dcr) (T& Type) (v! Poly) )(! (let ((?x6052 (TYPE%alloc!vec.Vec. T&. T& $ ALLOCATOR_GLOBAL)))
 (let (($x6056 (= (vstd!view.View.view.? $ ?x6052 v!) (vstd!seq.Seq.empty.? T&. T&))))
 (let (($x6053 (has_type v! ?x6052)))
 (let (($x6057 (and $x6053 $x6056)))
 (let (($x6051 (ens%alloc!vec.impl&%0.new. T&. T& v!)))
 (= $x6051 $x6057)))))) :pattern ( (ens%alloc!vec.impl&%0.new. T&. T& v!) ) :qid internal_ens__alloc!vec.impl&__0.new._definition))
 ))
 (let ((?x14800 (lambda ((T&. Dcr) (T& Type) (v! Poly) )(let (($x6051 (ens%alloc!vec.impl&%0.new. T&. T& v!)))
 (let ((?x6052 (TYPE%alloc!vec.Vec. T&. T& $ ALLOCATOR_GLOBAL)))
 (let (($x6056 (= (vstd!view.View.view.? $ ?x6052 v!) (vstd!seq.Seq.empty.? T&. T&))))
 (let (($x14783 (or (not (has_type v! ?x6052)) (not $x6056))))
 (let (($x14791 (not (= $x14783 $x6051))))
 (let (($x6053 (has_type v! ?x6052)))
 (let (($x6057 (and $x6053 $x6056)))
 (let (($x6058 (= $x6051 $x6057)))
 (let (($x14794 (= $x6058 $x14791)))
 (let ((@x14789 (monotonicity (rewrite (= $x6057 (not $x14783))) (= $x6058 (= $x6051 (not $x14783))))))
 (trans (trans @x14789 (rewrite (= (= $x6051 (not $x14783)) $x14791)) $x14794) (rewrite (= $x14791 $x14791)) $x14794))))))))))))
 ))
 (let ((?x11552 (lambda ((T&. Dcr) (T& Type) (v! Poly) )(let ((?x6052 (TYPE%alloc!vec.Vec. T&. T& $ ALLOCATOR_GLOBAL)))
 (let (($x6056 (= (vstd!view.View.view.? $ ?x6052 v!) (vstd!seq.Seq.empty.? T&. T&))))
 (let (($x6053 (has_type v! ?x6052)))
 (let (($x6057 (and $x6053 $x6056)))
 (let (($x6051 (ens%alloc!vec.impl&%0.new. T&. T& v!)))
 (let (($x6058 (= $x6051 $x6057)))
 (refl (~ $x6058 $x6058)))))))))
 ))
 (let ((@x14804 (mp (mp~ (asserted $x6060) (nnf-pos (proof-bind ?x11552) (~ $x6060 $x6060)) $x6060) (quant-intro (proof-bind ?x14800) (= $x6060 $x14799)) $x14799)))
 (let (($x44574 (or (not $x14799) $x44570)))
 (let ((@x44575 ((_ quant-inst $ (UINT 8) tmp%1) $x44574)))
 (let ((@x44179 (not-or-elim @x44176 $x43977)))
 (let ((@x44590 (def-axiom (or $x44569 $x44580 $x44379))))
 (let ((@x48799 (unit-resolution (unit-resolution @x44590 @x44179 (or $x44569 $x44580)) (unit-resolution @x44575 @x14804 $x44570) $x44580)))
 (let ((@x44579 (def-axiom (or $x44568 $x44566))))
 (let ((@x48800 (unit-resolution @x44579 @x48799 $x44566)))
 (let ((?x44635 (Poly%alloc!vec.Vec<u8./allocator_global%.>. ?x43979)))
 (let (($x45239 (= tmp%1 ?x44635)))
 (let (($x1891 (forall ((x Poly) )(! (let ((?x1881 (Poly%alloc!vec.Vec<u8./allocator_global%.>. (%Poly%alloc!vec.Vec<u8./allocator_global%.>. x))))
 (let (($x1882 (= x ?x1881)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let (($x1879 (has_type x ?x1878)))
 (let (($x1887 (not $x1879)))
 (or $x1887 $x1882))))))) :pattern ( (has_type x (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL)) ) :qid internal_alloc__vec__Vec<u8./allocator_global__.>_unbox_axiom_definition))
 ))
 (let ((?x9489 (lambda ((x Poly) )(let ((?x1881 (Poly%alloc!vec.Vec<u8./allocator_global%.>. (%Poly%alloc!vec.Vec<u8./allocator_global%.>. x))))
 (let (($x1882 (= x ?x1881)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let (($x1879 (has_type x ?x1878)))
 (let (($x1887 (not $x1879)))
 (let (($x1888 (or $x1887 $x1882)))
 (refl (~ $x1888 $x1888))))))))))
 ))
 (let (($x1885 (forall ((x Poly) )(! (let ((?x1881 (Poly%alloc!vec.Vec<u8./allocator_global%.>. (%Poly%alloc!vec.Vec<u8./allocator_global%.>. x))))
 (let (($x1882 (= x ?x1881)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let (($x1879 (has_type x ?x1878)))
 (=> $x1879 $x1882)))))) :pattern ( (has_type x (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL)) ) :qid internal_alloc__vec__Vec<u8./allocator_global__.>_unbox_axiom_definition))
 ))
 (let ((?x1892 (lambda ((x Poly) )(let ((?x1881 (Poly%alloc!vec.Vec<u8./allocator_global%.>. (%Poly%alloc!vec.Vec<u8./allocator_global%.>. x))))
 (let (($x1882 (= x ?x1881)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let (($x1879 (has_type x ?x1878)))
 (let (($x1887 (not $x1879)))
 (let (($x1888 (or $x1887 $x1882)))
 (let (($x1883 (=> $x1879 $x1882)))
 (rewrite (= $x1883 $x1888)))))))))))
 ))
 (let ((@x1896 (mp (asserted $x1885) (quant-intro (proof-bind ?x1892) (= $x1885 $x1891)) $x1891)))
 (let ((@x9493 (mp~ @x1896 (nnf-pos (proof-bind ?x9489) (~ $x1891 $x1891)) $x1891)))
 (let (($x45250 (not $x1891)))
 (let (($x45251 (or $x45250 $x44550 $x45239)))
 (let ((@x45256 (mp ((_ quant-inst tmp%1) (or $x45250 (or $x44550 $x45239))) (rewrite (= (or $x45250 (or $x44550 $x45239)) $x45251)) $x45251)))
 (let ((@x48802 (unit-resolution @x45256 @x9493 (unit-resolution (def-axiom (or $x44568 $x44549)) @x48799 $x44549) $x45239)))
 (let ((@x44174 (not-or-elim @x44176 $x43980)))
 (let ((@x44467 (symm @x44174 (= ?x43979 bytes@0))))
 (let ((@x48810 (trans* (symm (monotonicity @x44467 (= ?x44635 ?x43982)) (= ?x43982 ?x44635)) (symm @x48802 (= ?x44635 tmp%1)) (= ?x43982 tmp%1))))
 (let ((@x48812 (monotonicity @x48810 (= ?x43983 ?x44565))))
 (let ((@x48821 (monotonicity (trans* @x48812 @x48800 (= ?x43983 ?x7133)) (= ?x44835 (vstd!seq.Seq.add.? $ ?x1876 ?x7133 ?x43998)))))
 (let ((?x46064 (vstd!seq.Seq.add.? $ ?x1876 ?x7133 ?x43998)))
 (let (($x46065 (= ?x46064 ?x43998)))
 (let ((?x45690 (vstd!seq.Seq.len.? $ ?x1876 ?x7133)))
 (let (($x46062 (= ?x45690 0)))
 (let (($x4384 (forall ((A&. Dcr) (A& Type) )(! (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (let (($x4380 (not $x3813)))
 (or $x4380 $x4374)))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) ) :qid user_vstd__seq__axiom_seq_empty_2))
 ))
 (let (($x4372 (fuel_bool fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x45625 (= $x4372 $x1584)))
 (let ((@x45627 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_empty.) (or (not $x30) $x45625)) @x45572 (hypothesis (not $x45625)) false)))
 (let ((@x45639 (lemma @x45627 $x45625)))
 (let ((@x45632 (def-axiom (or (not $x45625) $x4372 $x13280))))
 (let ((@x48089 (unit-resolution @x45632 (unit-resolution (def-axiom (or $x13291 $x1584)) @x48086 $x1584) (or (not $x45625) $x4372))))
 (let (($x4392 (not $x4372)))
 (let (($x4393 (or $x4392 $x4384)))
 (let ((?x10779 (lambda ((A&. Dcr) (A& Type) )(let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (let (($x4380 (not $x3813)))
 (let (($x4381 (or $x4380 $x4374)))
 (refl (~ $x4381 $x4381)))))))))
 ))
 (let ((@x10784 (monotonicity (refl (~ $x4392 $x4392)) (nnf-pos (proof-bind ?x10779) (~ $x4384 $x4384)) (~ $x4393 $x4393))))
 (let (($x4377 (forall ((A&. Dcr) (A& Type) )(! (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (=> $x3813 $x4374))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) ) :qid user_vstd__seq__axiom_seq_empty_2))
 ))
 (let (($x4378 (=> $x4372 $x4377)))
 (let ((?x4385 (lambda ((A&. Dcr) (A& Type) )(let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let ((?x4373 (vstd!seq.Seq.len.? A&. A& ?x4367)))
 (let (($x4374 (= ?x4373 0)))
 (let (($x3813 (sized A&.)))
 (let (($x4380 (not $x3813)))
 (let (($x4381 (or $x4380 $x4374)))
 (let (($x4375 (=> $x3813 $x4374)))
 (rewrite (= $x4375 $x4381))))))))))
 ))
 (let ((@x4391 (monotonicity (quant-intro (proof-bind ?x4385) (= $x4377 $x4384)) (= $x4378 (=> $x4372 $x4384)))))
 (let ((@x4398 (mp (asserted $x4378) (trans @x4391 (rewrite (= (=> $x4372 $x4384) $x4393)) (= $x4378 $x4393)) $x4393)))
 (let ((@x10788 (mp (mp~ @x4398 @x10784 $x4393) (rewrite (= $x4393 $x4393)) $x4393)))
 (let (($x48079 (not $x4384)))
 (let (($x48080 (or $x48079 $x45720 $x46062)))
 (let ((@x48085 (mp ((_ quant-inst $ (UINT 8)) (or $x48079 (or $x45720 $x46062))) (rewrite (= (or $x48079 (or $x45720 $x46062)) $x48080)) $x48080)))
 (let ((@x48093 (unit-resolution @x48085 @x175 (unit-resolution @x10788 (unit-resolution @x48089 @x45639 $x4372) $x4384) (hypothesis (not $x46062)) false)))
 (let ((@x48094 (lemma @x48093 $x46062)))
 (let (($x45009 (has_type ?x7133 ?x1968)))
 (let (($x4370 (forall ((A&. Dcr) (A& Type) )(! (let ((?x3809 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (has_type ?x4367 ?x3809))) :pattern ( (vstd!seq.Seq.empty.? A&. A&) ) :qid internal_vstd!seq.Seq.empty.?_pre_post_definition))
 ))
 (let ((?x10770 (lambda ((A&. Dcr) (A& Type) )(let ((?x3809 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4367 (vstd!seq.Seq.empty.? A&. A&)))
 (let (($x4368 (has_type ?x4367 ?x3809)))
 (refl (~ $x4368 $x4368))))))
 ))
 (let ((@x10774 (mp~ (asserted $x4370) (nnf-pos (proof-bind ?x10770) (~ $x4370 $x4370)) $x4370)))
 (let (($x45026 (or (not $x4370) $x45009)))
 (let ((@x45027 ((_ quant-inst $ (UINT 8)) $x45026)))
 (let ((@x48790 (unit-resolution @x45027 @x10774 $x45009)))
 (let (($x14409 (forall ((A&. Dcr) (A& Type) (a! Poly) (b! Poly) )(! (let ((?x4940 (vstd!seq.Seq.add.? A&. A& a! b!)))
 (let (($x5142 (= ?x4940 b!)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type b! ?x3990)))
 (let (($x14104 (not $x4525)))
 (let (($x4101 (has_type a! ?x3990)))
 (let (($x13851 (not $x4101)))
 (or $x13851 $x14104 $x4431 (not (= (vstd!seq.Seq.len.? A&. A& a!) 0)) $x5142)))))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& a! b!) ) :qid user_vstd__seq_lib__impl&%0__add_empty_left_15))
 ))
 (let (($x5139 (fuel_bool fuel%vstd!seq_lib.impl&%0.add_empty_left.)))
 (let (($x1605 (fuel_bool_default fuel%vstd!seq_lib.impl&%0.add_empty_left.)))
 (let (($x46047 (= $x5139 $x1605)))
 (let ((@x46049 (unit-resolution ((_ quant-inst fuel%vstd!seq_lib.impl&%0.add_empty_left.) (or (not $x30) $x46047)) @x45572 (hypothesis (not $x46047)) false)))
 (let ((@x46061 (lemma @x46049 $x46047)))
 (let (($x1606 (fuel_bool_default fuel%vstd!seq_lib.impl&%0.add_empty_right.)))
 (let (($x13301 (not $x1606)))
 (let (($x13300 (not $x1605)))
 (let (($x1604 (fuel_bool_default fuel%vstd!seq_lib.group_filter_ensures.)))
 (let (($x13299 (not $x1604)))
 (let (($x13302 (or $x13299 $x13300 $x13301)))
 (let (($x13303 (not $x13302)))
 (let (($x13306 (or $x1610 $x13303)))
 (let (($x1607 (and $x1604 $x1605 $x1606)))
 (let (($x1611 (or $x1610 $x1607)))
 (let ((@x1614 (mp (asserted (=> $x1603 $x1607)) (rewrite (= (=> $x1603 $x1607) $x1611)) $x1611)))
 (let ((@x13308 (mp @x1614 (rewrite (= $x1611 $x13306)) $x13306)))
 (let ((@x48784 (unit-resolution @x13308 (unit-resolution (def-axiom (or $x13356 $x1603)) @x48071 $x1603) $x13303)))
 (let ((@x42133 (def-axiom (or $x13302 $x1605))))
 (let ((@x46054 (def-axiom (or (not $x46047) $x5139 $x13300))))
 (let ((@x48787 (unit-resolution @x46054 (unit-resolution @x42133 @x48784 $x1605) (or (not $x46047) $x5139))))
 (let (($x5168 (not $x5139)))
 (let (($x14414 (or $x5168 $x14409)))
 (let (($x5160 (forall ((A&. Dcr) (A& Type) (a! Poly) (b! Poly) )(! (let ((?x4940 (vstd!seq.Seq.add.? A&. A& a! b!)))
 (let (($x5142 (= ?x4940 b!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& a!)))
 (let (($x5140 (= ?x4092 0)))
 (let (($x3858 (sized A&.)))
 (let (($x5141 (and $x3858 $x5140)))
 (let (($x5148 (not $x5141)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type b! ?x3990)))
 (let (($x4101 (has_type a! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x5148 $x5142))))))))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& a! b!) ) :qid user_vstd__seq_lib__impl&%0__add_empty_left_15))
 ))
 (let (($x5169 (or $x5168 $x5160)))
 (let ((?x11111 (lambda ((A&. Dcr) (A& Type) (a! Poly) (b! Poly) )(let ((?x4940 (vstd!seq.Seq.add.? A&. A& a! b!)))
 (let (($x5142 (= ?x4940 b!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& a!)))
 (let (($x5140 (= ?x4092 0)))
 (let (($x3858 (sized A&.)))
 (let (($x5141 (and $x3858 $x5140)))
 (let (($x5148 (not $x5141)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type b! ?x3990)))
 (let (($x4101 (has_type a! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x5155 (or $x4568 $x5148 $x5142)))
 (refl (~ $x5155 $x5155))))))))))))))))
 ))
 (let ((@x11116 (monotonicity (refl (~ $x5168 $x5168)) (nnf-pos (proof-bind ?x11111) (~ $x5160 $x5160)) (~ $x5169 $x5169))))
 (let (($x5145 (forall ((A&. Dcr) (A& Type) (a! Poly) (b! Poly) )(! (let ((?x4940 (vstd!seq.Seq.add.? A&. A& a! b!)))
 (let (($x5142 (= ?x4940 b!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& a!)))
 (let (($x5140 (= ?x4092 0)))
 (let (($x3858 (sized A&.)))
 (let (($x5141 (and $x3858 $x5140)))
 (let (($x5143 (=> $x5141 $x5142)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type b! ?x3990)))
 (let (($x4101 (has_type a! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x5141) $x5142)))))))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& a! b!) ) :qid user_vstd__seq_lib__impl&%0__add_empty_left_15))
 ))
 (let (($x5146 (=> $x5139 $x5145)))
 (let ((?x5161 (lambda ((A&. Dcr) (A& Type) (a! Poly) (b! Poly) )(let ((?x4940 (vstd!seq.Seq.add.? A&. A& a! b!)))
 (let (($x5142 (= ?x4940 b!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& a!)))
 (let (($x5140 (= ?x4092 0)))
 (let (($x3858 (sized A&.)))
 (let (($x5141 (and $x3858 $x5140)))
 (let (($x5148 (not $x5141)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type b! ?x3990)))
 (let (($x4101 (has_type a! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x5155 (or $x4568 $x5148 $x5142)))
 (let (($x5143 (=> $x5141 $x5142)))
 (let (($x5144 (=> (and $x4526 $x5141) $x5142)))
 (let ((@x5154 (monotonicity (rewrite (= $x5143 (or $x5148 $x5142))) (= $x5144 (=> $x4526 (or $x5148 $x5142))))))
 (trans @x5154 (rewrite (= (=> $x4526 (or $x5148 $x5142)) $x5155)) (= $x5144 $x5155)))))))))))))))))))
 ))
 (let ((@x5167 (monotonicity (quant-intro (proof-bind ?x5161) (= $x5145 $x5160)) (= $x5146 (=> $x5139 $x5160)))))
 (let ((@x5174 (mp (asserted $x5146) (trans @x5167 (rewrite (= (=> $x5139 $x5160) $x5169)) (= $x5146 $x5169)) $x5169)))
 (let ((@x14416 (mp (mp (mp~ @x5174 @x11116 $x5169) (rewrite (= $x5169 $x5169)) $x5169) (rewrite (= $x5169 $x14414)) $x14414)))
 (let (($x46063 (not $x46062)))
 (let (($x45235 (not $x45009)))
 (let (($x46069 (not $x14409)))
 (let (($x46070 (or $x46069 $x45235 $x45290 $x45720 $x46063 $x46065)))
 (let ((@x46075 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.empty.? $ ?x1876) (vstd!view.View.view.? $ ?x1878 ?x43997)) (or $x46069 (or $x45235 $x45290 $x45720 $x46063 $x46065))) (rewrite (= (or $x46069 (or $x45235 $x45290 $x45720 $x46063 $x46065)) $x46070)) $x46070)))
 (let ((@x48792 (unit-resolution @x46075 @x175 (unit-resolution @x14416 (unit-resolution @x48787 @x46061 $x5139) $x14409) @x48790 (or $x45290 $x46063 $x46065))))
 (let ((@x48823 (symm (unit-resolution (unit-resolution @x48792 @x48730 (or $x46063 $x46065)) @x48094 $x46065) (= ?x43998 ?x46064))))
 (let ((@x48829 (trans* @x48742 @x48744 @x48823 (symm @x48821 (= ?x46064 ?x44835)) (symm (unit-resolution @x44860 @x48818 $x44836) (= ?x44835 ?x44834)) (= ?x44056 ?x44834))))
 (let ((@x48831 (monotonicity @x48829 @x48776 (= ?x48162 ?x44851))))
 (let ((@x48835 (monotonicity (symm @x48831 (= ?x44851 ?x48162)) (= ?x46079 ?x48163))))
 (let ((@x48841 (monotonicity (trans* @x48835 @x48782 @x48837 @x48647 @x48247 @x48249 (= ?x46079 ?x7368)) (trans* @x48641 @x48643 @x48611 (= ?x47649 8)) (= ?x48537 ?x7370))))
 (let ((?x48538 (nClip ?x48537)))
 (let (($x48426 (= ?x48537 ?x48538)))
 (let (($x48437 (>= ?x48537 0)))
 (let (($x48435 (not $x48437)))
 (let (($x48427 (or $x48435 $x48426)))
 (let (($x48442 (not $x48427)))
 (let (($x48428 (>= ?x48538 0)))
 (let (($x48429 (not $x48428)))
 (let (($x48443 (or $x48429 $x48442)))
 (let (($x48440 (not $x48443)))
 (let (($x48445 (or $x48124 $x48440)))
 (let ((@x48478 ((_ quant-inst (Add ?x46079 ?x47649)) $x48445)))
 (let ((@x48510 (def-axiom (or $x48443 $x48427))))
 (let ((?x48887 (* (- 1) ?x48537)))
 (let ((?x48441 (Add ?x46079 8)))
 (let ((?x48888 (+ ?x48441 ?x48887)))
 (let (($x48889 (<= ?x48888 0)))
 (let (($x48886 (= ?x48441 ?x48537)))
 (let ((@x49949 (symm @x48641 (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44751)) ?x47649))))
 (let ((@x49947 (symm @x48643 (= ?x44753 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44751))))))
 (let ((@x49952 (monotonicity (trans* (symm @x48611 (= 8 ?x44753)) @x49947 @x49949 (= 8 ?x47649)) $x48886)))
 (let ((@x49953 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48886) $x48889)) @x49952 $x48889)))
 (let ((?x48444 (* (- 1) ?x48441)))
 (let ((?x48594 (+ ?x46079 ?x48444)))
 (let (($x48512 (<= ?x48594 (- 8))))
 (let (($x48424 (= ?x48594 (- 8))))
 (let (($x48457 (or $x45516 $x48424)))
 (let (($x48593 (= (+ 8 ?x46079 ?x48444) 0)))
 (let (($x48459 (or $x45516 $x48593)))
 (let (($x48500 (= $x48459 $x48457)))
 (let ((@x48503 (trans (monotonicity (rewrite (= $x48593 $x48424)) $x48500) (rewrite (= $x48457 $x48457)) $x48500)))
 (let ((@x48504 (mp ((_ quant-inst (vstd!seq.Seq.len.? $ ?x1876 ?x44851) 8) $x48459) @x48503 $x48457)))
 (let ((@x49940 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48424) $x48512)) (unit-resolution @x48504 @x9197 $x48424) $x48512)))
 (let (($x48160 (>= ?x46079 0)))
 (let (($x45306 (has_type ?x44851 ?x1968)))
 (let ((?x44850 (vstd!view.View.view.? $ ?x1878 ?x44039)))
 (let (($x44874 (= ?x44850 ?x44851)))
 (let ((?x44876 (vstd!view.View.view.? $ ?x1878 ?x44041)))
 (let (($x44877 (= ?x44876 ?x7133)))
 (let (($x44878 (not $x44877)))
 (let (($x44875 (not $x44874)))
 (let (($x44847 (has_type ?x44041 ?x1878)))
 (let (($x44849 (not $x44847)))
 (let (($x44846 (has_type ?x44039 ?x1878)))
 (let (($x44848 (not $x44846)))
 (let (($x44879 (or $x44848 $x44849 $x44875 $x44878)))
 (let (($x44900 (not $x44879)))
 (let (($x44880 (= $x44879 $x44042)))
 (let (($x44881 (not $x44880)))
 (let (($x44890 (or $x44852 $x44881)))
 (let ((@x44891 ((_ quant-inst $ (UINT 8) $ ALLOCATOR_GLOBAL (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@1) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@2) (Poly%alloc!vec.Vec<u8./allocator_global%.>. tail_bytes@0) (Poly%alloc!vec.Vec<u8./allocator_global%.>. tail_bytes@1)) $x44890)))
 (let ((@x44183 (not-or-elim @x44176 $x44042)))
 (let ((@x44910 (def-axiom (or $x44880 $x44900 $x44190))))
 (let ((@x48847 (unit-resolution (unit-resolution @x44910 @x44183 (or $x44880 $x44900)) (unit-resolution @x44891 @x14830 $x44881) $x44900)))
 (let ((@x44897 (def-axiom (or $x44879 $x44874))))
 (let ((@x48850 (unit-resolution @x44897 @x48847 $x44874)))
 (let (($x45265 (has_type ?x44850 ?x44591)))
 (let (($x45275 (or $x44596 $x44848 $x45265)))
 (let ((@x45280 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@2)) (or $x44596 (or $x44848 $x45265))) (rewrite (= (or $x44596 (or $x44848 $x45265)) $x45275)) $x45275)))
 (let ((@x48849 (unit-resolution @x45280 @x11208 (unit-resolution (def-axiom (or $x44879 $x44846)) @x48847 $x44846) $x45265)))
 (let ((@x48853 (mp @x48849 (monotonicity @x48850 @x48618 (= $x45265 $x45306)) $x45306)))
 (let (($x4084 (forall ((A&. Dcr) (A& Type) (self! Poly) )(! (let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4073 (>= ?x4066 0)))
 (or (not (has_type self! (TYPE%vstd!seq.Seq. A&. A&))) $x4073))) :pattern ( (vstd!seq.Seq.len.? A&. A& self!) ) :qid internal_vstd!seq.Seq.len.?_pre_post_definition))
 ))
 (let ((?x10679 (lambda ((A&. Dcr) (A& Type) (self! Poly) )(let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4073 (>= ?x4066 0)))
 (let (($x4079 (or (not (has_type self! (TYPE%vstd!seq.Seq. A&. A&))) $x4073)))
 (refl (~ $x4079 $x4079))))))
 ))
 (let (($x4070 (forall ((A&. Dcr) (A& Type) (self! Poly) )(! (let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4067 (<= 0 ?x4066)))
 (let (($x4065 (has_type self! (TYPE%vstd!seq.Seq. A&. A&))))
 (=> $x4065 $x4067)))) :pattern ( (vstd!seq.Seq.len.? A&. A& self!) ) :qid internal_vstd!seq.Seq.len.?_pre_post_definition))
 ))
 (let ((?x4085 (lambda ((A&. Dcr) (A& Type) (self! Poly) )(let ((?x4066 (vstd!seq.Seq.len.? A&. A& self!)))
 (let (($x4073 (>= ?x4066 0)))
 (let (($x4079 (or (not (has_type self! (TYPE%vstd!seq.Seq. A&. A&))) $x4073)))
 (let (($x4067 (<= 0 ?x4066)))
 (let (($x4065 (has_type self! (TYPE%vstd!seq.Seq. A&. A&))))
 (let (($x4068 (=> $x4065 $x4067)))
 (trans (monotonicity (rewrite (= $x4067 $x4073)) (= $x4068 (=> $x4065 $x4073))) (rewrite (= (=> $x4065 $x4073) $x4079)) (= $x4068 $x4079)))))))))
 ))
 (let ((@x4089 (mp (asserted $x4070) (quant-intro (proof-bind ?x4085) (= $x4070 $x4084)) $x4084)))
 (let ((@x10683 (mp~ @x4089 (nnf-pos (proof-bind ?x10679) (~ $x4084 $x4084)) $x4084)))
 (let (($x45307 (not $x45306)))
 (let (($x45333 (not $x4084)))
 (let (($x48533 (or $x45333 $x45307 $x48160)))
 (let ((@x48589 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44834 ?x44012)) (or $x45333 (or $x45307 $x48160))) (rewrite (= (or $x45333 (or $x45307 $x48160)) $x48533)) $x48533)))
 (let ((@x49954 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1) (or $x48437 (not $x48889) (not $x48160) (not $x48512))) (unit-resolution @x48589 @x10683 @x48853 $x48160) @x49940 @x49953 $x48437)))
 (let ((@x48471 (def-axiom (or $x48442 $x48435 $x48426))))
 (let ((@x49957 (unit-resolution @x48471 @x49954 (unit-resolution @x48510 (unit-resolution @x48478 @x12798 $x48440) $x48427) $x48426)))
 (let ((?x48529 (vstd!seq.Seq.add.? $ ?x1876 ?x44851 ?x44071)))
 (let ((?x48530 (vstd!seq.Seq.len.? $ ?x1876 ?x48529)))
 (let (($x48539 (= ?x48530 ?x48538)))
 (let (($x47653 (has_type ?x44071 ?x1968)))
 (let ((@x48859 (symm (monotonicity (trans* @x48633 @x48635 (= ?x44071 ?x44026)) (= $x47653 $x45314)) (= $x45314 $x47653))))
 (let ((@x48860 (mp @x48621 @x48859 $x47653)))
 (let (($x47654 (not $x47653)))
 (let (($x48543 (or $x48072 $x45307 $x47654 $x45720 $x48539)))
 (let ((@x48548 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44834 ?x44012) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1)) (or $x48072 (or $x45307 $x47654 $x45720 $x48539))) (rewrite (= (or $x48072 (or $x45307 $x47654 $x45720 $x48539)) $x48543)) $x48543)))
 (let ((@x48861 (unit-resolution @x48548 @x175 @x48767 @x48853 @x48860 $x48539)))
 (let ((?x44888 (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026)))
 (let ((?x48487 (vstd!seq.Seq.len.? $ ?x1876 ?x44888)))
 (let ((@x48855 (trans* @x48633 @x48635 (= ?x44071 ?x44026))))
 (let ((@x48863 (symm @x48850 (= ?x44851 ?x44850))))
 (let ((@x48865 (monotonicity @x48863 @x48855 (= ?x48529 ?x44888))))
 (let ((@x48869 (monotonicity (symm @x48865 (= ?x44888 ?x48529)) (= ?x48487 ?x48530))))
 (let (($x44889 (= ?x44057 ?x44888)))
 (let ((?x44912 (vstd!view.View.view.? $ ?x1878 ?x44046)))
 (let (($x44913 (= ?x44912 ?x7133)))
 (let (($x44914 (not $x44913)))
 (let (($x44911 (not $x44889)))
 (let (($x44885 (has_type ?x44046 ?x1878)))
 (let (($x44887 (not $x44885)))
 (let (($x44884 (has_type ?x44044 ?x1878)))
 (let (($x44886 (not $x44884)))
 (let (($x44915 (or $x44886 $x44887 $x44911 $x44914)))
 (let (($x44936 (not $x44915)))
 (let (($x44916 (= $x44915 $x44047)))
 (let (($x44917 (not $x44916)))
 (let (($x44926 (or $x44852 $x44917)))
 (let ((@x44927 ((_ quant-inst $ (UINT 8) $ ALLOCATOR_GLOBAL (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@2) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3) (Poly%alloc!vec.Vec<u8./allocator_global%.>. log_size_bytes@0) (Poly%alloc!vec.Vec<u8./allocator_global%.>. log_size_bytes@1)) $x44926)))
 (let ((@x44184 (not-or-elim @x44176 $x44047)))
 (let ((@x44946 (def-axiom (or $x44916 $x44936 $x44181))))
 (let ((@x48988 (unit-resolution (unit-resolution @x44946 @x44184 (or $x44916 $x44936)) (unit-resolution @x44927 @x14830 $x44917) $x44936)))
 (let ((@x44933 (def-axiom (or $x44915 $x44889))))
 (let ((@x48991 (unit-resolution @x44933 @x48988 $x44889)))
 (let (($x44212 (not $x44150)))
 (let (($x44211 (not $x44146)))
 (let (($x44213 (or $x44211 $x44212)))
 (let (($x44214 (not $x44213)))
 (let (($x44218 (or $x44164 $x44148 $x44214)))
 (let (($x44223 (not $x44218)))
 (let ((?x50086 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44072 ?x44071 ?x1876 $)))
 (let ((?x50089 (vstd!seq.Seq.index.? $ ?x1876 ?x44072 ?x50086)))
 (let ((?x50143 (vstd!seq.Seq.index.? $ ?x1876 ?x44071 ?x50086)))
 (let (($x50146 (= ?x50143 ?x50089)))
 (let ((?x50119 (%I ?x50086)))
 (let ((?x50121 (* (- 1) ?x50119)))
 (let ((?x50118 (+ ?x47649 ?x50121)))
 (let (($x50122 (<= ?x50118 0)))
 (let (($x50120 (>= ?x50119 0)))
 (let (($x50125 (not $x50120)))
 (let (($x50172 (has_type ?x50086 INT)))
 (let (($x50175 (not $x50172)))
 (let (($x50176 (or $x50175 $x50125 $x50122 $x50146)))
 (let ((?x50869 (I ?x50119)))
 (let (($x50870 (= ?x50086 ?x50869)))
 (let (($x50174 (not $x50176)))
 (let ((@x51340 (hypothesis $x50174)))
 (let ((@x50289 (def-axiom (or $x50176 $x50172))))
 (let ((@x51341 (unit-resolution @x50289 @x51340 $x50172)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x8976 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x8980 (mp~ @x280 (nnf-pos (proof-bind ?x8976) (~ $x275 $x275)) $x275)))
 (let (($x48907 (not $x275)))
 (let (($x50927 (or $x48907 $x50175 $x50870)))
 (let ((@x50971 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44072 ?x44071 ?x1876 $)) (or $x48907 (or $x50175 $x50870))) (rewrite (= (or $x48907 (or $x50175 $x50870)) $x50927)) $x50927)))
 (let ((?x46896 (%I ?x7369)))
 (let ((?x50833 (Add ?x50119 ?x46896)))
 (let ((?x50834 (I ?x50833)))
 (let ((?x51067 (%I ?x50834)))
 (let ((?x51172 (I ?x51067)))
 (let ((?x50983 (%I ?x51172)))
 (let ((?x51098 (Sub ?x50983 ?x46079)))
 (let ((?x51099 (I ?x51098)))
 (let ((?x51100 (vstd!seq.Seq.index.? $ ?x1876 ?x44071 ?x51099)))
 (let ((?x51032 (vstd!seq.Seq.index.? $ ?x1876 ?x48529 ?x51172)))
 (let (($x51095 (= ?x51032 ?x51100)))
 (let ((?x51040 (* (- 1) ?x50983)))
 (let ((?x51041 (+ ?x46079 ?x51040)))
 (let (($x51042 (<= ?x51041 0)))
 (let ((?x51082 (* (- 1) ?x51067)))
 (let ((?x51166 (+ ?x50983 ?x51082)))
 (let (($x51171 (>= ?x51166 0)))
 (let (($x51165 (= ?x50983 ?x51067)))
 (let (($x51180 (= ?x51172 ?x50834)))
 (let (($x50519 (= ?x50834 ?x51172)))
 (let (($x51065 (has_type ?x50834 INT)))
 (let (($x51173 (has_type ?x51172 INT)))
 (let (($x51186 (not $x51173)))
 (let (($x51184 (= $x51065 $x51173)))
 (let (($x51182 (= $x51173 $x51065)))
 (let (($x51146 (= ?x50833 ?x51067)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x8955 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x8959 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x8955) (~ $x237 $x237)) $x237)))
 (let (($x45436 (not $x237)))
 (let (($x51149 (or $x45436 $x51146)))
 (let ((@x51150 ((_ quant-inst (Add ?x50119 ?x46896)) $x51149)))
 (let ((@x51175 (unit-resolution @x51150 @x8959 $x51146)))
 (let ((@x51185 (symm (monotonicity (monotonicity (symm @x51175 (= ?x51067 ?x50833)) $x51180) $x51182) $x51184)))
 (let ((@x51189 (mp (hypothesis (not $x51065)) (monotonicity @x51185 (= (not $x51065) $x51186)) $x51186)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x9095 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x9099 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x9095) (~ $x698 $x698)) $x698)))
 (let ((@x51191 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x50834)) (or (not $x698) $x51173)) @x9099 $x51173) @x51189 false)))
 (let ((@x51192 (lemma @x51191 $x51065)))
 (let (($x51066 (not $x51065)))
 (let (($x50732 (or $x48907 $x51066 $x50519)))
 (let ((@x50819 (mp ((_ quant-inst (I ?x50833)) (or $x48907 (or $x51066 $x50519))) (rewrite (= (or $x48907 (or $x51066 $x50519)) $x50732)) $x50732)))
 (let ((@x51308 (symm (unit-resolution @x50819 @x8980 @x51192 $x50519) $x51180)))
 (let ((@x51309 (monotonicity @x51308 $x51165)))
 (let (($x48891 (<= ?x48175 16)))
 (let ((?x51147 (Add ?x50119 16)))
 (let ((?x51148 (* (- 1) ?x51147)))
 (let ((?x50853 (+ ?x50833 ?x51148)))
 (let (($x50855 (>= ?x50853 0)))
 (let (($x50852 (= ?x50833 ?x51147)))
 (let (($x46897 (= ?x7368 ?x46896)))
 (let (($x46902 (or $x45436 $x46897)))
 (let ((@x46903 ((_ quant-inst (Sub pmemlog!logimpl_v.header_log_size_offset.? 8)) $x46902)))
 (let ((@x49706 (unit-resolution @x46903 @x8959 $x46897)))
 (let ((@x51298 (symm (monotonicity (trans* @x48247 @x48249 @x49706 (= 16 ?x46896)) (= ?x51147 ?x50833)) $x50852)))
 (let ((@x51407 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50852) $x50855)) @x51298 $x50855)))
 (let ((?x51153 (+ ?x50119 ?x51148)))
 (let (($x50851 (<= ?x51153 (- 16))))
 (let (($x50520 (= ?x51153 (- 16))))
 (let (($x50822 (or $x45516 $x50520)))
 (let (($x51152 (= (+ 16 ?x50119 ?x51148) 0)))
 (let (($x50825 (or $x45516 $x51152)))
 (let (($x50827 (= $x50825 $x50822)))
 (let ((@x50850 (trans (monotonicity (rewrite (= $x51152 $x50520)) $x50827) (rewrite (= $x50822 $x50822)) $x50827)))
 (let ((@x50849 (mp ((_ quant-inst (%I ?x50086) 16) $x50825) @x50850 $x50822)))
 (let ((@x51289 (unit-resolution @x50849 @x9197 $x50520)))
 (let ((@x51410 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50520) $x50851)) @x51289 $x50851)))
 (let ((?x50442 (+ ?x50833 ?x51082)))
 (let (($x50518 (<= ?x50442 0)))
 (let ((?x48898 (* (- 1) ?x48175)))
 (let ((?x48899 (+ ?x46079 ?x48898)))
 (let (($x48900 (<= ?x48899 0)))
 (let (($x48897 (= ?x46079 ?x48175)))
 (let ((@x49760 (trans* @x48835 @x48782 @x48837 $x48897)))
 (let ((@x50292 (def-axiom (or $x50176 $x50120))))
 (let ((@x51417 (unit-resolution @x50292 @x51340 $x50120)))
 (let (($x51423 (not $x50851)))
 (let (($x51422 (not $x50855)))
 (let (($x51424 (or $x51042 (not $x48891) (not $x48900) (not $x51171) (not $x50518) $x51422 $x50125 $x51423)))
 (let ((@x51426 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1 -1 1 1 -1) $x51424) @x51417 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48897) $x48900)) @x49760 $x48900) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51146) $x50518)) @x51175 $x50518) @x51410 @x51407 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x48439 $x48891)) @x48647 $x48891) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51165) $x51171)) @x51309 $x51171) $x51042)))
 (let ((?x51132 (+ ?x48538 ?x51040)))
 (let (($x51133 (<= ?x51132 0)))
 (let (($x51313 (not $x51133)))
 (let (($x50408 (not $x50122)))
 (let ((@x50412 (def-axiom (or $x50176 $x50408))))
 (let ((@x51430 (unit-resolution @x50412 @x51340 $x50408)))
 (let ((@x51043 (hypothesis $x50408)))
 (let (($x51167 (>= ?x51153 (- 16))))
 (let ((@x51290 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50520) $x51167)) @x51289 $x51167)))
 (let (($x50854 (<= ?x50853 0)))
 (let ((@x51299 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50852) $x50854)) @x51298 $x50854)))
 (let (($x50823 (>= ?x50442 0)))
 (let (($x51168 (<= ?x51166 0)))
 (let (($x48901 (>= ?x48899 0)))
 (let ((@x49761 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48897) $x48901)) @x49760 $x48901)))
 (let (($x48893 (>= ?x48175 16)))
 (let ((@x49764 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x48439 $x48893)) @x48647 $x48893)))
 (let ((?x48479 (* (- 1) ?x48538)))
 (let ((?x48481 (+ ?x48537 ?x48479)))
 (let (($x48482 (<= ?x48481 0)))
 (let ((@x49958 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48426) $x48482)) @x49957 $x48482)))
 (let ((?x47682 (* (- 1) ?x47649)))
 (let ((?x47689 (+ ?x44753 ?x47682)))
 (let (($x47691 (>= ?x47689 0)))
 (let ((@x51057 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x44753 ?x47649)) $x47691)) (trans* @x49947 @x49949 (= ?x44753 ?x47649)) $x47691)))
 (let (($x45463 (<= ?x44753 8)))
 (let ((@x51060 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x44773 $x45463)) @x48611 $x45463)))
 (let ((@x51312 ((_ th-lemma arith farkas -1 1 -1 -1 -1 -1 1 1 -1 1 -1 1 1) @x51060 @x51057 (hypothesis $x51133) @x49958 @x49953 @x49940 @x49764 @x49761 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51165) $x51168)) @x51309 $x51168) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51146) $x50823)) @x51175 $x50823) @x51299 @x51290 @x51043 false)))
 (let ((@x51315 (lemma @x51312 (or $x51313 $x50122))))
 (let (($x14366 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x4282 (sized A&.)))
 (let (($x13979 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x14307 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x13943 (not $x4256)))
 (or $x13943 $x14307 $x271 $x13979 $x4555 $x5071 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5048 (fuel_bool fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x46016 (= $x5048 $x1594)))
 (let ((@x46018 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index2.) (or (not $x30) $x46016)) @x45572 (hypothesis (not $x46016)) false)))
 (let ((@x46030 (lemma @x46018 $x46016)))
 (let ((@x46023 (def-axiom (or (not $x46016) $x5048 $x13290))))
 (let ((@x50721 (unit-resolution @x46023 (unit-resolution (def-axiom (or $x13291 $x1594)) @x48086 $x1594) (or (not $x46016) $x5048))))
 (let (($x5079 (not $x5048)))
 (let (($x14371 (or $x5079 $x14366)))
 (let (($x5101 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5087 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5106 (or $x5079 $x5101)))
 (let ((?x11076 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (refl (~ $x5096 $x5096)))))))))))))))))))))))
 ))
 (let ((@x11081 (monotonicity (refl (~ $x5079 $x5079)) (nnf-pos (proof-bind ?x11076) (~ $x5101 $x5101)) (~ $x5106 $x5106))))
 (let (($x5062 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x4282 (sized A&.)))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x5055) $x5059)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5063 (=> $x5048 $x5062)))
 (let ((?x5102 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x5061 (=> (and $x4994 $x5055) $x5059)))
 (let ((@x5072 (monotonicity (rewrite (= $x5054 (and $x4552 $x5076))) (= $x5055 (and $x4282 (and $x4552 $x5076))))))
 (let ((@x5083 (trans @x5072 (rewrite (= (and $x4282 (and $x4552 $x5076)) $x5075)) (= $x5055 $x5075))))
 (let ((@x5092 (trans (monotonicity @x5083 (= $x5060 (=> $x5075 $x5059))) (rewrite (= (=> $x5075 $x5059) (or $x5087 $x5059))) (= $x5060 (or $x5087 $x5059)))))
 (trans (monotonicity @x5092 (= $x5061 (=> $x4994 (or $x5087 $x5059)))) (rewrite (= (=> $x4994 (or $x5087 $x5059)) $x5096)) (= $x5061 $x5096))))))))))))))))))))))))))))))
 ))
 (let ((@x5077 (monotonicity (quant-intro (proof-bind ?x5102) (= $x5062 $x5101)) (= $x5063 (=> $x5048 $x5101)))))
 (let ((@x5111 (mp (asserted $x5063) (trans @x5077 (rewrite (= (=> $x5048 $x5101) $x5106)) (= $x5063 $x5106)) $x5106)))
 (let ((@x14373 (mp (mp (mp~ @x5111 @x11081 $x5106) (rewrite (= $x5106 $x5106)) $x5106) (rewrite (= $x5106 $x14371)) $x14371)))
 (let ((@x50723 (unit-resolution @x14373 (unit-resolution @x50721 @x46030 $x5048) $x14366)))
 (let (($x51102 (not $x51042)))
 (let (($x49563 (not $x14366)))
 (let (($x51158 (or $x49563 $x45307 $x47654 $x51186 $x45720 $x51102 $x51133 $x51095)))
 (let ((?x51093 (+ ?x50983 ?x48479)))
 (let (($x51094 (>= ?x51093 0)))
 (let ((?x49365 (* (- 1) ?x46079)))
 (let ((?x51030 (+ ?x50983 ?x49365)))
 (let (($x51031 (>= ?x51030 0)))
 (let (($x51092 (not $x51031)))
 (let (($x51101 (or $x45307 $x47654 $x51186 $x45720 $x51092 $x51094 $x51095)))
 (let (($x51159 (or $x49563 $x51101)))
 (let ((@x51161 (rewrite (= (or $x49563 (or $x45307 $x47654 $x51186 $x45720 $x51102 $x51133 $x51095)) $x51158))))
 (let (($x51135 (or $x45307 $x47654 $x51186 $x45720 $x51102 $x51133 $x51095)))
 (let (($x51141 (= $x51101 $x51135)))
 (let ((@x51131 (monotonicity (rewrite (= ?x51093 (+ ?x48479 ?x50983))) (= $x51094 (>= (+ ?x48479 ?x50983) 0)))))
 (let ((@x51140 (trans @x51131 (rewrite (= (>= (+ ?x48479 ?x50983) 0) $x51133)) (= $x51094 $x51133))))
 (let ((@x51105 (rewrite (= $x51092 $x51102))))
 (let ((@x51157 (monotonicity (trans (monotonicity @x51105 @x51140 $x51141) (rewrite (= $x51135 $x51135)) $x51141) (= $x51159 (or $x49563 $x51135)))))
 (let ((@x51433 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44834 ?x44012) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1) (I ?x51067)) $x51159) (trans @x51157 @x51161 (= $x51159 $x51158)) $x51158) @x175 @x50723 @x48853 @x48860 (or $x51186 $x51102 $x51133 $x51095))))
 (let ((@x51434 (unit-resolution @x51433 (unit-resolution @x51315 @x51430 $x51313) (mp @x51192 (symm (monotonicity @x51308 $x51182) $x51184) $x51173) @x51426 $x51095)))
 (let ((?x50835 (vstd!seq.Seq.index.? $ ?x1876 ?x44888 ?x50834)))
 (let ((?x50354 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44888 ?x7369 ?x7371)))
 (let ((?x50832 (vstd!seq.Seq.index.? $ ?x1876 ?x50354 ?x50086)))
 (let (($x50836 (= ?x50832 ?x50835)))
 (let ((?x46890 (%I ?x7371)))
 (let ((?x50530 (Sub ?x46890 ?x46896)))
 (let ((?x50829 (* (- 1) ?x50530)))
 (let ((?x50830 (+ ?x50119 ?x50829)))
 (let (($x50831 (>= ?x50830 0)))
 (let (($x51062 (not $x50831)))
 (let (($x50886 (>= ?x50530 8)))
 (let (($x50878 (= ?x50530 8)))
 (let ((?x50180 (vstd!seq.Seq.len.? $ ?x1876 ?x44072)))
 (let (($x50183 (= ?x47649 ?x50180)))
 (let ((?x50529 (vstd!seq.Seq.len.? $ ?x1876 ?x50354)))
 (let (($x50813 (= ?x50529 ?x50180)))
 (let ((@x49017 (symm @x48991 (= ?x44888 ?x44057))))
 (let ((@x50800 (monotonicity @x49017 (= ?x50354 ?x44072))))
 (let ((@x50802 (symm @x50800 (= ?x44072 ?x50354))))
 (let (($x50531 (= ?x50529 ?x50530)))
 (let (($x50451 (>= ?x46896 0)))
 (let ((?x49711 (* (- 1) ?x46896)))
 (let ((?x49703 (+ ?x7368 ?x49711)))
 (let (($x49704 (<= ?x49703 0)))
 (let ((@x49465 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46897) $x49704)) @x49706 $x49704)))
 (let ((@x50744 (lemma ((_ th-lemma arith farkas 1 1 1) @x48370 @x49465 (hypothesis (not $x50451)) false) $x50451)))
 (let ((?x48488 (* (- 1) ?x48487)))
 (let ((?x50527 (+ ?x46890 ?x48488)))
 (let (($x50528 (<= ?x50527 0)))
 (let ((?x48598 (+ ?x48487 ?x48479)))
 (let (($x48885 (>= ?x48598 0)))
 (let ((@x49963 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x48487 ?x48538)) $x48885)) (trans* @x48869 @x48861 (= ?x48487 ?x48538)) $x48885)))
 (let ((?x50533 (* (- 1) ?x46890)))
 (let ((?x50729 (+ ?x7370 ?x50533)))
 (let (($x50737 (>= ?x50729 0)))
 (let (($x46893 (= ?x7370 ?x46890)))
 (let (($x46898 (or $x45436 $x46893)))
 (let ((@x46899 ((_ quant-inst (Add ?x7368 8)) $x46898)))
 (let ((@x50776 (unit-resolution @x46899 @x8959 $x46893)))
 (let (($x49971 (not $x47071)))
 (let (($x49970 (not $x48901)))
 (let (($x49969 (not $x48893)))
 (let (($x49932 (not $x48512)))
 (let (($x49930 (not $x48889)))
 (let (($x49968 (not $x48885)))
 (let (($x49967 (not $x48482)))
 (let ((@x50796 ((_ th-lemma arith assign-bounds -1 1 -1 -1 1 1 1 -1 1) (or $x50528 $x49967 $x49968 $x49930 $x49932 $x49969 $x49970 (not $x50737) $x49971 (not $x46987)))))
 (let ((@x50797 (unit-resolution @x50796 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46893) $x50737)) @x50776 $x50737) @x49958 @x49940 @x49963 @x49953 @x49764 @x49761 @x48367 @x48362 $x50528)))
 (let ((?x50521 (+ ?x46890 ?x49711)))
 (let (($x50522 (>= ?x50521 0)))
 (let (($x49705 (>= ?x49703 0)))
 (let ((@x49966 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46897) $x49705)) @x49706 $x49705)))
 (let (($x50736 (<= ?x50729 0)))
 (let ((@x50789 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1) (or $x50522 (not $x49705) (not $x50736) (not $x46986))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46893) $x50736)) @x50776 $x50736) @x49966 @x48359 $x50522)))
 (let (($x46950 (has_type ?x7371 INT)))
 (let ((?x48350 (I 24)))
 (let (($x48351 (has_type ?x48350 INT)))
 (let (($x48381 (not $x48351)))
 (let ((@x48378 (monotonicity (monotonicity (symm @x48372 (= 24 ?x7370)) (= ?x48350 ?x7371)) (= $x48351 $x46950))))
 (let ((@x48384 (mp (hypothesis (not $x46950)) (monotonicity (symm @x48378 (= $x46950 $x48351)) (= (not $x46950) $x48381)) $x48381)))
 (let ((@x48386 (unit-resolution (unit-resolution ((_ quant-inst 24) (or (not $x698) $x48351)) @x9099 $x48351) @x48384 false)))
 (let ((@x48387 (lemma @x48386 $x46950)))
 (let (($x46936 (has_type ?x7369 INT)))
 (let ((?x48234 (I 16)))
 (let (($x48235 (has_type ?x48234 INT)))
 (let (($x48258 (not $x48235)))
 (let ((@x48255 (monotonicity (monotonicity (trans* @x48247 @x48249 (= 16 ?x7368)) (= ?x48234 ?x7369)) (= $x48235 $x46936))))
 (let ((@x48261 (mp (hypothesis (not $x46936)) (monotonicity (symm @x48255 (= $x46936 $x48235)) (= (not $x46936) $x48258)) $x48258)))
 (let ((@x48263 (unit-resolution (unit-resolution ((_ quant-inst 16) (or (not $x698) $x48235)) @x9099 $x48235) @x48261 false)))
 (let ((@x48264 (lemma @x48263 $x46936)))
 (let (($x45475 (has_type ?x44888 ?x1968)))
 (let ((@x48995 (symm (monotonicity @x48863 (= (vstd!seq.Seq.add.? $ ?x1876 ?x44851 ?x44026) ?x44888)) (= ?x44888 (vstd!seq.Seq.add.? $ ?x1876 ?x44851 ?x44026)))))
 (let ((@x49002 (monotonicity @x48995 (= $x45475 (has_type (vstd!seq.Seq.add.? $ ?x1876 ?x44851 ?x44026) ?x1968)))))
 (let ((@x49004 (symm @x49002 (= (has_type (vstd!seq.Seq.add.? $ ?x1876 ?x44851 ?x44026) ?x1968) $x45475))))
 (let ((?x45316 (vstd!seq.Seq.add.? $ ?x1876 ?x44851 ?x44026)))
 (let (($x45317 (has_type ?x45316 ?x1968)))
 (let ((@x48999 (monotonicity (trans* @x48991 @x48995 (= ?x44057 ?x45316)) @x48618 (= (has_type ?x44057 ?x44591) $x45317))))
 (let (($x45273 (has_type ?x44057 ?x44591)))
 (let (($x45283 (or $x44596 $x44886 $x45273)))
 (let ((@x45288 (mp ((_ quant-inst $ (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)) (or $x44596 (or $x44886 $x45273))) (rewrite (= (or $x44596 (or $x44886 $x45273)) $x45283)) $x45283)))
 (let ((@x48990 (unit-resolution @x45288 @x11208 (unit-resolution (def-axiom (or $x44915 $x44884)) @x48988 $x44884) $x45273)))
 (let ((@x49005 (mp (mp @x48990 @x48999 $x45317) @x49004 $x45475)))
 (let (($x14139 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x13939 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x13938 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x13143 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x13979 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x13953 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x13943 (not $x4256)))
 (or $x13943 $x13953 $x271 $x13979 $x13143 $x13938 $x13939 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x45941 (= $x4641 $x1589)))
 (let ((@x45943 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x45941)) @x45572 (hypothesis (not $x45941)) false)))
 (let ((@x45955 (lemma @x45943 $x45941)))
 (let ((@x45948 (def-axiom (or (not $x45941) $x4641 $x13285))))
 (let ((@x48982 (unit-resolution @x45948 (unit-resolution (def-axiom (or $x13291 $x1589)) @x48086 $x1589) (or (not $x45941) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x14190 (or $x4675 $x14139)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x10981 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x11004 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x10981) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x14192 (mp (mp (mp~ @x4681 @x11004 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x14190)) $x14190)))
 (let ((@x48984 (unit-resolution @x14192 (unit-resolution @x48982 @x45955 $x4641) $x14139)))
 (let (($x50523 (not $x50528)))
 (let (($x50526 (not $x50522)))
 (let (($x50452 (not $x50451)))
 (let (($x46951 (not $x46950)))
 (let (($x46943 (not $x46936)))
 (let (($x45476 (not $x45475)))
 (let (($x48929 (not $x14139)))
 (let (($x50730 (or $x48929 $x45476 $x46943 $x46951 $x45720 $x50452 $x50526 $x50523 $x50531)))
 (let ((@x50738 (rewrite (= (or $x48929 (or $x45476 $x46943 $x46951 $x45720 $x50452 $x50526 $x50523 $x50531)) $x50730))))
 (let ((@x50739 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7368) (I ?x7370)) (or $x48929 (or $x45476 $x46943 $x46951 $x45720 $x50452 $x50526 $x50523 $x50531))) @x50738 $x50730)))
 (let ((@x50812 (symm (unit-resolution @x50739 @x175 @x48984 @x49005 @x48264 @x48387 @x50789 @x50797 @x50744 $x50531) (= ?x50530 ?x50529))))
 (let ((@x50806 (monotonicity (trans* (symm @x50776 (= ?x46890 ?x7370)) @x48372 (= ?x46890 24)) (trans* (symm @x49706 (= ?x46896 ?x7368)) @x48245 @x48237 (= ?x46896 16)) (= ?x50530 (Sub 24 16)))))
 (let ((?x50745 (Sub 24 16)))
 (let (($x50759 (= ?x50745 8)))
 (let (($x50764 (or $x45535 $x50759)))
 (let ((?x50746 (+ 16 ?x47006 ?x50745)))
 (let (($x50747 (= ?x50746 0)))
 (let (($x50765 (or $x45535 $x50747)))
 (let (($x50767 (= $x50765 $x50764)))
 (let ((@x50755 (trans (monotonicity (rewrite (= ?x47006 (- 24))) (= ?x50746 (+ 16 (- 24) ?x50745))) (rewrite (= (+ 16 (- 24) ?x50745) (+ (- 8) ?x50745))) (= ?x50746 (+ (- 8) ?x50745)))))
 (let ((@x50763 (trans (monotonicity @x50755 (= $x50747 (= (+ (- 8) ?x50745) 0))) (rewrite (= (= (+ (- 8) ?x50745) 0) $x50759)) (= $x50747 $x50759))))
 (let ((@x50772 (mp ((_ quant-inst 24 16) $x50765) (trans (monotonicity @x50763 $x50767) (rewrite (= $x50764 $x50764)) $x50767) $x50764)))
 (let ((@x50815 (trans* @x48641 @x48643 @x48611 (symm (unit-resolution @x50772 @x9204 $x50759) (= 8 ?x50745)) (symm @x50806 (= ?x50745 ?x50530)) @x50812 (symm (monotonicity @x50802 (= ?x50180 ?x50529)) $x50813) $x50183)))
 (let ((@x50818 (lemma (unit-resolution (hypothesis (not $x50183)) @x50815 false) $x50183)))
 (let ((@x51051 (trans* @x50812 (monotonicity @x50800 $x50813) (symm @x50818 (= ?x50180 ?x47649)) @x48641 @x48643 @x48611 $x50878)))
 (let ((@x51061 ((_ th-lemma arith farkas -1 1 1 1 1) @x51060 @x51057 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50878) $x50886)) @x51051 $x50886) (hypothesis $x50831) @x51043 false)))
 (let ((@x51064 (lemma @x51061 (or $x51062 $x50122))))
 (let (($x14209 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13839 (not $x821)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4686 (sized A&.)))
 (let (($x14159 (not $x4686)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k! INT)))
 (let (($x13953 (not $x4257)))
 (let (($x4684 (has_type j! INT)))
 (let (($x14199 (not $x4684)))
 (or (not (has_type s! (TYPE%vstd!seq.Seq. A&. A&))) $x14199 $x13953 $x271 $x14159 (not (>= (%I j!) 0)) (not (<= (+ (%I j!) (* (- 1) (%I k!))) 0)) (not $x4711) $x13839 $x4741 $x4703)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4682 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x45956 (= $x4682 $x1590)))
 (let ((@x45958 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_index.) (or (not $x30) $x45956)) @x45572 (hypothesis (not $x45956)) false)))
 (let ((@x45970 (lemma @x45958 $x45956)))
 (let ((@x45963 (def-axiom (or (not $x45956) $x4682 $x13286))))
 (let ((@x49876 (unit-resolution @x45963 (unit-resolution (def-axiom (or $x13291 $x1590)) @x48086 $x1590) (or (not $x45956) $x4682))))
 (let (($x4749 (not $x4682)))
 (let (($x14214 (or $x4749 $x14209)))
 (let (($x4774 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (or (not $x4685) $x4759 $x4703)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4779 (or $x4749 $x4774)))
 (let ((?x11013 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (refl (~ $x4769 $x4769)))))))))))))))))))))))
 ))
 (let ((@x11018 (monotonicity (refl (~ $x4749 $x4749)) (nnf-pos (proof-bind ?x11013) (~ $x4774 $x4774)) (~ $x4779 $x4779))))
 (let (($x4707 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) (%I j!))))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let ((?x1186 (%I j!)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4686 (sized A&.)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (=> (and $x4685 $x4697) $x4703))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4708 (=> $x4682 $x4707)))
 (let ((?x4775 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) ?x1186)))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x4705 (=> (and $x4685 $x4697) $x4703)))
 (let ((@x4734 (rewrite (= (and $x4686 (and $x4710 $x4714 $x4711)) (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4723 (monotonicity (rewrite (= $x4689 (and $x4710 $x4714))) (rewrite (= $x4691 $x4711)) (= $x4692 (and (and $x4710 $x4714) $x4711)))))
 (let ((@x4728 (trans @x4723 (rewrite (= (and (and $x4710 $x4714) $x4711) (and $x4710 $x4714 $x4711))) (= $x4692 (and $x4710 $x4714 $x4711)))))
 (let ((@x4736 (trans (monotonicity @x4728 (= $x4693 (and $x4686 (and $x4710 $x4714 $x4711)))) @x4734 (= $x4693 (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4742 (monotonicity @x4736 (rewrite (= $x4696 (and $x821 $x4746))) (= $x4697 (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746))))))
 (let ((@x4755 (trans @x4742 (rewrite (= (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746)) $x4745)) (= $x4697 $x4745))))
 (let ((@x4764 (trans (monotonicity @x4755 (= $x4704 (=> $x4745 $x4703))) (rewrite (= (=> $x4745 $x4703) (or $x4759 $x4703))) (= $x4704 (or $x4759 $x4703)))))
 (trans (monotonicity @x4764 (= $x4705 (=> $x4685 (or $x4759 $x4703)))) (rewrite (= (=> $x4685 (or $x4759 $x4703)) $x4769)) (= $x4705 $x4769))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4747 (monotonicity (quant-intro (proof-bind ?x4775) (= $x4707 $x4774)) (= $x4708 (=> $x4682 $x4774)))))
 (let ((@x4784 (mp (asserted $x4708) (trans @x4747 (rewrite (= (=> $x4682 $x4774) $x4779)) (= $x4708 $x4779)) $x4779)))
 (let ((@x14216 (mp (mp (mp~ @x4784 @x11018 $x4779) (rewrite (= $x4779 $x4779)) $x4779) (rewrite (= $x4779 $x14214)) $x14214)))
 (let ((@x49878 (unit-resolution @x14216 (unit-resolution @x49876 @x45970 $x4682) $x14209)))
 (let (($x49116 (not $x14209)))
 (let (($x50898 (or $x49116 $x45476 $x46943 $x46951 $x50175 $x45720 $x50452 $x50526 $x50523 $x50125 $x50831 $x50836)))
 (let ((?x50820 (+ ?x46896 ?x50533)))
 (let (($x50821 (<= ?x50820 0)))
 (let (($x50828 (not $x50821)))
 (let (($x50837 (or $x45476 $x46943 $x46951 $x50175 $x45720 $x50452 $x50828 $x50523 $x50125 $x50831 $x50836)))
 (let (($x50899 (or $x49116 $x50837)))
 (let (($x50860 (or $x45476 $x46943 $x46951 $x50175 $x45720 $x50452 $x50526 $x50523 $x50125 $x50831 $x50836)))
 (let (($x50905 (or $x49116 $x50860)))
 (let (($x50893 (= $x50837 $x50860)))
 (let ((@x50897 (trans (monotonicity (rewrite (= $x50828 $x50526)) $x50893) (rewrite (= $x50860 $x50860)) $x50893)))
 (let ((@x50915 (trans (monotonicity @x50897 (= $x50899 $x50905)) (rewrite (= $x50905 $x50898)) (= $x50899 $x50898))))
 (let ((@x50916 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7368) (I ?x7370) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44072 ?x44071 ?x1876 $)) $x50899) @x50915 $x50898)))
 (let ((@x51436 (unit-resolution @x50916 @x175 @x49878 @x49005 @x48264 @x48387 @x51341 @x51417 @x50789 @x50797 @x50744 (unit-resolution @x51064 @x51430 $x51062) $x50836)))
 (let ((?x51319 (Sub ?x50833 16)))
 (let (($x51344 (= ?x50119 ?x51319)))
 (let ((?x51325 (* (- 1) ?x51319)))
 (let ((?x51345 (+ ?x50119 ?x51325)))
 (let (($x51346 (<= ?x51345 0)))
 (let ((?x51326 (+ ?x50833 ?x51325)))
 (let (($x51338 (<= ?x51326 16)))
 (let (($x51324 (= ?x51326 16)))
 (let (($x51329 (or $x45535 $x51324)))
 (let (($x51323 (= (+ 16 (* (- 1) ?x50833) ?x51319) 0)))
 (let (($x51330 (or $x45535 $x51323)))
 (let (($x51332 (= $x51330 $x51329)))
 (let ((@x51336 (trans (monotonicity (rewrite (= $x51323 $x51324)) $x51332) (rewrite (= $x51329 $x51329)) $x51332)))
 (let ((@x51442 (unit-resolution (mp ((_ quant-inst (Add ?x50119 ?x46896) 16) $x51330) @x51336 $x51329) @x9204 $x51324)))
 (let ((@x51459 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x51346 $x51422 $x51423 (not $x51338))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51324) $x51338)) @x51442 $x51338) @x51407 @x51410 $x51346)))
 (let (($x51347 (>= ?x51345 0)))
 (let (($x51339 (>= ?x51326 16)))
 (let ((@x51452 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x51347 (not $x50854) (not $x51167) (not $x51339))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x51324) $x51339)) @x51442 $x51339) @x51299 @x51290 $x51347)))
 (let ((@x51460 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x51344 (not $x51346) (not $x51347))) @x51452 @x51459 $x51344)))
 (let ((@x51358 (trans* (symm @x48647 (= 16 ?x48175)) (symm @x48837 (= ?x48175 ?x48171)) (symm @x48782 (= ?x48171 ?x48163)) (symm @x48835 (= ?x48163 ?x46079)) (= 16 ?x46079))))
 (let ((@x51365 (monotonicity (trans* @x51175 (symm @x51309 (= ?x51067 ?x50983)) (= ?x50833 ?x50983)) @x51358 (= ?x51319 ?x51098))))
 (let ((@x51371 (trans* (symm @x51365 (= ?x51098 ?x51319)) (symm (hypothesis $x51344) (= ?x51319 ?x50119)) (= ?x51098 ?x50119))))
 (let ((@x51378 (trans* (hypothesis $x50870) (symm (monotonicity @x51371 (= ?x51099 ?x50869)) (= ?x50869 ?x51099)) (= ?x50086 ?x51099))))
 (let ((@x51391 (trans* (monotonicity @x51378 (= ?x50143 ?x51100)) (symm (hypothesis $x51095) (= ?x51100 ?x51032)) (monotonicity @x48865 @x51308 (= ?x51032 ?x50835)) (symm (hypothesis $x50836) (= ?x50835 ?x50832)) (symm (monotonicity @x50802 (= ?x50089 ?x50832)) (= ?x50832 ?x50089)) $x50146)))
 (let ((@x51399 (lemma (unit-resolution (hypothesis (not $x50146)) @x51391 false) (or (not $x51344) $x50146 (not $x50836) (not $x51095) (not $x50870)))))
 (let ((@x51461 (unit-resolution @x51399 @x51460 (unit-resolution (def-axiom (or $x50176 (not $x50146))) @x51340 (not $x50146)) @x51436 @x51434 (unit-resolution @x50971 @x8980 @x51341 $x50870) false)))
 (let ((@x51462 (lemma @x51461 $x50176)))
 (let (($x50184 (not $x50183)))
 (let (($x50177 (or $x44073 $x50184 $x50174)))
 (let (($x50186 (not $x50177)))
 (let (($x50253 (forall ((i$ Poly) )(! (let ((?x7368 (Sub pmemlog!logimpl_v.header_log_size_offset.? 8)))
 (let ((?x7370 (Add ?x7368 8)))
 (let ((?x7371 (I ?x7370)))
 (let ((?x7369 (I ?x7368)))
 (let ((?x44044 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44057 (vstd!view.View.view.? $ ?x1878 ?x44044)))
 (let ((?x44072 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7369 ?x7371)))
 (let ((?x50188 (vstd!seq.Seq.index.? $ ?x1876 ?x44072 i$)))
 (let ((?x44071 (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1)))
 (let ((?x50187 (vstd!seq.Seq.index.? $ ?x1876 ?x44071 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13839 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13839 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x44071))) 0) (= ?x50187 ?x50188))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)) (I (Sub pmemlog!logimpl_v.header_log_size_offset.? 8)) (I (Add (Sub pmemlog!logimpl_v.header_log_size_offset.? 8) 8))) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x50254 (not $x50253)))
 (let (($x50255 (or $x50184 $x50254)))
 (let (($x50260 (not $x50255)))
 (let (($x44357 (not $x44073)))
 (let (($x50261 (or $x44357 $x50260)))
 (let (($x50256 (not $x50261)))
 (let (($x50262 (or $x50256 $x50186)))
 (let (($x50257 (not $x50262)))
 (let (($x50263 (has_type ?x44072 ?x1968)))
 (let (($x50378 (has_type ?x50354 ?x1968)))
 (let (($x13973 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x13953 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x13943 (not $x4256)))
 (or $x13943 $x13953 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x13974 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x13953 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x13943 (not $x4256)))
 (let (($x13968 (or $x13943 $x13953 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x13960 (monotonicity (rewrite (= $x4258 (not (or $x13943 $x13953 $x271)))) (= $x4266 (not (not (or $x13943 $x13953 $x271)))))))
 (let ((@x13964 (trans @x13960 (rewrite (= (not (not (or $x13943 $x13953 $x271))) (or $x13943 $x13953 $x271))) (= $x4266 (or $x13943 $x13953 $x271)))))
 (trans (monotonicity @x13964 (= $x4269 (or (or $x13943 $x13953 $x271) $x4261))) (rewrite (= (or (or $x13943 $x13953 $x271) $x4261) $x13968)) (= $x4269 $x13968))))))))))))))))))
 ))
 (let ((?x10749 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x13978 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x10749) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x13974) (= $x4272 $x13973)) $x13973)))
 (let (($x45498 (not $x13973)))
 (let (($x50382 (or $x45498 $x45476 $x46943 $x46951 $x50378)))
 (let ((@x50419 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7368) (I ?x7370)) (or $x45498 (or $x45476 $x46943 $x46951 $x50378))) (rewrite (= (or $x45498 (or $x45476 $x46943 $x46951 $x50378)) $x50382)) $x50382)))
 (let ((@x51090 (mp (unit-resolution @x50419 @x13978 @x49005 @x48264 @x48387 $x50378) (monotonicity @x50800 (= $x50378 $x50263)) $x50263)))
 (let (($x14183 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10848 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10860 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10848) (vstd!seq.Seq.index.? A&. A& s2! ?x10848))))
 (let (($x10899 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x10848))) 0)))
 (let (($x10850 (not (has_type ?x10848 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10845 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x14164 (not (or $x4527 $x10845 (not (or $x10850 (not (>= (%I ?x10848) 0)) $x10899 $x10860))))))
 (let (($x14135 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13839 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13839 $x4552 $x4534))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x10832 (not $x4527)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14104 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x13851 (not $x4101)))
 (or $x13851 $x14104 $x4431 (not (or (not (or $x10832 (not (or $x10845 (not $x14135))))) $x14164)))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4524 (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x45670 (= $x4524 $x1587)))
 (let ((@x45672 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_ext_equal.) (or (not $x30) $x45670)) @x45572 (hypothesis (not $x45670)) false)))
 (let ((@x45684 (lemma @x45672 $x45670)))
 (let ((@x45677 (def-axiom (or (not $x45670) $x4524 $x13283))))
 (let ((@x51017 (unit-resolution @x45677 (unit-resolution (def-axiom (or $x13291 $x1587)) @x48086 $x1587) (or (not $x45670) $x4524))))
 (let (($x4583 (not $x4524)))
 (let (($x14116 (or $x4583 $x14183)))
 (let (($x10913 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10848 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10860 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10848) (vstd!seq.Seq.index.? A&. A& s2! ?x10848))))
 (let (($x10899 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x10848))) 0)))
 (let ((?x10851 (%I ?x10848)))
 (let (($x10852 (>= ?x10851 0)))
 (let (($x10850 (not (has_type ?x10848 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10845 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10832 (not $x4527)))
 (let (($x10871 (or $x10832 $x4548)))
 (let (($x10914 (and $x10871 (or $x4527 $x10845 (not (or $x10850 (not (and $x10852 (not $x10899))) $x10860))))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x10914)))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x10887 (or $x4583 $x10913)))
 (let (($x10878 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10848 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10860 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10848) (vstd!seq.Seq.index.? A&. A& s2! ?x10848))))
 (let (($x10854 (>= (+ (%I ?x10848) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x10851 (%I ?x10848)))
 (let (($x10852 (>= ?x10851 0)))
 (let (($x10850 (not (has_type ?x10848 INT))))
 (let (($x10862 (not (or $x10850 (not (and $x10852 (not $x10854))) $x10860))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10845 (not $x4529)))
 (let (($x10866 (or $x10845 $x10862)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10832 (not $x4527)))
 (let (($x10871 (or $x10832 $x4548)))
 (let (($x10872 (and $x10871 (or $x4527 $x10866))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x10872)))))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x10883 (or $x4583 $x10878)))
 (let (($x4576 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4559))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4584 (or $x4583 $x4576)))
 (let ((?x10879 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x10848 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10860 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10848) (vstd!seq.Seq.index.? A&. A& s2! ?x10848))))
 (let (($x10854 (>= (+ (%I ?x10848) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x10851 (%I ?x10848)))
 (let (($x10852 (>= ?x10851 0)))
 (let (($x10850 (not (has_type ?x10848 INT))))
 (let (($x10862 (not (or $x10850 (not (and $x10852 (not $x10854))) $x10860))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10845 (not $x4529)))
 (let (($x10866 (or $x10845 $x10862)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10832 (not $x4527)))
 (let (($x10871 (or $x10832 $x4548)))
 (let (($x10872 (and $x10871 (or $x4527 $x10866))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x10875 (or $x4568 $x4431 $x10872)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let ((@x10847 (refl (~ $x10845 $x10845))))
 (let ((?x10839 (lambda ((i$ Poly) )(let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4569 (or $x271 $x4554 $x4534)))
 (refl (~ $x4569 $x4569))))))))))))))))
 ))
 (let ((@x10836 (refl (~ $x4529 $x4529))))
 (let ((@x10844 (monotonicity @x10836 (nnf-pos (proof-bind ?x10839) (~ $x4574 $x4574)) (~ $x4548 $x4548))))
 (let ((@x10874 (nnf-pos (refl (~ $x4527 $x4527)) (refl (~ $x10832 $x10832)) @x10844 (nnf-neg @x10847 (sk (~ (not $x4574) $x10862)) (~ (not $x4548) $x10866)) (~ $x4559 $x10872))))
 (let ((@x10829 (refl (~ $x4431 $x4431))))
 (let ((@x10827 (refl (~ $x4568 $x4568))))
 (monotonicity @x10827 @x10829 @x10874 (~ $x4570 $x10875))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x10885 (monotonicity (refl (~ $x4583 $x4583)) (nnf-pos (proof-bind ?x10879) (~ $x4576 $x10878)) (~ $x4584 $x10883))))
 (let (($x4545 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x3858 (sized A&.)))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4541))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4546 (=> $x4524 $x4545)))
 (let ((?x4577 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4543 (=> (and $x4526 $x3858) $x4541)))
 (let ((@x4564 (trans (monotonicity (rewrite (= $x4541 $x4559)) (= $x4542 (=> $x3858 $x4559))) (rewrite (= (=> $x3858 $x4559) (or $x4431 $x4559))) (= $x4542 (or $x4431 $x4559)))))
 (trans (monotonicity @x4564 (= $x4543 (=> $x4526 (or $x4431 $x4559)))) (rewrite (= (=> $x4526 (or $x4431 $x4559)) $x4570)) (= $x4543 $x4570)))))))))))))))))))))))
 ))
 (let ((@x4582 (monotonicity (quant-intro (proof-bind ?x4577) (= $x4545 $x4576)) (= $x4546 (=> $x4524 $x4576)))))
 (let ((@x4589 (mp (asserted $x4546) (trans @x4582 (rewrite (= (=> $x4524 $x4576) $x4584)) (= $x4546 $x4584)) $x4584)))
 (let ((@x14105 (mp (mp (mp~ @x4589 @x10885 $x10883) (rewrite (= $x10883 $x10887)) $x10887) (rewrite (= $x10887 $x14116)) $x14116)))
 (let ((@x51024 (unit-resolution @x14105 (unit-resolution @x51017 @x45684 $x4524) $x14183)))
 (let (($x50384 (not $x50263)))
 (let (($x45805 (not $x14183)))
 (let (($x50423 (or $x45805 $x47654 $x50384 $x45720 $x50257)))
 (let ((@x50426 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7369 ?x7371)) (or $x45805 (or $x47654 $x50384 $x45720 $x50257))) (rewrite (= (or $x45805 (or $x47654 $x50384 $x45720 $x50257)) $x50423)) $x50423)))
 (let ((@x51091 (unit-resolution (unit-resolution @x50426 @x175 @x51024 @x48860 (or $x50384 $x50257)) @x51090 $x50257)))
 (let ((@x50462 (def-axiom (or $x50262 $x50177))))
 (let ((@x50460 (def-axiom (or $x50186 $x44073 $x50184 $x50174))))
 (let ((@x51213 (unit-resolution @x50460 @x50818 (unit-resolution @x50462 @x51091 $x50177) (or $x44073 $x50174))))
 (let ((@x51214 (unit-resolution @x51213 @x51462 $x44073)))
 (let (($x44222 (not $x44142)))
 (let (($x44224 (or $x44222 $x44223)))
 (let (($x44225 (not $x44224)))
 (let (($x44231 (or $x44163 $x44152 $x44225)))
 (let (($x44215 (not $x44231)))
 (let ((?x49079 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44065 ?x44064 ?x1876 $)))
 (let ((?x49074 (vstd!seq.Seq.index.? $ ?x1876 ?x44065 ?x49079)))
 (let ((?x49094 (vstd!seq.Seq.index.? $ ?x1876 ?x44064 ?x49079)))
 (let (($x49117 (= ?x49094 ?x49074)))
 (let ((?x49119 (%I ?x49079)))
 (let ((?x49143 (* (- 1) ?x49119)))
 (let ((?x49144 (+ ?x47603 ?x49143)))
 (let (($x49142 (<= ?x49144 0)))
 (let (($x49145 (>= ?x49119 0)))
 (let (($x49146 (not $x49145)))
 (let (($x49151 (has_type ?x49079 INT)))
 (let (($x49157 (not $x49151)))
 (let (($x49158 (or $x49157 $x49146 $x49142 $x49117)))
 (let (($x49150 (not $x49158)))
 (let ((@x50578 (hypothesis $x49150)))
 (let ((@x49453 (def-axiom (or $x49158 $x49145))))
 (let ((@x50579 (unit-resolution @x49453 @x50578 $x49145)))
 (let ((?x45844 (* (- 1) ?x45825)))
 (let ((?x47564 (+ ?x44708 ?x45844)))
 (let (($x47560 (>= ?x47564 0)))
 (let (($x47563 (= ?x44708 ?x45825)))
 (let ((@x49353 (symm @x48750 (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44705)) ?x45825))))
 (let ((@x49351 (symm @x48752 (= ?x44708 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44705))))))
 (let ((@x49355 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47563) $x47560)) (trans* @x49351 @x49353 $x47563) $x47560)))
 (let (($x45457 (<= ?x44708 8)))
 (let ((@x49358 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x44710 $x45457)) @x48721 $x45457)))
 (let (($x50512 (<= (+ ?x45825 (* (- 1) (%I (I (%I (I (Add ?x49119 (%I ?x7359)))))))) 0)))
 (let (($x50542 (not $x50512)))
 (let ((?x45465 (%I ?x7359)))
 (let ((?x50019 (Add ?x49119 ?x45465)))
 (let ((?x50020 (I ?x50019)))
 (let ((?x50128 (%I ?x50020)))
 (let ((?x50387 (I ?x50128)))
 (let ((?x50077 (%I ?x50387)))
 (let ((?x50285 (* (- 1) ?x50077)))
 (let ((?x50551 (+ ?x48171 ?x50285)))
 (let (($x50552 (<= ?x50551 0)))
 (let (($x50691 (not $x50552)))
 (let ((?x49811 (* (- 1) ?x48171)))
 (let ((?x49654 (+ ?x46079 ?x49811)))
 (let (($x49690 (<= ?x49654 0)))
 (let ((@x50688 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x46079 ?x48171)) $x49690)) (trans* @x48835 @x48782 (= ?x46079 ?x48171)) $x49690)))
 (let ((?x50286 (+ ?x46079 ?x50285)))
 (let (($x50287 (<= ?x50286 0)))
 (let (($x50306 (not $x50287)))
 (let (($x49457 (not $x49142)))
 (let ((@x49459 (def-axiom (or $x49158 $x49457))))
 (let ((@x50689 (unit-resolution @x49459 @x50578 $x49457)))
 (let ((@x50211 (hypothesis $x49457)))
 (let ((?x50269 (Add ?x49119 8)))
 (let ((?x50270 (* (- 1) ?x50269)))
 (let ((?x50275 (+ ?x49119 ?x50270)))
 (let (($x50070 (>= ?x50275 (- 8))))
 (let (($x50038 (= ?x50275 (- 8))))
 (let (($x50056 (or $x45516 $x50038)))
 (let (($x50274 (= (+ 8 ?x49119 ?x50270) 0)))
 (let (($x50057 (or $x45516 $x50274)))
 (let (($x50061 (= $x50057 $x50056)))
 (let ((@x50069 (trans (monotonicity (rewrite (= $x50274 $x50038)) $x50061) (rewrite (= $x50056 $x50056)) $x50061)))
 (let ((@x50067 (mp ((_ quant-inst (%I ?x49079) 8) $x50057) @x50069 $x50056)))
 (let ((@x50473 (unit-resolution @x50067 @x9197 $x50038)))
 (let ((@x50474 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50038) $x50070)) @x50473 $x50070)))
 (let ((?x50078 (+ ?x50019 ?x50270)))
 (let (($x50071 (<= ?x50078 0)))
 (let (($x50072 (= ?x50019 ?x50269)))
 (let (($x45466 (= ?x7358 ?x45465)))
 (let (($x45469 (or $x45436 $x45466)))
 (let ((@x45470 ((_ quant-inst (Add ?x7356 8)) $x45469)))
 (let ((@x48522 (unit-resolution @x45470 @x8959 $x45466)))
 (let ((?x45531 (* (- 1) ?x7356)))
 (let ((?x45532 (+ pmemlog!logimpl_v.header_head_offset.? ?x45531)))
 (let (($x45545 (<= ?x45532 8)))
 (let (($x45530 (= ?x45532 8)))
 (let (($x45536 (or $x45535 $x45530)))
 (let (($x45529 (= (+ 8 (* (- 1) pmemlog!logimpl_v.header_head_offset.?) ?x7356) 0)))
 (let (($x45537 (or $x45535 $x45529)))
 (let (($x45539 (= $x45537 $x45536)))
 (let ((@x45543 (trans (monotonicity (rewrite (= $x45529 $x45530)) $x45539) (rewrite (= $x45536 $x45536)) $x45539)))
 (let ((@x45544 (mp ((_ quant-inst pmemlog!logimpl_v.header_head_offset.? 8) $x45537) @x45543 $x45536)))
 (let ((@x47908 (unit-resolution @x45544 @x9204 $x45530)))
 (let ((@x47909 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45530) $x45545)) @x47908 $x45545)))
 (let (($x45546 (>= ?x45532 8)))
 (let ((@x47912 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45530) $x45546)) @x47908 $x45546)))
 (let ((?x45506 (* (- 1) ?x7358)))
 (let ((?x45512 (+ ?x7356 ?x45506)))
 (let (($x45526 (<= ?x45512 (- 8))))
 (let (($x45513 (= ?x45512 (- 8))))
 (let (($x45517 (or $x45516 $x45513)))
 (let (($x45510 (= (+ 8 ?x7356 ?x45506) 0)))
 (let (($x45518 (or $x45516 $x45510)))
 (let (($x45520 (= $x45518 $x45517)))
 (let ((@x45524 (trans (monotonicity (rewrite (= $x45510 $x45513)) $x45520) (rewrite (= $x45517 $x45517)) $x45520)))
 (let ((@x45525 (mp ((_ quant-inst (Sub pmemlog!logimpl_v.header_head_offset.? 8) 8) $x45518) @x45524 $x45517)))
 (let ((@x47949 (unit-resolution @x45525 @x9197 $x45513)))
 (let ((@x47950 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45513) $x45526)) @x47949 $x45526)))
 (let (($x45527 (>= ?x45512 (- 8))))
 (let ((@x47953 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45513) $x45527)) @x47949 $x45527)))
 (let ((@x47955 ((_ th-lemma arith eq-propagate 1 1 1 1) @x47953 @x47950 @x47912 @x47909 (= pmemlog!logimpl_v.header_head_offset.? ?x7358))))
 (let (($x7277 (= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let (($x7275 (fuel_bool fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x7273 (fuel_bool_default fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x46758 (= $x7275 $x7273)))
 (let ((@x46788 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_head_offset.) (or (not $x30) $x46758)) @x45572 (hypothesis (not $x46758)) false)))
 (let ((@x46801 (lemma @x46788 $x46758)))
 (let ((@x7274 (asserted $x7273)))
 (let ((@x46779 (def-axiom (or (not $x46758) $x7275 (not $x7273)))))
 (let ((@x47918 (unit-resolution (unit-resolution @x46779 @x7274 (or (not $x46758) $x7275)) @x46801 $x7275)))
 (let (($x7280 (not $x7275)))
 (let (($x7281 (or $x7280 $x7277)))
 (let ((@x7284 (mp (asserted (=> $x7275 $x7277)) (rewrite (= (=> $x7275 $x7277) $x7281)) $x7281)))
 (let ((@x47919 (unit-resolution @x7284 @x47918 $x7277)))
 (let ((@x47959 (symm @x47919 (= 8 pmemlog!logimpl_v.header_head_offset.?))))
 (let ((@x50482 (symm (monotonicity (trans* @x47959 @x47955 @x48522 (= 8 ?x45465)) (= ?x50269 ?x50019)) $x50072)))
 (let ((@x50483 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50072) $x50071)) @x50482 $x50071)))
 (let ((?x50199 (* (- 1) ?x50128)))
 (let ((?x50035 (+ ?x50019 ?x50199)))
 (let (($x50058 (>= ?x50035 0)))
 (let (($x50268 (= ?x50019 ?x50128)))
 (let (($x50271 (or $x45436 $x50268)))
 (let ((@x50272 ((_ quant-inst (Add ?x49119 ?x45465)) $x50271)))
 (let ((@x50390 (unit-resolution @x50272 @x8959 $x50268)))
 (let ((?x50360 (+ ?x50077 ?x50199)))
 (let (($x50361 (<= ?x50360 0)))
 (let (($x50359 (= ?x50077 ?x50128)))
 (let (($x50395 (= ?x50387 ?x50020)))
 (let (($x50034 (= ?x50020 ?x50387)))
 (let (($x50140 (has_type ?x50020 INT)))
 (let (($x50388 (has_type ?x50387 INT)))
 (let (($x50401 (not $x50388)))
 (let (($x50399 (= $x50140 $x50388)))
 (let (($x50397 (= $x50388 $x50140)))
 (let ((@x50400 (symm (monotonicity (monotonicity (symm @x50390 (= ?x50128 ?x50019)) $x50395) $x50397) $x50399)))
 (let ((@x50404 (mp (hypothesis (not $x50140)) (monotonicity @x50400 (= (not $x50140) $x50401)) $x50401)))
 (let ((@x50406 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x50020)) (or (not $x698) $x50388)) @x9099 $x50388) @x50404 false)))
 (let ((@x50407 (lemma @x50406 $x50140)))
 (let (($x50141 (not $x50140)))
 (let (($x50044 (or $x48907 $x50141 $x50034)))
 (let ((@x50048 (mp ((_ quant-inst (I ?x50019)) (or $x48907 (or $x50141 $x50034))) (rewrite (= (or $x48907 (or $x50141 $x50034)) $x50044)) $x50044)))
 (let ((@x50492 (symm (unit-resolution @x50048 @x8980 @x50407 $x50034) $x50395)))
 (let ((@x50493 (monotonicity @x50492 $x50359)))
 (let ((?x47636 (* (- 1) ?x47603)))
 (let ((?x47643 (+ ?x44721 ?x47636)))
 (let (($x47645 (>= ?x47643 0)))
 (let (($x47635 (= ?x44721 ?x47603)))
 (let ((@x50223 (symm @x48709 (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44719)) ?x47603))))
 (let ((@x50221 (symm @x48711 (= ?x44721 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44719))))))
 (let ((@x50225 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47635) $x47645)) (trans* @x50221 @x50223 $x47635) $x47645)))
 (let (($x45461 (<= ?x44721 8)))
 (let ((@x50228 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x44742 $x45461)) @x48680 $x45461)))
 (let ((@x50496 ((_ th-lemma arith farkas -1 1 -1 1 1 -1 1 -1 1 1) @x50228 @x50225 (hypothesis $x50287) @x49764 @x49761 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50359) $x50361)) @x50493 $x50361) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50268) $x50058)) @x50390 $x50058) @x50483 @x50474 @x50211 false)))
 (let ((@x50498 (lemma @x50496 (or $x50306 $x49142))))
 (let ((@x50690 (unit-resolution @x50498 @x50689 $x50306)))
 (let ((?x50537 (Sub ?x50077 ?x45825)))
 (let ((?x50538 (I ?x50537)))
 (let ((?x50539 (vstd!seq.Seq.index.? $ ?x1876 ?x44064 ?x50538)))
 (let ((?x50501 (vstd!seq.Seq.index.? $ ?x1876 ?x48162 ?x50387)))
 (let (($x50540 (= ?x50501 ?x50539)))
 (let (($x50678 (not $x50540)))
 (let ((?x50032 (I ?x49119)))
 (let (($x50033 (= ?x49079 ?x50032)))
 (let ((@x49449 (def-axiom (or $x49158 $x49151))))
 (let ((@x50696 (unit-resolution @x49449 @x50578 $x49151)))
 (let (($x50126 (or $x48907 $x49157 $x50033)))
 (let ((@x50182 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44065 ?x44064 ?x1876 $)) (or $x48907 (or $x49157 $x50033))) (rewrite (= (or $x48907 (or $x49157 $x50033)) $x50126)) $x50126)))
 (let ((?x50280 (vstd!seq.Seq.index.? $ ?x1876 ?x44851 ?x50387)))
 (let ((?x50267 (vstd!seq.Seq.index.? $ ?x1876 ?x48529 ?x50387)))
 (let (($x50281 (= ?x50267 ?x50280)))
 (let (($x50080 (>= ?x50077 0)))
 (let (($x50364 (>= ?x50360 0)))
 (let ((@x50700 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50359) $x50364)) @x50493 $x50364)))
 (let (($x50288 (<= ?x50275 (- 8))))
 (let ((@x50626 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50038) $x50288)) @x50473 $x50288)))
 (let (($x50079 (>= ?x50078 0)))
 (let ((@x50629 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50072) $x50079)) @x50482 $x50079)))
 (let (($x50036 (<= ?x50035 0)))
 (let ((@x50703 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50268) $x50036)) @x50390 $x50036)))
 (let ((@x50707 ((_ th-lemma arith assign-bounds 1 1 1 1 1) (or $x50080 (not $x50364) (not $x50036) (not $x50079) $x49146 (not $x50288)))))
 (let ((@x50711 (mp @x50407 (symm (monotonicity @x50492 $x50397) $x50399) $x50388)))
 (let (($x14338 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13839 (not $x821)))
 (let (($x4282 (sized A&.)))
 (let (($x13979 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x14307 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x13943 (not $x4256)))
 (or $x13943 $x14307 $x271 $x13979 $x13839 $x4552 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x4992 (fuel_bool fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x46001 (= $x4992 $x1593)))
 (let ((@x46003 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index1.) (or (not $x30) $x46001)) @x45572 (hypothesis (not $x46001)) false)))
 (let ((@x46015 (lemma @x46003 $x46001)))
 (let ((@x46008 (def-axiom (or (not $x46001) $x4992 $x13289))))
 (let ((@x49889 (unit-resolution @x46008 (unit-resolution (def-axiom (or $x13291 $x1593)) @x48086 $x1593) (or (not $x46001) $x4992))))
 (let (($x5013 (not $x4992)))
 (let (($x14343 (or $x5013 $x14338)))
 (let (($x5037 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5022 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5042 (or $x5013 $x5037)))
 (let ((?x11062 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (refl (~ $x5032 $x5032)))))))))))))))))))))
 ))
 (let ((@x11067 (monotonicity (refl (~ $x5013 $x5013)) (nnf-pos (proof-bind ?x11062) (~ $x5037 $x5037)) (~ $x5042 $x5042))))
 (let (($x5002 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4282 (sized A&.)))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x4995) $x4998))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5003 (=> $x4992 $x5002)))
 (let ((?x5038 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x5000 (=> (and $x4994 $x4995) $x4998)))
 (let ((@x5009 (monotonicity (rewrite (= $x4531 (and $x821 $x4555))) (= $x4995 (and $x4282 (and $x821 $x4555))))))
 (let ((@x5018 (trans @x5009 (rewrite (= (and $x4282 (and $x821 $x4555)) $x5010)) (= $x4995 $x5010))))
 (let ((@x5027 (trans (monotonicity @x5018 (= $x4999 (=> $x5010 $x4998))) (rewrite (= (=> $x5010 $x4998) (or $x5022 $x4998))) (= $x4999 (or $x5022 $x4998)))))
 (trans (monotonicity @x5027 (= $x5000 (=> $x4994 (or $x5022 $x4998)))) (rewrite (= (=> $x4994 (or $x5022 $x4998)) $x5032)) (= $x5000 $x5032)))))))))))))))))))))))))))))
 ))
 (let ((@x5011 (monotonicity (quant-intro (proof-bind ?x5038) (= $x5002 $x5037)) (= $x5003 (=> $x4992 $x5037)))))
 (let ((@x5047 (mp (asserted $x5003) (trans @x5011 (rewrite (= (=> $x4992 $x5037) $x5042)) (= $x5003 $x5042)) $x5042)))
 (let ((@x14345 (mp (mp (mp~ @x5047 @x11067 $x5042) (rewrite (= $x5042 $x5042)) $x5042) (rewrite (= $x5042 $x14343)) $x14343)))
 (let ((@x49891 (unit-resolution @x14345 (unit-resolution @x49889 @x46015 $x4992) $x14338)))
 (let (($x50264 (not $x50080)))
 (let (($x49155 (not $x14338)))
 (let (($x50320 (or $x49155 $x45307 $x47654 $x50401 $x45720 $x50264 $x50287 $x50281)))
 (let ((?x50265 (+ ?x50077 ?x49365)))
 (let (($x50266 (>= ?x50265 0)))
 (let (($x50276 (or $x45307 $x47654 $x50401 $x45720 $x50264 $x50266 $x50281)))
 (let (($x50321 (or $x49155 $x50276)))
 (let ((@x50327 (rewrite (= (or $x49155 (or $x45307 $x47654 $x50401 $x45720 $x50264 $x50287 $x50281)) $x50320))))
 (let (($x50316 (or $x45307 $x47654 $x50401 $x45720 $x50264 $x50287 $x50281)))
 (let (($x50317 (= $x50276 $x50316)))
 (let ((@x50279 (rewrite (= ?x50265 (+ ?x49365 ?x50077)))))
 (let ((@x50315 (trans (monotonicity @x50279 (= $x50266 (>= (+ ?x49365 ?x50077) 0))) (rewrite (= (>= (+ ?x49365 ?x50077) 0) $x50287)) (= $x50266 $x50287))))
 (let ((@x50325 (monotonicity (trans (monotonicity @x50315 $x50317) (rewrite (= $x50316 $x50316)) $x50317) (= $x50321 (or $x49155 $x50316)))))
 (let ((@x50713 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44834 ?x44012) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1) (I ?x50128)) $x50321) (trans @x50325 @x50327 (= $x50321 $x50320)) $x50320) @x175 @x49891 @x48853 @x48860 (or $x50401 $x50264 $x50287 $x50281))))
 (let ((@x50714 (unit-resolution @x50713 @x50690 @x50711 (unit-resolution @x50707 @x50579 @x50703 @x50629 @x50626 @x50700 $x50080) $x50281)))
 (let ((?x50021 (vstd!seq.Seq.index.? $ ?x1876 ?x44888 ?x50020)))
 (let ((?x49196 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44888 ?x7359 ?x7369)))
 (let ((?x50018 (vstd!seq.Seq.index.? $ ?x1876 ?x49196 ?x49079)))
 (let (($x50022 (= ?x50018 ?x50021)))
 (let ((?x49644 (Sub ?x46896 ?x45465)))
 (let ((?x50009 (* (- 1) ?x49644)))
 (let ((?x50010 (+ ?x49119 ?x50009)))
 (let (($x50017 (>= ?x50010 0)))
 (let (($x50230 (not $x50017)))
 (let ((?x50041 (+ ?x7362 ?x50009)))
 (let (($x50042 (<= ?x50041 0)))
 (let (($x49997 (= ?x7362 ?x49644)))
 (let ((@x48979 (trans* (symm @x48522 (= ?x45465 ?x7358)) (symm @x47955 (= ?x7358 pmemlog!logimpl_v.header_head_offset.?)) @x47919 (= ?x45465 8))))
 (let ((@x49842 (symm @x49706 (= ?x46896 ?x7368))))
 (let ((@x49837 (trans* @x49842 @x48245 @x48237 (symm @x48663 (= 16 pmemlog!logimpl_v.header_tail_offset.?)) (= ?x46896 pmemlog!logimpl_v.header_tail_offset.?))))
 (let ((@x49998 (symm (monotonicity @x49837 @x48979 (= ?x49644 ?x7362)) $x49997)))
 (let ((@x50229 ((_ th-lemma arith farkas -1 1 1 1 -1 1) @x50228 @x50225 (hypothesis $x50017) @x48670 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49997) $x50042)) @x49998 $x50042) @x50211 false)))
 (let ((@x50232 (lemma @x50229 (or $x50230 $x49142))))
 (let (($x49662 (>= ?x45465 0)))
 (let (($x43664 (>= pmemlog!logimpl_v.header_head_offset.? 0)))
 (let ((?x43677 (* (- 1) pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x441 (uHi 64)))
 (let ((?x43678 (+ ?x441 ?x43677)))
 (let (($x43679 (<= ?x43678 0)))
 (let (($x43665 (not $x43664)))
 (let (($x43684 (or $x43665 $x43679)))
 (let (($x43710 (not $x43684)))
 (let (($x7285 (uInv 64 pmemlog!logimpl_v.header_head_offset.?)))
 (let (($x43686 (= $x43684 $x7285)))
 (let (($x43689 (not $x43686)))
 (let (($x12924 (forall ((bits Int) (i Int) )(! (let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12799 (or $x540 $x578)))
 (not (= $x12799 $x648))))))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let (($x669 (forall ((bits Int) (i Int) )(! (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x584)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x12925 (lambda ((bits Int) (i Int) )(let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12799 (or $x540 $x578)))
 (let (($x12916 (not (= $x12799 $x648))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x667 (= $x648 $x584)))
 (let (($x12919 (= $x667 $x12916)))
 (let ((@x12802 (rewrite (= $x584 (not $x12799)))))
 (let ((@x12920 (trans (monotonicity @x12802 (= $x667 (= $x648 (not $x12799)))) (rewrite (= (= $x648 (not $x12799)) $x12916)) $x12919)))
 (trans @x12920 (rewrite (= $x12916 $x12916)) $x12919)))))))))))))
 ))
 (let ((?x9074 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (refl (~ $x667 $x667)))))))
 ))
 (let (($x660 (forall ((bits Int) (i Int) )(! (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x548)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x674 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x658 (= $x648 $x548)))
 (rewrite (= $x658 $x667))))))))))
 ))
 (let ((@x640 (mp (asserted $x660) (quant-intro (proof-bind ?x674) (= $x660 $x669)) $x669)))
 (let ((@x12929 (mp (mp~ @x640 (nnf-pos (proof-bind ?x9074) (~ $x669 $x669)) $x669) (quant-intro (proof-bind ?x12925) (= $x669 $x12924)) $x12924)))
 (let (($x43289 (not $x12924)))
 (let (($x43696 (or $x43289 $x43689)))
 (let ((?x43258 (* (- 1) ?x441)))
 (let ((?x43666 (+ pmemlog!logimpl_v.header_head_offset.? ?x43258)))
 (let (($x43667 (>= ?x43666 0)))
 (let (($x43668 (or $x43665 $x43667)))
 (let (($x43669 (= $x43668 $x7285)))
 (let (($x43670 (not $x43669)))
 (let (($x43697 (or $x43289 $x43670)))
 (let (($x43699 (= $x43697 $x43696)))
 (let (($x43691 (= $x43670 $x43689)))
 (let ((@x43695 (trans (monotonicity (rewrite (= $x43669 $x43686)) $x43691) (rewrite (= $x43689 $x43689)) $x43691)))
 (let ((@x43704 (mp ((_ quant-inst 64 pmemlog!logimpl_v.header_head_offset.?) $x43697) (trans (monotonicity @x43695 $x43699) (rewrite (= $x43696 $x43696)) $x43699) $x43696)))
 (let ((@x7286 (asserted $x7285)))
 (let ((@x43721 (def-axiom (or $x43686 $x43710 (not $x7285)))))
 (let ((@x49840 (unit-resolution (unit-resolution @x43721 @x7286 (or $x43686 $x43710)) (unit-resolution @x43704 @x12929 $x43689) $x43710)))
 (let ((@x43706 (def-axiom (or $x43684 $x43664))))
 (let ((?x48506 (* (- 1) ?x45465)))
 (let ((?x48507 (+ ?x7358 ?x48506)))
 (let (($x48508 (<= ?x48507 0)))
 (let ((@x48523 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45466) $x48508)) @x48522 $x48508)))
 (let ((@x49847 ((_ th-lemma arith farkas 1 1 1 1 1) @x48523 @x47950 (unit-resolution @x43706 @x49840 $x43664) @x47909 (hypothesis (not $x49662)) false)))
 (let ((@x49848 (lemma @x49847 $x49662)))
 (let ((?x49638 (+ ?x46896 ?x48488)))
 (let (($x49639 (<= ?x49638 0)))
 (let ((@x49975 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1 1 1 1 1) (or $x49639 $x49967 $x49968 $x49930 $x49932 $x49969 $x49970 $x49971 (not $x49705))) @x49966 @x49940 @x49963 @x49953 @x49764 @x49761 @x49958 @x48367 $x49639)))
 (let ((?x49712 (+ ?x45465 ?x49711)))
 (let (($x49713 (<= ?x49712 0)))
 (let (($x48423 (>= ?x48507 0)))
 (let ((@x48881 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45466) $x48423)) @x48522 $x48423)))
 (let (($x46787 (<= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let ((@x47920 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7277) $x46787)) @x47919 $x46787)))
 (let (($x49853 (or $x49713 (not $x48423) (not $x45527) (not $x46787) (not $x45546) (not $x47072) (not $x49704))))
 (let ((@x49927 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1 1 1) $x49853) @x49465 @x47920 @x48370 @x48881 @x47912 @x47953 $x49713)))
 (let (($x45491 (has_type ?x7359 INT)))
 (let ((?x47799 (I 8)))
 (let (($x47800 (has_type ?x47799 INT)))
 (let (($x47968 (not $x47800)))
 (let ((@x47965 (monotonicity (monotonicity (trans* @x47959 @x47955 (= 8 ?x7358)) (= ?x47799 ?x7359)) (= $x47800 $x45491))))
 (let ((@x47971 (mp (hypothesis (not $x45491)) (monotonicity (symm @x47965 (= $x45491 $x47800)) (= (not $x45491) $x47968)) $x47968)))
 (let ((@x47973 (unit-resolution (unit-resolution ((_ quant-inst 8) (or (not $x698) $x47800)) @x9099 $x47800) @x47971 false)))
 (let ((@x47974 (lemma @x47973 $x45491)))
 (let (($x49640 (not $x49639)))
 (let (($x49716 (not $x49713)))
 (let (($x49663 (not $x49662)))
 (let (($x45492 (not $x45491)))
 (let (($x50147 (or $x49116 $x45476 $x45492 $x46943 $x49157 $x45720 $x49663 $x49716 $x49640 $x49146 $x50017 $x50022)))
 (let (($x50023 (or $x45476 $x45492 $x46943 $x49157 $x45720 $x49663 $x49716 $x49640 $x49146 $x50017 $x50022)))
 (let (($x50123 (or $x49116 $x50023)))
 (let ((@x50117 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7358) (I ?x7368) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44065 ?x44064 ?x1876 $)) $x50123) (rewrite (= $x50123 $x50147)) $x50147)))
 (let ((@x50716 (unit-resolution @x50117 @x175 @x49878 @x49005 @x47974 @x48264 @x50696 @x50579 @x49927 @x49975 @x49848 (unit-resolution @x50232 @x50689 $x50230) $x50022)))
 (let ((@x49982 (symm (monotonicity (trans* @x48672 @x48247 @x48249 (= ?x7364 ?x7368)) (= ?x7365 ?x7369)) (= ?x7369 ?x7365))))
 (let ((@x49986 (monotonicity (trans* @x48665 @x48659 @x47959 @x47955 (= ?x7362 ?x7358)) (= ?x7363 ?x7359))))
 (let ((@x49990 (monotonicity @x49017 (symm @x49986 (= ?x7359 ?x7363)) @x49982 (= ?x49196 ?x44065))))
 (let ((@x49992 (symm @x49990 (= ?x44065 ?x49196))))
 (let ((?x50577 (Sub ?x50019 8)))
 (let (($x50598 (= ?x49119 ?x50577)))
 (let ((?x50583 (* (- 1) ?x50577)))
 (let ((?x50599 (+ ?x49119 ?x50583)))
 (let (($x50601 (>= ?x50599 0)))
 (let ((?x50584 (+ ?x50019 ?x50583)))
 (let (($x50597 (>= ?x50584 8)))
 (let (($x50582 (= ?x50584 8)))
 (let (($x50587 (or $x45535 $x50582)))
 (let (($x50581 (= (+ 8 (* (- 1) ?x50019) ?x50577) 0)))
 (let (($x50588 (or $x45535 $x50581)))
 (let (($x50590 (= $x50588 $x50587)))
 (let ((@x50594 (trans (monotonicity (rewrite (= $x50581 $x50582)) $x50590) (rewrite (= $x50587 $x50587)) $x50590)))
 (let ((@x50613 (unit-resolution (mp ((_ quant-inst (Add ?x49119 ?x45465) 8) $x50588) @x50594 $x50587) @x9204 $x50582)))
 (let ((@x50623 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x50601 (not $x50071) (not $x50070) (not $x50597))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50582) $x50597)) @x50613 $x50597) @x50483 @x50474 $x50601)))
 (let (($x50600 (<= ?x50599 0)))
 (let (($x50596 (<= ?x50584 8)))
 (let ((@x50638 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 -1) (or $x50600 (not $x50079) (not $x50288) (not $x50596))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x50582) $x50596)) @x50613 $x50596) @x50629 @x50626 $x50600)))
 (let ((@x50643 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x50598 (not $x50600) (not $x50601))) @x50638 @x50623 $x50598)))
 (let ((@x50645 (monotonicity (trans* @x50390 (symm @x50493 (= ?x50128 ?x50077)) (= ?x50019 ?x50077)) (trans* (symm @x48721 (= 8 ?x44708)) @x49351 @x49353 (= 8 ?x45825)) (= ?x50577 ?x50537))))
 (let ((@x50651 (trans* (symm @x50645 (= ?x50537 ?x50577)) (symm @x50643 (= ?x50577 ?x49119)) (= ?x50537 ?x49119))))
 (let ((@x50658 (trans* (hypothesis $x50033) (symm (monotonicity @x50651 (= ?x50538 ?x50032)) (= ?x50032 ?x50538)) (= ?x49079 ?x50538))))
 (let ((@x50675 (trans* (monotonicity @x50658 (= ?x49094 ?x50539)) (symm (hypothesis $x50540) (= ?x50539 ?x50501)) (monotonicity @x48831 (= ?x50501 ?x50280)) (symm (hypothesis $x50281) (= ?x50280 ?x50267)) (monotonicity @x48865 @x50492 (= ?x50267 ?x50021)) (symm (hypothesis $x50022) (= ?x50021 ?x50018)) (symm (monotonicity @x49992 (= ?x49074 ?x50018)) (= ?x50018 ?x49074)) $x49117)))
 (let ((@x50683 (lemma (unit-resolution (hypothesis (not $x49117)) @x50675 false) (or $x50678 $x49117 (not $x50022) (not $x50281) (not $x50033)))))
 (let ((@x50718 (unit-resolution @x50683 (unit-resolution (def-axiom (or $x49158 (not $x49117))) @x50578 (not $x49117)) @x50716 @x50714 (unit-resolution @x50182 @x8980 @x50696 $x50033) $x50678)))
 (let (($x50563 (or $x49563 $x45859 $x47608 $x50401 $x45720 $x50542 $x50552 $x50540)))
 (let ((?x50535 (+ ?x50077 ?x49811)))
 (let (($x50536 (>= ?x50535 0)))
 (let ((?x50499 (+ ?x50077 ?x45844)))
 (let (($x50500 (>= ?x50499 0)))
 (let (($x50534 (not $x50500)))
 (let (($x50541 (or $x45859 $x47608 $x50401 $x45720 $x50534 $x50536 $x50540)))
 (let (($x50564 (or $x49563 $x50541)))
 (let ((@x50570 (rewrite (= (or $x49563 (or $x45859 $x47608 $x50401 $x45720 $x50542 $x50552 $x50540)) $x50563))))
 (let (($x50557 (or $x45859 $x47608 $x50401 $x45720 $x50542 $x50552 $x50540)))
 (let (($x50558 (= $x50541 $x50557)))
 (let ((@x50550 (monotonicity (rewrite (= ?x50535 (+ ?x49811 ?x50077))) (= $x50536 (>= (+ ?x49811 ?x50077) 0)))))
 (let ((@x50556 (trans @x50550 (rewrite (= (>= (+ ?x49811 ?x50077) 0) $x50552)) (= $x50536 $x50552))))
 (let ((@x50545 (rewrite (= $x50534 $x50542))))
 (let ((@x50568 (monotonicity (trans (monotonicity @x50545 @x50556 $x50558) (rewrite (= $x50557 $x50557)) $x50558) (= $x50564 (or $x49563 $x50557)))))
 (let ((@x50725 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1) (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1) (I ?x50128)) $x50564) (trans @x50568 @x50570 (= $x50564 $x50563)) $x50563) @x175 @x50723 @x48774 @x48781 @x50711 (or $x50542 $x50552 $x50540))))
 (let ((@x50726 (unit-resolution @x50725 @x50718 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1) (or $x50691 (not $x49690) $x50287)) @x50690 @x50688 $x50691) $x50542)))
 (let ((@x50728 (lemma ((_ th-lemma arith farkas 1 -1 1 -1 1 -1 1 1) @x50700 @x50703 @x50629 @x50626 @x50726 @x49358 @x49355 @x50579 false) $x49158)))
 (let ((?x49140 (vstd!seq.Seq.len.? $ ?x1876 ?x44065)))
 (let (($x49152 (= ?x47603 ?x49140)))
 (let ((@x50002 (symm (monotonicity @x49992 (= ?x49140 (vstd!seq.Seq.len.? $ ?x1876 ?x49196))) (= (vstd!seq.Seq.len.? $ ?x1876 ?x49196) ?x49140))))
 (let ((?x49643 (vstd!seq.Seq.len.? $ ?x1876 ?x49196)))
 (let (($x49645 (= ?x49643 ?x49644)))
 (let (($x49694 (or $x48929 $x45476 $x45492 $x46943 $x45720 $x49663 $x49716 $x49640 $x49645)))
 (let ((?x49635 (+ ?x46896 ?x48506)))
 (let (($x49636 (>= ?x49635 0)))
 (let (($x49637 (not $x49636)))
 (let (($x49646 (or $x45476 $x45492 $x46943 $x45720 $x49663 $x49637 $x49640 $x49645)))
 (let (($x49695 (or $x48929 $x49646)))
 (let ((@x49702 (rewrite (= (or $x48929 (or $x45476 $x45492 $x46943 $x45720 $x49663 $x49716 $x49640 $x49645)) $x49694))))
 (let (($x49642 (or $x45476 $x45492 $x46943 $x45720 $x49663 $x49716 $x49640 $x49645)))
 (let (($x49632 (= $x49646 $x49642)))
 (let ((@x49693 (trans (monotonicity (rewrite (= $x49637 $x49716)) $x49632) (rewrite (= $x49642 $x49642)) $x49632)))
 (let ((@x49463 (trans (monotonicity @x49693 (= $x49695 (or $x48929 $x49642))) @x49702 (= $x49695 $x49694))))
 (let ((@x49976 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7358) (I ?x7368)) $x49695) @x49463 $x49694) @x175 @x48984 @x49005 @x47974 @x48264 @x49927 @x49975 @x49848 $x49645)))
 (let ((@x50003 (trans* @x48709 @x48711 @x48680 @x48754 @x48756 @x49998 (symm @x49976 (= ?x49644 ?x49643)) @x50002 $x49152)))
 (let ((@x50006 (lemma (unit-resolution (hypothesis (not $x49152)) @x50003 false) $x49152)))
 (let (($x49153 (not $x49152)))
 (let (($x49148 (or $x44066 $x49153 $x49150)))
 (let (($x49154 (not $x49148)))
 (let (($x49181 (forall ((i$ Poly) )(! (let ((?x7362 (Sub pmemlog!logimpl_v.header_tail_offset.? 8)))
 (let ((?x7364 (Add ?x7362 8)))
 (let ((?x7365 (I ?x7364)))
 (let ((?x7363 (I ?x7362)))
 (let ((?x44044 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44057 (vstd!view.View.view.? $ ?x1878 ?x44044)))
 (let ((?x44065 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7363 ?x7365)))
 (let ((?x49167 (vstd!seq.Seq.index.? $ ?x1876 ?x44065 i$)))
 (let ((?x44064 (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1)))
 (let ((?x49164 (vstd!seq.Seq.index.? $ ?x1876 ?x44064 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13839 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13839 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x44064))) 0) (= ?x49164 ?x49167))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)) (I (Sub pmemlog!logimpl_v.header_tail_offset.? 8)) (I (Add (Sub pmemlog!logimpl_v.header_tail_offset.? 8) 8))) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x49191 (not $x49181)))
 (let (($x49194 (or $x49153 $x49191)))
 (let (($x49192 (not $x49194)))
 (let (($x44309 (not $x44066)))
 (let (($x49183 (or $x44309 $x49192)))
 (let (($x49184 (not $x49183)))
 (let (($x49182 (or $x49184 $x49154)))
 (let (($x49185 (not $x49182)))
 (let (($x49186 (has_type ?x44065 ?x1968)))
 (let (($x49197 (has_type ?x49196 ?x1968)))
 (let (($x49202 (or $x45498 $x45476 $x45492 $x46943 $x49197)))
 (let ((@x49273 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7358) (I ?x7368)) (or $x45498 (or $x45476 $x45492 $x46943 $x49197))) (rewrite (= (or $x45498 (or $x45476 $x45492 $x46943 $x49197)) $x49202)) $x49202)))
 (let ((@x51259 (mp (unit-resolution @x49273 @x13978 @x49005 @x47974 @x48264 $x49197) (monotonicity @x49990 (= $x49197 $x49186)) $x49186)))
 (let (($x49187 (not $x49186)))
 (let (($x49240 (or $x45805 $x47608 $x49187 $x45720 $x49185)))
 (let ((@x49253 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7363 ?x7365)) (or $x45805 (or $x47608 $x49187 $x45720 $x49185))) (rewrite (= (or $x45805 (or $x47608 $x49187 $x45720 $x49185)) $x49240)) $x49240)))
 (let ((@x51260 (unit-resolution (unit-resolution @x49253 @x175 @x51024 @x48781 (or $x49187 $x49185)) @x51259 $x49185)))
 (let ((@x49506 (def-axiom (or $x49182 $x49148))))
 (let ((@x49497 (def-axiom (or $x49154 $x44066 $x49153 $x49150))))
 (let ((@x51266 (unit-resolution (unit-resolution @x49497 (unit-resolution @x49506 @x51260 $x49148) $x49148) @x50006 (or $x44066 $x49150))))
 (let ((@x51267 (unit-resolution @x51266 @x50728 $x44066)))
 (let (($x44221 (not $x44138)))
 (let (($x44216 (or $x44221 $x44215)))
 (let (($x44220 (not $x44216)))
 (let (($x44202 (or $x44162 $x44156 $x44220)))
 (let (($x44209 (not $x44202)))
 (let ((?x45834 (vstd!seq.Seq.len.? $ ?x1876 ?x44058)))
 (let (($x45835 (= ?x45825 ?x45834)))
 (let ((?x45493 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44888 ?x7357 ?x7359)))
 (let ((?x48492 (vstd!seq.Seq.len.? $ ?x1876 ?x45493)))
 (let (($x49032 (= ?x48492 ?x45834)))
 (let ((@x49019 (monotonicity @x49017 (= ?x45493 ?x44058))))
 (let ((@x49021 (symm @x49019 (= ?x44058 ?x45493))))
 (let ((?x45467 (%I ?x7357)))
 (let ((?x48493 (Sub ?x45465 ?x45467)))
 (let (($x48494 (= ?x48492 ?x48493)))
 (let ((?x48489 (+ ?x45465 ?x48488)))
 (let (($x48490 (<= ?x48489 0)))
 (let (($x48599 (>= (+ ?x48487 (* (- 1) (nClip 24))) 0)))
 (let ((?x48541 (nClip 24)))
 (let (($x48595 (= ?x48487 ?x48541)))
 (let ((@x48872 (trans* @x48869 @x48861 (monotonicity (trans* @x48841 @x48372 (= ?x48537 24)) (= ?x48538 ?x48541)) $x48595)))
 (let (($x48588 (>= ?x48541 24)))
 (let (($x48564 (= ?x48541 24)))
 (let (($x48573 (not $x48564)))
 (let (($x48542 (>= ?x48541 0)))
 (let (($x48549 (not $x48542)))
 (let (($x48575 (or $x48549 $x48573)))
 (let (($x48582 (not $x48575)))
 (let (($x48574 (or $x48124 $x48582)))
 (let (($x48556 (not (or $x48549 (not (or (not (>= 24 0)) (= 24 ?x48541)))))))
 (let (($x48576 (or $x48124 $x48556)))
 (let (($x48578 (= $x48576 $x48574)))
 (let ((@x48584 (trans (monotonicity (rewrite (= $x48556 $x48582)) $x48578) (rewrite (= $x48574 $x48574)) $x48578)))
 (let ((@x48875 (unit-resolution (def-axiom (or $x48575 $x48564)) (unit-resolution (mp ((_ quant-inst 24) $x48576) @x48584 $x48574) @x12798 $x48582) $x48564)))
 (let ((@x48882 ((_ th-lemma arith farkas 1 1 1 1 1 1 1) @x48881 @x47953 @x47920 @x47912 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x48573 $x48588)) @x48875 $x48588) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48595) $x48599)) @x48872 $x48599) (hypothesis (not $x48490)) false)))
 (let ((@x48883 (lemma @x48882 $x48490)))
 (let ((?x48483 (* (- 1) ?x45467)))
 (let ((?x48484 (+ ?x45465 ?x48483)))
 (let (($x48485 (>= ?x48484 0)))
 (let ((?x48496 (+ ?x7356 ?x48483)))
 (let (($x48505 (>= ?x48496 0)))
 (let (($x45468 (= ?x7356 ?x45467)))
 (let (($x45473 (or $x45436 $x45468)))
 (let ((@x45474 ((_ quant-inst (Sub pmemlog!logimpl_v.header_head_offset.? 8)) $x45473)))
 (let ((@x48517 (unit-resolution @x45474 @x8959 $x45468)))
 (let ((@x48525 ((_ th-lemma arith farkas 1 1 1 1) (hypothesis (not $x48485)) @x48523 @x47950 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45468) $x48505)) @x48517 $x48505) false)))
 (let ((@x48526 (lemma @x48525 $x48485)))
 (let (($x48475 (>= ?x45467 0)))
 (let (($x46775 (>= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let ((@x47923 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7277) $x46775)) @x47919 $x46775)))
 (let (($x48497 (<= ?x48496 0)))
 (let ((@x49014 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 1) (or $x48475 (not $x48497) (not $x46775) (not $x45545))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x45468) $x48497)) @x48517 $x48497) @x47923 @x47909 $x48475)))
 (let (($x45489 (has_type ?x7357 INT)))
 (let ((?x7131 (I 0)))
 (let (($x47773 (has_type ?x7131 INT)))
 (let (($x47934 (not $x47773)))
 (let ((@x47925 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x47923 @x47920 @x47912 @x47909 (= ?x7356 0))))
 (let ((@x47927 (symm @x47925 (= 0 ?x7356))))
 (let ((@x47933 (symm (monotonicity (monotonicity @x47927 (= ?x7131 ?x7357)) (= $x47773 $x45489)) (= $x45489 $x47773))))
 (let ((@x47937 (mp (hypothesis (not $x45489)) (monotonicity @x47933 (= (not $x45489) $x47934)) $x47934)))
 (let ((@x47939 (unit-resolution (unit-resolution ((_ quant-inst 0) (or (not $x698) $x47773)) @x9099 $x47773) @x47937 false)))
 (let ((@x47940 (lemma @x47939 $x45489)))
 (let (($x48491 (not $x48490)))
 (let (($x48486 (not $x48485)))
 (let (($x48476 (not $x48475)))
 (let (($x45490 (not $x45489)))
 (let (($x48930 (or $x48929 $x45476 $x45490 $x45492 $x45720 $x48476 $x48486 $x48491 $x48494)))
 (let ((@x48934 (rewrite (= (or $x48929 (or $x45476 $x45490 $x45492 $x45720 $x48476 $x48486 $x48491 $x48494)) $x48930))))
 (let ((@x48935 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7356) (I ?x7358)) (or $x48929 (or $x45476 $x45490 $x45492 $x45720 $x48476 $x48486 $x48491 $x48494))) @x48934 $x48930)))
 (let ((@x49031 (symm (unit-resolution @x48935 @x175 @x48984 @x49005 @x47940 @x47974 @x49014 @x48526 @x48883 $x48494) (= ?x48493 ?x48492))))
 (let ((@x49025 (monotonicity @x48979 (trans* (symm @x48517 (= ?x45467 ?x7356)) @x47925 (= ?x45467 0)) (= ?x48493 (Sub 8 0)))))
 (let ((?x48939 (Sub 8 0)))
 (let (($x48955 (= ?x48939 8)))
 (let (($x48960 (or $x45535 $x48955)))
 (let ((?x48938 (* (- 1) 8)))
 (let ((?x48940 (+ 0 ?x48938 ?x48939)))
 (let (($x48941 (= ?x48940 0)))
 (let (($x48961 (or $x45535 $x48941)))
 (let (($x48963 (= $x48961 $x48960)))
 (let ((@x48951 (trans (monotonicity (rewrite (= ?x48938 (- 8))) (= ?x48940 (+ 0 (- 8) ?x48939))) (rewrite (= (+ 0 (- 8) ?x48939) (+ (- 8) ?x48939))) (= ?x48940 (+ (- 8) ?x48939)))))
 (let ((@x48959 (trans (monotonicity @x48951 (= $x48941 (= (+ (- 8) ?x48939) 0))) (rewrite (= (= (+ (- 8) ?x48939) 0) $x48955)) (= $x48941 $x48955))))
 (let ((@x48968 (mp ((_ quant-inst 8 0) $x48961) (trans (monotonicity @x48959 $x48963) (rewrite (= $x48960 $x48960)) $x48963) $x48960)))
 (let ((@x49034 (trans* @x48750 @x48752 @x48721 (symm (unit-resolution @x48968 @x9204 $x48955) (= 8 ?x48939)) (symm @x49025 (= ?x48939 ?x48493)) @x49031 (symm (monotonicity @x49021 (= ?x45834 ?x48492)) $x49032) $x45835)))
 (let ((@x49037 (lemma (unit-resolution (hypothesis (not $x45835)) @x49034 false) $x45835)))
 (let ((?x45819 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44058 ?x44056 ?x1876 $)))
 (let ((?x45820 (vstd!seq.Seq.index.? $ ?x1876 ?x44058 ?x45819)))
 (let ((?x45821 (vstd!seq.Seq.index.? $ ?x1876 ?x44056 ?x45819)))
 (let (($x45822 (= ?x45821 ?x45820)))
 (let ((?x45823 (%I ?x45819)))
 (let ((?x45877 (+ ?x45823 ?x45844)))
 (let (($x45878 (>= ?x45877 0)))
 (let (($x45828 (>= ?x45823 0)))
 (let (($x45829 (not $x45828)))
 (let (($x45830 (has_type ?x45819 INT)))
 (let (($x45831 (not $x45830)))
 (let (($x45883 (or $x45831 $x45829 $x45878 $x45822)))
 (let (($x45904 (not $x45878)))
 (let (($x45889 (not $x45883)))
 (let ((@x49855 (hypothesis $x45889)))
 (let ((@x45906 (def-axiom (or $x45883 $x45904))))
 (let ((@x49856 (unit-resolution @x45906 @x49855 $x45904)))
 (let (($x49788 (<= (+ ?x45825 (* (- 1) (%I (I (%I (I (Add ?x45823 ?x45467))))))) 0)))
 (let ((?x49050 (Add ?x45823 ?x45467)))
 (let ((?x49051 (I ?x49050)))
 (let ((?x49336 (%I ?x49051)))
 (let ((?x49586 (I ?x49336)))
 (let ((?x49778 (vstd!seq.Seq.index.? $ ?x1876 ?x44056 ?x49586)))
 (let ((?x49728 (vstd!seq.Seq.index.? $ ?x1876 ?x48162 ?x49586)))
 (let (($x49779 (= ?x49728 ?x49778)))
 (let (($x49918 (not $x49779)))
 (let ((?x49159 (I ?x45823)))
 (let (($x49160 (= ?x45819 ?x49159)))
 (let ((@x45901 (def-axiom (or $x45883 $x45830))))
 (let ((@x49862 (unit-resolution @x45901 @x49855 $x45830)))
 (let (($x49213 (or $x48907 $x45831 $x49160)))
 (let ((@x49257 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44058 ?x44056 ?x1876 $)) (or $x48907 (or $x45831 $x49160))) (rewrite (= (or $x48907 (or $x45831 $x49160)) $x49213)) $x49213)))
 (let (($x49442 (= ?x49050 ?x49336)))
 (let (($x49445 (or $x45436 $x49442)))
 (let ((@x49446 ((_ quant-inst (Add ?x45823 ?x45467)) $x49445)))
 (let ((@x49589 (unit-resolution @x49446 @x8959 $x49442)))
 (let ((@x49748 (monotonicity (trans* @x47927 @x48517 (= 0 ?x45467)) (= (Add ?x45823 0) ?x49050))))
 (let ((?x49443 (Add ?x45823 0)))
 (let ((?x49444 (* (- 1) ?x49443)))
 (let ((?x48928 (+ ?x45823 ?x49444)))
 (let (($x49066 (<= ?x48928 0)))
 (let (($x49041 (= ?x48928 0)))
 (let (($x48906 (or $x45516 $x49041)))
 (let (($x49448 (= (+ 0 ?x45823 ?x49444) 0)))
 (let (($x49040 (or $x45516 $x49448)))
 (let (($x49044 (= $x49040 $x48906)))
 (let ((@x49065 (trans (monotonicity (rewrite (= $x49448 $x49041)) $x49044) (rewrite (= $x48906 $x48906)) $x49044)))
 (let ((@x49067 (mp ((_ quant-inst (%I ?x45819) 0) $x49040) @x49065 $x48906)))
 (let ((@x49729 (unit-resolution @x49067 @x9197 $x49041)))
 (let ((@x49733 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49041) $x49066)) @x49729 $x49066)))
 (let (($x49068 (>= ?x48928 0)))
 (let ((@x49774 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49041) $x49068)) @x49729 $x49068)))
 (let ((@x49865 (monotonicity (trans* ((_ th-lemma arith eq-propagate 1 1) @x49774 @x49733 (= ?x45823 ?x49443)) @x49748 @x49589 (= ?x45823 ?x49336)) (= ?x49159 ?x49586))))
 (let ((@x49871 (trans* (symm @x49865 (= ?x49586 ?x49159)) (symm (unit-resolution @x49257 @x8980 @x49862 $x49160) (= ?x49159 ?x45819)) (= ?x49586 ?x45819))))
 (let ((@x49906 (symm (monotonicity @x49021 (= ?x45820 (vstd!seq.Seq.index.? $ ?x1876 ?x45493 ?x45819))) (= (vstd!seq.Seq.index.? $ ?x1876 ?x45493 ?x45819) ?x45820))))
 (let ((?x49049 (vstd!seq.Seq.index.? $ ?x1876 ?x45493 ?x45819)))
 (let ((?x49052 (vstd!seq.Seq.index.? $ ?x1876 ?x44888 ?x49051)))
 (let (($x49053 (= ?x49049 ?x49052)))
 (let ((?x49046 (* (- 1) ?x48493)))
 (let ((?x49047 (+ ?x45823 ?x49046)))
 (let (($x49048 (>= ?x49047 0)))
 (let (($x49360 (not $x49048)))
 (let ((@x49337 (hypothesis $x45904)))
 (let (($x49171 (>= ?x48493 8)))
 (let (($x49162 (= ?x48493 8)))
 (let ((@x49345 (trans* @x49031 (monotonicity @x49019 $x49032) (symm @x49037 (= ?x45834 ?x45825)) @x48750 @x48752 @x48721 $x49162)))
 (let ((@x49359 ((_ th-lemma arith farkas 1 -1 -1 -1 1) @x49358 @x49355 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49162) $x49171)) @x49345 $x49171) (hypothesis $x49048) @x49337 false)))
 (let ((@x49362 (lemma @x49359 (or $x49360 $x45878))))
 (let ((@x45903 (def-axiom (or $x45883 $x45828))))
 (let ((@x49879 (unit-resolution @x45903 @x49855 $x45828)))
 (let (($x49121 (or $x49116 $x45476 $x45490 $x45492 $x45831 $x45720 $x48476 $x48486 $x48491 $x45829 $x49048 $x49053)))
 (let ((?x48936 (+ ?x45467 ?x48506)))
 (let (($x48937 (<= ?x48936 0)))
 (let (($x49045 (not $x48937)))
 (let (($x49054 (or $x45476 $x45490 $x45492 $x45831 $x45720 $x48476 $x49045 $x48491 $x45829 $x49048 $x49053)))
 (let (($x49122 (or $x49116 $x49054)))
 (let (($x49070 (or $x45476 $x45490 $x45492 $x45831 $x45720 $x48476 $x48486 $x48491 $x45829 $x49048 $x49053)))
 (let (($x49118 (or $x49116 $x49070)))
 (let (($x49111 (= $x49054 $x49070)))
 (let ((@x49115 (trans (monotonicity (rewrite (= $x49045 $x48486)) $x49111) (rewrite (= $x49070 $x49070)) $x49111)))
 (let ((@x49147 (trans (monotonicity @x49115 (= $x49122 $x49118)) (rewrite (= $x49118 $x49121)) (= $x49122 $x49121))))
 (let ((@x49149 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7356) (I ?x7358) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x44058 ?x44056 ?x1876 $)) $x49122) @x49147 $x49121)))
 (let ((@x49881 (unit-resolution @x49149 @x175 @x49878 @x49005 @x47940 @x47974 @x49862 @x49879 @x49014 @x48526 @x48883 (unit-resolution @x49362 @x49856 $x49360) $x49053)))
 (let (($x49594 (= ?x49586 ?x49051)))
 (let (($x48926 (= ?x49051 ?x49586)))
 (let (($x49334 (has_type ?x49051 INT)))
 (let (($x49587 (has_type ?x49586 INT)))
 (let (($x49600 (not $x49587)))
 (let (($x49598 (= $x49334 $x49587)))
 (let (($x49596 (= $x49587 $x49334)))
 (let ((@x49599 (symm (monotonicity (monotonicity (symm @x49589 (= ?x49336 ?x49050)) $x49594) $x49596) $x49598)))
 (let ((@x49603 (mp (hypothesis (not $x49334)) (monotonicity @x49599 (= (not $x49334) $x49600)) $x49600)))
 (let ((@x49605 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x49051)) (or (not $x698) $x49587)) @x9099 $x49587) @x49603 false)))
 (let ((@x49606 (lemma @x49605 $x49334)))
 (let (($x49335 (not $x49334)))
 (let (($x48920 (or $x48907 $x49335 $x48926)))
 (let ((@x49038 (mp ((_ quant-inst (I ?x49050)) (or $x48907 (or $x49335 $x48926))) (rewrite (= (or $x48907 (or $x49335 $x48926)) $x48920)) $x48920)))
 (let ((@x49738 (symm (unit-resolution @x49038 @x8980 @x49606 $x48926) $x49594)))
 (let ((@x49900 (monotonicity @x48865 @x49738 (= (vstd!seq.Seq.index.? $ ?x1876 ?x48529 ?x49586) ?x49052))))
 (let ((?x49324 (vstd!seq.Seq.index.? $ ?x1876 ?x48529 ?x49586)))
 (let ((?x49325 (vstd!seq.Seq.index.? $ ?x1876 ?x44851 ?x49586)))
 (let (($x49326 (= ?x49324 ?x49325)))
 (let ((?x49315 (%I ?x49586)))
 (let (($x49316 (>= ?x49315 0)))
 (let ((?x49378 (* (- 1) ?x49336)))
 (let ((?x49580 (+ ?x49315 ?x49378)))
 (let (($x49582 (>= ?x49580 0)))
 (let (($x49579 (= ?x49315 ?x49336)))
 (let ((@x49739 (monotonicity @x49738 $x49579)))
 (let ((?x49467 (+ ?x49336 ?x49444)))
 (let (($x49578 (>= ?x49467 0)))
 (let (($x49466 (= ?x49336 ?x49443)))
 (let ((@x49593 (symm @x49589 (= ?x49336 ?x49050))))
 (let ((@x49751 (trans* @x49593 (symm @x49748 (= ?x49050 ?x49443)) $x49466)))
 (let ((@x49754 ((_ th-lemma arith farkas -1 -1 1 -1 1) (hypothesis $x45828) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49466) $x49578)) @x49751 $x49578) (hypothesis (not $x49316)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49579) $x49582)) @x49739 $x49582) @x49733 false)))
 (let ((@x49756 (lemma @x49754 (or $x49316 $x45829))))
 (let ((@x49882 (unit-resolution @x49756 @x49879 $x49316)))
 (let ((@x49885 (mp @x49606 (symm (monotonicity @x49738 $x49596) $x49598) $x49587)))
 (let ((?x49298 (* (- 1) ?x49315)))
 (let ((?x49300 (+ ?x46079 ?x49298)))
 (let (($x49301 (<= ?x49300 0)))
 (let (($x49433 (not $x49301)))
 (let (($x49581 (<= ?x49580 0)))
 (let ((@x49768 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49579) $x49581)) @x49739 $x49581)))
 (let (($x49577 (<= ?x49467 0)))
 (let ((@x49771 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49466) $x49577)) @x49751 $x49577)))
 (let ((@x49775 ((_ th-lemma arith farkas 1 1 1 1 1 1 1 1 1) @x49358 @x49355 @x49774 @x49771 @x49768 (hypothesis $x49301) @x49764 @x49761 @x49337 false)))
 (let ((@x49777 (lemma @x49775 (or $x49433 $x45878))))
 (let (($x49296 (not $x49316)))
 (let (($x49314 (or $x49155 $x45307 $x47654 $x49600 $x45720 $x49296 $x49301 $x49326)))
 (let ((?x49299 (+ ?x49315 ?x49365)))
 (let (($x49323 (>= ?x49299 0)))
 (let (($x49327 (or $x45307 $x47654 $x49600 $x45720 $x49296 $x49323 $x49326)))
 (let (($x49392 (or $x49155 $x49327)))
 (let ((@x49389 (rewrite (= (or $x49155 (or $x45307 $x47654 $x49600 $x45720 $x49296 $x49301 $x49326)) $x49314))))
 (let (($x49306 (or $x45307 $x47654 $x49600 $x45720 $x49296 $x49301 $x49326)))
 (let (($x49309 (= $x49327 $x49306)))
 (let ((@x49330 (rewrite (= ?x49299 (+ ?x49365 ?x49315)))))
 (let ((@x49305 (trans (monotonicity @x49330 (= $x49323 (>= (+ ?x49365 ?x49315) 0))) (rewrite (= (>= (+ ?x49365 ?x49315) 0) $x49301)) (= $x49323 $x49301))))
 (let ((@x49387 (monotonicity (trans (monotonicity @x49305 $x49309) (rewrite (= $x49306 $x49306)) $x49309) (= $x49392 (or $x49155 $x49306)))))
 (let ((@x49893 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44834 ?x44012) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1) (I ?x49336)) $x49392) (trans @x49387 @x49389 (= $x49392 $x49314)) $x49314) @x175 @x49891 @x48853 @x48860 (or $x49600 $x49296 $x49301 $x49326))))
 (let ((@x49898 (symm (unit-resolution @x49893 (unit-resolution @x49777 @x49856 $x49433) @x49885 @x49882 $x49326) (= ?x49325 ?x49324))))
 (let ((@x49908 (trans* (monotonicity @x48831 (= ?x49728 ?x49325)) @x49898 @x49900 (symm @x49881 (= ?x49052 ?x49049)) @x49906 (= ?x49728 ?x45820))))
 (let ((@x49911 (monotonicity @x49908 (monotonicity @x49871 (= ?x49778 ?x45821)) (= $x49779 (= ?x45820 ?x45821)))))
 (let ((@x49917 (symm (trans @x49911 (commutativity (= (= ?x45820 ?x45821) $x45822)) (= $x49779 $x45822)) (= $x45822 $x49779))))
 (let ((@x49921 (mp (unit-resolution (def-axiom (or $x45883 (not $x45822))) @x49855 (not $x45822)) (monotonicity @x49917 (= (not $x45822) $x49918)) $x49918)))
 (let (($x49799 (or $x49155 $x45859 $x47608 $x49600 $x45720 $x49296 $x49788 $x49779)))
 (let ((?x49726 (+ ?x49315 ?x45844)))
 (let (($x49727 (>= ?x49726 0)))
 (let (($x49780 (or $x45859 $x47608 $x49600 $x45720 $x49296 $x49727 $x49779)))
 (let (($x49800 (or $x49155 $x49780)))
 (let ((@x49806 (rewrite (= (or $x49155 (or $x45859 $x47608 $x49600 $x45720 $x49296 $x49788 $x49779)) $x49799))))
 (let (($x49793 (or $x45859 $x47608 $x49600 $x45720 $x49296 $x49788 $x49779)))
 (let (($x49794 (= $x49780 $x49793)))
 (let ((@x49783 (rewrite (= ?x49726 (+ ?x45844 ?x49315)))))
 (let ((@x49792 (trans (monotonicity @x49783 (= $x49727 (>= (+ ?x45844 ?x49315) 0))) (rewrite (= (>= (+ ?x45844 ?x49315) 0) $x49788)) (= $x49727 $x49788))))
 (let ((@x49804 (monotonicity (trans (monotonicity @x49792 $x49794) (rewrite (= $x49793 $x49793)) $x49794) (= $x49800 (or $x49155 $x49793)))))
 (let ((@x49923 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1) (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1) (I ?x49336)) $x49800) (trans @x49804 @x49806 (= $x49800 $x49799)) $x49799) @x175 @x49891 @x48774 @x48781 @x49885 @x49882 (or $x49788 $x49779))))
 (let ((@x49925 ((_ th-lemma arith farkas -1 1 1 1 1) @x49774 @x49771 @x49768 (unit-resolution @x49923 @x49921 $x49788) @x49856 false)))
 (let ((@x49926 (lemma @x49925 $x45883)))
 (let (($x45836 (not $x45835)))
 (let (($x45871 (or $x44059 $x45836 $x45889)))
 (let (($x45879 (not $x45871)))
 (let (($x45848 (forall ((i$ Poly) )(! (let ((?x7356 (Sub pmemlog!logimpl_v.header_head_offset.? 8)))
 (let ((?x7358 (Add ?x7356 8)))
 (let ((?x7359 (I ?x7358)))
 (let ((?x7357 (I ?x7356)))
 (let ((?x44044 (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1878 (TYPE%alloc!vec.Vec. $ ?x1876 $ ALLOCATOR_GLOBAL)))
 (let ((?x44057 (vstd!view.View.view.? $ ?x1878 ?x44044)))
 (let ((?x44058 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7357 ?x7359)))
 (let ((?x45841 (vstd!seq.Seq.index.? $ ?x1876 ?x44058 i$)))
 (let ((?x44056 (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1)))
 (let ((?x45839 (vstd!seq.Seq.index.? $ ?x1876 ?x44056 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13839 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13839 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x44056))) 0) (= ?x45839 ?x45841))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.subrange.? $ (UINT 8) (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. $ (UINT 8) $ ALLOCATOR_GLOBAL) (Poly%alloc!vec.Vec<u8./allocator_global%.>. bytes@3)) (I (Sub pmemlog!logimpl_v.header_head_offset.? 8)) (I (Add (Sub pmemlog!logimpl_v.header_head_offset.? 8) 8))) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x45849 (not $x45848)))
 (let (($x45850 (or $x45836 $x45849)))
 (let (($x45851 (not $x45850)))
 (let (($x44337 (not $x44059)))
 (let (($x45852 (or $x44337 $x45851)))
 (let (($x45853 (not $x45852)))
 (let (($x45890 (or $x45853 $x45879)))
 (let (($x45876 (not $x45890)))
 (let (($x45856 (has_type ?x44058 ?x1968)))
 (let ((@x51250 (symm (monotonicity @x49021 (= $x45856 (has_type ?x45493 ?x1968))) (= (has_type ?x45493 ?x1968) $x45856))))
 (let (($x45494 (has_type ?x45493 ?x1968)))
 (let (($x45495 (or $x45476 $x45490 $x45492 $x45494)))
 (let (($x45499 (or $x45498 $x45476 $x45490 $x45492 $x45494)))
 (let ((@x45504 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x44850 ?x44026) (I ?x7356) (I ?x7358)) (or $x45498 $x45495)) (rewrite (= (or $x45498 $x45495) $x45499)) $x45499)))
 (let ((@x51272 (unit-resolution (unit-resolution @x45504 @x13978 $x45495) @x49005 (or $x45490 $x45492 $x45494))))
 (let (($x45857 (not $x45856)))
 (let (($x45867 (or $x45805 $x45859 $x45857 $x45720 $x45876)))
 (let (($x45837 (or $x44059 $x45836 (not (or $x45831 $x45829 (<= (+ ?x45825 (* (- 1) ?x45823)) 0) $x45822)))))
 (let (($x45855 (not (or $x45853 (not $x45837)))))
 (let (($x45860 (or $x45859 $x45857 $x45720 $x45855)))
 (let (($x45868 (or $x45805 $x45860)))
 (let (($x45861 (or $x45859 $x45857 $x45720 $x45876)))
 (let (($x45862 (= $x45860 $x45861)))
 (let ((@x45866 (trans (monotonicity (rewrite (= $x45855 $x45876)) $x45862) (rewrite (= $x45861 $x45861)) $x45862)))
 (let ((@x45874 (trans (monotonicity @x45866 (= $x45868 (or $x45805 $x45861))) (rewrite (= (or $x45805 $x45861) $x45867)) (= $x45868 $x45867))))
 (let ((@x45875 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7357 ?x7359)) $x45868) @x45874 $x45867)))
 (let ((@x51269 (unit-resolution (unit-resolution @x45875 @x175 @x51024 (or $x45859 $x45857 $x45876)) @x48774 (or $x45857 $x45876))))
 (let ((@x51277 (unit-resolution @x51269 (mp (unit-resolution @x51272 @x47974 @x47940 $x45494) @x51250 $x45856) $x45876)))
 (let ((@x45923 (def-axiom (or $x45890 $x45871))))
 (let ((@x45919 (def-axiom (or $x45879 $x44059 $x45836 $x45889))))
 (let ((@x51280 (unit-resolution (unit-resolution @x45919 (unit-resolution @x45923 @x51277 $x45871) $x45871) @x49926 @x49037 $x44059)))
 (let (($x44234 (not $x44134)))
 (let (($x44210 (or $x44234 $x44209)))
 (let (($x44219 (not $x44210)))
 (let (($x44197 (or $x44161 $x44173 $x44219)))
 (let (($x44200 (not $x44197)))
 (let (($x44966 (= ?x44050 ?x7133)))
 (let (($x44969 (= $x44966 $x44051)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x9039 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x9043 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x9039) (~ $x418 $x418)) $x418)))
 (let (($x45011 (not $x418)))
 (let (($x45012 (or $x45011 $x44969)))
 (let ((@x45013 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. old_bytes@1) (vstd!seq.Seq.empty.? $ ?x1876)) $x45012)))
 (let ((?x7134 (%Poly%vstd!seq.Seq<u8.>. ?x7133)))
 (let ((?x45236 (Poly%vstd!seq.Seq<u8.>. ?x7134)))
 (let (($x45237 (= ?x7133 ?x45236)))
 (let (($x45242 (or $x45241 $x45235 $x45237)))
 (let ((@x45247 (mp ((_ quant-inst (vstd!seq.Seq.empty.? $ ?x1876)) (or $x45241 (or $x45235 $x45237))) (rewrite (= (or $x45241 (or $x45235 $x45237)) $x45242)) $x45242)))
 (let ((@x51219 (trans* (symm @x48800 (= ?x7133 ?x44565)) (symm @x48812 (= ?x44565 ?x43983)) (= ?x7133 ?x43983))))
 (let ((@x44177 (not-or-elim @x44176 $x43985)))
 (let ((@x44172 (not-or-elim @x44176 $x43987)))
 (let ((@x44171 (not-or-elim @x44176 $x43989)))
 (let ((@x51225 (trans* @x44171 @x44172 @x44177 (symm (monotonicity @x51219 (= ?x7134 ?x43984)) (= ?x43984 ?x7134)) (= old_bytes@1 ?x7134))))
 (let ((@x51194 (trans* (monotonicity @x51225 (= ?x44050 ?x45236)) (symm (unit-resolution @x45247 @x9556 @x48790 $x45237) (= ?x45236 ?x7133)) $x44966)))
 (let ((@x45019 (def-axiom (or (not $x44969) (not $x44966) $x44051))))
 (let ((@x44186 (not-or-elim @x44176 $x44052)))
 (let ((@x44308 (unit-resolution (def-axiom (or tmp%5 (not $x44051) $x44175)) @x44186 (or tmp%5 (not $x44051)))))
 (let ((@x51198 (unit-resolution @x44308 (unit-resolution @x45019 @x51194 (unit-resolution @x45013 @x9043 $x44969) $x44051) tmp%5)))
 (let ((@x44333 (def-axiom (or $x44130 $x44161))))
 (let (($x44236 (not $x44130)))
 (let (($x44207 (or $x44236 $x44200)))
 (let (($x44261 (not (or (or $x44163 $x44152) (not (or $x44222 (not (or (or $x44164 $x44148) $x44214))))))))
 (let (($x44263 (not (or $x44221 $x44261))))
 (let (($x44257 (or $x44162 $x44156)))
 (let (($x44268 (not (or $x44234 (not (or $x44257 $x44263))))))
 (let (($x44259 (or $x44161 $x44173)))
 (let (($x44260 (or $x44259 $x44268)))
 (let (($x44275 (or $x44236 (not $x44260))))
 (let ((@x44204 (monotonicity (rewrite (= $x44130 $x44130)) (rewrite (= $x44168 $x44197)) (= $x44136 (and $x44130 $x44197)))))
 (let ((@x44230 (trans @x44204 (rewrite (= (and $x44130 $x44197) (not $x44207))) (= $x44136 (not $x44207)))))
 (let ((@x44241 (trans (monotonicity @x44230 (= (not $x44136) (not (not $x44207)))) (rewrite (= (not (not $x44207)) $x44207)) (= (not $x44136) $x44207))))
 (let (($x44187 (not $x44136)))
 (let ((@x44189 (mp (not-or-elim @x44176 $x44187) (monotonicity (rewrite (= $x44136 $x44136)) (= $x44187 $x44187)) $x44187)))
 (let ((@x44321 (mp (mp (mp @x44189 @x44241 $x44207) (rewrite (= $x44207 $x44275)) $x44275) (rewrite (= $x44275 $x44207)) $x44207)))
 (let ((@x51200 (unit-resolution @x44321 (unit-resolution @x44333 @x51198 $x44130) $x44200)))
 (let ((@x44455 (def-axiom (or $x44197 $x44060))))
 (let ((@x44339 (def-axiom (or $x44173 tmp%6 $x44337))))
 (let ((@x51207 (unit-resolution @x44339 (unit-resolution @x44455 @x51200 $x44060) (or tmp%6 $x44337))))
 (let ((@x44276 (def-axiom (or $x44134 $x44162))))
 (let ((@x44451 (def-axiom (or $x44219 $x44234 $x44209))))
 (let ((@x51202 (unit-resolution @x44451 (unit-resolution (def-axiom (or $x44197 $x44210)) @x51200 $x44210) $x44210)))
 (let ((@x51283 (unit-resolution @x51202 (unit-resolution @x44276 (unit-resolution @x51207 @x51280 tmp%6) $x44134) $x44209)))
 (let ((@x44441 (def-axiom (or $x44202 $x44067))))
 (let ((@x44295 (def-axiom (or $x44156 tmp%7 $x44309))))
 (let ((@x51252 (unit-resolution @x44295 (unit-resolution @x44441 @x51283 $x44067) (or tmp%7 $x44309))))
 (let ((@x44354 (def-axiom (or $x44138 $x44163))))
 (let ((@x44437 (def-axiom (or $x44220 $x44221 $x44215))))
 (let ((@x51285 (unit-resolution @x44437 (unit-resolution (def-axiom (or $x44202 $x44216)) @x51283 $x44216) $x44216)))
 (let ((@x51321 (unit-resolution @x51285 (unit-resolution @x44354 (unit-resolution @x51252 @x51267 tmp%7) $x44138) $x44215)))
 (let ((@x44427 (def-axiom (or $x44231 $x44074))))
 (let ((@x44359 (def-axiom (or $x44152 tmp%8 $x44357))))
 (let ((@x51465 (unit-resolution @x44359 (unit-resolution @x44427 @x51321 $x44074) (or tmp%8 $x44357))))
 (let ((@x44371 (def-axiom (or $x44142 $x44164))))
 (let ((@x44423 (def-axiom (or $x44225 $x44222 $x44223))))
 (let ((@x51469 (unit-resolution @x44423 (unit-resolution (def-axiom (or $x44231 $x44224)) @x51321 $x44224) $x44224)))
 (let ((@x51470 (unit-resolution @x51469 (unit-resolution @x44371 (unit-resolution @x51465 @x51214 tmp%8) $x44142) $x44223)))
 (let ((@x44413 (def-axiom (or $x44218 $x44078))))
 (let ((@x51475 (monotonicity (monotonicity (unit-resolution @x44413 @x51470 $x44078) (= ?x44080 ?x44044)) (= ?x44081 ?x44057))))
 (let ((@x51488 (trans* (monotonicity (trans* @x51475 @x48991 (= ?x44081 ?x44888)) (= ?x44086 ?x48487)) @x48869 @x48861 (symm @x49957 (= ?x48538 ?x48537)) @x48841 @x48372 (symm (unit-resolution @x51028 @x9204 $x50955) (= 24 ?x50882)) (symm @x51483 (= ?x50882 ?x8522)) $x44087)))
 (let (($x44399 (not $x44087)))
 (let ((?x44376 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x44082)))
 (let ((?x44375 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x44082)))
 (let ((?x44374 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44082)))
 (let ((?x44377 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44374 ?x44375 ?x44376)))
 (let ((@x51523 (symm ((_ th-lemma datatype) (= ?x44082 ?x44377)) (= ?x44377 ?x44082))))
 (let ((?x44302 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x43991)))
 (let ((?x44294 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x43991)))
 (let ((?x44292 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x43991)))
 (let ((?x44304 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44292 ?x44294 ?x44302)))
 (let (($x50874 (= ?x44302 ?x44376)))
 (let ((?x44387 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x44377)))
 (let (($x48319 (= ?x44387 ?x44376)))
 (let ((?x46869 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44081 ?x7369 ?x7371)))
 (let ((?x46870 (vstd!bytes.spec_u64_from_le_bytes.? ?x46869)))
 (let ((?x46871 (I ?x46870)))
 (let ((?x46872 (%I ?x46871)))
 (let ((?x46865 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44081 ?x7363 ?x7365)))
 (let ((?x46866 (vstd!bytes.spec_u64_from_le_bytes.? ?x46865)))
 (let ((?x46867 (I ?x46866)))
 (let ((?x46868 (%I ?x46867)))
 (let ((?x46859 (vstd!seq.Seq.subrange.? $ ?x1876 ?x44081 ?x7357 ?x7359)))
 (let ((?x46847 (vstd!bytes.spec_u64_from_le_bytes.? ?x46859)))
 (let ((?x46848 (I ?x46847)))
 (let ((?x46864 (%I ?x46848)))
 (let ((?x46874 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x46864 ?x46868 ?x46872)))
 (let ((?x46885 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x46874)))
 (let (($x46875 (= ?x44082 ?x46874)))
 (let (($x7383 (forall ((header_seq! Poly) )(! (let ((?x7368 (Sub pmemlog!logimpl_v.header_log_size_offset.? 8)))
 (let ((?x7370 (Add ?x7368 8)))
 (let ((?x7371 (I ?x7370)))
 (let ((?x7369 (I ?x7368)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7373 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7369 ?x7371))))
 (let ((?x7362 (Sub pmemlog!logimpl_v.header_tail_offset.? 8)))
 (let ((?x7364 (Add ?x7362 8)))
 (let ((?x7365 (I ?x7364)))
 (let ((?x7363 (I ?x7362)))
 (let ((?x7367 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7363 ?x7365))))
 (let ((?x7356 (Sub pmemlog!logimpl_v.header_head_offset.? 8)))
 (let ((?x7358 (Add ?x7356 8)))
 (let ((?x7359 (I ?x7358)))
 (let ((?x7357 (I ?x7356)))
 (let ((?x7361 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7357 ?x7359))))
 (let ((?x7380 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata (%I (I ?x7361)) (%I (I ?x7367)) (%I (I ?x7373)))))
 (let ((?x7355 (pmemlog!logimpl_v.spec_bytes_to_metadata.? header_seq!)))
 (= ?x7355 ?x7380))))))))))))))))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_metadata.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_metadata.?_definition))
 ))
 (let (($x7354 (fuel_bool fuel%pmemlog!logimpl_v.spec_bytes_to_metadata.)))
 (let (($x7352 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_bytes_to_metadata.)))
 (let (($x46830 (= $x7354 $x7352)))
 (let ((@x46860 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_bytes_to_metadata.) (or (not $x30) $x46830)) @x45572 (hypothesis (not $x46830)) false)))
 (let ((@x46873 (lemma @x46860 $x46830)))
 (let ((@x7353 (asserted $x7352)))
 (let ((@x46851 (def-axiom (or (not $x46830) $x7354 (not $x7352)))))
 (let ((@x51517 (unit-resolution (unit-resolution @x46851 @x7353 (or (not $x46830) $x7354)) @x46873 $x7354)))
 (let (($x7386 (not $x7354)))
 (let (($x7387 (or $x7386 $x7383)))
 (let ((?x12241 (lambda ((header_seq! Poly) )(let ((?x7368 (Sub pmemlog!logimpl_v.header_log_size_offset.? 8)))
 (let ((?x7370 (Add ?x7368 8)))
 (let ((?x7371 (I ?x7370)))
 (let ((?x7369 (I ?x7368)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7373 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7369 ?x7371))))
 (let ((?x7362 (Sub pmemlog!logimpl_v.header_tail_offset.? 8)))
 (let ((?x7364 (Add ?x7362 8)))
 (let ((?x7365 (I ?x7364)))
 (let ((?x7363 (I ?x7362)))
 (let ((?x7367 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7363 ?x7365))))
 (let ((?x7356 (Sub pmemlog!logimpl_v.header_head_offset.? 8)))
 (let ((?x7358 (Add ?x7356 8)))
 (let ((?x7359 (I ?x7358)))
 (let ((?x7357 (I ?x7356)))
 (let ((?x7361 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7357 ?x7359))))
 (let ((?x7380 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata (%I (I ?x7361)) (%I (I ?x7367)) (%I (I ?x7373)))))
 (let ((?x7355 (pmemlog!logimpl_v.spec_bytes_to_metadata.? header_seq!)))
 (let (($x7381 (= ?x7355 ?x7380)))
 (refl (~ $x7381 $x7381))))))))))))))))))))))
 ))
 (let ((@x12246 (monotonicity (refl (~ $x7386 $x7386)) (nnf-pos (proof-bind ?x12241) (~ $x7383 $x7383)) (~ $x7387 $x7387))))
 (let ((@x7390 (mp (asserted (=> $x7354 $x7383)) (rewrite (= (=> $x7354 $x7383) $x7387)) $x7387)))
 (let ((@x12250 (mp (mp~ @x7390 @x12246 $x7387) (rewrite (= $x7387 $x7387)) $x7387)))
 (let (($x46879 (or (not $x7383) $x46875)))
 (let ((@x46880 ((_ quant-inst (vstd!view.View.view.? $ ?x1878 ?x44080)) $x46879)))
 (let ((@x51525 (trans* @x51523 (unit-resolution @x46880 (unit-resolution @x12250 @x51517 $x7383) $x46875) (= ?x44377 ?x46874))))
 (let (($x46877 (= ?x46870 ?x46872)))
 (let (($x46891 (or $x45436 $x46877)))
 (let ((@x46892 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x46869)) $x46891)))
 (let ((?x45392 (Poly%vstd!seq.Seq<u8.>. ?x44751)))
 (let ((?x45410 (vstd!bytes.spec_u64_from_le_bytes.? ?x45392)))
 (let (($x50081 (= ?x44071 ?x44072)))
 (let (($x50088 (= $x50081 $x44073)))
 (let (($x50134 (or $x45011 $x50088)))
 (let ((@x50136 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. old_log_size_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7369 ?x7371)) $x50134)))
 (let ((@x50138 (def-axiom (or (not $x50088) $x50081 $x44357))))
 (let ((@x51506 (unit-resolution (unit-resolution @x50138 (unit-resolution @x50136 @x9043 $x50088) (or $x50081 $x44357)) @x51214 $x50081)))
 (let ((@x51512 (trans* (monotonicity @x51475 (= ?x46869 ?x44072)) (symm @x51506 (= ?x44072 ?x44071)) @x48639 (= ?x46869 ?x45392))))
 (let ((?x45411 (%I ?x44749)))
 (let (($x45412 (= ?x45410 ?x45411)))
 (let (($x45413 (not $x45412)))
 (let ((?x45393 (vstd!seq.Seq.len.? $ ?x1876 ?x45392)))
 (let (($x45408 (= ?x45393 8)))
 (let (($x45409 (not $x45408)))
 (let (($x45414 (or $x45409 $x45413)))
 (let (($x45415 (not $x45414)))
 (let ((?x4023 (UINT 64)))
 (let (($x45394 (has_type ?x44749 ?x4023)))
 (let ((?x45452 (I ?x44302)))
 (let (($x47769 (has_type ?x45452 ?x4023)))
 (let (($x47889 (not $x47769)))
 (let ((?x44814 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x44304)))
 (let ((@x47880 (symm (monotonicity ((_ th-lemma datatype) (= ?x43991 ?x44304)) (= ?x44020 ?x44814)) (= ?x44814 ?x44020))))
 (let (($x44817 (= ?x44814 ?x44302)))
 (let (($x2815 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2812 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size x)))
 (let ((?x2811 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size x)))
 (= ?x2811 ?x2812))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size x) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size_accessor_definition))
 ))
 (let ((?x9972 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2812 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size x)))
 (let ((?x2811 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size x)))
 (let (($x2813 (= ?x2811 ?x2812)))
 (refl (~ $x2813 $x2813))))))
 ))
 (let ((@x9976 (mp~ (asserted $x2815) (nnf-pos (proof-bind ?x9972) (~ $x2815 $x2815)) $x2815)))
 (let (($x44819 (not $x2815)))
 (let (($x44821 (or $x44819 $x44817)))
 (let ((?x44282 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x44304)))
 (let (($x44815 (= ?x44814 ?x44282)))
 (let (($x44822 (or $x44819 $x44815)))
 (let (($x44824 (= $x44822 $x44821)))
 (let ((@x44828 (trans (monotonicity (rewrite (= $x44815 $x44817)) $x44824) (rewrite (= $x44821 $x44821)) $x44824)))
 (let ((@x44829 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44292 ?x44294 ?x44302)) $x44822) @x44828 $x44821)))
 (let ((@x47882 (trans* (symm (unit-resolution @x44829 @x9976 $x44817) (= ?x44302 ?x44814)) @x47880 (= ?x44302 ?x44020))))
 (let ((@x47884 (monotonicity @x47882 (= ?x45452 ?x44749))))
 (let ((@x47891 (monotonicity (symm (monotonicity @x47884 (= $x47769 $x45394)) (= $x45394 $x47769)) (= (not $x45394) $x47889))))
 (let (($x45049 (uInv 64 ?x44302)))
 (let ((@x47897 (symm (monotonicity @x47882 (= $x45049 (uInv 64 ?x44020))) (= (uInv 64 ?x44020) $x45049))))
 (let (($x44509 (uInv 64 ?x44020)))
 (let (($x43974 (has_type ?x43973 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let ((@x43975 (asserted $x43974)))
 (let (($x2826 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let (($x2818 (uInv 64 ?x2817)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (or $x2739 $x2818)))))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size_invariant_definition))
 ))
 (let ((?x9979 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let (($x2818 (uInv 64 ?x2817)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2823 (or $x2739 $x2818)))
 (refl (~ $x2823 $x2823)))))))))
 ))
 (let (($x2821 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let (($x2818 (uInv 64 ?x2817)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (=> $x2731 $x2818))))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size_invariant_definition))
 ))
 (let ((?x2827 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let (($x2818 (uInv 64 ?x2817)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2823 (or $x2739 $x2818)))
 (let (($x2819 (=> $x2731 $x2818)))
 (rewrite (= $x2819 $x2823))))))))))
 ))
 (let ((@x2831 (mp (asserted $x2821) (quant-intro (proof-bind ?x2827) (= $x2821 $x2826)) $x2826)))
 (let ((@x9983 (mp~ @x2831 (nnf-pos (proof-bind ?x9979) (~ $x2826 $x2826)) $x2826)))
 (let (($x44508 (not $x43974)))
 (let (($x44513 (not $x2826)))
 (let (($x44514 (or $x44513 $x44508 $x44509)))
 (let ((@x44519 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. metadata!)) (or $x44513 (or $x44508 $x44509))) (rewrite (= (or $x44513 (or $x44508 $x44509)) $x44514)) $x44514)))
 (let (($x766 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (or $x762 $x757)))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x9123 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (refl (~ $x763 $x763)))))))))
 ))
 (let (($x760 (forall ((bits Int) (x Int) )(! (let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (=> $x648 $x757))))) :pattern ( (has_type (I x) (UINT bits)) ) :qid prelude_has_type_uint))
 ))
 (let ((?x767 (lambda ((bits Int) (x Int) )(let ((?x330 (UINT bits)))
 (let ((?x233 (I x)))
 (let (($x757 (has_type ?x233 ?x330)))
 (let (($x648 (uInv bits x)))
 (let (($x762 (not $x648)))
 (let (($x763 (or $x762 $x757)))
 (let (($x758 (=> $x648 $x757)))
 (rewrite (= $x758 $x763))))))))))
 ))
 (let ((@x771 (mp (asserted $x760) (quant-intro (proof-bind ?x767) (= $x760 $x766)) $x766)))
 (let ((@x9127 (mp~ @x771 (nnf-pos (proof-bind ?x9123) (~ $x766 $x766)) $x766)))
 (let (($x45094 (not $x45049)))
 (let (($x47783 (not $x766)))
 (let (($x47867 (or $x47783 $x45094 $x47769)))
 (let ((@x47872 (mp ((_ quant-inst 64 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x43991)) (or $x47783 (or $x45094 $x47769))) (rewrite (= (or $x47783 (or $x45094 $x47769)) $x47867)) $x47867)))
 (let ((@x47899 (unit-resolution @x47872 @x9127 (mp (unit-resolution @x44519 @x9983 @x43975 $x44509) @x47897 $x45049) $x47769)))
 (let ((@x47901 (lemma (unit-resolution @x47899 (mp (hypothesis (not $x45394)) @x47891 $x47889) false) $x45394)))
 (let (($x45396 (not $x45394)))
 (let (($x45416 (or $x45396 $x45415)))
 (let (($x14863 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14857 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14857)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11633 (not $x6172)))
 (let (($x14870 (not $x14863)))
 (let (($x14871 (or $x14870 $x11633)))
 (let (($x14872 (not $x14871)))
 (let (($x44921 (or $x44160 $x14872)))
 (let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let (($x14881 (not $x11613)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let (($x14879 (not $x11610)))
 (let (($x14882 (or $x14879 $x14881)))
 (let (($x14883 (not $x14882)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x14886 (or $x11606 $x14883)))
 (let (($x14884 (not $x14886)))
 (let (($x44920 (or $x44048 $x14884 $x11632)))
 (let (($x44922 (not $x44920)))
 (let (($x44923 (not $x44921)))
 (let (($x44924 (or $x44923 $x44922)))
 (let (($x44925 (not $x44924)))
 (let (($x14907 (forall ((no%param Int) )(! (let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let (($x14881 (not $x11613)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let (($x14879 (not $x11610)))
 (let (($x14882 (or $x14879 $x14881)))
 (let (($x14883 (not $x14882)))
 (let ((?x4023 (UINT 64)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x14886 (or $x11606 $x14883)))
 (let (($x14884 (not $x14886)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x14887 (or $x6127 $x14884 $x11632)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11633 (not $x6172)))
 (let (($x14863 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14857 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14857)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14870 (not $x14863)))
 (let (($x14871 (or $x14870 $x11633)))
 (let (($x14872 (not $x14871)))
 (let (($x11587 (not $x6127)))
 (let (($x14877 (or $x11587 $x14872)))
 (not (or (not $x14877) (not $x14887))))))))))))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let (($x11663 (forall ((no%param Int) )(! (let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x11616 (not (or $x11606 (and $x11610 $x11613)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x11665 (or $x6127 $x11616 $x11632)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11587 (not $x6127)))
 (let (($x11641 (or $x11587 $x6177)))
 (and $x11641 $x11665))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x14908 (lambda ((no%param Int) )(let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let (($x14881 (not $x11613)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let (($x14879 (not $x11610)))
 (let (($x14882 (or $x14879 $x14881)))
 (let (($x14883 (not $x14882)))
 (let ((?x4023 (UINT 64)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x14886 (or $x11606 $x14883)))
 (let (($x14884 (not $x14886)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x14887 (or $x6127 $x14884 $x11632)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11633 (not $x6172)))
 (let (($x14863 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14857 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14857)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14870 (not $x14863)))
 (let (($x14871 (or $x14870 $x11633)))
 (let (($x14872 (not $x14871)))
 (let (($x11587 (not $x6127)))
 (let (($x14877 (or $x11587 $x14872)))
 (let (($x14902 (not (or (not $x14877) (not $x14887)))))
 (let (($x11616 (not (or $x11606 (and $x11610 $x11613)))))
 (let (($x11665 (or $x6127 $x11616 $x11632)))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11641 (or $x11587 $x6177)))
 (let (($x11669 (and $x11641 $x11665)))
 (let (($x14889 (= $x11665 $x14887)))
 (let ((@x14895 (trans (monotonicity (rewrite (= $x11616 $x14884)) (rewrite (= $x11632 $x11632)) $x14889) (rewrite (= $x14887 $x14887)) $x14889)))
 (trans (monotonicity (rewrite (= $x11641 $x14877)) @x14895 (= $x11669 (and $x14877 $x14887))) (rewrite (= (and $x14877 $x14887) $x14902)) (= $x11669 $x14902))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x11645 (forall ((no%param Int) )(! (let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x11616 (not (or $x11606 (and $x11610 $x11613)))))
 (let (($x11636 (or $x11616 $x11632)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11587 (not $x6127)))
 (let (($x11641 (or $x11587 $x6177)))
 (and $x11641 (or $x6127 $x11636)))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x11664 (lambda ((no%param Int) )(let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x11616 (not (or $x11606 (and $x11610 $x11613)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x11665 (or $x6127 $x11616 $x11632)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11587 (not $x6127)))
 (let (($x11641 (or $x11587 $x6177)))
 (let (($x11669 (and $x11641 $x11665)))
 (let (($x11642 (and $x11641 (or $x6127 (or $x11616 $x11632)))))
 (rewrite (= $x11642 $x11669)))))))))))))))))))))))))))))))))))))
 ))
 (let (($x6178 (forall ((no%param Int) )(! (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 $x6177))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x11646 (lambda ((no%param Int) )(let ((?x11629 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11626 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11627 (I ?x11626)))
 (let ((?x11628 (vstd!bytes.spec_u64_to_le_bytes.? ?x11627)))
 (let (($x11630 (= ?x11628 ?x11629)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11623 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11624 (= ?x11623 8)))
 (let (($x11625 (not $x11624)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11621 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11622 (not $x11621)))
 (let (($x11631 (or $x11622 $x11625 $x11630)))
 (let (($x11632 (not $x11631)))
 (let ((?x11612 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11607 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11608 (Poly%vstd!seq.Seq<u8.>. ?x11607)))
 (let ((?x11611 (vstd!bytes.spec_u64_from_le_bytes.? ?x11608)))
 (let (($x11613 (= ?x11611 ?x11612)))
 (let ((?x11609 (vstd!seq.Seq.len.? $ ?x1876 ?x11608)))
 (let (($x11610 (= ?x11609 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11605 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11606 (not $x11605)))
 (let (($x11616 (not (or $x11606 (and $x11610 $x11613)))))
 (let (($x11636 (or $x11616 $x11632)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11587 (not $x6127)))
 (let (($x11641 (or $x11587 $x6177)))
 (let (($x11642 (and $x11641 (or $x6127 $x11636))))
 (let (($x6161 (= $x6127 $x6177)))
 (let ((@x11639 (nnf-neg (sk (~ (not $x6155) $x11616)) (sk (~ (not $x6172) $x11632)) (~ (not $x6177) $x11636))))
 (let ((?x11598 (lambda ((s$ Poly) )(let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x6167 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))
 (refl (~ $x6167 $x6167)))))))))))
 ))
 (let ((?x11592 (lambda ((x$ Poly) )(let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (let (($x6152 (or $x6151 $x6135)))
 (refl (~ $x6152 $x6152)))))))))))))
 ))
 (let ((@x11603 (monotonicity (nnf-pos (proof-bind ?x11592) (~ $x6155 $x6155)) (nnf-pos (proof-bind ?x11598) (~ $x6172 $x6172)) (~ $x6177 $x6177))))
 (nnf-pos (refl (~ $x6127 $x6127)) (refl (~ $x11587 $x11587)) @x11603 @x11639 (~ $x6161 $x11642)))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x6149 (forall ((no%param Int) )(! (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 (and $x6138 $x6145))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x6180 (lambda ((no%param Int) )(let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6161 (= $x6127 $x6177)))
 (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6147 (= $x6127 (and $x6138 $x6145))))
 (rewrite (= $x6147 $x6161)))))))))))
 ))
 (let ((@x6168 (mp (asserted $x6149) (quant-intro (proof-bind ?x6180) (= $x6149 $x6178)) $x6178)))
 (let ((@x11655 (mp (mp~ @x6168 (nnf-pos (proof-bind ?x11646) (~ $x6178 $x11645)) $x11645) (quant-intro (proof-bind ?x11664) (= $x11645 $x11663)) $x11663)))
 (let ((@x14862 (mp @x11655 (quant-intro (proof-bind ?x14908) (= $x11663 $x14907)) $x14907)))
 (let (($x44951 (or (not $x14907) $x44925)))
 (let ((@x44950 ((_ quant-inst 0) $x44951)))
 (let ((@x45004 (def-axiom (or $x44924 $x44921))))
 (let ((@x44185 (not-or-elim @x44176 $x44048)))
 (let ((@x44973 (def-axiom (or $x44923 $x44160 $x14872))))
 (let ((@x51498 (unit-resolution (unit-resolution @x44973 @x44185 (or $x44923 $x14872)) (unit-resolution @x45004 (unit-resolution @x44950 @x14862 $x44925) $x44921) $x14872)))
 (let ((@x44965 (def-axiom (or $x14871 $x14863))))
 (let ((@x51499 (unit-resolution @x44965 @x51498 $x14863)))
 (let (($x45420 (or $x14870 $x45396 $x45415)))
 (let ((@x45426 (mp ((_ quant-inst (I ?x44020)) (or $x14870 $x45416)) (rewrite (= (or $x14870 $x45416) $x45420)) $x45420)))
 (let ((@x45430 (def-axiom (or $x45414 $x45412))))
 (let ((@x51502 (unit-resolution @x45430 (unit-resolution (unit-resolution @x45426 @x51499 $x45416) @x47901 $x45415) $x45412)))
 (let ((@x51540 (symm (monotonicity (symm @x47884 (= ?x44749 ?x45452)) (= ?x45411 (%I ?x45452))) (= (%I ?x45452) ?x45411))))
 (let ((?x45453 (%I ?x45452)))
 (let (($x45456 (= ?x44302 ?x45453)))
 (let (($x45459 (or $x45436 $x45456)))
 (let ((@x45460 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x43991)) $x45459)))
 (let ((@x51548 (trans* (unit-resolution @x45460 @x8959 $x45456) @x51540 (symm @x51502 (= ?x45411 ?x45410)) (symm (monotonicity @x51512 (= ?x46870 ?x45410)) (= ?x45410 ?x46870)) (unit-resolution @x46892 @x8959 $x46877) ((_ th-lemma datatype) (= ?x46872 ?x46885)) (symm (monotonicity @x51525 (= ?x44387 ?x46885)) (= ?x46885 ?x44387)) (symm ((_ th-lemma datatype) (= ?x44376 ?x44387)) $x48319) $x50874)))
 (let (($x50866 (= ?x44294 ?x44375)))
 (let ((?x44383 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x44377)))
 (let (($x48177 (= ?x44383 ?x44375)))
 (let ((?x46883 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x46874)))
 (let (($x46887 (= ?x46866 ?x46868)))
 (let (($x46894 (or $x45436 $x46887)))
 (let ((@x46895 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x46865)) $x46894)))
 (let ((?x45367 (Poly%vstd!seq.Seq<u8.>. ?x44719)))
 (let ((?x45385 (vstd!bytes.spec_u64_from_le_bytes.? ?x45367)))
 (let (($x49077 (= ?x44064 ?x44065)))
 (let (($x49078 (= $x49077 $x44066)))
 (let (($x49080 (or $x45011 $x49078)))
 (let ((@x49081 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. old_tail_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7363 ?x7365)) $x49080)))
 (let ((@x49084 (def-axiom (or (not $x49078) $x49077 $x44309))))
 (let ((@x51558 (unit-resolution (unit-resolution @x49084 (unit-resolution @x49081 @x9043 $x49078) (or $x49077 $x44309)) @x51267 $x49077)))
 (let ((@x51564 (trans* (monotonicity @x51475 (= ?x46865 ?x44065)) (symm @x51558 (= ?x44065 ?x44064)) @x48707 (= ?x46865 ?x45367))))
 (let ((?x45386 (%I ?x44717)))
 (let (($x45387 (= ?x45385 ?x45386)))
 (let (($x45388 (not $x45387)))
 (let ((?x45368 (vstd!seq.Seq.len.? $ ?x1876 ?x45367)))
 (let (($x45383 (= ?x45368 8)))
 (let (($x45384 (not $x45383)))
 (let (($x45389 (or $x45384 $x45388)))
 (let (($x45390 (not $x45389)))
 (let (($x45369 (has_type ?x44717 ?x4023)))
 (let ((?x45449 (I ?x44294)))
 (let (($x47765 (has_type ?x45449 ?x4023)))
 (let (($x47852 (not $x47765)))
 (let ((?x44780 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x44304)))
 (let ((@x47843 (symm (monotonicity ((_ th-lemma datatype) (= ?x43991 ?x44304)) (= ?x44006 ?x44780)) (= ?x44780 ?x44006))))
 (let (($x44783 (= ?x44780 ?x44294)))
 (let (($x2794 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2791 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail x)))
 (let ((?x2790 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail x)))
 (= ?x2790 ?x2791))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail x) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail_accessor_definition))
 ))
 (let ((?x9958 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2791 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail x)))
 (let ((?x2790 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail x)))
 (let (($x2792 (= ?x2790 ?x2791)))
 (refl (~ $x2792 $x2792))))))
 ))
 (let ((@x9962 (mp~ (asserted $x2794) (nnf-pos (proof-bind ?x9958) (~ $x2794 $x2794)) $x2794)))
 (let (($x44785 (not $x2794)))
 (let (($x44805 (or $x44785 $x44783)))
 (let ((?x44291 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x44304)))
 (let (($x44782 (= ?x44780 ?x44291)))
 (let (($x44806 (or $x44785 $x44782)))
 (let (($x44808 (= $x44806 $x44805)))
 (let ((@x44812 (trans (monotonicity (rewrite (= $x44782 $x44783)) $x44808) (rewrite (= $x44805 $x44805)) $x44808)))
 (let ((@x44813 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44292 ?x44294 ?x44302)) $x44806) @x44812 $x44805)))
 (let ((@x47845 (trans* (symm (unit-resolution @x44813 @x9962 $x44783) (= ?x44294 ?x44780)) @x47843 (= ?x44294 ?x44006))))
 (let ((@x47847 (monotonicity @x47845 (= ?x45449 ?x44717))))
 (let ((@x47854 (monotonicity (symm (monotonicity @x47847 (= $x47765 $x45369)) (= $x45369 $x47765)) (= (not $x45369) $x47852))))
 (let (($x45108 (uInv 64 ?x44294)))
 (let ((@x47860 (symm (monotonicity @x47845 (= $x45108 (uInv 64 ?x44006))) (= (uInv 64 ?x44006) $x45108))))
 (let (($x44511 (uInv 64 ?x44006)))
 (let (($x2805 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let (($x2797 (uInv 64 ?x2796)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (or $x2739 $x2797)))))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail_invariant_definition))
 ))
 (let ((?x9965 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let (($x2797 (uInv 64 ?x2796)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2802 (or $x2739 $x2797)))
 (refl (~ $x2802 $x2802)))))))))
 ))
 (let (($x2800 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let (($x2797 (uInv 64 ?x2796)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (=> $x2731 $x2797))))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail_invariant_definition))
 ))
 (let ((?x2806 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let (($x2797 (uInv 64 ?x2796)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2802 (or $x2739 $x2797)))
 (let (($x2798 (=> $x2731 $x2797)))
 (rewrite (= $x2798 $x2802))))))))))
 ))
 (let ((@x2810 (mp (asserted $x2800) (quant-intro (proof-bind ?x2806) (= $x2800 $x2805)) $x2805)))
 (let ((@x9969 (mp~ @x2810 (nnf-pos (proof-bind ?x9965) (~ $x2805 $x2805)) $x2805)))
 (let (($x44522 (not $x2805)))
 (let (($x44523 (or $x44522 $x44508 $x44511)))
 (let ((@x44528 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. metadata!)) (or $x44522 (or $x44508 $x44511))) (rewrite (= (or $x44522 (or $x44508 $x44511)) $x44523)) $x44523)))
 (let (($x45153 (not $x45108)))
 (let (($x47830 (or $x47783 $x45153 $x47765)))
 (let ((@x47835 (mp ((_ quant-inst 64 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x43991)) (or $x47783 (or $x45153 $x47765))) (rewrite (= (or $x47783 (or $x45153 $x47765)) $x47830)) $x47830)))
 (let ((@x47862 (unit-resolution @x47835 @x9127 (mp (unit-resolution @x44528 @x9969 @x43975 $x44511) @x47860 $x45108) $x47765)))
 (let ((@x47864 (lemma (unit-resolution @x47862 (mp (hypothesis (not $x45369)) @x47854 $x47852) false) $x45369)))
 (let (($x45371 (not $x45369)))
 (let (($x45391 (or $x45371 $x45390)))
 (let (($x45395 (or $x14870 $x45371 $x45390)))
 (let ((@x45401 (mp ((_ quant-inst (I ?x44006)) (or $x14870 $x45391)) (rewrite (= (or $x14870 $x45391) $x45395)) $x45395)))
 (let ((@x45405 (def-axiom (or $x45389 $x45387))))
 (let ((@x51554 (unit-resolution @x45405 (unit-resolution (unit-resolution @x45401 @x51499 $x45391) @x47864 $x45390) $x45387)))
 (let ((@x51581 (symm (monotonicity (symm @x47847 (= ?x44717 ?x45449)) (= ?x45386 (%I ?x45449))) (= (%I ?x45449) ?x45386))))
 (let ((?x45450 (%I ?x45449)))
 (let (($x45451 (= ?x44294 ?x45450)))
 (let (($x45454 (or $x45436 $x45451)))
 (let ((@x45455 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x43991)) $x45454)))
 (let ((@x51589 (trans* (unit-resolution @x45455 @x8959 $x45451) @x51581 (symm @x51554 (= ?x45386 ?x45385)) (symm (monotonicity @x51564 (= ?x46866 ?x45385)) (= ?x45385 ?x46866)) (unit-resolution @x46895 @x8959 $x46887) ((_ th-lemma datatype) (= ?x46868 ?x46883)) (symm (monotonicity @x51525 (= ?x44383 ?x46883)) (= ?x46883 ?x44383)) (symm ((_ th-lemma datatype) (= ?x44375 ?x44383)) $x48177) $x50866)))
 (let (($x50862 (= ?x44292 ?x44374)))
 (let ((?x44381 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44377)))
 (let (($x47989 (= ?x44381 ?x44374)))
 (let ((?x46881 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x46874)))
 (let (($x46876 (= ?x46847 ?x46864)))
 (let (($x46888 (or $x45436 $x46876)))
 (let ((@x46889 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x46859)) $x46888)))
 (let ((?x45356 (Poly%vstd!seq.Seq<u8.>. ?x44705)))
 (let ((?x45360 (vstd!bytes.spec_u64_from_le_bytes.? ?x45356)))
 (let (($x45471 (= ?x44056 ?x44058)))
 (let (($x45472 (= $x45471 $x44059)))
 (let (($x45477 (or $x45011 $x45472)))
 (let ((@x45478 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. old_head_bytes@1) (vstd!seq.Seq.subrange.? $ ?x1876 ?x44057 ?x7357 ?x7359)) $x45477)))
 (let ((@x45481 (def-axiom (or (not $x45472) $x45471 $x44337))))
 (let ((@x51599 (unit-resolution (unit-resolution @x45481 (unit-resolution @x45478 @x9043 $x45472) (or $x45471 $x44337)) @x51280 $x45471)))
 (let ((@x51605 (trans* (monotonicity @x51475 (= ?x46859 ?x44058)) (symm @x51599 (= ?x44058 ?x44056)) @x48748 (= ?x46859 ?x45356))))
 (let ((?x45361 (%I ?x44704)))
 (let (($x45362 (= ?x45360 ?x45361)))
 (let (($x45363 (not $x45362)))
 (let ((?x45357 (vstd!seq.Seq.len.? $ ?x1876 ?x45356)))
 (let (($x45358 (= ?x45357 8)))
 (let (($x45359 (not $x45358)))
 (let (($x45364 (or $x45359 $x45363)))
 (let (($x45365 (not $x45364)))
 (let (($x45348 (has_type ?x44704 ?x4023)))
 (let ((?x45418 (I ?x44292)))
 (let (($x47777 (has_type ?x45418 ?x4023)))
 (let (($x47815 (not $x47777)))
 (let ((?x44685 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x44304)))
 (let ((@x47806 (symm (monotonicity ((_ th-lemma datatype) (= ?x43991 ?x44304)) (= ?x43992 ?x44685)) (= ?x44685 ?x43992))))
 (let (($x44691 (= ?x44685 ?x44292)))
 (let (($x2773 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2770 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head x)))
 (let ((?x2769 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head x)))
 (= ?x2769 ?x2770))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head x) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head_accessor_definition))
 ))
 (let ((?x9944 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2770 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head x)))
 (let ((?x2769 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head x)))
 (let (($x2771 (= ?x2769 ?x2770)))
 (refl (~ $x2771 $x2771))))))
 ))
 (let ((@x9948 (mp~ (asserted $x2773) (nnf-pos (proof-bind ?x9944) (~ $x2773 $x2773)) $x2773)))
 (let (($x44693 (not $x2773)))
 (let (($x44695 (or $x44693 $x44691)))
 (let ((?x44299 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44304)))
 (let (($x44686 (= ?x44685 ?x44299)))
 (let (($x44696 (or $x44693 $x44686)))
 (let (($x44698 (= $x44696 $x44695)))
 (let ((@x44702 (trans (monotonicity (rewrite (= $x44686 $x44691)) $x44698) (rewrite (= $x44695 $x44695)) $x44698)))
 (let ((@x44703 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44292 ?x44294 ?x44302)) $x44696) @x44702 $x44695)))
 (let ((@x47808 (trans* (symm (unit-resolution @x44703 @x9948 $x44691) (= ?x44292 ?x44685)) @x47806 (= ?x44292 ?x43992))))
 (let ((@x47810 (monotonicity @x47808 (= ?x45418 ?x44704))))
 (let ((@x47817 (monotonicity (symm (monotonicity @x47810 (= $x47777 $x45348)) (= $x45348 $x47777)) (= (not $x45348) $x47815))))
 (let (($x45196 (uInv 64 ?x44292)))
 (let ((@x47823 (symm (monotonicity @x47808 (= $x45196 (uInv 64 ?x43992))) (= (uInv 64 ?x43992) $x45196))))
 (let (($x44520 (uInv 64 ?x43992)))
 (let (($x2784 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let (($x2776 (uInv 64 ?x2775)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (or $x2739 $x2776)))))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head_invariant_definition))
 ))
 (let ((?x9951 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let (($x2776 (uInv 64 ?x2775)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2781 (or $x2739 $x2776)))
 (refl (~ $x2781 $x2781)))))))))
 ))
 (let (($x2779 (forall ((x Poly) )(! (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let (($x2776 (uInv 64 ?x2775)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (=> $x2731 $x2776))))) :pattern ( (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head_invariant_definition))
 ))
 (let ((?x2785 (lambda ((x Poly) )(let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let (($x2776 (uInv 64 ?x2775)))
 (let (($x2731 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2781 (or $x2739 $x2776)))
 (let (($x2777 (=> $x2731 $x2776)))
 (rewrite (= $x2777 $x2781))))))))))
 ))
 (let ((@x2789 (mp (asserted $x2779) (quant-intro (proof-bind ?x2785) (= $x2779 $x2784)) $x2784)))
 (let ((@x9955 (mp~ @x2789 (nnf-pos (proof-bind ?x9951) (~ $x2784 $x2784)) $x2784)))
 (let (($x44531 (not $x2784)))
 (let (($x44532 (or $x44531 $x44508 $x44520)))
 (let ((@x44537 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. metadata!)) (or $x44531 (or $x44508 $x44520))) (rewrite (= (or $x44531 (or $x44508 $x44520)) $x44532)) $x44532)))
 (let (($x45226 (not $x45196)))
 (let (($x47785 (or $x47783 $x45226 $x47777)))
 (let ((?x45419 (I ?x44299)))
 (let (($x47749 (has_type ?x45419 ?x4023)))
 (let (($x45167 (uInv 64 ?x44299)))
 (let (($x47748 (not $x45167)))
 (let (($x47775 (or $x47748 $x47749)))
 (let (($x47786 (or $x47783 $x47775)))
 (let ((@x47790 (monotonicity (rewrite (= $x47775 (or $x45226 $x47777))) (= $x47786 (or $x47783 (or $x45226 $x47777))))))
 (let ((@x47794 (trans @x47790 (rewrite (= (or $x47783 (or $x45226 $x47777)) $x47785)) (= $x47786 $x47785))))
 (let ((@x47825 (unit-resolution (mp ((_ quant-inst 64 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44304)) $x47786) @x47794 $x47785) @x9127 (mp (unit-resolution @x44537 @x9955 @x43975 $x44520) @x47823 $x45196) $x47777)))
 (let ((@x47827 (lemma (unit-resolution @x47825 (mp (hypothesis (not $x45348)) @x47817 $x47815) false) $x45348)))
 (let (($x45349 (not $x45348)))
 (let (($x45366 (or $x45349 $x45365)))
 (let (($x45370 (or $x14870 $x45349 $x45365)))
 (let ((@x45376 (mp ((_ quant-inst (I ?x43992)) (or $x14870 $x45366)) (rewrite (= (or $x14870 $x45366) $x45370)) $x45370)))
 (let ((@x45380 (def-axiom (or $x45364 $x45362))))
 (let ((@x51595 (unit-resolution @x45380 (unit-resolution (unit-resolution @x45376 @x51499 $x45366) @x47827 $x45365) $x45362)))
 (let ((@x51622 (symm (monotonicity (symm @x47810 (= ?x44704 ?x45418)) (= ?x45361 (%I ?x45418))) (= (%I ?x45418) ?x45361))))
 (let ((?x45434 (%I ?x45418)))
 (let (($x45437 (= ?x44292 ?x45434)))
 (let (($x45438 (or $x45436 $x45437)))
 (let (($x45417 (= ?x44299 (%I ?x45419))))
 (let (($x45440 (or $x45436 $x45417)))
 (let (($x45443 (= $x45440 $x45438)))
 (let ((@x45447 (trans (monotonicity (rewrite (= $x45417 $x45437)) $x45443) (rewrite (= $x45438 $x45438)) $x45443)))
 (let ((@x45448 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44304)) $x45440) @x45447 $x45438)))
 (let ((@x51630 (trans* (unit-resolution @x45448 @x8959 $x45437) @x51622 (symm @x51595 (= ?x45361 ?x45360)) (symm (monotonicity @x51605 (= ?x46847 ?x45360)) (= ?x45360 ?x46847)) (unit-resolution @x46889 @x8959 $x46876) ((_ th-lemma datatype) (= ?x46864 ?x46881)) (symm (monotonicity @x51525 (= ?x44381 ?x46881)) (= ?x46881 ?x44381)) (symm ((_ th-lemma datatype) (= ?x44374 ?x44381)) $x47989) $x50862)))
 (let (($x44296 (= ?x43991 ?x44304)))
 (let ((@x47798 ((_ th-lemma datatype) $x44296)))
 (let ((?x44319 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size metadata!)))
 (let ((?x44285 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail metadata!)))
 (let ((?x44283 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head metadata!)))
 (let ((?x44312 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44283 ?x44285 ?x44319)))
 (let ((?x44539 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44312)))
 (let ((?x44540 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44539)))
 (let ((@x51635 (monotonicity (symm ((_ th-lemma datatype) (= metadata! ?x44312)) (= ?x44312 metadata!)) (= ?x44539 ?x43973))))
 (let (($x44548 (= ?x44312 ?x44540)))
 (let (($x2729 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_box_axiom_definition))
 ))
 (let ((?x9923 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2727 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))))
 (refl (~ $x2727 $x2727)))))
 ))
 (let ((@x9927 (mp~ (asserted $x2729) (nnf-pos (proof-bind ?x9923) (~ $x2729 $x2729)) $x2729)))
 (let (($x44551 (not $x2729)))
 (let (($x44552 (or $x44551 $x44548)))
 (let ((@x44553 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44283 ?x44285 ?x44319)) $x44552)))
 (let (($x44306 (= metadata! ?x44312)))
 (let ((@x51631 ((_ th-lemma datatype) $x44306)))
 (let ((@x51641 (trans* @x51631 (unit-resolution @x44553 @x9927 $x44548) (monotonicity @x51635 (= ?x44540 ?x43991)) @x47798 (monotonicity @x51630 @x51589 @x51548 (= ?x44304 ?x44377)) @x51523 $x44083)))
 (let ((@x44394 (def-axiom (or $x44146 (not $x44083)))))
 (let ((@x44409 (def-axiom (or $x44214 $x44211 $x44212))))
 (let ((@x51643 (unit-resolution @x44409 (unit-resolution @x44394 @x51641 $x44146) (unit-resolution (def-axiom (or $x44218 $x44213)) @x51470 $x44213) $x44212)))
 (let ((@x44401 (def-axiom (or $x44150 $x44399))))
 (unit-resolution (unit-resolution @x44401 @x51643 $x44399) @x51488 false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

