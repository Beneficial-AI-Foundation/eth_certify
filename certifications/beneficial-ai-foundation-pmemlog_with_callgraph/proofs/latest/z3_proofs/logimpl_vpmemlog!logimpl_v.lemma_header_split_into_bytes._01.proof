(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10200)
(:version "4.12.5")
unsat
((declare-fun i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 (Poly Poly Type Dcr) Poly)
(declare-fun s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 () Poly)
(declare-fun x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 () Poly)
(proof
(let ((?x1876 (UINT 8)))
 (let ((?x43799 (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)))
 (let ((?x43794 (Poly%vstd!seq.Seq<u8.>. crc_bytes!)))
 (let ((?x43873 (vstd!seq.Seq.add.? $ ?x1876 ?x43794 ?x43799)))
 (let ((?x43804 (Poly%vstd!seq.Seq<u8.>. header_bytes!)))
 (let ((?x48410 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x43804 ?x43873 ?x1876 $)))
 (let ((?x48411 (vstd!seq.Seq.index.? $ ?x1876 ?x43804 ?x48410)))
 (let ((?x48468 (vstd!seq.Seq.index.? $ ?x1876 ?x43873 ?x48410)))
 (let (($x48469 (= ?x48468 ?x48411)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x44784 (%I ?x7829)))
 (let ((?x48470 (%I ?x48410)))
 (let ((?x48867 (I ?x48470)))
 (let ((?x49171 (%I ?x48867)))
 (let ((?x49229 (Add ?x49171 ?x44784)))
 (let ((?x49162 (I ?x49229)))
 (let ((?x49175 (vstd!seq.Seq.index.? $ ?x1876 ?x43804 ?x49162)))
 (let (($x49483 (= ?x49171 ?x48470)))
 (let (($x49461 (= ?x48470 ?x49171)))
 (let (($x48868 (= ?x48410 ?x48867)))
 (let (($x48477 (has_type ?x48410 INT)))
 (let ((?x48472 (vstd!seq.Seq.len.? $ ?x1876 ?x43873)))
 (let ((?x48490 (* (- 1) ?x48472)))
 (let ((?x48521 (+ ?x48470 ?x48490)))
 (let (($x48522 (>= ?x48521 0)))
 (let (($x48475 (>= ?x48470 0)))
 (let (($x48476 (not $x48475)))
 (let (($x48478 (not $x48477)))
 (let (($x48527 (or $x48478 $x48476 $x48522 $x48469)))
 (let (($x48533 (not $x48527)))
 (let ((?x43805 (vstd!seq.Seq.len.? $ ?x1876 ?x43804)))
 (let (($x48481 (= ?x48472 ?x43805)))
 (let (($x48482 (not $x48481)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x43874 (ext_eq false ?x1968 ?x43873 ?x43804)))
 (let (($x48515 (or $x43874 $x48482 $x48533)))
 (let (($x48523 (not $x48515)))
 (let (($x48494 (forall ((i$ Poly) )(! (let ((?x43804 (Poly%vstd!seq.Seq<u8.>. header_bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x48487 (vstd!seq.Seq.index.? $ ?x1876 ?x43804 i$)))
 (let ((?x43799 (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)))
 (let ((?x43794 (Poly%vstd!seq.Seq<u8.>. crc_bytes!)))
 (let ((?x43873 (vstd!seq.Seq.add.? $ ?x1876 ?x43794 ?x43799)))
 (let ((?x48485 (vstd!seq.Seq.index.? $ ?x1876 ?x43873 i$)))
 (let ((?x264 (%I i$)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13740 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13740 (>= (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? $ ?x1876 ?x43873))) 0) (= ?x48485 ?x48487)))))))))))))) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (vstd!seq.Seq.add.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. crc_bytes!) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!)) i$) ) :pattern ( (vstd!seq.Seq.index.? $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x48495 (not $x48494)))
 (let (($x48496 (or $x48482 $x48495)))
 (let (($x48497 (not $x48496)))
 (let (($x44329 (not $x43874)))
 (let (($x48498 (or $x44329 $x48497)))
 (let (($x48499 (not $x48498)))
 (let (($x48534 (or $x48499 $x48523)))
 (let (($x48520 (not $x48534)))
 (let (($x48502 (has_type ?x43873 ?x1968)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x43851 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7834 ?x7835)))
 (let ((?x43859 (%Poly%vstd!seq.Seq<u8.>. ?x43851)))
 (let ((?x46925 (Poly%vstd!seq.Seq<u8.>. ?x43859)))
 (let ((?x43822 (Poly%pmemlog!logimpl_v.PersistentHeader. header@)))
 (let ((?x43823 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x43822)))
 (let ((?x43824 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x43823)))
 (let ((?x43831 (I ?x43824)))
 (let ((?x43832 (vstd!bytes.spec_u64_to_le_bytes.? ?x43831)))
 (let ((?x43833 (Poly%vstd!seq.Seq<u8.>. ?x43832)))
 (let ((?x48572 (vstd!seq.Seq.add.? $ ?x1876 ?x43833 ?x46925)))
 (let (($x48575 (has_type ?x48572 ?x1968)))
 (let (($x47884 (= ?x46925 ?x43799)))
 (let (($x48323 (= ?x43799 ?x46925)))
 (let (($x48327 (ext_eq false ?x1968 ?x43799 ?x46925)))
 (let (($x48310 (= $x48323 $x48327)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x8975 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x8979 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x8975) (~ $x418 $x418)) $x418)))
 (let (($x44735 (not $x418)))
 (let (($x48313 (or $x44735 $x48310)))
 (let ((@x48364 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (Poly%vstd!seq.Seq<u8.>. metadata_bytes!) (Poly%vstd!seq.Seq<u8.>. ?x43859)) $x48313)))
 (let ((?x44463 (%Poly%vstd!seq.Seq<u8.>. ?x43799)))
 (let ((?x47379 (Poly%vstd!seq.Seq<u8.>. ?x44463)))
 (let (($x47871 (ext_eq false ?x1968 ?x47379 ?x46925)))
 (let (($x44464 (= metadata_bytes! ?x44463)))
 (let (($x1966 (forall ((x vstd!seq.Seq<u8.>.) )(! (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x))) :pattern ( (Poly%vstd!seq.Seq<u8.>. x) ) :qid internal_vstd__seq__Seq<u8.>_box_axiom_definition))
 ))
 (let ((?x9481 (lambda ((x vstd!seq.Seq<u8.>.) )(let (($x1964 (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x)))))
 (refl (~ $x1964 $x1964))))
 ))
 (let ((@x9485 (mp~ (asserted $x1966) (nnf-pos (proof-bind ?x9481) (~ $x1966 $x1966)) $x1966)))
 (let (($x44465 (not $x1966)))
 (let (($x44470 (or $x44465 $x44464)))
 (let ((@x44471 ((_ quant-inst metadata_bytes!) $x44470)))
 (let ((@x47398 (symm (unit-resolution @x44471 @x9485 $x44464) (= ?x44463 metadata_bytes!))))
 (let ((@x47400 (monotonicity @x47398 (= ?x47379 ?x43799))))
 (let ((@x48778 (symm (monotonicity (symm @x47400 (= ?x43799 ?x47379)) (= $x48327 $x47871)) (= $x47871 $x48327))))
 (let ((?x43815 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x43804)))
 (let ((?x44103 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43815)))
 (let (($x47870 (ens%pmemlog!logimpl_v.lemma_metadata_bytes_eq. ?x44463 ?x43859 ?x44103)))
 (let (($x47872 (= $x47870 $x47871)))
 (let (($x8678 (forall ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x8659 (ens%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (= $x8659 (ext_eq false ?x1968 ?x6680 ?x6683))))))) :pattern ( (ens%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!) ) :qid internal_ens__pmemlog!logimpl_v.lemma_metadata_bytes_eq._definition))
 ))
 (let ((?x12676 (lambda ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x8659 (ens%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (let (($x8676 (= $x8659 (ext_eq false ?x1968 ?x6680 ?x6683))))
 (refl (~ $x8676 $x8676)))))))))
 ))
 (let ((@x12680 (mp~ (asserted $x8678) (nnf-pos (proof-bind ?x12676) (~ $x8678 $x8678)) $x8678)))
 (let (($x47887 (or (not $x8678) $x47872)))
 (let ((@x47888 ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x43799) (%Poly%vstd!seq.Seq<u8.>. ?x43851) (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43815)) $x47887)))
 (let (($x43866 (ens%pmemlog!logimpl_v.lemma_metadata_bytes_eq. metadata_bytes! tmp%6 tmp%7)))
 (let ((?x43844 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x43823)))
 (let (($x43862 (= tmp%7 ?x43844)))
 (let (($x43930 (not %%location_label%%7)))
 (let (($x43937 (not tmp%8)))
 (let (($x43938 (or $x43937 $x43930 $x43874)))
 (let (($x43990 (not $x43938)))
 (let (($x43926 (not %%location_label%%6)))
 (let (($x43927 (or $x43926 tmp%8)))
 (let (($x43989 (not $x43927)))
 (let (($x43991 (or $x43989 $x43990)))
 (let (($x43992 (not $x43991)))
 (let (($x43868 (ext_eq false ?x1968 ?x43851 ?x43799)))
 (let (($x43869 (= tmp%8 $x43868)))
 (let (($x43934 (not $x43869)))
 (let (($x43945 (not $x43866)))
 (let (($x43996 (or $x43945 $x43934 $x43992)))
 (let (($x43987 (not $x43996)))
 (let (($x43864 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. metadata_bytes! tmp%6 tmp%7)))
 (let (($x43922 (not %%location_label%%5)))
 (let (($x43923 (or $x43922 $x43864)))
 (let (($x43985 (not $x43923)))
 (let (($x43988 (or $x43985 $x43987)))
 (let (($x43993 (not $x43988)))
 (let (($x43932 (not $x43862)))
 (let (($x43860 (= tmp%6 ?x43859)))
 (let (($x43929 (not $x43860)))
 (let (($x43957 (not tmp%5)))
 (let (($x43998 (or $x43957 $x43929 $x43932 $x43993)))
 (let (($x44009 (not $x43998)))
 (let (($x43918 (not %%location_label%%4)))
 (let (($x43919 (or $x43918 tmp%5)))
 (let (($x44008 (not $x43919)))
 (let (($x44010 (or $x44008 $x44009)))
 (let (($x44011 (not $x44010)))
 (let ((?x43852 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x43851)))
 (let ((?x43853 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43852)))
 (let ((?x43845 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43844)))
 (let (($x43854 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43845 ?x43853)))
 (let (($x43855 (= tmp%5 $x43854)))
 (let (($x43946 (not $x43855)))
 (let (($x43928 (not tmp%4)))
 (let (($x44016 (or $x43928 $x43946 $x44011)))
 (let (($x43979 (not $x44016)))
 (let (($x43914 (not %%location_label%%3)))
 (let (($x43915 (or $x43914 tmp%4)))
 (let (($x43999 (not $x43915)))
 (let (($x43971 (or $x43999 $x43979)))
 (let (($x43972 (not $x43971)))
 (let ((?x43811 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x43799)))
 (let ((?x43812 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43811)))
 (let (($x43846 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43845 ?x43812)))
 (let (($x43847 (= tmp%4 $x43846)))
 (let (($x43955 (not $x43847)))
 (let (($x43942 (not tmp%3)))
 (let (($x44000 (or $x43942 $x43955 $x43972)))
 (let (($x43984 (not $x44000)))
 (let (($x43910 (not %%location_label%%2)))
 (let (($x43911 (or $x43910 tmp%3)))
 (let (($x44019 (not $x43911)))
 (let (($x43973 (or $x44019 $x43984)))
 (let (($x43997 (not $x43973)))
 (let (($x43839 (ext_eq false ?x1968 ?x43794 ?x43833)))
 (let (($x43840 (= tmp%3 $x43839)))
 (let (($x43966 (not $x43840)))
 (let (($x43941 (not tmp%2)))
 (let (($x43904 (or $x43941 $x43966 $x43997)))
 (let (($x43921 (not $x43904)))
 (let (($x43906 (not %%location_label%%1)))
 (let (($x43907 (or $x43906 tmp%2)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x43830 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7829 ?x7831)))
 (let (($x43834 (ext_eq false ?x1968 ?x43830 ?x43833)))
 (let (($x44731 (= ?x43830 ?x43833)))
 (let ((?x46609 (vstd!bytes.spec_u64_from_le_bytes.? ?x43830)))
 (let ((?x46582 (I ?x46609)))
 (let ((?x46676 (vstd!bytes.spec_u64_to_le_bytes.? ?x46582)))
 (let ((?x43808 (vstd!bytes.spec_u64_from_le_bytes.? ?x43794)))
 (let (($x43825 (= ?x43824 ?x43808)))
 (let ((?x43809 (I ?x43808)))
 (let ((?x43810 (%I ?x43809)))
 (let (($x44525 (= ?x43808 ?x43810)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x8891 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x8895 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x8891) (~ $x237 $x237)) $x237)))
 (let (($x44542 (not $x237)))
 (let (($x44543 (or $x44542 $x44525)))
 (let ((@x44544 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x43794)) $x44543)))
 (let ((@x48139 (symm (unit-resolution @x44544 @x8895 $x44525) (= ?x43810 ?x43808))))
 (let ((?x43813 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43812)))
 (let ((?x43814 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x43810 ?x43813)))
 (let ((?x44063 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x43814)))
 (let ((@x48137 (symm ((_ th-lemma datatype) (= ?x43810 ?x44063)) (= ?x44063 ?x43810))))
 (let ((?x44101 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x43815)))
 (let ((?x44129 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44101 ?x44103)))
 (let ((?x44091 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44129)))
 (let (($x44121 (= ?x43815 ?x44129)))
 (let ((@x47916 ((_ th-lemma datatype) $x44121)))
 (let (($x43816 (= ?x43815 ?x43814)))
 (let ((@x43817 (asserted $x43816)))
 (let ((@x44423 (symm @x43817 (= ?x43814 ?x43815))))
 (let ((@x48084 (trans* @x44423 @x47916 (= ?x43814 ?x44129))))
 (let ((@x48135 (symm (monotonicity @x48084 (= ?x44063 ?x44091)) (= ?x44091 ?x44063))))
 (let ((?x44110 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43823)))
 (let ((?x44109 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x43823)))
 (let ((?x44111 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44109 ?x44110)))
 (let ((?x44136 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44111)))
 (let ((?x44585 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x44129)))
 (let ((?x44588 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x44585)))
 (let (($x44628 (= ?x44129 ?x44588)))
 (let (($x2616 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2612 (Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x2612))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeader. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeader_box_axiom_definition))
 ))
 (let ((?x9803 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2612 (Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let (($x2614 (= x (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x2612))))
 (refl (~ $x2614 $x2614)))))
 ))
 (let ((@x9807 (mp~ (asserted $x2616) (nnf-pos (proof-bind ?x9803) (~ $x2616 $x2616)) $x2616)))
 (let (($x44632 (or (not $x2616) $x44628)))
 (let ((@x44633 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44101 ?x44103)) $x44632)))
 (let (($x43820 (= header@ ?x43814)))
 (let (($x43963 (and $x43919 (or $x43957 $x43929 $x43932 (and $x43923 (or $x43945 $x43934 (and $x43927 $x43938)))))))
 (let (($x43950 (or $x43941 $x43966 (and $x43911 (or $x43942 $x43955 (and $x43915 (or $x43928 $x43946 $x43963)))))))
 (let (($x43835 (= tmp%2 $x43834)))
 (let (($x43959 (not $x43835)))
 (let (($x43940 (not tmp%1)))
 (let (($x43951 (or $x43940 $x43959 (and $x43907 $x43950))))
 (let (($x43902 (not %%location_label%%0)))
 (let (($x43903 (or $x43902 tmp%1)))
 (let (($x43909 (and $x43903 $x43951)))
 (let (($x43826 (= tmp%1 $x43825)))
 (let (($x43961 (not $x43826)))
 (let (($x43818 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. 0)))
 (let (($x43968 (not $x43818)))
 (let (($x43974 (not (or $x43968 (not $x43820) $x43961 $x43909))))
 (let (($x43877 (and (=> %%location_label%%6 tmp%8) (=> (and tmp%8 %%location_label%%7) $x43874))))
 (let (($x43881 (=> $x43862 (and (=> %%location_label%%5 $x43864) (=> (and $x43866 $x43869) $x43877)))))
 (let (($x43885 (=> $x43855 (and (=> %%location_label%%4 tmp%5) (=> (and tmp%5 $x43860 $x43862) (and (=> %%location_label%%5 $x43864) (=> (and $x43866 $x43869) $x43877)))))))
 (let (($x43889 (=> (and tmp%3 $x43847) (and (=> %%location_label%%3 tmp%4) (=> (and tmp%4 $x43855) (and (=> %%location_label%%4 tmp%5) (=> (and tmp%5 $x43860 $x43862) (and (=> %%location_label%%5 $x43864) (=> (and $x43866 $x43869) $x43877)))))))))
 (let (($x43893 (and (=> %%location_label%%1 tmp%2) (=> (and tmp%2 $x43840) (and (=> %%location_label%%2 tmp%3) $x43889)))))
 (let (($x43897 (=> $x43826 (and (=> %%location_label%%0 tmp%1) (=> (and tmp%1 $x43835) $x43893)))))
 (let (($x43900 (not (=> (and $x43818 $x43820 $x43826) (and (=> %%location_label%%0 tmp%1) (=> (and tmp%1 $x43835) $x43893))))))
 (let ((@x43962 (mp (asserted $x43900) (rewrite (= $x43900 $x43974)) $x43974)))
 (let ((@x43960 (not-or-elim @x43962 $x43820)))
 (let ((@x48050 (symm @x43960 (= ?x43814 header@))))
 (let ((@x48054 (monotonicity (trans* (symm @x47916 (= ?x44129 ?x43815)) @x43817 @x48050 (= ?x44129 header@)) (= ?x44585 ?x43822))))
 (let ((@x48065 (trans* (symm ((_ th-lemma datatype) (= ?x43823 ?x44111)) (= ?x44111 ?x43823)) (monotonicity (symm @x48054 (= ?x43822 ?x44585)) (= ?x43823 ?x44588)) (symm (unit-resolution @x44633 @x9807 $x44628) (= ?x44588 ?x44129)) (= ?x44111 ?x44129))))
 (let ((?x44629 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc ?x44111)))
 (let (($x44666 (= ?x44629 ?x44109)))
 (let (($x2664 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc x)))
 (= ?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc x))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc x) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc_accessor_definition))
 ))
 (let ((?x9824 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/crc x)))
 (let (($x2662 (= ?x2660 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc x))))
 (refl (~ $x2662 $x2662)))))
 ))
 (let ((@x9828 (mp~ (asserted $x2664) (nnf-pos (proof-bind ?x9824) (~ $x2664 $x2664)) $x2664)))
 (let (($x44668 (not $x2664)))
 (let (($x44670 (or $x44668 $x44666)))
 (let (($x44630 (= ?x44629 ?x44136)))
 (let (($x44671 (or $x44668 $x44630)))
 (let (($x44673 (= $x44671 $x44670)))
 (let ((@x44677 (trans (monotonicity (rewrite (= $x44630 $x44666)) $x44673) (rewrite (= $x44670 $x44670)) $x44673)))
 (let ((@x44678 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44109 ?x44110)) $x44671) @x44677 $x44670)))
 (let ((@x48140 (trans* (monotonicity ((_ th-lemma datatype) (= ?x43823 ?x44111)) (= ?x43824 ?x44629)) (unit-resolution @x44678 @x9828 $x44666) ((_ th-lemma datatype) (= ?x44109 ?x44136)) (monotonicity @x48065 (= ?x44136 ?x44091)) @x48135 @x48137 @x48139 $x43825)))
 (let ((@x48161 (symm (monotonicity @x48140 (= ?x43831 ?x43809)) (= ?x43809 ?x43831))))
 (let ((?x46614 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43853)))
 (let ((?x46598 (%I ?x46582)))
 (let ((?x46615 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x46598 ?x46614)))
 (let ((?x46634 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x46615)))
 (let (($x46616 (= ?x43815 ?x46615)))
 (let (($x7845 (forall ((header_seq! Poly) )(! (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7837 (pmemlog!logimpl_v.spec_bytes_to_metadata.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7834 ?x7835))))
 (let ((?x7841 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7837))))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7833 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7829 ?x7831))))
 (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (= ?x7828 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I ?x7833)) ?x7841)))))))))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_definition))
 ))
 (let (($x7827 (fuel_bool fuel%pmemlog!logimpl_v.spec_bytes_to_header.)))
 (let (($x7825 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_bytes_to_header.)))
 (let (($x46593 (= $x7827 $x7825)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x43792 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x8725 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x8730 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x8725) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x8734 (mp (mp~ @x37 @x8730 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x44825 (unit-resolution @x8734 @x43792 $x30)))
 (let ((@x46610 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_bytes_to_header.) (or (not $x30) $x46593)) @x44825 (hypothesis (not $x46593)) false)))
 (let ((@x46623 (lemma @x46610 $x46593)))
 (let ((@x7826 (asserted $x7825)))
 (let ((@x46601 (def-axiom (or (not $x46593) $x7827 (not $x7825)))))
 (let ((@x48143 (unit-resolution (unit-resolution @x46601 @x7826 (or (not $x46593) $x7827)) @x46623 $x7827)))
 (let (($x7848 (not $x7827)))
 (let (($x7849 (or $x7848 $x7845)))
 (let ((?x12372 (lambda ((header_seq! Poly) )(let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7837 (pmemlog!logimpl_v.spec_bytes_to_metadata.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7834 ?x7835))))
 (let ((?x7841 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7837))))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7833 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7829 ?x7831))))
 (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7843 (= ?x7828 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I ?x7833)) ?x7841))))
 (refl (~ $x7843 $x7843))))))))))))))
 ))
 (let ((@x12377 (monotonicity (refl (~ $x7848 $x7848)) (nnf-pos (proof-bind ?x12372) (~ $x7845 $x7845)) (~ $x7849 $x7849))))
 (let ((@x7852 (mp (asserted (=> $x7827 $x7845)) (rewrite (= (=> $x7827 $x7845) $x7849)) $x7849)))
 (let ((@x12381 (mp (mp~ @x7852 @x12377 $x7849) (rewrite (= $x7849 $x7849)) $x7849)))
 (let (($x46620 (or (not $x7845) $x46616)))
 (let ((@x46621 ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. header_bytes!)) $x46620)))
 (let ((@x48147 (symm (unit-resolution @x46621 (unit-resolution @x12381 @x48143 $x7845) $x46616) (= ?x46615 ?x43815))))
 (let ((@x48149 (trans* @x48147 @x47916 (= ?x46615 ?x44129))))
 (let (($x46650 (= ?x46609 ?x46598)))
 (let (($x46666 (or $x44542 $x46650)))
 (let ((@x46667 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x43830)) $x46666)))
 (let ((@x48155 (trans* (unit-resolution @x46667 @x8895 $x46650) ((_ th-lemma datatype) (= ?x46598 ?x46634)) (monotonicity @x48149 (= ?x46634 ?x44091)) @x48135 @x48137 @x48139 (= ?x46609 ?x43808))))
 (let ((@x48177 (monotonicity (trans* (monotonicity @x48155 (= ?x46582 ?x43809)) @x48161 (= ?x46582 ?x43831)) (= ?x46676 ?x43832))))
 (let ((?x46677 (%Poly%vstd!seq.Seq<u8.>. ?x43830)))
 (let (($x46678 (= ?x46676 ?x46677)))
 (let (($x44754 (has_type ?x43830 ?x1968)))
 (let (($x44752 (has_type ?x7831 INT)))
 (let ((?x46917 (I 8)))
 (let (($x46918 (has_type ?x46917 INT)))
 (let (($x46966 (not $x46918)))
 (let ((?x44802 (* (- 1) ?x7830)))
 (let ((?x44808 (+ pmemlog!logimpl_v.header_crc_offset.? ?x44802)))
 (let (($x44822 (<= ?x44808 (- 8))))
 (let (($x44809 (= ?x44808 (- 8))))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x9129 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x9133 (mp~ @x925 (nnf-pos (proof-bind ?x9129) (~ $x920 $x920)) $x920)))
 (let (($x44812 (not $x920)))
 (let (($x44813 (or $x44812 $x44809)))
 (let (($x44806 (= (+ 8 pmemlog!logimpl_v.header_crc_offset.? ?x44802) 0)))
 (let (($x44814 (or $x44812 $x44806)))
 (let (($x44816 (= $x44814 $x44813)))
 (let ((@x44820 (trans (monotonicity (rewrite (= $x44806 $x44809)) $x44816) (rewrite (= $x44813 $x44813)) $x44816)))
 (let ((@x44821 (mp ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.? 8) $x44814) @x44820 $x44813)))
 (let ((@x46938 (unit-resolution @x44821 @x9133 $x44809)))
 (let ((@x46939 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44809) $x44822)) @x46938 $x44822)))
 (let (($x44823 (>= ?x44808 (- 8))))
 (let ((@x46942 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44809) $x44823)) @x46938 $x44823)))
 (let (($x45816 (<= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7263 (= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7261 (fuel_bool fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x7259 (fuel_bool_default fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x45787 (= $x7261 $x7259)))
 (let ((@x45817 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_crc_offset.) (or (not $x30) $x45787)) @x44825 (hypothesis (not $x45787)) false)))
 (let ((@x45830 (lemma @x45817 $x45787)))
 (let ((@x7260 (asserted $x7259)))
 (let ((@x45808 (def-axiom (or (not $x45787) $x7261 (not $x7259)))))
 (let ((@x46948 (unit-resolution (unit-resolution @x45808 @x7260 (or (not $x45787) $x7261)) @x45830 $x7261)))
 (let (($x7266 (not $x7261)))
 (let (($x7267 (or $x7266 $x7263)))
 (let ((@x7270 (mp (asserted (=> $x7261 $x7263)) (rewrite (= (=> $x7261 $x7263) $x7267)) $x7267)))
 (let ((@x46949 (unit-resolution @x7270 @x46948 $x7263)))
 (let ((@x46950 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7263) $x45816)) @x46949 $x45816)))
 (let (($x43427 (>= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let ((?x43440 (* (- 1) pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x441 (uHi 64)))
 (let ((?x43441 (+ ?x441 ?x43440)))
 (let (($x43442 (<= ?x43441 0)))
 (let (($x43428 (not $x43427)))
 (let (($x43447 (or $x43428 $x43442)))
 (let (($x43473 (not $x43447)))
 (let (($x7271 (uInv 64 pmemlog!logimpl_v.header_crc_offset.?)))
 (let (($x43449 (= $x43447 $x7271)))
 (let (($x43452 (not $x43449)))
 (let (($x12825 (forall ((bits Int) (i Int) )(! (let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12700 (or $x540 $x578)))
 (not (= $x12700 $x648))))))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let (($x669 (forall ((bits Int) (i Int) )(! (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x584)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x12826 (lambda ((bits Int) (i Int) )(let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12700 (or $x540 $x578)))
 (let (($x12817 (not (= $x12700 $x648))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x667 (= $x648 $x584)))
 (let (($x12820 (= $x667 $x12817)))
 (let ((@x12703 (rewrite (= $x584 (not $x12700)))))
 (let ((@x12821 (trans (monotonicity @x12703 (= $x667 (= $x648 (not $x12700)))) (rewrite (= (= $x648 (not $x12700)) $x12817)) $x12820)))
 (trans @x12821 (rewrite (= $x12817 $x12817)) $x12820)))))))))))))
 ))
 (let ((?x9010 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (refl (~ $x667 $x667)))))))
 ))
 (let (($x660 (forall ((bits Int) (i Int) )(! (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x548)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x674 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x658 (= $x648 $x548)))
 (rewrite (= $x658 $x667))))))))))
 ))
 (let ((@x640 (mp (asserted $x660) (quant-intro (proof-bind ?x674) (= $x660 $x669)) $x669)))
 (let ((@x12830 (mp (mp~ @x640 (nnf-pos (proof-bind ?x9010) (~ $x669 $x669)) $x669) (quant-intro (proof-bind ?x12826) (= $x669 $x12825)) $x12825)))
 (let (($x43110 (not $x12825)))
 (let (($x43459 (or $x43110 $x43452)))
 (let ((?x43079 (* (- 1) ?x441)))
 (let ((?x43429 (+ pmemlog!logimpl_v.header_crc_offset.? ?x43079)))
 (let (($x43430 (>= ?x43429 0)))
 (let (($x43431 (or $x43428 $x43430)))
 (let (($x43432 (= $x43431 $x7271)))
 (let (($x43433 (not $x43432)))
 (let (($x43460 (or $x43110 $x43433)))
 (let (($x43462 (= $x43460 $x43459)))
 (let (($x43454 (= $x43433 $x43452)))
 (let ((@x43458 (trans (monotonicity (rewrite (= $x43432 $x43449)) $x43454) (rewrite (= $x43452 $x43452)) $x43454)))
 (let ((@x43467 (mp ((_ quant-inst 64 pmemlog!logimpl_v.header_crc_offset.?) $x43460) (trans (monotonicity @x43458 $x43462) (rewrite (= $x43459 $x43459)) $x43462) $x43459)))
 (let ((@x7272 (asserted $x7271)))
 (let ((@x43484 (def-axiom (or $x43449 $x43473 (not $x7271)))))
 (let ((@x46954 (unit-resolution (unit-resolution @x43484 @x7272 (or $x43449 $x43473)) (unit-resolution @x43467 @x12830 $x43452) $x43473)))
 (let ((@x43469 (def-axiom (or $x43447 $x43427))))
 (let ((@x46955 (unit-resolution @x43469 @x46954 $x43427)))
 (let ((@x46957 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x46955 @x46950 @x46942 @x46939 (= ?x7830 8))))
 (let ((@x46959 (symm @x46957 (= 8 ?x7830))))
 (let ((@x46965 (symm (monotonicity (monotonicity @x46959 (= ?x46917 ?x7831)) (= $x46918 $x44752)) (= $x44752 $x46918))))
 (let ((@x46969 (mp (hypothesis (not $x44752)) (monotonicity @x46965 (= (not $x44752) $x46966)) $x46966)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x9031 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x9035 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x9031) (~ $x698 $x698)) $x698)))
 (let ((@x46971 (unit-resolution (unit-resolution ((_ quant-inst 8) (or (not $x698) $x46918)) @x9035 $x46918) @x46969 false)))
 (let ((@x46972 (lemma @x46971 $x44752)))
 (let (($x44445 (has_type ?x43804 ?x1968)))
 (let ((?x44468 (%Poly%vstd!seq.Seq<u8.>. ?x43804)))
 (let ((?x46813 (Poly%vstd!seq.Seq<u8.>. ?x44468)))
 (let (($x46786 (has_type ?x46813 ?x1968)))
 (let (($x46843 (not $x46786)))
 (let (($x44469 (= header_bytes! ?x44468)))
 (let (($x44474 (or $x44465 $x44469)))
 (let ((@x44475 ((_ quant-inst header_bytes!) $x44474)))
 (let ((@x46838 (monotonicity (symm (unit-resolution @x44475 @x9485 $x44469) (= ?x44468 header_bytes!)) (= ?x46813 ?x43804))))
 (let ((@x46845 (monotonicity (symm (monotonicity @x46838 (= $x46786 $x44445)) (= $x44445 $x46786)) (= (not $x44445) $x46843))))
 (let (($x1989 (forall ((x vstd!seq.Seq<u8.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (has_type ?x1962 ?x1968)))) :pattern ( (has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_has_type_always_definition))
 ))
 (let ((?x9495 (lambda ((x vstd!seq.Seq<u8.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let ((?x1962 (Poly%vstd!seq.Seq<u8.>. x)))
 (let (($x1987 (has_type ?x1962 ?x1968)))
 (refl (~ $x1987 $x1987)))))))
 ))
 (let ((@x9499 (mp~ (asserted $x1989) (nnf-pos (proof-bind ?x9495) (~ $x1989 $x1989)) $x1989)))
 (let ((@x46848 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x43804)) (or (not $x1989) $x46786)) @x9499 $x46786) (mp (hypothesis (not $x44445)) @x46845 $x46843) false)))
 (let ((@x46849 (lemma @x46848 $x44445)))
 (let (($x44748 (has_type ?x7829 INT)))
 (let ((?x7131 (I 0)))
 (let (($x46928 (has_type ?x7131 INT)))
 (let (($x47019 (not $x46928)))
 (let ((@x47012 (symm @x46949 (= 0 pmemlog!logimpl_v.header_crc_offset.?))))
 (let ((@x47018 (symm (monotonicity (monotonicity @x47012 (= ?x7131 ?x7829)) (= $x46928 $x44748)) (= $x44748 $x46928))))
 (let ((@x47022 (mp (hypothesis (not $x44748)) (monotonicity @x47018 (= (not $x44748) $x47019)) $x47019)))
 (let ((@x47024 (unit-resolution (unit-resolution ((_ quant-inst 0) (or (not $x698) $x46928)) @x9035 $x46928) @x47022 false)))
 (let ((@x47025 (lemma @x47024 $x44748)))
 (let (($x44753 (not $x44752)))
 (let (($x44749 (not $x44748)))
 (let (($x44446 (not $x44445)))
 (let (($x44755 (or $x44446 $x44749 $x44753 $x44754)))
 (let (($x13874 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x13854 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x13844 (not $x4256)))
 (or $x13844 $x13854 $x271 $x4261)))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let (($x4272 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4261))))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x13875 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x13854 (not $x4257)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x13844 (not $x4256)))
 (let (($x13869 (or $x13844 $x13854 $x271 $x4261)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let ((@x13861 (monotonicity (rewrite (= $x4258 (not (or $x13844 $x13854 $x271)))) (= $x4266 (not (not (or $x13844 $x13854 $x271)))))))
 (let ((@x13865 (trans @x13861 (rewrite (= (not (not (or $x13844 $x13854 $x271))) (or $x13844 $x13854 $x271))) (= $x4266 (or $x13844 $x13854 $x271)))))
 (trans (monotonicity @x13865 (= $x4269 (or (or $x13844 $x13854 $x271) $x4261))) (rewrite (= (or (or $x13844 $x13854 $x271) $x4261) $x13869)) (= $x4269 $x13869))))))))))))))))))
 ))
 (let ((?x10685 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (refl (~ $x4269 $x4269))))))))))))
 ))
 (let (($x4264 (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(! (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> $x4258 $x4261)))))))) :pattern ( (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) ) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition))
 ))
 (let ((?x4275 (lambda ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly) )(let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)))
 (let (($x4261 (has_type ?x4260 ?x4244)))
 (let (($x263 (has_type end_exclusive! INT)))
 (let (($x4257 (has_type start_inclusive! INT)))
 (let (($x4256 (has_type self! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4269 (or $x4266 $x4261)))
 (let (($x4262 (=> $x4258 $x4261)))
 (rewrite (= $x4262 $x4269)))))))))))))
 ))
 (let ((@x4280 (mp (asserted $x4264) (quant-intro (proof-bind ?x4275) (= $x4264 $x4272)) $x4272)))
 (let ((@x13879 (mp (mp~ @x4280 (nnf-pos (proof-bind ?x10685) (~ $x4272 $x4272)) $x4272) (quant-intro (proof-bind ?x13875) (= $x4272 $x13874)) $x13874)))
 (let (($x44714 (not $x13874)))
 (let (($x44758 (or $x44714 $x44446 $x44749 $x44753 $x44754)))
 (let ((@x44763 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830)) (or $x44714 $x44755)) (rewrite (= (or $x44714 $x44755) $x44758)) $x44758)))
 (let ((@x48172 (unit-resolution (unit-resolution @x44763 @x13879 $x44755) @x47025 @x46849 @x46972 $x44754)))
 (let ((?x44938 (vstd!seq.Seq.len.? $ ?x1876 ?x43830)))
 (let (($x46668 (= ?x44938 8)))
 (let ((?x47542 (Sub 8 0)))
 (let (($x47556 (= ?x47542 8)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x9136 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x9140 (mp~ @x956 (nnf-pos (proof-bind ?x9136) (~ $x951 $x951)) $x951)))
 (let (($x44481 (not $x951)))
 (let (($x47561 (or $x44481 $x47556)))
 (let ((?x46163 (* (- 1) 8)))
 (let ((?x47543 (+ 0 ?x46163 ?x47542)))
 (let (($x47544 (= ?x47543 0)))
 (let (($x47562 (or $x44481 $x47544)))
 (let (($x47564 (= $x47562 $x47561)))
 (let ((@x47552 (trans (monotonicity (rewrite (= ?x46163 (- 8))) (= ?x47543 (+ 0 (- 8) ?x47542))) (rewrite (= (+ 0 (- 8) ?x47542) (+ (- 8) ?x47542))) (= ?x47543 (+ (- 8) ?x47542)))))
 (let ((@x47560 (trans (monotonicity @x47552 (= $x47544 (= (+ (- 8) ?x47542) 0))) (rewrite (= (= (+ (- 8) ?x47542) 0) $x47556)) (= $x47544 $x47556))))
 (let ((@x47569 (mp ((_ quant-inst 8 0) $x47562) (trans (monotonicity @x47560 $x47564) (rewrite (= $x47561 $x47561)) $x47564) $x47561)))
 (let (($x44785 (= pmemlog!logimpl_v.header_crc_offset.? ?x44784)))
 (let (($x44804 (or $x44542 $x44785)))
 (let ((@x44805 ((_ quant-inst pmemlog!logimpl_v.header_crc_offset.?) $x44804)))
 (let ((@x47532 (unit-resolution @x44805 @x8895 $x44785)))
 (let ((@x47574 (trans* (symm @x47532 (= ?x44784 pmemlog!logimpl_v.header_crc_offset.?)) @x46949 (= ?x44784 0))))
 (let ((?x44786 (%I ?x7831)))
 (let (($x44788 (= ?x7830 ?x44786)))
 (let (($x44800 (or $x44542 $x44788)))
 (let ((@x44801 ((_ quant-inst (Add pmemlog!logimpl_v.header_crc_offset.? 8)) $x44800)))
 (let ((@x47537 (unit-resolution @x44801 @x8895 $x44788)))
 (let ((@x47578 (trans* (symm @x47537 (= ?x44786 ?x7830)) @x46957 (= ?x44786 8))))
 (let ((?x47466 (Sub ?x44786 ?x44784)))
 (let (($x47467 (= ?x44938 ?x47466)))
 (let ((?x47475 (* (- 1) ?x44786)))
 (let ((?x47476 (+ ?x44784 ?x47475)))
 (let (($x47477 (<= ?x47476 0)))
 (let ((?x47459 (* (- 1) ?x44784)))
 (let ((?x47518 (+ pmemlog!logimpl_v.header_crc_offset.? ?x47459)))
 (let (($x47520 (>= ?x47518 0)))
 (let ((?x47521 (+ ?x7830 ?x47475)))
 (let (($x47522 (<= ?x47521 0)))
 (let ((@x47538 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44788) $x47522)) @x47537 $x47522)))
 (let ((@x47540 ((_ th-lemma arith farkas 1 1 1 1) (hypothesis (not $x47477)) @x47538 @x46939 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44785) $x47520)) @x47532 $x47520) false)))
 (let ((@x47541 (lemma @x47540 $x47477)))
 (let ((?x47491 (+ ?x43805 ?x47475)))
 (let (($x47492 (>= ?x47491 0)))
 (let ((?x44722 (* (- 1) ?x43805)))
 (let ((?x44723 (+ pmemlog!logimpl_v.header_size.? ?x44722)))
 (let (($x44724 (<= ?x44723 0)))
 (let (($x44721 (= pmemlog!logimpl_v.header_size.? ?x43805)))
 (let (($x43806 (= ?x43805 pmemlog!logimpl_v.header_size.?)))
 (let ((@x43807 (asserted $x43806)))
 (let ((@x47597 (symm @x43807 $x44721)))
 (let ((@x47598 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44721) $x44724)) @x47597 $x44724)))
 (let (($x45875 (>= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7320 (= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7318 (fuel_bool fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x7316 (fuel_bool_default fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x45858 (= $x7318 $x7316)))
 (let ((@x45888 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_size.) (or (not $x30) $x45858)) @x44825 (hypothesis (not $x45858)) false)))
 (let ((@x45901 (lemma @x45888 $x45858)))
 (let ((@x7317 (asserted $x7316)))
 (let ((@x45879 (def-axiom (or (not $x45858) $x7318 (not $x7316)))))
 (let ((@x46980 (unit-resolution (unit-resolution @x45879 @x7317 (or (not $x45858) $x7318)) @x45901 $x7318)))
 (let (($x7323 (not $x7318)))
 (let (($x7324 (or $x7323 $x7320)))
 (let ((@x7327 (mp (asserted (=> $x7318 $x7320)) (rewrite (= (=> $x7318 $x7320) $x7324)) $x7324)))
 (let ((@x46981 (unit-resolution @x7327 @x46980 $x7320)))
 (let ((@x47602 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x45875)) @x46981 $x45875)))
 (let (($x47523 (>= ?x47521 0)))
 (let ((@x47605 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44788) $x47523)) @x47537 $x47523)))
 (let ((@x47612 ((_ th-lemma arith assign-bounds 1 1 1 1 1) (or $x47492 (not $x45875) (not $x44724) (not $x47523) (not $x45816) (not $x44823)))))
 (let ((@x47613 (unit-resolution @x47612 @x47605 @x46950 @x47602 @x46942 @x47598 $x47492)))
 (let (($x47451 (>= ?x44784 0)))
 (let (($x47519 (<= ?x47518 0)))
 (let ((@x47593 (unit-resolution ((_ th-lemma arith assign-bounds -1 1) (or $x47451 $x43428 (not $x47519))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44785) $x47519)) @x47532 $x47519) @x46955 $x47451)))
 (let (($x14040 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x13840 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x13839 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x13044 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x13880 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x13854 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x13844 (not $x4256)))
 (or $x13844 $x13854 $x271 $x13880 $x13044 $x13839 $x13840 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x45055 (= $x4641 $x1589)))
 (let ((@x45057 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x45055)) @x44825 (hypothesis (not $x45055)) false)))
 (let ((@x45069 (lemma @x45057 $x45055)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x13191 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x13190 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x13189 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x13188 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x13187 (not $x1590)))
 (let (($x13186 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x13185 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x13184 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x13183 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x13182 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x13181 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x13180 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x13179 (not $x1582)))
 (let (($x13192 (or $x13179 $x13180 $x13181 $x13182 $x13183 $x13184 $x13185 $x13186 $x13187 $x13188 $x13189 $x13190 $x13191)))
 (let (($x13193 (not $x13192)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x13256 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x13255 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x13254 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x13253 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x13252 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x13251 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x13250 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x13249 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x13248 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x13247 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x13246 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x13245 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x13244 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x13243 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x13242 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x13257 (or $x1598 $x1610 $x13242 $x1621 $x13243 $x13244 $x13245 $x1565 $x13246 $x1633 $x13247 $x13248 $x1576 $x13249 $x13250 $x13251 $x13252 $x13253 $x13254 $x1644 $x13255 $x13256)))
 (let (($x13258 (not $x13257)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x13261 (or $x1669 $x13258)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x13263 (mp @x1673 (rewrite (= $x1670 $x13261)) $x13261)))
 (let ((@x41990 (def-axiom (or $x13257 $x1581))))
 (let (($x13196 (or $x1598 $x13193)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x13198 (mp @x1602 (rewrite (= $x1599 $x13196)) $x13196)))
 (let ((@x47581 (unit-resolution @x13198 (unit-resolution @x41990 (unit-resolution @x13263 @x1650 $x13258) $x1581) $x13193)))
 (let ((@x41948 (def-axiom (or $x13192 $x1589))))
 (let ((@x45062 (def-axiom (or (not $x45055) $x4641 $x13186))))
 (let ((@x47584 (unit-resolution @x45062 (unit-resolution @x41948 @x47581 $x1589) (or (not $x45055) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x14091 (or $x4675 $x14040)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x10917 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x10940 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x10917) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x14093 (mp (mp (mp~ @x4681 @x10940 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x14091)) $x14091)))
 (let ((@x47586 (unit-resolution @x14093 (unit-resolution @x47584 @x45069 $x4641) $x14040)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x47497 (not $x47492)))
 (let (($x47482 (not $x47477)))
 (let (($x47452 (not $x47451)))
 (let (($x44969 (not $x174)))
 (let (($x47503 (not $x14040)))
 (let (($x47504 (or $x47503 $x44446 $x44749 $x44753 $x44969 $x47452 $x47482 $x47497 $x47467)))
 (let ((?x47463 (+ ?x44786 ?x44722)))
 (let (($x47464 (<= ?x47463 0)))
 (let (($x47465 (not $x47464)))
 (let ((?x47460 (+ ?x44786 ?x47459)))
 (let (($x47461 (>= ?x47460 0)))
 (let (($x47462 (not $x47461)))
 (let (($x47468 (or $x44446 $x44749 $x44753 $x44969 $x47452 $x47462 $x47465 $x47467)))
 (let (($x47505 (or $x47503 $x47468)))
 (let ((@x47514 (rewrite (= (or $x47503 (or $x44446 $x44749 $x44753 $x44969 $x47452 $x47482 $x47497 $x47467)) $x47504))))
 (let (($x47434 (or $x44446 $x44749 $x44753 $x44969 $x47452 $x47482 $x47497 $x47467)))
 (let (($x47435 (= $x47468 $x47434)))
 (let ((@x47502 (trans (monotonicity (rewrite (= $x47462 $x47482)) (rewrite (= $x47465 $x47497)) $x47435) (rewrite (= $x47434 $x47434)) $x47435)))
 (let ((@x47516 (trans (monotonicity @x47502 (= $x47505 (or $x47503 $x47434))) @x47514 (= $x47505 $x47504))))
 (let ((@x47517 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830)) $x47505) @x47516 $x47504)))
 (let ((@x47614 (unit-resolution @x47517 @x175 @x47586 @x46849 @x47025 @x46972 @x47593 @x47613 @x47541 $x47467)))
 (let ((@x47617 (trans* @x47614 (monotonicity @x47578 @x47574 (= ?x47466 ?x47542)) (unit-resolution @x47569 @x9140 $x47556) $x46668)))
 (let ((@x47620 (lemma (unit-resolution (hypothesis (not $x46668)) @x47617 false) $x46668)))
 (let (($x46669 (not $x46668)))
 (let (($x44972 (not $x44754)))
 (let (($x46679 (or $x44972 $x46669 $x46678)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11569 (not $x6172)))
 (let (($x14764 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14758 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14758)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14771 (not $x14764)))
 (let (($x14772 (or $x14771 $x11569)))
 (let (($x14773 (not $x14772)))
 (let (($x44562 (or $x43968 $x14773)))
 (let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let (($x14782 (not $x11549)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let (($x14780 (not $x11546)))
 (let (($x14783 (or $x14780 $x14782)))
 (let (($x14784 (not $x14783)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x14787 (or $x11542 $x14784)))
 (let (($x14785 (not $x14787)))
 (let (($x44553 (or $x43818 $x14785 $x11568)))
 (let (($x44554 (not $x44553)))
 (let (($x44563 (not $x44562)))
 (let (($x44564 (or $x44563 $x44554)))
 (let (($x44565 (not $x44564)))
 (let (($x14808 (forall ((no%param Int) )(! (let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let (($x14782 (not $x11549)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let (($x14780 (not $x11546)))
 (let (($x14783 (or $x14780 $x14782)))
 (let (($x14784 (not $x14783)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x14787 (or $x11542 $x14784)))
 (let (($x14785 (not $x14787)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x14788 (or $x6127 $x14785 $x11568)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11569 (not $x6172)))
 (let (($x14764 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14758 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14758)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14771 (not $x14764)))
 (let (($x14772 (or $x14771 $x11569)))
 (let (($x14773 (not $x14772)))
 (let (($x11523 (not $x6127)))
 (let (($x14778 (or $x11523 $x14773)))
 (not (or (not $x14778) (not $x14788))))))))))))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let (($x11599 (forall ((no%param Int) )(! (let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x11552 (not (or $x11542 (and $x11546 $x11549)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x11601 (or $x6127 $x11552 $x11568)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11523 (not $x6127)))
 (let (($x11577 (or $x11523 $x6177)))
 (and $x11577 $x11601))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x14809 (lambda ((no%param Int) )(let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let (($x14782 (not $x11549)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let (($x14780 (not $x11546)))
 (let (($x14783 (or $x14780 $x14782)))
 (let (($x14784 (not $x14783)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x14787 (or $x11542 $x14784)))
 (let (($x14785 (not $x14787)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x14788 (or $x6127 $x14785 $x11568)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x11569 (not $x6172)))
 (let (($x14764 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x14758 (or (not (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)) (not $x6134))))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 (not $x14758)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x14771 (not $x14764)))
 (let (($x14772 (or $x14771 $x11569)))
 (let (($x14773 (not $x14772)))
 (let (($x11523 (not $x6127)))
 (let (($x14778 (or $x11523 $x14773)))
 (let (($x14803 (not (or (not $x14778) (not $x14788)))))
 (let (($x11552 (not (or $x11542 (and $x11546 $x11549)))))
 (let (($x11601 (or $x6127 $x11552 $x11568)))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11577 (or $x11523 $x6177)))
 (let (($x11605 (and $x11577 $x11601)))
 (let (($x14790 (= $x11601 $x14788)))
 (let ((@x14796 (trans (monotonicity (rewrite (= $x11552 $x14785)) (rewrite (= $x11568 $x11568)) $x14790) (rewrite (= $x14788 $x14788)) $x14790)))
 (trans (monotonicity (rewrite (= $x11577 $x14778)) @x14796 (= $x11605 (and $x14778 $x14788))) (rewrite (= (and $x14778 $x14788) $x14803)) (= $x11605 $x14803))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x11581 (forall ((no%param Int) )(! (let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x11552 (not (or $x11542 (and $x11546 $x11549)))))
 (let (($x11572 (or $x11552 $x11568)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11523 (not $x6127)))
 (let (($x11577 (or $x11523 $x6177)))
 (and $x11577 (or $x6127 $x11572)))))))))))))))))))))))))))))))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x11600 (lambda ((no%param Int) )(let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x11552 (not (or $x11542 (and $x11546 $x11549)))))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x11601 (or $x6127 $x11552 $x11568)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11523 (not $x6127)))
 (let (($x11577 (or $x11523 $x6177)))
 (let (($x11605 (and $x11577 $x11601)))
 (let (($x11578 (and $x11577 (or $x6127 (or $x11552 $x11568)))))
 (rewrite (= $x11578 $x11605)))))))))))))))))))))))))))))))))))))
 ))
 (let (($x6178 (forall ((no%param Int) )(! (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 $x6177))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x11582 (lambda ((no%param Int) )(let ((?x11565 (%Poly%vstd!seq.Seq<u8.>. s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11562 (vstd!bytes.spec_u64_from_le_bytes.? s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let ((?x11563 (I ?x11562)))
 (let ((?x11564 (vstd!bytes.spec_u64_to_le_bytes.? ?x11563)))
 (let (($x11566 (= ?x11564 ?x11565)))
 (let ((?x1876 (UINT 8)))
 (let ((?x11559 (vstd!seq.Seq.len.? $ ?x1876 s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7)))
 (let (($x11560 (= ?x11559 8)))
 (let (($x11561 (not $x11560)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x11557 (has_type s$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30!7 ?x1968)))
 (let (($x11558 (not $x11557)))
 (let (($x11567 (or $x11558 $x11561 $x11566)))
 (let (($x11568 (not $x11567)))
 (let ((?x11548 (%I x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11543 (vstd!bytes.spec_u64_to_le_bytes.? x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6)))
 (let ((?x11544 (Poly%vstd!seq.Seq<u8.>. ?x11543)))
 (let ((?x11547 (vstd!bytes.spec_u64_from_le_bytes.? ?x11544)))
 (let (($x11549 (= ?x11547 ?x11548)))
 (let ((?x11545 (vstd!seq.Seq.len.? $ ?x1876 ?x11544)))
 (let (($x11546 (= ?x11545 8)))
 (let ((?x4023 (UINT 64)))
 (let (($x11541 (has_type x$!skolem_user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29!6 ?x4023)))
 (let (($x11542 (not $x11541)))
 (let (($x11552 (not (or $x11542 (and $x11546 $x11549)))))
 (let (($x11572 (or $x11552 $x11568)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x11523 (not $x6127)))
 (let (($x11577 (or $x11523 $x6177)))
 (let (($x11578 (and $x11577 (or $x6127 $x11572))))
 (let (($x6161 (= $x6127 $x6177)))
 (let ((@x11575 (nnf-neg (sk (~ (not $x6155) $x11552)) (sk (~ (not $x6172) $x11568)) (~ (not $x6177) $x11572))))
 (let ((?x11534 (lambda ((s$ Poly) )(let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x6167 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))
 (refl (~ $x6167 $x6167)))))))))))
 ))
 (let ((?x11528 (lambda ((x$ Poly) )(let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (let (($x6152 (or $x6151 $x6135)))
 (refl (~ $x6152 $x6152)))))))))))))
 ))
 (let ((@x11539 (monotonicity (nnf-pos (proof-bind ?x11528) (~ $x6155 $x6155)) (nnf-pos (proof-bind ?x11534) (~ $x6172 $x6172)) (~ $x6177 $x6177))))
 (nnf-pos (refl (~ $x6127 $x6127)) (refl (~ $x11523 $x11523)) @x11539 @x11575 (~ $x6161 $x11578)))))))))))))))))))))))))))))))))))))))))
 ))
 (let (($x6149 (forall ((no%param Int) )(! (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (= $x6127 (and $x6138 $x6145))))) :pattern ( (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param) ) :qid internal_ens__vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes._definition))
 ))
 (let ((?x6180 (lambda ((no%param Int) )(let (($x6172 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 (not (= (vstd!seq.Seq.len.? $ ?x1876 s$) 8)) $x6141)))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6155 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (let (($x6151 (not $x6128)))
 (or $x6151 $x6135)))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6177 (and $x6155 $x6172)))
 (let (($x6127 (ens%vstd!bytes.lemma_auto_spec_u64_to_from_le_bytes. no%param)))
 (let (($x6161 (= $x6127 $x6177)))
 (let (($x6145 (forall ((s$ Poly) )(! (let ((?x1970 (%Poly%vstd!seq.Seq<u8.>. s$)))
 (let ((?x6140 (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$)))))
 (let (($x6141 (= ?x6140 ?x1970)))
 (let ((?x1876 (UINT 8)))
 (let ((?x6094 (vstd!seq.Seq.len.? $ ?x1876 s$)))
 (let (($x6095 (= ?x6094 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type s$ ?x1968)))
 (=> (and $x1969 $x6095) $x6141))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? (I (vstd!bytes.spec_u64_from_le_bytes.? s$))) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_30))
 ))
 (let (($x6138 (forall ((x$ Poly) )(! (let ((?x264 (%I x$)))
 (let ((?x6129 (vstd!bytes.spec_u64_to_le_bytes.? x$)))
 (let ((?x6130 (Poly%vstd!seq.Seq<u8.>. ?x6129)))
 (let (($x6134 (= (vstd!bytes.spec_u64_from_le_bytes.? ?x6130) ?x264)))
 (let (($x6132 (= (vstd!seq.Seq.len.? $ (UINT 8) ?x6130) 8)))
 (let (($x6135 (and $x6132 $x6134)))
 (let ((?x4023 (UINT 64)))
 (let (($x6128 (has_type x$ ?x4023)))
 (=> $x6128 $x6135))))))))) :pattern ( (vstd!bytes.spec_u64_to_le_bytes.? x$) ) :qid user_vstd__bytes__lemma_auto_spec_u64_to_from_le_bytes_29))
 ))
 (let (($x6147 (= $x6127 (and $x6138 $x6145))))
 (rewrite (= $x6147 $x6161)))))))))))
 ))
 (let ((@x6168 (mp (asserted $x6149) (quant-intro (proof-bind ?x6180) (= $x6149 $x6178)) $x6178)))
 (let ((@x11591 (mp (mp~ @x6168 (nnf-pos (proof-bind ?x11582) (~ $x6178 $x11581)) $x11581) (quant-intro (proof-bind ?x11600) (= $x11581 $x11599)) $x11599)))
 (let ((@x14763 (mp @x11591 (quant-intro (proof-bind ?x14809) (= $x11599 $x14808)) $x14808)))
 (let (($x44570 (or (not $x14808) $x44565)))
 (let ((@x44569 ((_ quant-inst 0) $x44570)))
 (let ((@x44623 (def-axiom (or $x44564 $x44562))))
 (let ((@x43965 (not-or-elim @x43962 $x43818)))
 (let ((@x44592 (def-axiom (or $x44563 $x43968 $x14773))))
 (let ((@x48168 (unit-resolution (unit-resolution @x44592 @x43965 (or $x44563 $x14773)) (unit-resolution @x44623 (unit-resolution @x44569 @x14763 $x44565) $x44562) $x14773)))
 (let ((@x44580 (def-axiom (or $x14772 $x6172))))
 (let ((@x48169 (unit-resolution @x44580 @x48168 $x6172)))
 (let (($x46682 (or $x11569 $x44972 $x46669 $x46678)))
 (let ((@x46687 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7829 ?x7831)) (or $x11569 $x46679)) (rewrite (= (or $x11569 $x46679) $x46682)) $x46682)))
 (let ((@x48175 (symm (unit-resolution (unit-resolution @x46687 @x48169 $x46679) @x47620 @x48172 $x46678) (= ?x46677 ?x46676))))
 (let ((@x48182 (monotonicity (trans* @x48175 @x48177 (= ?x46677 ?x43832)) (= (Poly%vstd!seq.Seq<u8.>. ?x46677) ?x43833))))
 (let ((?x46999 (Poly%vstd!seq.Seq<u8.>. ?x46677)))
 (let (($x47000 (= ?x43830 ?x46999)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x9488 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x9492 (mp~ @x1986 (nnf-pos (proof-bind ?x9488) (~ $x1981 $x1981)) $x1981)))
 (let (($x46930 (not $x1981)))
 (let (($x47004 (or $x46930 $x44972 $x47000)))
 (let ((@x46997 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7829 ?x7831)) (or $x46930 (or $x44972 $x47000))) (rewrite (= (or $x46930 (or $x44972 $x47000)) $x47004)) $x47004)))
 (let ((@x48180 (unit-resolution @x46997 @x9492 @x48172 $x47000)))
 (let ((@x48183 (trans* @x48180 @x48182 $x44731)))
 (let (($x44732 (= $x44731 $x43834)))
 (let (($x44736 (or $x44735 $x44732)))
 (let ((@x44737 ((_ quant-inst false (TYPE%vstd!seq.Seq. $ ?x1876) (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7829 ?x7831) (Poly%vstd!seq.Seq<u8.>. ?x43832)) $x44736)))
 (let ((@x44743 (def-axiom (or (not $x44732) (not $x44731) $x43834))))
 (let ((@x48123 (unit-resolution @x44743 (unit-resolution @x44737 @x8979 $x44732) (or (not $x44731) $x43834))))
 (let ((@x48184 (unit-resolution @x48123 @x48183 $x43834)))
 (let (($x44003 (not $x43907)))
 (let (($x43986 (or $x44003 $x43921)))
 (let (($x44017 (not $x43986)))
 (let (($x43924 (or $x43940 $x43959 $x44017)))
 (let (($x43912 (not $x43924)))
 (let ((@x43920 (not-or-elim @x43962 $x43826)))
 (let ((@x44199 (unit-resolution (def-axiom (or tmp%1 (not $x43825) $x43961)) @x43920 (or tmp%1 (not $x43825)))))
 (let ((@x44207 (def-axiom (or $x43903 $x43940))))
 (let (($x44004 (not $x43903)))
 (let (($x43967 (or $x44004 $x43912)))
 (let (($x44034 (not (or (or $x43945 $x43934) (not (or $x43989 (not (or (or $x43937 $x43930) $x43874))))))))
 (let (($x44035 (not (or $x43985 $x44034))))
 (let (($x44031 (or $x43932 $x44035)))
 (let (($x44030 (or $x43957 $x43929)))
 (let (($x44041 (not (or $x44008 (not (or $x44030 $x44031))))))
 (let (($x44033 (or $x43928 $x43946)))
 (let (($x44046 (not (or $x43999 (not (or $x44033 $x44041))))))
 (let (($x44038 (or $x43942 $x43955)))
 (let (($x44051 (not (or $x44019 (not (or $x44038 $x44046))))))
 (let (($x44042 (or $x43941 $x43966)))
 (let (($x44056 (not (or $x44003 (not (or $x44042 $x44051))))))
 (let (($x44047 (or $x43940 $x43959)))
 (let (($x44049 (or $x44047 $x44056)))
 (let (($x44062 (or $x44004 (not $x44049))))
 (let ((@x43982 (monotonicity (rewrite (= $x43903 $x43903)) (rewrite (= $x43951 $x43924)) (= $x43909 (and $x43903 $x43924)))))
 (let ((@x43981 (trans @x43982 (rewrite (= (and $x43903 $x43924) (not $x43967))) (= $x43909 (not $x43967)))))
 (let ((@x44013 (trans (monotonicity @x43981 (= (not $x43909) (not (not $x43967)))) (rewrite (= (not (not $x43967)) $x43967)) (= (not $x43909) $x43967))))
 (let (($x43956 (not $x43909)))
 (let ((@x43964 (mp (not-or-elim @x43962 $x43956) (monotonicity (rewrite (= $x43909 $x43909)) (= $x43956 $x43956)) $x43956)))
 (let ((@x44135 (mp (mp (mp @x43964 @x44013 $x43967) (rewrite (= $x43967 $x44062)) $x44062) (rewrite (= $x44062 $x43967)) $x43967)))
 (let ((@x48205 (unit-resolution @x44135 (unit-resolution @x44207 (unit-resolution @x44199 @x48140 tmp%1) $x43903) $x43912)))
 (let ((@x44415 (def-axiom (or $x43924 $x43835))))
 (let ((@x44212 (def-axiom (or $x43959 tmp%2 (not $x43834)))))
 (let ((@x48210 (unit-resolution @x44212 (unit-resolution @x44415 @x48205 $x43835) (or tmp%2 (not $x43834)))))
 (let ((@x44222 (def-axiom (or $x43907 $x43941))))
 (let ((@x44411 (def-axiom (or $x44017 $x44003 $x43921))))
 (let ((@x48207 (unit-resolution @x44411 (unit-resolution (def-axiom (or $x43924 $x43986)) @x48205 $x43986) $x43986)))
 (let ((@x48213 (unit-resolution @x48207 (unit-resolution @x44222 (unit-resolution @x48210 @x48184 tmp%2) $x43907) $x43921)))
 (let ((@x44403 (def-axiom (or $x43904 $x43973))))
 (let ((@x48191 (monotonicity @x48161 (= (vstd!bytes.spec_u64_to_le_bytes.? ?x43809) ?x43832))))
 (let ((?x44757 (vstd!bytes.spec_u64_to_le_bytes.? ?x43809)))
 (let ((?x44455 (%Poly%vstd!seq.Seq<u8.>. ?x43794)))
 (let (($x44764 (= ?x44757 ?x44455)))
 (let (($x44430 (has_type ?x43794 ?x1968)))
 (let ((?x47108 (Poly%vstd!seq.Seq<u8.>. ?x44455)))
 (let (($x47109 (has_type ?x47108 ?x1968)))
 (let (($x47134 (not $x47109)))
 (let (($x44456 (= crc_bytes! ?x44455)))
 (let (($x44466 (or $x44465 $x44456)))
 (let ((@x44467 ((_ quant-inst crc_bytes!) $x44466)))
 (let ((@x47123 (unit-resolution @x44467 @x9485 $x44456)))
 (let ((@x47131 (monotonicity (monotonicity (symm @x47123 (= ?x44455 crc_bytes!)) (= ?x47108 ?x43794)) (= $x47109 $x44430))))
 (let ((@x47137 (mp (hypothesis (not $x44430)) (monotonicity (symm @x47131 (= $x44430 $x47109)) (= (not $x44430) $x47134)) $x47134)))
 (let ((@x47139 (unit-resolution (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x43794)) (or (not $x1989) $x47109)) @x9499 $x47109) @x47137 false)))
 (let ((@x47140 (lemma @x47139 $x44430)))
 (let ((?x43795 (vstd!seq.Seq.len.? $ ?x1876 ?x43794)))
 (let (($x43796 (= ?x43795 8)))
 (let ((@x43797 (asserted $x43796)))
 (let (($x44756 (not $x43796)))
 (let (($x44431 (not $x44430)))
 (let (($x44768 (or $x11569 $x44431 $x44756 $x44764)))
 (let ((@x44773 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. crc_bytes!)) (or $x11569 (or $x44431 $x44756 $x44764))) (rewrite (= (or $x11569 (or $x44431 $x44756 $x44764)) $x44768)) $x44768)))
 (let ((@x48187 (unit-resolution (unit-resolution @x44773 @x43797 @x48169 (or $x44431 $x44764)) @x47140 $x44764)))
 (let ((@x48195 (monotonicity (trans* @x47123 (symm @x48187 (= ?x44455 ?x44757)) @x48191 (= crc_bytes! ?x43832)) (= ?x43794 ?x43833))))
 (let ((@x48197 (symm @x48195 (= ?x43833 ?x43794))))
 (let ((@x48202 (mp @x48184 (monotonicity (trans* @x48180 @x48182 @x48197 (= ?x43830 ?x43794)) (= $x43834 $x43839)) $x43839)))
 (let ((@x44227 (def-axiom (or $x43966 tmp%3 (not $x43839)))))
 (let ((@x48215 (unit-resolution @x44227 @x48202 (unit-resolution (def-axiom (or $x43904 $x43840)) @x48213 $x43840) tmp%3)))
 (let ((@x44237 (def-axiom (or $x43911 $x43942))))
 (let ((@x44397 (def-axiom (or $x43997 $x44019 $x43984))))
 (let ((@x48218 (unit-resolution @x44397 (unit-resolution @x44237 @x48215 $x43911) (unit-resolution @x44403 @x48213 $x43973) $x43984)))
 (let ((@x44389 (def-axiom (or $x44000 $x43971))))
 (let (($x47756 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43812 ?x43812)))
 (let ((?x44167 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x43811)))
 (let ((?x44166 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x43811)))
 (let ((?x44165 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x43811)))
 (let ((?x44168 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44165 ?x44166 ?x44167)))
 (let ((@x48088 (symm ((_ th-lemma datatype) (= ?x43811 ?x44168)) (= ?x44168 ?x43811))))
 (let ((?x44516 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44168)))
 (let ((?x44517 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44516)))
 (let (($x44524 (= ?x44168 ?x44517)))
 (let (($x2729 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_box_axiom_definition))
 ))
 (let ((?x9859 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2727 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))))
 (refl (~ $x2727 $x2727)))))
 ))
 (let ((@x9863 (mp~ (asserted $x2729) (nnf-pos (proof-bind ?x9859) (~ $x2729 $x2729)) $x2729)))
 (let (($x44527 (not $x2729)))
 (let (($x44528 (or $x44527 $x44524)))
 (let ((@x44529 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44165 ?x44166 ?x44167)) $x44528)))
 (let ((@x48107 (symm (unit-resolution @x44529 @x9863 $x44524) (= ?x44517 ?x44168))))
 (let ((@x48105 (symm (monotonicity (monotonicity @x48088 (= ?x44516 ?x43812)) (= ?x44517 ?x43813)) (= ?x43813 ?x44517))))
 (let ((?x44138 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43814)))
 (let ((@x48103 (symm ((_ th-lemma datatype) (= ?x43813 ?x44138)) (= ?x44138 ?x43813))))
 (let ((?x44092 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44129)))
 (let ((@x48101 (symm (monotonicity @x48084 (= ?x44138 ?x44092)) (= ?x44092 ?x44138))))
 (let ((?x44124 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44111)))
 (let ((@x48095 (monotonicity @x48065 (= ?x44124 ?x44092))))
 (let (($x44126 (= ?x44110 ?x44124)))
 (let ((@x48066 ((_ th-lemma datatype) $x44126)))
 (let ((?x44679 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x44111)))
 (let (($x44683 (= ?x44679 ?x44110)))
 (let (($x2685 (forall ((x pmemlog!logimpl_v.PersistentHeader.) )(! (let ((?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x)))
 (= ?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata x))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_accessor_definition))
 ))
 (let ((?x9838 (lambda ((x pmemlog!logimpl_v.PersistentHeader.) )(let ((?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata x)))
 (let (($x2683 (= ?x2681 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata x))))
 (refl (~ $x2683 $x2683)))))
 ))
 (let ((@x9842 (mp~ (asserted $x2685) (nnf-pos (proof-bind ?x9838) (~ $x2685 $x2685)) $x2685)))
 (let (($x44685 (not $x2685)))
 (let (($x44687 (or $x44685 $x44683)))
 (let (($x44680 (= ?x44679 ?x44124)))
 (let (($x44688 (or $x44685 $x44680)))
 (let (($x44690 (= $x44688 $x44687)))
 (let ((@x44694 (trans (monotonicity (rewrite (= $x44680 $x44683)) $x44690) (rewrite (= $x44687 $x44687)) $x44690)))
 (let ((@x44695 (mp ((_ quant-inst (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44109 ?x44110)) $x44688) @x44694 $x44687)))
 (let ((@x48067 (unit-resolution @x44695 @x9842 $x44683)))
 (let (($x44112 (= ?x43823 ?x44111)))
 (let ((@x48057 ((_ th-lemma datatype) $x44112)))
 (let ((@x48093 (monotonicity @x48057 (= ?x43844 ?x44679))))
 (let ((@x48111 (monotonicity (trans* @x48093 @x48067 @x48066 @x48095 @x48101 @x48103 @x48105 @x48107 @x48088 (= ?x43844 ?x43811)) (= ?x43845 ?x43812))))
 (let ((@x48119 (monotonicity (symm @x48111 (= ?x43812 ?x43845)) (= $x47756 $x43846))))
 (let (($x44496 (has_type ?x43812 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let ((@x48113 (monotonicity @x48111 (= (has_type ?x43845 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.) $x44496))))
 (let (($x46821 (has_type ?x43845 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x46819 (has_type ?x43822 TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x44493 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x43815)))
 (let (($x44494 (has_type ?x44493 TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((@x48076 (symm (monotonicity (trans* @x43817 @x48050 (= ?x43815 header@)) (= ?x44493 ?x43822)) (= ?x43822 ?x44493))))
 (let (($x44495 (or $x44446 $x44494)))
 (let (($x7861 (forall ((header_seq! Poly) )(! (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x7854))))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_pre_post_definition))
 ))
 (let ((?x12384 (lambda ((header_seq! Poly) )(let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7858 (or $x1977 $x7854)))
 (refl (~ $x7858 $x7858))))))))))
 ))
 (let (($x7856 (forall ((header_seq! Poly) )(! (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (=> $x1969 $x7854)))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_pre_post_definition))
 ))
 (let ((?x7862 (lambda ((header_seq! Poly) )(let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7858 (or $x1977 $x7854)))
 (let (($x7855 (=> $x1969 $x7854)))
 (rewrite (= $x7855 $x7858)))))))))))
 ))
 (let ((@x7866 (mp (asserted $x7856) (quant-intro (proof-bind ?x7862) (= $x7856 $x7861)) $x7861)))
 (let ((@x12388 (mp~ @x7866 (nnf-pos (proof-bind ?x12384) (~ $x7861 $x7861)) $x7861)))
 (let (($x44498 (not $x7861)))
 (let (($x44499 (or $x44498 $x44446 $x44494)))
 (let ((@x44504 (mp ((_ quant-inst (Poly%vstd!seq.Seq<u8.>. header_bytes!)) (or $x44498 $x44495)) (rewrite (= (or $x44498 $x44495) $x44499)) $x44499)))
 (let ((@x48081 (mp (unit-resolution (unit-resolution @x44504 @x12388 $x44495) @x46849 $x44494) (symm (monotonicity @x48076 (= $x46819 $x44494)) (= $x44494 $x46819)) $x46819)))
 (let (($x46820 (not $x46819)))
 (let (($x46822 (or $x46820 $x46821)))
 (let (($x2697 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (or $x2627 $x2689))))))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_invariant_definition))
 ))
 (let ((?x9845 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2694 (or $x2627 $x2689)))
 (refl (~ $x2694 $x2694))))))))))
 ))
 (let (($x2692 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (=> $x2619 $x2689)))))) :pattern ( (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata (%Poly%pmemlog!logimpl_v.PersistentHeader. x)) (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata_invariant_definition))
 ))
 (let ((?x2698 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let ((?x2687 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/metadata ?x2620)))
 (let ((?x2688 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2687)))
 (let (($x2689 (has_type ?x2688 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2694 (or $x2627 $x2689)))
 (let (($x2690 (=> $x2619 $x2689)))
 (rewrite (= $x2690 $x2694)))))))))))
 ))
 (let ((@x2702 (mp (asserted $x2692) (quant-intro (proof-bind ?x2698) (= $x2692 $x2697)) $x2697)))
 (let ((@x9849 (mp~ @x2702 (nnf-pos (proof-bind ?x9845) (~ $x2697 $x2697)) $x2697)))
 (let (($x46825 (not $x2697)))
 (let (($x46826 (or $x46825 $x46820 $x46821)))
 (let ((@x46850 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeader. header@)) (or $x46825 $x46822)) (rewrite (= (or $x46825 $x46822) $x46826)) $x46826)))
 (let ((@x48114 (mp (unit-resolution (unit-resolution @x46850 @x9849 $x46822) @x48081 $x46821) @x48113 $x44496)))
 (let (($x13523 (forall ((deep Bool) (x Poly) (y Poly) )(! (let (($x2841 (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y)))
 (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. y)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let ((?x2833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2838 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2833)))
 (let (($x2839 (= ?x2838 ?x2817)))
 (let (($x13503 (not $x2839)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let ((?x2836 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2833)))
 (let (($x2837 (= ?x2836 ?x2796)))
 (let (($x13502 (not $x2837)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let ((?x2834 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2833)))
 (let (($x2835 (= ?x2834 ?x2775)))
 (let (($x13501 (not $x2835)))
 (let (($x2731 (has_type y TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2832 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x13500 (not $x2832)))
 (or $x13500 $x2739 $x13501 $x13502 $x13503 $x2841)))))))))))))))))))) :pattern ( (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata_ext_equal_definition))
 ))
 (let (($x2850 (forall ((deep Bool) (x Poly) (y Poly) )(! (let (($x2841 (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y)))
 (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. y)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let ((?x2833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2838 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2833)))
 (let (($x2839 (= ?x2838 ?x2817)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let ((?x2836 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2833)))
 (let (($x2837 (= ?x2836 ?x2796)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let ((?x2834 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2833)))
 (let (($x2835 (= ?x2834 ?x2775)))
 (let (($x2731 (has_type y TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2832 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2840 (and $x2832 $x2731 $x2835 $x2837 $x2839)))
 (let (($x2846 (not $x2840)))
 (or $x2846 $x2841))))))))))))))))) :pattern ( (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata_ext_equal_definition))
 ))
 (let ((?x13524 (lambda ((deep Bool) (x Poly) (y Poly) )(let (($x2841 (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y)))
 (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. y)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let ((?x2833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2838 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2833)))
 (let (($x2839 (= ?x2838 ?x2817)))
 (let (($x13503 (not $x2839)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let ((?x2836 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2833)))
 (let (($x2837 (= ?x2836 ?x2796)))
 (let (($x13502 (not $x2837)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let ((?x2834 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2833)))
 (let (($x2835 (= ?x2834 ?x2775)))
 (let (($x13501 (not $x2835)))
 (let (($x2731 (has_type y TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2739 (not $x2731)))
 (let (($x2832 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x13500 (not $x2832)))
 (let (($x13518 (or $x13500 $x2739 $x13501 $x13502 $x13503 $x2841)))
 (let (($x2840 (and $x2832 $x2731 $x2835 $x2837 $x2839)))
 (let (($x2846 (not $x2840)))
 (let (($x2847 (or $x2846 $x2841)))
 (let (($x13504 (or $x13500 $x2739 $x13501 $x13502 $x13503)))
 (let (($x13505 (not $x13504)))
 (let (($x13508 (not $x13505)))
 (let ((@x13514 (trans (monotonicity (rewrite (= $x2840 $x13505)) (= $x2846 $x13508)) (rewrite (= $x13508 $x13504)) (= $x2846 $x13504))))
 (trans (monotonicity @x13514 (= $x2847 (or $x13504 $x2841))) (rewrite (= (or $x13504 $x2841) $x13518)) (= $x2847 $x13518))))))))))))))))))))))))))))))
 ))
 (let ((?x9922 (lambda ((deep Bool) (x Poly) (y Poly) )(let (($x2841 (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y)))
 (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. y)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let ((?x2833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2838 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2833)))
 (let (($x2839 (= ?x2838 ?x2817)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let ((?x2836 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2833)))
 (let (($x2837 (= ?x2836 ?x2796)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let ((?x2834 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2833)))
 (let (($x2835 (= ?x2834 ?x2775)))
 (let (($x2731 (has_type y TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2832 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2840 (and $x2832 $x2731 $x2835 $x2837 $x2839)))
 (let (($x2846 (not $x2840)))
 (let (($x2847 (or $x2846 $x2841)))
 (refl (~ $x2847 $x2847))))))))))))))))))))
 ))
 (let (($x2844 (forall ((deep Bool) (x Poly) (y Poly) )(! (let (($x2841 (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y)))
 (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. y)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let ((?x2833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2838 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2833)))
 (let (($x2839 (= ?x2838 ?x2817)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let ((?x2836 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2833)))
 (let (($x2837 (= ?x2836 ?x2796)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let ((?x2834 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2833)))
 (let (($x2835 (= ?x2834 ?x2775)))
 (let (($x2731 (has_type y TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2832 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2840 (and $x2832 $x2731 $x2835 $x2837 $x2839)))
 (=> $x2840 $x2841)))))))))))))))) :pattern ( (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y) ) :qid internal_pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata_ext_equal_definition))
 ))
 (let ((?x2851 (lambda ((deep Bool) (x Poly) (y Poly) )(let (($x2841 (ext_eq deep TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata. x y)))
 (let ((?x2732 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. y)))
 (let ((?x2817 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2732)))
 (let ((?x2833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let ((?x2838 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x2833)))
 (let (($x2839 (= ?x2838 ?x2817)))
 (let ((?x2796 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2732)))
 (let ((?x2836 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x2833)))
 (let (($x2837 (= ?x2836 ?x2796)))
 (let ((?x2775 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2732)))
 (let ((?x2834 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x2833)))
 (let (($x2835 (= ?x2834 ?x2775)))
 (let (($x2731 (has_type y TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2832 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x2840 (and $x2832 $x2731 $x2835 $x2837 $x2839)))
 (let (($x2846 (not $x2840)))
 (let (($x2847 (or $x2846 $x2841)))
 (let (($x2842 (=> $x2840 $x2841)))
 (rewrite (= $x2842 $x2847)))))))))))))))))))))
 ))
 (let ((@x2855 (mp (asserted $x2844) (quant-intro (proof-bind ?x2851) (= $x2844 $x2850)) $x2850)))
 (let ((@x13528 (mp (mp~ @x2855 (nnf-pos (proof-bind ?x9922) (~ $x2850 $x2850)) $x2850) (quant-intro (proof-bind ?x13524) (= $x2850 $x13523)) $x13523)))
 (let (($x47746 (not $x44496)))
 (let (($x47784 (not $x13523)))
 (let (($x47785 (or $x47784 $x47746 $x47756)))
 (let ((?x47753 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/log_size ?x43813)))
 (let (($x47754 (= ?x47753 ?x47753)))
 (let (($x47755 (not $x47754)))
 (let ((?x47750 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/tail ?x43813)))
 (let (($x47751 (= ?x47750 ?x47750)))
 (let (($x47752 (not $x47751)))
 (let ((?x47747 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/head ?x43813)))
 (let (($x47748 (= ?x47747 ?x47747)))
 (let (($x47749 (not $x47748)))
 (let (($x47757 (or $x47746 $x47746 $x47749 $x47752 $x47755 $x47756)))
 (let (($x47786 (or $x47784 $x47757)))
 (let ((@x47781 (rewrite (= (or $x47746 $x47746 false false false $x47756) (or $x47746 $x47756)))))
 (let ((@x47656 (rewrite (= (not true) false))))
 (let ((@x47775 (trans (monotonicity (rewrite (= $x47754 true)) (= $x47755 (not true))) @x47656 (= $x47755 false))))
 (let ((@x47769 (trans (monotonicity (rewrite (= $x47751 true)) (= $x47752 (not true))) @x47656 (= $x47752 false))))
 (let ((@x47763 (trans (monotonicity (rewrite (= $x47748 true)) (= $x47749 (not true))) @x47656 (= $x47749 false))))
 (let ((@x47778 (monotonicity @x47763 @x47769 @x47775 (= $x47757 (or $x47746 $x47746 false false false $x47756)))))
 (let ((@x47790 (monotonicity (trans @x47778 @x47781 (= $x47757 (or $x47746 $x47756))) (= $x47786 (or $x47784 (or $x47746 $x47756))))))
 (let ((@x47794 (trans @x47790 (rewrite (= (or $x47784 (or $x47746 $x47756)) $x47785)) (= $x47786 $x47785))))
 (let ((@x47795 (mp ((_ quant-inst false (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43811) (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43811)) $x47786) @x47794 $x47785)))
 (let ((@x48115 (unit-resolution @x47795 @x13528 @x48114 $x47756)))
 (let ((@x44253 (def-axiom (or $x43955 tmp%4 (not $x43846)))))
 (let ((@x48220 (unit-resolution @x44253 (mp @x48115 @x48119 $x43846) (unit-resolution (def-axiom (or $x44000 $x43847)) @x48218 $x43847) tmp%4)))
 (let ((@x44263 (def-axiom (or $x43915 $x43928))))
 (let ((@x44383 (def-axiom (or $x43972 $x43999 $x43979))))
 (let ((@x48223 (unit-resolution @x44383 (unit-resolution @x44263 @x48220 $x43915) (unit-resolution @x44389 @x48218 $x43971) $x43979)))
 (let ((@x44375 (def-axiom (or $x44016 $x44010))))
 (let ((?x46636 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x46615)))
 (let ((@x48235 (monotonicity @x48149 (= ?x46636 ?x44092))))
 (let (($x46637 (= ?x46614 ?x46636)))
 (let ((@x48225 ((_ th-lemma datatype) $x46637)))
 (let ((?x44268 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x43852)))
 (let ((?x44267 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x43852)))
 (let ((?x44266 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x43852)))
 (let ((?x44269 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44266 ?x44267 ?x44268)))
 (let ((?x46617 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44269)))
 (let ((?x46618 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x46617)))
 (let (($x44270 (= ?x43852 ?x44269)))
 (let ((@x48226 ((_ th-lemma datatype) $x44270)))
 (let ((@x48228 (symm @x48226 (= ?x44269 ?x43852))))
 (let ((@x48233 (monotonicity (monotonicity @x48228 (= ?x46617 ?x43853)) (= ?x46618 ?x46614))))
 (let (($x46649 (= ?x44269 ?x46618)))
 (let (($x46652 (or $x44527 $x46649)))
 (let ((@x46653 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44266 ?x44267 ?x44268)) $x46652)))
 (let ((@x48231 (unit-resolution @x46653 @x9863 $x46649)))
 (let ((@x48237 (trans* @x48226 @x48231 @x48233 @x48225 @x48235 @x48101 @x48103 @x48105 @x48107 @x48088 (= ?x43852 ?x43811))))
 (let ((@x48243 (symm (monotonicity (monotonicity @x48237 (= ?x43853 ?x43812)) (= $x43854 $x43846)) (= $x43846 $x43854))))
 (let ((@x44279 (def-axiom (or $x43946 tmp%5 (not $x43854)))))
 (let ((@x48247 (unit-resolution @x44279 (unit-resolution (def-axiom (or $x44016 $x43855)) @x48223 $x43855) (mp @x48115 (trans* @x48119 @x48243 (= $x47756 $x43854)) $x43854) tmp%5)))
 (let ((@x44289 (def-axiom (or $x43919 $x43957))))
 (let ((@x44369 (def-axiom (or $x44011 $x44008 $x44009))))
 (let ((@x48250 (unit-resolution @x44369 (unit-resolution @x44289 @x48247 $x43919) (unit-resolution @x44375 @x48223 $x44010) $x44009)))
 (let ((@x44359 (def-axiom (or $x43998 $x43862))))
 (let ((@x48253 (symm ((_ th-lemma datatype) (= ?x44092 ?x44103)) (= ?x44103 ?x44092))))
 (let ((@x48264 (trans* @x48253 (symm @x48095 (= ?x44092 ?x44124)) (symm @x48066 (= ?x44124 ?x44110)) (symm @x48067 (= ?x44110 ?x44679)) (symm @x48093 (= ?x44679 ?x43844)) (symm (unit-resolution @x44359 @x48250 $x43862) (= ?x43844 tmp%7)) (= ?x44103 tmp%7))))
 (let ((@x48267 (symm (unit-resolution (def-axiom (or $x43998 $x43860)) @x48250 $x43860) (= ?x43859 tmp%6))))
 (let ((?x47840 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x46925)))
 (let (($x47841 (= ?x44103 ?x47840)))
 (let (($x8668 (not %%global_location_label%%42)))
 (let (($x47842 (or $x8668 $x47841)))
 (let (($x47843 (not $x47842)))
 (let ((?x47836 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x47379)))
 (let (($x47837 (= ?x44103 ?x47836)))
 (let (($x8664 (not %%global_location_label%%41)))
 (let (($x47838 (or $x8664 $x47837)))
 (let (($x47839 (not $x47838)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x47832 (vstd!seq.Seq.len.? $ ?x1876 ?x46925)))
 (let (($x47833 (= ?x47832 ?x8522)))
 (let (($x8660 (not %%global_location_label%%40)))
 (let (($x47834 (or $x8660 $x47833)))
 (let (($x47835 (not $x47834)))
 (let ((?x47816 (vstd!seq.Seq.len.? $ ?x1876 ?x47379)))
 (let (($x47817 (= ?x47816 ?x8522)))
 (let (($x8656 (not %%global_location_label%%39)))
 (let (($x47830 (or $x8656 $x47817)))
 (let (($x47831 (not $x47830)))
 (let (($x47844 (or $x47831 $x47835 $x47839 $x47843)))
 (let (($x47845 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. ?x44463 ?x43859 ?x44103)))
 (let (($x47846 (= $x47844 $x47845)))
 (let (($x47847 (not $x47846)))
 (let (($x15884 (forall ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let (($x8638 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x8555 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6683)))
 (let (($x8649 (= metadata! ?x8555)))
 (let (($x8668 (not %%global_location_label%%42)))
 (let (($x8669 (or $x8668 $x8649)))
 (let (($x8646 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? (Poly%vstd!seq.Seq<u8.>. bytes1!)))))
 (let (($x8664 (not %%global_location_label%%41)))
 (let (($x8665 (or $x8664 $x8646)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8501 (vstd!seq.Seq.len.? $ ?x1876 ?x6683)))
 (let (($x8523 (= ?x8501 ?x8522)))
 (let (($x8660 (not %%global_location_label%%40)))
 (let (($x8661 (or $x8660 $x8523)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x8640 (= ?x8518 ?x8522)))
 (let (($x8656 (not %%global_location_label%%39)))
 (let (($x8657 (or $x8656 $x8640)))
 (let (($x15868 (or (not $x8657) (not $x8661) (not $x8665) (not $x8669))))
 (not (= $x15868 $x8638))))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!) ) :qid internal_req__pmemlog!logimpl_v.lemma_metadata_bytes_eq._definition))
 ))
 (let (($x8673 (forall ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x8555 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6683)))
 (let (($x8649 (= metadata! ?x8555)))
 (let (($x8668 (not %%global_location_label%%42)))
 (let (($x8669 (or $x8668 $x8649)))
 (let (($x8646 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? (Poly%vstd!seq.Seq<u8.>. bytes1!)))))
 (let (($x8664 (not %%global_location_label%%41)))
 (let (($x8665 (or $x8664 $x8646)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8501 (vstd!seq.Seq.len.? $ ?x1876 ?x6683)))
 (let (($x8523 (= ?x8501 ?x8522)))
 (let (($x8660 (not %%global_location_label%%40)))
 (let (($x8661 (or $x8660 $x8523)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x8640 (= ?x8518 ?x8522)))
 (let (($x8656 (not %%global_location_label%%39)))
 (let (($x8657 (or $x8656 $x8640)))
 (let (($x8672 (and $x8657 $x8661 $x8665 $x8669)))
 (let (($x8638 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (= $x8638 $x8672)))))))))))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!) ) :qid internal_req__pmemlog!logimpl_v.lemma_metadata_bytes_eq._definition))
 ))
 (let ((?x15885 (lambda ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let (($x8638 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x8555 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6683)))
 (let (($x8649 (= metadata! ?x8555)))
 (let (($x8668 (not %%global_location_label%%42)))
 (let (($x8669 (or $x8668 $x8649)))
 (let (($x8646 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? (Poly%vstd!seq.Seq<u8.>. bytes1!)))))
 (let (($x8664 (not %%global_location_label%%41)))
 (let (($x8665 (or $x8664 $x8646)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8501 (vstd!seq.Seq.len.? $ ?x1876 ?x6683)))
 (let (($x8523 (= ?x8501 ?x8522)))
 (let (($x8660 (not %%global_location_label%%40)))
 (let (($x8661 (or $x8660 $x8523)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x8640 (= ?x8518 ?x8522)))
 (let (($x8656 (not %%global_location_label%%39)))
 (let (($x8657 (or $x8656 $x8640)))
 (let (($x15868 (or (not $x8657) (not $x8661) (not $x8665) (not $x8669))))
 (let (($x15876 (not (= $x15868 $x8638))))
 (let (($x8672 (and $x8657 $x8661 $x8665 $x8669)))
 (let (($x8670 (= $x8638 $x8672)))
 (let (($x15879 (= $x8670 $x15876)))
 (let ((@x15874 (monotonicity (rewrite (= $x8672 (not $x15868))) (= $x8670 (= $x8638 (not $x15868))))))
 (trans (trans @x15874 (rewrite (= (= $x8638 (not $x15868)) $x15876)) $x15879) (rewrite (= $x15876 $x15876)) $x15879))))))))))))))))))))))))))))
 ))
 (let ((?x12669 (lambda ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x8555 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6683)))
 (let (($x8649 (= metadata! ?x8555)))
 (let (($x8668 (not %%global_location_label%%42)))
 (let (($x8669 (or $x8668 $x8649)))
 (let (($x8646 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? (Poly%vstd!seq.Seq<u8.>. bytes1!)))))
 (let (($x8664 (not %%global_location_label%%41)))
 (let (($x8665 (or $x8664 $x8646)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8501 (vstd!seq.Seq.len.? $ ?x1876 ?x6683)))
 (let (($x8523 (= ?x8501 ?x8522)))
 (let (($x8660 (not %%global_location_label%%40)))
 (let (($x8661 (or $x8660 $x8523)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x8640 (= ?x8518 ?x8522)))
 (let (($x8656 (not %%global_location_label%%39)))
 (let (($x8657 (or $x8656 $x8640)))
 (let (($x8672 (and $x8657 $x8661 $x8665 $x8669)))
 (let (($x8638 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (let (($x8670 (= $x8638 $x8672)))
 (refl (~ $x8670 $x8670)))))))))))))))))))))))))
 ))
 (let (($x8654 (forall ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x8555 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6683)))
 (let (($x8649 (= metadata! ?x8555)))
 (let (($x8646 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? (Poly%vstd!seq.Seq<u8.>. bytes1!)))))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8501 (vstd!seq.Seq.len.? $ ?x1876 ?x6683)))
 (let (($x8523 (= ?x8501 ?x8522)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x8640 (= ?x8518 ?x8522)))
 (let (($x8651 (and (=> %%global_location_label%%39 $x8640) (=> %%global_location_label%%40 $x8523) (=> %%global_location_label%%41 $x8646) (=> %%global_location_label%%42 $x8649))))
 (let (($x8638 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (= $x8638 $x8651)))))))))))))) :pattern ( (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!) ) :qid internal_req__pmemlog!logimpl_v.lemma_metadata_bytes_eq._definition))
 ))
 (let ((?x8675 (lambda ((bytes1! vstd!seq.Seq<u8.>.) (bytes2! vstd!seq.Seq<u8.>.) (metadata! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x6683 (Poly%vstd!seq.Seq<u8.>. bytes2!)))
 (let ((?x8555 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6683)))
 (let (($x8649 (= metadata! ?x8555)))
 (let (($x8668 (not %%global_location_label%%42)))
 (let (($x8669 (or $x8668 $x8649)))
 (let (($x8646 (= metadata! (pmemlog!logimpl_v.spec_bytes_to_metadata.? (Poly%vstd!seq.Seq<u8.>. bytes1!)))))
 (let (($x8664 (not %%global_location_label%%41)))
 (let (($x8665 (or $x8664 $x8646)))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x1876 (UINT 8)))
 (let ((?x8501 (vstd!seq.Seq.len.? $ ?x1876 ?x6683)))
 (let (($x8523 (= ?x8501 ?x8522)))
 (let (($x8660 (not %%global_location_label%%40)))
 (let (($x8661 (or $x8660 $x8523)))
 (let ((?x6680 (Poly%vstd!seq.Seq<u8.>. bytes1!)))
 (let ((?x8518 (vstd!seq.Seq.len.? $ ?x1876 ?x6680)))
 (let (($x8640 (= ?x8518 ?x8522)))
 (let (($x8656 (not %%global_location_label%%39)))
 (let (($x8657 (or $x8656 $x8640)))
 (let (($x8672 (and $x8657 $x8661 $x8665 $x8669)))
 (let (($x8638 (req%pmemlog!logimpl_v.lemma_metadata_bytes_eq. bytes1! bytes2! metadata!)))
 (let (($x8670 (= $x8638 $x8672)))
 (let (($x8651 (and (=> %%global_location_label%%39 $x8640) (=> %%global_location_label%%40 $x8523) (=> %%global_location_label%%41 $x8646) (=> %%global_location_label%%42 $x8649))))
 (let (($x8652 (= $x8638 $x8651)))
 (rewrite (= $x8652 $x8670)))))))))))))))))))))))))))
 ))
 (let ((@x8658 (mp (asserted $x8654) (quant-intro (proof-bind ?x8675) (= $x8654 $x8673)) $x8673)))
 (let ((@x15889 (mp (mp~ @x8658 (nnf-pos (proof-bind ?x12669) (~ $x8673 $x8673)) $x8673) (quant-intro (proof-bind ?x15885) (= $x8673 $x15884)) $x15884)))
 (let (($x48039 (not $x47845)))
 (let ((@x48273 (monotonicity (symm (monotonicity @x47398 @x48267 @x48264 (= $x47845 $x43864)) (= $x43864 $x47845)) (= (not $x43864) $x48039))))
 (let ((@x48275 (unit-resolution (def-axiom (or $x47846 $x47844 $x47845)) (mp (hypothesis (not $x43864)) @x48273 $x48039) (unit-resolution ((_ quant-inst (%Poly%vstd!seq.Seq<u8.>. ?x43799) (%Poly%vstd!seq.Seq<u8.>. ?x43851) (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43815)) (or (not $x15884) $x47847)) @x15889 $x47847) $x47844)))
 (let (($x46926 (= ?x43851 ?x46925)))
 (let (($x44505 (has_type ?x43851 ?x1968)))
 (let (($x44707 (has_type ?x7834 INT)))
 (let (($x7277 (= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let (($x7275 (fuel_bool fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x7273 (fuel_bool_default fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x45804 (= $x7275 $x7273)))
 (let ((@x45834 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_head_offset.) (or (not $x30) $x45804)) @x44825 (hypothesis (not $x45804)) false)))
 (let ((@x45847 (lemma @x45834 $x45804)))
 (let ((@x7274 (asserted $x7273)))
 (let ((@x45825 (def-axiom (or (not $x45804) $x7275 (not $x7273)))))
 (let ((@x48008 (unit-resolution (unit-resolution @x45825 @x7274 (or (not $x45804) $x7275)) @x45847 $x7275)))
 (let (($x7280 (not $x7275)))
 (let (($x7281 (or $x7280 $x7277)))
 (let ((@x7284 (mp (asserted (=> $x7275 $x7277)) (rewrite (= (=> $x7275 $x7277) $x7281)) $x7281)))
 (let ((@x48011 (trans* (unit-resolution @x7284 @x48008 $x7277) @x46959 (= pmemlog!logimpl_v.header_head_offset.? ?x7830))))
 (let ((@x48013 (monotonicity @x48011 (= ?x7834 ?x7831))))
 (let ((@x48018 (mp @x46972 (symm (monotonicity @x48013 (= $x44707 $x44752)) (= $x44752 $x44707)) $x44707)))
 (let (($x44709 (has_type ?x7835 INT)))
 (let ((?x46921 (I 32)))
 (let (($x46922 (has_type ?x46921 INT)))
 (let (($x46990 (not $x46922)))
 (let ((@x46983 (symm @x46981 (= 32 pmemlog!logimpl_v.header_size.?))))
 (let ((@x46989 (symm (monotonicity (monotonicity @x46983 (= ?x46921 ?x7835)) (= $x46922 $x44709)) (= $x44709 $x46922))))
 (let ((@x46993 (mp (hypothesis (not $x44709)) (monotonicity @x46989 (= (not $x44709) $x46990)) $x46990)))
 (let ((@x46995 (unit-resolution (unit-resolution ((_ quant-inst 32) (or (not $x698) $x46922)) @x9035 $x46922) @x46993 false)))
 (let ((@x46996 (lemma @x46995 $x44709)))
 (let (($x44710 (not $x44709)))
 (let (($x44708 (not $x44707)))
 (let (($x44711 (or $x44446 $x44708 $x44710 $x44505)))
 (let (($x44715 (or $x44714 $x44446 $x44708 $x44710 $x44505)))
 (let ((@x44720 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_head_offset.?) (I pmemlog!logimpl_v.header_size.?)) (or $x44714 $x44711)) (rewrite (= (or $x44714 $x44711) $x44715)) $x44715)))
 (let ((@x48019 (unit-resolution (unit-resolution @x44720 @x13879 $x44711) @x46996 @x46849 @x48018 $x44505)))
 (let (($x44506 (not $x44505)))
 (let (($x46919 (or $x46930 $x44506 $x46926)))
 (let ((@x46924 (mp ((_ quant-inst (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7834 ?x7835)) (or $x46930 (or $x44506 $x46926))) (rewrite (= (or $x46930 (or $x44506 $x46926)) $x46919)) $x46919)))
 (let ((@x48020 (unit-resolution @x46924 @x9492 @x48019 $x46926)))
 (let ((@x48026 (symm @x48020 (= ?x46925 ?x43851))))
 (let ((@x48288 (trans* @x48253 (symm @x48235 (= ?x44092 ?x46636)) (symm @x48225 (= ?x46636 ?x46614)) (symm @x48233 (= ?x46614 ?x46618)) (symm @x48231 (= ?x46618 ?x44269)) @x48228 (symm (monotonicity @x48026 (= ?x47840 ?x43852)) (= ?x43852 ?x47840)) $x47841)))
 (let ((?x43800 (vstd!seq.Seq.len.? $ ?x1876 ?x43799)))
 (let (($x43801 (= ?x43800 ?x8522)))
 (let ((@x43802 (asserted $x43801)))
 (let ((@x48293 (unit-resolution (def-axiom (or $x47830 (not $x47817))) (trans* (monotonicity @x47400 (= ?x47816 ?x43800)) @x43802 $x47817) $x47830)))
 (let ((@x48298 (trans* @x48253 @x48101 @x48103 @x48105 @x48107 @x48088 (symm (monotonicity @x47400 (= ?x47836 ?x43811)) (= ?x43811 ?x47836)) $x47837)))
 (let ((?x44526 (%I ?x7835)))
 (let (($x44541 (= pmemlog!logimpl_v.header_size.? ?x44526)))
 (let (($x44547 (or $x44542 $x44541)))
 (let ((@x44548 ((_ quant-inst pmemlog!logimpl_v.header_size.?) $x44547)))
 (let ((@x47984 (symm (unit-resolution @x44548 @x8895 $x44541) (= ?x44526 pmemlog!logimpl_v.header_size.?))))
 (let ((@x48034 (monotonicity @x47984 @x47578 (= (Sub ?x44526 ?x44786) ?x8522))))
 (let ((?x47943 (Sub ?x44526 ?x44786)))
 (let ((?x47941 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43804 ?x7831 ?x7835)))
 (let ((?x47942 (vstd!seq.Seq.len.? $ ?x1876 ?x47941)))
 (let (($x47944 (= ?x47942 ?x47943)))
 (let (($x47854 (>= ?x44786 0)))
 (let ((@x47989 (lemma ((_ th-lemma arith farkas 1 1 1 1) @x47538 @x46955 @x46939 (hypothesis (not $x47854)) false) $x47854)))
 (let ((?x47952 (* (- 1) ?x44526)))
 (let ((?x47953 (+ ?x43805 ?x47952)))
 (let (($x47954 (>= ?x47953 0)))
 (let (($x47980 (<= ?x44526 32)))
 (let (($x47820 (= ?x44526 32)))
 (let ((@x47991 (trans* @x47984 @x46981 $x47820)))
 (let ((@x48003 (unit-resolution ((_ th-lemma arith assign-bounds 1 -1 1) (or $x47954 (not $x47980) (not $x45875) (not $x44724))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47820) $x47980)) @x47991 $x47980) @x47602 @x47598 $x47954)))
 (let ((?x47935 (+ ?x44526 ?x47475)))
 (let (($x47936 (>= ?x47935 0)))
 (let (($x47981 (>= ?x44526 32)))
 (let ((@x47996 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1) (or $x47936 (not $x47981) (not $x47523) (not $x45816) (not $x44823))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47820) $x47981)) @x47991 $x47981) @x47605 @x46950 @x46942 $x47936)))
 (let (($x47959 (not $x47954)))
 (let (($x47937 (not $x47936)))
 (let (($x47855 (not $x47854)))
 (let (($x47892 (or $x47503 $x44446 $x44753 $x44710 $x44969 $x47855 $x47937 $x47959 $x47944)))
 (let ((?x47938 (+ ?x44526 ?x44722)))
 (let (($x47939 (<= ?x47938 0)))
 (let (($x47940 (not $x47939)))
 (let (($x47945 (or $x44446 $x44753 $x44710 $x44969 $x47855 $x47937 $x47940 $x47944)))
 (let (($x47893 (or $x47503 $x47945)))
 (let ((@x47900 (rewrite (= (or $x47503 (or $x44446 $x44753 $x44710 $x44969 $x47855 $x47937 $x47959 $x47944)) $x47892))))
 (let (($x47821 (or $x44446 $x44753 $x44710 $x44969 $x47855 $x47937 $x47959 $x47944)))
 (let (($x47822 (= $x47945 $x47821)))
 (let ((@x47891 (trans (monotonicity (rewrite (= $x47940 $x47959)) $x47822) (rewrite (= $x47821 $x47821)) $x47822)))
 (let ((@x47895 (trans (monotonicity @x47891 (= $x47893 (or $x47503 $x47821))) @x47900 (= $x47893 $x47892))))
 (let ((@x48004 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I ?x7830) (I pmemlog!logimpl_v.header_size.?)) $x47893) @x47895 $x47892) @x175 @x47586 @x46849 @x46996 @x46972 @x47996 @x48003 @x47989 $x47944)))
 (let ((@x48024 (monotonicity (symm @x48013 (= ?x7831 ?x7834)) (= ?x47941 ?x43851))))
 (let ((@x48032 (monotonicity (trans* @x48026 (symm @x48024 (= ?x43851 ?x47941)) (= ?x46925 ?x47941)) (= ?x47832 ?x47942))))
 (let ((@x48037 (unit-resolution (hypothesis (not $x47833)) (trans* @x48032 @x48004 @x48034 $x47833) false)))
 (let ((@x48038 (lemma @x48037 $x47833)))
 (let ((@x48302 (unit-resolution (def-axiom (or (not $x47844) $x47831 $x47835 $x47839 $x47843)) (unit-resolution (def-axiom (or $x47834 (not $x47833))) @x48038 $x47834) (or (not $x47844) $x47831 $x47839 $x47843))))
 (let ((@x48303 (unit-resolution @x48302 (unit-resolution (def-axiom (or $x47838 (not $x47837))) @x48298 $x47838) @x48293 (unit-resolution (def-axiom (or $x47842 (not $x47841))) @x48288 $x47842) @x48275 false)))
 (let ((@x48304 (lemma @x48303 $x43864)))
 (let ((@x44307 (def-axiom (or $x43923 (not $x43864)))))
 (let ((@x44353 (def-axiom (or $x43993 $x43985 $x43987))))
 (let ((@x48764 (unit-resolution @x44353 (unit-resolution (def-axiom (or $x43998 $x43988)) @x48250 $x43988) $x43988)))
 (let ((@x48765 (unit-resolution @x48764 (unit-resolution @x44307 @x48304 $x43923) $x43987)))
 (let ((@x44341 (def-axiom (or $x43996 $x43866))))
 (let ((@x48771 (mp (unit-resolution @x44341 @x48765 $x43866) (symm (monotonicity @x47398 @x48267 @x48264 (= $x47870 $x43866)) (= $x43866 $x47870)) $x47870)))
 (let ((@x47934 (def-axiom (or (not $x47872) (not $x47870) $x47871))))
 (let ((@x48772 (unit-resolution @x47934 @x48771 (unit-resolution @x47888 @x12680 $x47872) $x47871)))
 (let ((@x48368 (def-axiom (or (not $x48310) $x48323 (not $x48327)))))
 (let ((@x48780 (unit-resolution @x48368 (mp @x48772 @x48778 $x48327) (unit-resolution @x48364 @x8979 $x48310) $x48323)))
 (let ((@x48781 (symm @x48780 $x47884)))
 (let ((@x48783 (monotonicity @x48197 @x48781 (= ?x48572 ?x43873))))
 (let (($x47850 (has_type ?x46925 ?x1968)))
 (let ((@x48758 (mp @x48019 (symm (monotonicity @x48026 (= $x47850 $x44505)) (= $x44505 $x47850)) $x47850)))
 (let (($x44970 (has_type ?x43833 ?x1968)))
 (let ((@x48753 (mp @x47140 (monotonicity @x48195 (= $x44430 $x44970)) $x44970)))
 (let (($x14185 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x14005 (not $x4525)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x13752 (not $x4101)))
 (or $x13752 $x14005 $x4941)))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let (($x4949 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4941)))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let ((?x14186 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x14005 (not $x4525)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x13752 (not $x4101)))
 (let (($x14180 (or $x13752 $x14005 $x4941)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (let ((@x14172 (monotonicity (rewrite (= $x4526 (not (or $x13752 $x14005)))) (= $x4568 (not (not (or $x13752 $x14005)))))))
 (let ((@x14176 (trans @x14172 (rewrite (= (not (not (or $x13752 $x14005))) (or $x13752 $x14005))) (= $x4568 (or $x13752 $x14005)))))
 (trans (monotonicity @x14176 (= $x4946 (or (or $x13752 $x14005) $x4941))) (rewrite (= (or (or $x13752 $x14005) $x4941) $x14180)) (= $x4946 $x14180))))))))))))))))
 ))
 (let ((?x10975 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (refl (~ $x4946 $x4946)))))))))))
 ))
 (let (($x4944 (forall ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(! (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> $x4526 $x4941))))))) :pattern ( (vstd!seq.Seq.add.? A&. A& self! rhs!) ) :qid internal_vstd!seq.Seq.add.?_pre_post_definition))
 ))
 (let ((?x4950 (lambda ((A&. Dcr) (A& Type) (self! Poly) (rhs! Poly) )(let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& self! rhs!)))
 (let (($x4941 (has_type ?x4940 ?x3990)))
 (let (($x4525 (has_type rhs! ?x3990)))
 (let (($x4101 (has_type self! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4946 (or $x4568 $x4941)))
 (let (($x4942 (=> $x4526 $x4941)))
 (rewrite (= $x4942 $x4946))))))))))))
 ))
 (let ((@x4954 (mp (asserted $x4944) (quant-intro (proof-bind ?x4950) (= $x4944 $x4949)) $x4949)))
 (let ((@x14190 (mp (mp~ @x4954 (nnf-pos (proof-bind ?x10975) (~ $x4949 $x4949)) $x4949) (quant-intro (proof-bind ?x14186) (= $x4949 $x14185)) $x14185)))
 (let (($x47852 (not $x47850)))
 (let (($x44971 (not $x44970)))
 (let (($x48587 (not $x14185)))
 (let (($x48588 (or $x48587 $x44971 $x47852 $x48575)))
 (let ((@x48593 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x43832) (Poly%vstd!seq.Seq<u8.>. ?x43859)) (or $x48587 (or $x44971 $x47852 $x48575))) (rewrite (= (or $x48587 (or $x44971 $x47852 $x48575)) $x48588)) $x48588)))
 (let ((@x49087 (mp (unit-resolution @x48593 @x14190 @x48753 @x48758 $x48575) (monotonicity @x48783 (= $x48575 $x48502)) $x48502)))
 (let (($x14084 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10784 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10796 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10784) (vstd!seq.Seq.index.? A&. A& s2! ?x10784))))
 (let (($x10835 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x10784))) 0)))
 (let (($x10786 (not (has_type ?x10784 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10781 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x14065 (not (or $x4527 $x10781 (not (or $x10786 (not (>= (%I ?x10784) 0)) $x10835 $x10796))))))
 (let (($x14036 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13740 (not $x821)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x13740 $x4552 $x4534))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x10768 (not $x4527)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14005 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x13752 (not $x4101)))
 (or $x13752 $x14005 $x4431 (not (or (not (or $x10768 (not (or $x10781 (not $x14036))))) $x14065)))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4524 (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x44917 (= $x4524 $x1587)))
 (let ((@x44919 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_ext_equal.) (or (not $x30) $x44917)) @x44825 (hypothesis (not $x44917)) false)))
 (let ((@x44931 (lemma @x44919 $x44917)))
 (let ((@x44924 (def-axiom (or (not $x44917) $x4524 $x13184))))
 (let ((@x49079 (unit-resolution @x44924 (unit-resolution (def-axiom (or $x13192 $x1587)) @x47581 $x1587) (or (not $x44917) $x4524))))
 (let (($x4583 (not $x4524)))
 (let (($x14017 (or $x4583 $x14084)))
 (let (($x10849 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10784 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10796 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10784) (vstd!seq.Seq.index.? A&. A& s2! ?x10784))))
 (let (($x10835 (<= (+ (vstd!seq.Seq.len.? A&. A& s1!) (* (- 1) (%I ?x10784))) 0)))
 (let ((?x10787 (%I ?x10784)))
 (let (($x10788 (>= ?x10787 0)))
 (let (($x10786 (not (has_type ?x10784 INT))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10781 (not $x4529)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10768 (not $x4527)))
 (let (($x10807 (or $x10768 $x4548)))
 (let (($x10850 (and $x10807 (or $x4527 $x10781 (not (or $x10786 (not (and $x10788 (not $x10835))) $x10796))))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x10850)))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x10823 (or $x4583 $x10849)))
 (let (($x10814 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x10784 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10796 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10784) (vstd!seq.Seq.index.? A&. A& s2! ?x10784))))
 (let (($x10790 (>= (+ (%I ?x10784) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x10787 (%I ?x10784)))
 (let (($x10788 (>= ?x10787 0)))
 (let (($x10786 (not (has_type ?x10784 INT))))
 (let (($x10798 (not (or $x10786 (not (and $x10788 (not $x10790))) $x10796))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10781 (not $x4529)))
 (let (($x10802 (or $x10781 $x10798)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10768 (not $x4527)))
 (let (($x10807 (or $x10768 $x4548)))
 (let (($x10808 (and $x10807 (or $x4527 $x10802))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x10808)))))))))))))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x10819 (or $x4583 $x10814)))
 (let (($x4576 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4559))))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4584 (or $x4583 $x4576)))
 (let ((?x10815 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x10784 (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 s2! s1! A& A&.)))
 (let (($x10796 (= (vstd!seq.Seq.index.? A&. A& s1! ?x10784) (vstd!seq.Seq.index.? A&. A& s2! ?x10784))))
 (let (($x10790 (>= (+ (%I ?x10784) (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!))) 0)))
 (let ((?x10787 (%I ?x10784)))
 (let (($x10788 (>= ?x10787 0)))
 (let (($x10786 (not (has_type ?x10784 INT))))
 (let (($x10798 (not (or $x10786 (not (and $x10788 (not $x10790))) $x10796))))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x10781 (not $x4529)))
 (let (($x10802 (or $x10781 $x10798)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4548 (and $x4529 $x4574)))
 (let (($x10768 (not $x4527)))
 (let (($x10807 (or $x10768 $x4548)))
 (let (($x10808 (and $x10807 (or $x4527 $x10802))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x10811 (or $x4568 $x4431 $x10808)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let ((@x10783 (refl (~ $x10781 $x10781))))
 (let ((?x10775 (lambda ((i$ Poly) )(let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (let (($x4569 (or $x271 $x4554 $x4534)))
 (refl (~ $x4569 $x4569))))))))))))))))
 ))
 (let ((@x10772 (refl (~ $x4529 $x4529))))
 (let ((@x10780 (monotonicity @x10772 (nnf-pos (proof-bind ?x10775) (~ $x4574 $x4574)) (~ $x4548 $x4548))))
 (let ((@x10810 (nnf-pos (refl (~ $x4527 $x4527)) (refl (~ $x10768 $x10768)) @x10780 (nnf-neg @x10783 (sk (~ (not $x4574) $x10798)) (~ (not $x4548) $x10802)) (~ $x4559 $x10808))))
 (let ((@x10765 (refl (~ $x4431 $x4431))))
 (let ((@x10763 (refl (~ $x4568 $x4568))))
 (monotonicity @x10763 @x10765 @x10810 (~ $x4570 $x10811))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x10821 (monotonicity (refl (~ $x4583 $x4583)) (nnf-pos (proof-bind ?x10815) (~ $x4576 $x10814)) (~ $x4584 $x10819))))
 (let (($x4545 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x3858 (sized A&.)))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4541))))))))))))) :pattern ( (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) ) :qid user_vstd__seq__axiom_seq_ext_equal_6))
 ))
 (let (($x4546 (=> $x4524 $x4545)))
 (let ((?x4577 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let (($x4574 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4557 (and $x821 $x4555)))
 (let (($x4554 (not $x4557)))
 (let (($x263 (has_type i$ INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x4554 $x4534))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let (($x4529 (= ?x4092 ?x4528)))
 (let (($x4548 (and $x4529 $x4574)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4527 (ext_eq false ?x3990 s1! s2!)))
 (let (($x4559 (= $x4527 $x4548)))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4570 (or $x4568 $x4431 $x4559)))
 (let (($x4539 (forall ((i$ Poly) )(! (let ((?x4533 (vstd!seq.Seq.index.? A&. A& s2! i$)))
 (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i$)))
 (let (($x4534 (= ?x4532 ?x4533)))
 (let ((?x264 (%I i$)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x263 (has_type i$ INT)))
 (=> (and $x263 $x4531) $x4534)))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& s1! i$) ) :pattern ( (vstd!seq.Seq.index.? A&. A& s2! i$) ) :qid user_vstd__seq__axiom_seq_ext_equal_5))
 ))
 (let (($x4541 (= $x4527 (and $x4529 $x4539))))
 (let (($x4542 (=> $x3858 $x4541)))
 (let (($x4543 (=> (and $x4526 $x3858) $x4541)))
 (let ((@x4564 (trans (monotonicity (rewrite (= $x4541 $x4559)) (= $x4542 (=> $x3858 $x4559))) (rewrite (= (=> $x3858 $x4559) (or $x4431 $x4559))) (= $x4542 (or $x4431 $x4559)))))
 (trans (monotonicity @x4564 (= $x4543 (=> $x4526 (or $x4431 $x4559)))) (rewrite (= (=> $x4526 (or $x4431 $x4559)) $x4570)) (= $x4543 $x4570)))))))))))))))))))))))
 ))
 (let ((@x4582 (monotonicity (quant-intro (proof-bind ?x4577) (= $x4545 $x4576)) (= $x4546 (=> $x4524 $x4576)))))
 (let ((@x4589 (mp (asserted $x4546) (trans @x4582 (rewrite (= (=> $x4524 $x4576) $x4584)) (= $x4546 $x4584)) $x4584)))
 (let ((@x14006 (mp (mp (mp~ @x4589 @x10821 $x10819) (rewrite (= $x10819 $x10823)) $x10823) (rewrite (= $x10823 $x14017)) $x14017)))
 (let (($x48503 (not $x48502)))
 (let (($x44980 (not $x14084)))
 (let (($x48511 (or $x44980 $x48503 $x44446 $x44969 $x48520)))
 (let (($x48483 (or $x43874 $x48482 (not (or $x48478 $x48476 (<= (+ ?x48472 (* (- 1) ?x48470)) 0) $x48469)))))
 (let (($x48501 (not (or $x48499 (not $x48483)))))
 (let (($x48504 (or $x48503 $x44446 $x44969 $x48501)))
 (let (($x48512 (or $x44980 $x48504)))
 (let (($x48505 (or $x48503 $x44446 $x44969 $x48520)))
 (let (($x48506 (= $x48504 $x48505)))
 (let ((@x48510 (trans (monotonicity (rewrite (= $x48501 $x48520)) $x48506) (rewrite (= $x48505 $x48505)) $x48506)))
 (let ((@x48518 (trans (monotonicity @x48510 (= $x48512 (or $x44980 $x48505))) (rewrite (= (or $x44980 $x48505) $x48511)) (= $x48512 $x48511))))
 (let ((@x48519 (mp ((_ quant-inst $ (UINT 8) (vstd!seq.Seq.add.? $ ?x1876 ?x43794 ?x43799) (Poly%vstd!seq.Seq<u8.>. header_bytes!)) $x48512) @x48518 $x48511)))
 (let ((@x49083 (unit-resolution @x48519 @x175 (unit-resolution @x14006 (unit-resolution @x49079 @x44931 $x4524) $x14084) @x46849 (or $x48503 $x48520))))
 (let ((@x48567 (def-axiom (or $x48534 $x48515))))
 (let ((?x44947 (vstd!seq.Seq.len.? $ ?x1876 ?x43833)))
 (let ((?x48633 (Add ?x44947 ?x47832)))
 (let (($x48709 (>= ?x48633 32)))
 (let (($x48707 (= ?x48633 32)))
 (let ((?x48659 (Add 8 24)))
 (let (($x48690 (= ?x48659 32)))
 (let (($x48694 (or $x44812 $x48690)))
 (let ((?x48660 (* (- 1) ?x48659)))
 (let ((?x48681 (+ 24 8 ?x48660)))
 (let (($x48682 (= ?x48681 0)))
 (let (($x48695 (or $x44812 $x48682)))
 (let (($x48697 (= $x48695 $x48694)))
 (let ((@x48685 (rewrite (= ?x48681 (+ 32 ?x48660)))))
 (let ((@x48693 (trans (monotonicity @x48685 (= $x48682 (= (+ 32 ?x48660) 0))) (rewrite (= (= (+ 32 ?x48660) 0) $x48690)) (= $x48682 $x48690))))
 (let ((@x48702 (mp ((_ quant-inst 8 24) $x48695) (trans (monotonicity @x48693 $x48697) (rewrite (= $x48694 $x48694)) $x48697) $x48694)))
 (let ((@x48713 (unit-resolution @x48702 @x9133 $x48690)))
 (let (($x47825 (= ?x47832 24)))
 (let ((?x44478 (* (- 1) ?x8522)))
 (let ((?x44479 (+ pmemlog!logimpl_v.header_size.? ?x44478)))
 (let (($x44491 (<= ?x44479 8)))
 (let (($x44476 (= ?x44479 8)))
 (let (($x44482 (or $x44481 $x44476)))
 (let (($x44473 (= (+ 8 (* (- 1) pmemlog!logimpl_v.header_size.?) ?x8522) 0)))
 (let (($x44483 (or $x44481 $x44473)))
 (let (($x44485 (= $x44483 $x44482)))
 (let ((@x44489 (trans (monotonicity (rewrite (= $x44473 $x44476)) $x44485) (rewrite (= $x44482 $x44482)) $x44485)))
 (let ((@x44490 (mp ((_ quant-inst pmemlog!logimpl_v.header_size.? 8) $x44483) @x44489 $x44482)))
 (let ((@x48717 (unit-resolution @x44490 @x9140 $x44476)))
 (let ((@x48718 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44476) $x44491)) @x48717 $x44491)))
 (let (($x44492 (>= ?x44479 8)))
 (let (($x45887 (<= pmemlog!logimpl_v.header_size.? 32)))
 (let ((@x48726 ((_ th-lemma arith eq-propagate -1 -1 1 1) @x47602 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x45887)) @x46981 $x45887) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44476) $x44492)) @x48717 $x44492) @x48718 (= ?x8522 24))))
 (let (($x47114 (= ?x44947 8)))
 (let ((@x48729 (monotonicity @x48191 (= (Poly%vstd!seq.Seq<u8.>. ?x44757) ?x43833))))
 (let ((@x48737 (monotonicity (trans* @x48729 @x48197 (= (Poly%vstd!seq.Seq<u8.>. ?x44757) ?x43794)) (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44757)) ?x43795))))
 (let ((@x48735 (monotonicity (symm @x48729 (= ?x43833 (Poly%vstd!seq.Seq<u8.>. ?x44757))) (= ?x44947 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44757))))))
 (let ((@x48738 (trans* @x48735 @x48737 @x43797 $x47114)))
 (let ((@x48740 (monotonicity @x48738 (trans* @x48038 @x48726 $x47825) (= ?x48633 ?x48659))))
 (let ((@x48742 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48707) $x48709)) (trans* @x48740 @x48713 $x48707) $x48709)))
 (let (($x48652 (>= ?x48633 0)))
 (let (($x48653 (not $x48652)))
 (let ((?x48640 (nClip ?x48633)))
 (let (($x48654 (= ?x48633 ?x48640)))
 (let (($x48655 (or $x48653 $x48654)))
 (let (($x48656 (not $x48655)))
 (let (($x48643 (>= ?x48640 0)))
 (let (($x48644 (not $x48643)))
 (let (($x48657 (or $x48644 $x48656)))
 (let (($x48658 (not $x48657)))
 (let (($x10935 (forall ((i Int) )(! (let (($x10929 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (not $x10929)) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let (($x534 (forall ((i Int) )(! (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (and $x533 $x541))))))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x12695 (lambda ((i Int) )(let (($x10929 (or (not (>= (nClip i) 0)) (not (or (not (>= i 0)) (= i (nClip i)))))))
 (let (($x10906 (not $x10929)))
 (let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (rewrite (= $x546 $x10906))))))))))))
 ))
 (let ((?x8982 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (refl (~ $x546 $x546))))))))))
 ))
 (let (($x529 (forall ((i Int) )(! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ( (nClip i) ) :qid prelude_nat_clip))
 ))
 (let ((?x535 (lambda ((i Int) )(let ((?x522 (nClip i)))
 (let (($x525 (= i ?x522)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x541 (or $x540 $x525)))
 (let (($x533 (>= ?x522 0)))
 (let (($x546 (and $x533 $x541)))
 (let (($x527 (and (<= 0 ?x522) (=> (<= 0 i) $x525))))
 (rewrite (= $x527 $x546)))))))))))
 ))
 (let ((@x542 (mp (asserted $x529) (quant-intro (proof-bind ?x535) (= $x529 $x534)) $x534)))
 (let ((@x12699 (mp (mp~ @x542 (nnf-pos (proof-bind ?x8982) (~ $x534 $x534)) $x534) (quant-intro (proof-bind ?x12695) (= $x534 $x10935)) $x10935)))
 (let (($x48662 (or (not $x10935) $x48658)))
 (let ((@x48663 ((_ quant-inst (Add ?x44947 ?x47832)) $x48662)))
 (let ((@x48678 (def-axiom (or $x48657 $x48655))))
 (let (($x48670 (not $x48654)))
 (let ((?x48632 (vstd!seq.Seq.len.? $ ?x1876 ?x48572)))
 (let (($x48790 (= ?x48632 ?x48472)))
 (let (($x48641 (= ?x48632 ?x48640)))
 (let (($x14199 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x14005 (not $x4525)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x13752 (not $x4101)))
 (or $x13752 $x14005 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4955 (fuel_bool fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x45100 (= $x4955 $x1592)))
 (let ((@x45102 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_len.) (or (not $x30) $x45100)) @x44825 (hypothesis (not $x45100)) false)))
 (let ((@x45114 (lemma @x45102 $x45100)))
 (let ((@x45107 (def-axiom (or (not $x45100) $x4955 $x13189))))
 (let ((@x48748 (unit-resolution @x45107 (unit-resolution (def-axiom (or $x13192 $x1592)) @x47581 $x1592) (or (not $x45100) $x4955))))
 (let (($x4985 (not $x4955)))
 (let (($x14204 (or $x4985 $x14199)))
 (let (($x4977 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (or $x4568 $x4431 $x4959))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4986 (or $x4985 $x4977)))
 (let ((?x10984 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (refl (~ $x4972 $x4972))))))))))))))))
 ))
 (let ((@x10989 (monotonicity (refl (~ $x4985 $x4985)) (nnf-pos (proof-bind ?x10984) (~ $x4977 $x4977)) (~ $x4986 $x4986))))
 (let (($x4963 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(! (let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (=> (and $x4526 $x3858) $x4959)))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!)) ) :qid user_vstd__seq__axiom_seq_add_len_12))
 ))
 (let (($x4964 (=> $x4955 $x4963)))
 (let ((?x4978 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) )(let ((?x4528 (vstd!seq.Seq.len.? A&. A& s2!)))
 (let ((?x4092 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x4940 (vstd!seq.Seq.add.? A&. A& s1! s2!)))
 (let ((?x4956 (vstd!seq.Seq.len.? A&. A& ?x4940)))
 (let (($x4959 (= ?x4956 (nClip (Add ?x4092 ?x4528)))))
 (let (($x3858 (sized A&.)))
 (let (($x4431 (not $x3858)))
 (let ((?x3990 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4525 (has_type s2! ?x3990)))
 (let (($x4101 (has_type s1! ?x3990)))
 (let (($x4526 (and $x4101 $x4525)))
 (let (($x4568 (not $x4526)))
 (let (($x4972 (or $x4568 $x4431 $x4959)))
 (let (($x4960 (=> $x3858 $x4959)))
 (let (($x4961 (=> (and $x4526 $x3858) $x4959)))
 (let ((@x4971 (monotonicity (rewrite (= $x4960 (or $x4431 $x4959))) (= $x4961 (=> $x4526 (or $x4431 $x4959))))))
 (trans @x4971 (rewrite (= (=> $x4526 (or $x4431 $x4959)) $x4972)) (= $x4961 $x4972)))))))))))))))))))
 ))
 (let ((@x4984 (monotonicity (quant-intro (proof-bind ?x4978) (= $x4963 $x4977)) (= $x4964 (=> $x4955 $x4977)))))
 (let ((@x4991 (mp (asserted $x4964) (trans @x4984 (rewrite (= (=> $x4955 $x4977) $x4986)) (= $x4964 $x4986)) $x4986)))
 (let ((@x14206 (mp (mp (mp~ @x4991 @x10989 $x4986) (rewrite (= $x4986 $x4986)) $x4986) (rewrite (= $x4986 $x14204)) $x14204)))
 (let (($x48645 (not $x14199)))
 (let (($x48646 (or $x48645 $x44971 $x47852 $x44969 $x48641)))
 (let ((@x48651 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x43832) (Poly%vstd!seq.Seq<u8.>. ?x43859)) (or $x48645 (or $x44971 $x47852 $x44969 $x48641))) (rewrite (= (or $x48645 (or $x44971 $x47852 $x44969 $x48641)) $x48646)) $x48646)))
 (let ((@x48759 (unit-resolution @x48651 @x175 (unit-resolution @x14206 (unit-resolution @x48748 @x45114 $x4955) $x14199) @x48753 @x48758 $x48641)))
 (let ((@x48793 (trans* (symm @x48759 (= ?x48640 ?x48632)) (symm (monotonicity (symm @x48783 (= ?x43873 ?x48572)) (= ?x48472 ?x48632)) $x48790) (= ?x48640 ?x48472))))
 (let ((@x48797 (monotonicity (trans* @x48740 @x48713 @x46983 @x47597 (= ?x48633 ?x43805)) @x48793 (= $x48654 (= ?x43805 ?x48472)))))
 (let ((@x48803 (symm (trans @x48797 (commutativity (= (= ?x43805 ?x48472) $x48481)) (= $x48654 $x48481)) (= $x48481 $x48654))))
 (let ((@x48674 (def-axiom (or $x48656 $x48653 $x48654))))
 (let ((@x48807 (unit-resolution @x48674 (mp (hypothesis $x48482) (monotonicity @x48803 (= $x48482 $x48670)) $x48670) (unit-resolution @x48678 (unit-resolution @x48663 @x12699 $x48658) $x48655) $x48653)))
 (let ((@x48812 (lemma (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x48709) $x48652)) @x48807 @x48742 false) $x48481)))
 (let ((@x49067 (monotonicity (trans* @x47400 @x48780 @x48026 (= ?x47379 ?x43851)) @x48781 (= $x47871 $x43868))))
 (let ((@x44312 (def-axiom (or $x43934 tmp%8 (not $x43868)))))
 (let ((@x49070 (unit-resolution @x44312 (mp @x48772 @x49067 $x43868) (unit-resolution (def-axiom (or $x43996 $x43869)) @x48765 $x43869) tmp%8)))
 (let ((@x44322 (def-axiom (or $x43927 $x43937))))
 (let ((@x44339 (def-axiom (or $x43992 $x43989 $x43990))))
 (let ((@x49073 (unit-resolution @x44339 (unit-resolution @x44322 @x49070 $x43927) (unit-resolution (def-axiom (or $x43996 $x43991)) @x48765 $x43991) $x43990)))
 (let ((@x44331 (def-axiom (or $x43938 $x44329))))
 (let ((@x48563 (def-axiom (or $x48523 $x43874 $x48482 $x48533))))
 (let ((@x49076 (unit-resolution @x48563 (unit-resolution @x44331 @x49073 $x44329) (or $x48523 $x48482 $x48533))))
 (let ((@x49090 (unit-resolution @x49076 @x48812 (unit-resolution @x48567 (unit-resolution @x49083 @x49087 $x48520) $x48515) $x48533)))
 (let ((@x48545 (def-axiom (or $x48527 $x48477))))
 (let ((@x49340 (unit-resolution @x48545 @x49090 $x48477)))
 (let (($x275 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (or $x271 $x266)))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x8912 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (refl (~ $x272 $x272)))))))
 ))
 (let (($x269 (forall ((x Poly) )(! (let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (=> $x263 $x266))) :pattern ( (has_type x INT) ) :qid prelude_box_unbox_int))
 ))
 (let ((?x276 (lambda ((x Poly) )(let (($x266 (= x (I (%I x)))))
 (let (($x263 (has_type x INT)))
 (let (($x271 (not $x263)))
 (let (($x272 (or $x271 $x266)))
 (let (($x267 (=> $x263 $x266)))
 (rewrite (= $x267 $x272))))))))
 ))
 (let ((@x280 (mp (asserted $x269) (quant-intro (proof-bind ?x276) (= $x269 $x275)) $x275)))
 (let ((@x8916 (mp~ @x280 (nnf-pos (proof-bind ?x8912) (~ $x275 $x275)) $x275)))
 (let (($x48872 (not $x275)))
 (let (($x48873 (or $x48872 $x48478 $x48868)))
 (let ((@x48878 (mp ((_ quant-inst (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x43804 ?x43873 ?x1876 $)) (or $x48872 (or $x48478 $x48868))) (rewrite (= (or $x48872 (or $x48478 $x48868)) $x48873)) $x48873)))
 (let ((@x49405 (unit-resolution @x48878 @x8916 @x49340 $x48868)))
 (let ((@x49511 (monotonicity @x49405 $x49461)))
 (let ((?x49434 (* (- 1) ?x49171)))
 (let ((?x49462 (+ ?x48470 ?x49434)))
 (let (($x49463 (<= ?x49462 0)))
 (let ((@x49480 ((_ th-lemma arith triangle-eq) (or (not $x49461) $x49463))))
 (let (($x49464 (>= ?x49462 0)))
 (let ((@x49512 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49461) $x49464)) @x49511 $x49464)))
 (let ((?x49471 (Add ?x48470 0)))
 (let ((?x49472 (* (- 1) ?x49471)))
 (let ((?x49477 (+ ?x48470 ?x49472)))
 (let (($x49499 (<= ?x49477 0)))
 (let (($x49468 (= ?x49477 0)))
 (let (($x49478 (or $x44812 $x49468)))
 (let (($x49476 (= (+ 0 ?x48470 ?x49472) 0)))
 (let (($x49467 (or $x44812 $x49476)))
 (let (($x49493 (= $x49467 $x49478)))
 (let ((@x49497 (trans (monotonicity (rewrite (= $x49476 $x49468)) $x49493) (rewrite (= $x49478 $x49478)) $x49493)))
 (let ((@x49498 (mp ((_ quant-inst (%I ?x48410) 0) $x49467) @x49497 $x49478)))
 (let ((@x49541 (unit-resolution @x49498 @x9133 $x49468)))
 (let (($x49500 (>= ?x49477 0)))
 (let ((@x49550 ((_ th-lemma arith eq-propagate 1 1 -1 -1) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49468) $x49500)) @x49541 $x49500) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49468) $x49499)) @x49541 $x49499) @x49512 (unit-resolution @x49480 @x49511 $x49463) (= ?x49171 ?x49471))))
 (let ((@x49554 (symm (monotonicity @x49511 (trans* @x47012 @x47532 (= 0 ?x44784)) (= ?x49471 ?x49229)) (= ?x49229 ?x49471))))
 (let ((@x49559 (trans* @x49554 (symm @x49550 (= ?x49471 ?x49171)) (symm @x49511 $x49483) (= ?x49229 ?x48470))))
 (let ((@x49565 (trans* @x49405 (symm (monotonicity @x49559 (= ?x49162 ?x48867)) (= ?x48867 ?x49162)) (= ?x48410 ?x49162))))
 (let ((?x49228 (vstd!seq.Seq.index.? $ ?x1876 ?x43830 ?x48867)))
 (let (($x49308 (= ?x49228 ?x49175)))
 (let ((?x49435 (+ ?x47466 ?x49434)))
 (let (($x49436 (<= ?x49435 0)))
 (let (($x49523 (not $x49436)))
 (let (($x49460 (>= ?x47466 8)))
 (let ((@x49519 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x47466 8)) $x49460)) (trans* (symm @x47614 (= ?x47466 ?x44938)) @x47620 (= ?x47466 8)) $x49460)))
 (let (($x47115 (<= ?x44947 8)))
 (let ((?x48471 (* (- 1) ?x48470)))
 (let ((?x48813 (+ ?x44947 ?x48471)))
 (let (($x48814 (<= ?x48813 0)))
 (let (($x48846 (not $x48814)))
 (let ((?x48841 (Sub ?x48470 ?x44947)))
 (let ((?x48842 (I ?x48841)))
 (let ((?x49108 (%I ?x48842)))
 (let ((?x49193 (I ?x49108)))
 (let ((?x49156 (%I ?x49193)))
 (let ((?x49179 (Add ?x49156 ?x44786)))
 (let ((?x49180 (I ?x49179)))
 (let ((?x49181 (vstd!seq.Seq.index.? $ ?x1876 ?x43804 ?x49180)))
 (let ((?x49306 (Add ?x49108 8)))
 (let (($x49331 (= ?x48470 ?x49306)))
 (let ((?x49307 (* (- 1) ?x49306)))
 (let ((?x49332 (+ ?x48470 ?x49307)))
 (let (($x49334 (>= ?x49332 0)))
 (let ((?x49164 (Sub ?x48470 8)))
 (let ((?x49063 (* (- 1) ?x49164)))
 (let ((?x49058 (+ ?x48470 ?x49063)))
 (let (($x49155 (>= ?x49058 8)))
 (let (($x49062 (= ?x49058 8)))
 (let (($x49153 (or $x44481 $x49062)))
 (let (($x49168 (= (+ 8 ?x48471 ?x49164) 0)))
 (let (($x49154 (or $x44481 $x49168)))
 (let (($x49132 (= $x49154 $x49153)))
 (let ((@x49148 (trans (monotonicity (rewrite (= $x49168 $x49062)) $x49132) (rewrite (= $x49153 $x49153)) $x49132)))
 (let ((@x49149 (mp ((_ quant-inst (%I ?x48410) 8) $x49154) @x49148 $x49153)))
 (let ((@x49269 (unit-resolution @x49149 @x9140 $x49062)))
 (let ((@x49300 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49062) $x49155)) @x49269 $x49155)))
 (let ((?x49328 (+ ?x49108 ?x49063)))
 (let (($x49329 (<= ?x49328 0)))
 (let (($x49327 (= ?x49108 ?x49164)))
 (let ((@x49255 (symm @x48735 (= (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44757)) ?x44947))))
 (let ((@x49253 (symm @x48737 (= ?x43795 (vstd!seq.Seq.len.? $ ?x1876 (Poly%vstd!seq.Seq<u8.>. ?x44757))))))
 (let ((@x49263 (monotonicity (trans* (symm @x43797 (= 8 ?x43795)) @x49253 @x49255 (= 8 ?x44947)) (= ?x49164 ?x48841))))
 (let ((@x49265 (symm @x49263 (= ?x48841 ?x49164))))
 (let (($x49163 (= ?x48841 ?x49108)))
 (let (($x49166 (or $x44542 $x49163)))
 (let ((@x49167 ((_ quant-inst (Sub ?x48470 ?x44947)) $x49166)))
 (let ((@x49200 (symm (unit-resolution @x49167 @x8895 $x49163) (= ?x49108 ?x48841))))
 (let ((@x49367 (trans* @x49200 @x49265 $x49327)))
 (let ((?x49312 (+ ?x49108 ?x49307)))
 (let (($x49326 (>= ?x49312 (- 8))))
 (let (($x49313 (= ?x49312 (- 8))))
 (let (($x49316 (or $x44812 $x49313)))
 (let (($x49311 (= (+ 8 ?x49108 ?x49307) 0)))
 (let (($x49317 (or $x44812 $x49311)))
 (let (($x49319 (= $x49317 $x49316)))
 (let ((@x49323 (trans (monotonicity (rewrite (= $x49311 $x49313)) $x49319) (rewrite (= $x49316 $x49316)) $x49319)))
 (let ((@x49369 (unit-resolution (mp ((_ quant-inst (%I ?x48842) 8) $x49317) @x49323 $x49316) @x9133 $x49313)))
 (let ((@x49379 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1) (or $x49334 (not $x49155) (not $x49326) (not $x49329))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49313) $x49326)) @x49369 $x49326) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49327) $x49329)) @x49367 $x49329) @x49300 $x49334)))
 (let (($x49333 (<= ?x49332 0)))
 (let (($x49150 (<= ?x49058 8)))
 (let ((@x49273 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49062) $x49150)) @x49269 $x49150)))
 (let (($x49330 (>= ?x49328 0)))
 (let (($x49325 (<= ?x49312 (- 8))))
 (let ((@x49391 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1) (or $x49333 (not $x49150) (not $x49325) (not $x49330))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49313) $x49325)) @x49369 $x49325) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49327) $x49330)) @x49367 $x49330) @x49273 $x49333)))
 (let ((@x49396 (unit-resolution ((_ th-lemma arith triangle-eq) (or $x49331 (not $x49333) (not $x49334))) @x49391 @x49379 $x49331)))
 (let (($x49201 (= ?x49193 ?x48842)))
 (let (($x49060 (= ?x48842 ?x49193)))
 (let (($x49056 (has_type ?x48842 INT)))
 (let (($x49194 (has_type ?x49193 INT)))
 (let (($x49207 (not $x49194)))
 (let (($x49205 (= $x49056 $x49194)))
 (let ((@x49209 (monotonicity (symm (monotonicity (monotonicity @x49200 $x49201) (= $x49194 $x49056)) $x49205) (= (not $x49056) $x49207))))
 (let ((@x49212 (unit-resolution (unit-resolution ((_ quant-inst (%I ?x48842)) (or (not $x698) $x49194)) @x9035 $x49194) (mp (hypothesis (not $x49056)) @x49209 $x49207) false)))
 (let ((@x49213 (lemma @x49212 $x49056)))
 (let (($x49057 (not $x49056)))
 (let (($x49064 (or $x48872 $x49057 $x49060)))
 (let ((@x49104 (mp ((_ quant-inst (I ?x48841)) (or $x48872 (or $x49057 $x49060))) (rewrite (= (or $x48872 (or $x49057 $x49060)) $x49064)) $x49064)))
 (let ((@x49259 (symm (unit-resolution @x49104 @x8916 @x49213 $x49060) $x49201)))
 (let ((@x49261 (monotonicity @x49259 (= ?x49156 ?x49108))))
 (let ((@x49398 (monotonicity (symm @x49261 (= ?x49108 ?x49156)) (trans* @x46959 @x47537 (= 8 ?x44786)) (= ?x49306 ?x49179))))
 (let ((@x49404 (trans* (symm @x49398 (= ?x49179 ?x49306)) (symm @x49396 (= ?x49306 ?x48470)) (= ?x49179 ?x48470))))
 (let ((@x49411 (trans* @x49405 (symm (monotonicity @x49404 (= ?x49180 ?x48867)) (= ?x48867 ?x49180)) (= ?x48410 ?x49180))))
 (let ((?x49178 (vstd!seq.Seq.index.? $ ?x1876 ?x47941 ?x49193)))
 (let (($x49182 (= ?x49178 ?x49181)))
 (let (($x48548 (not $x48522)))
 (let ((@x48550 (def-axiom (or $x48527 $x48548))))
 (let ((@x49091 (unit-resolution @x48550 @x49090 $x48548)))
 (let ((?x49111 (* (- 1) ?x47943)))
 (let ((?x49243 (+ ?x8522 ?x49111)))
 (let (($x49244 (<= ?x49243 0)))
 (let ((@x49285 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x8522 ?x47943)) $x49244)) (symm @x48034 (= ?x8522 ?x47943)) $x49244)))
 (let ((?x49239 (+ ?x49156 ?x49063)))
 (let (($x49240 (<= ?x49239 0)))
 (let (($x49238 (= ?x49156 ?x49164)))
 (let ((@x49266 (trans* @x49261 @x49200 @x49265 $x49238)))
 (let (($x44725 (>= ?x44723 0)))
 (let ((?x48618 (+ ?x43805 ?x48490)))
 (let (($x48620 (>= ?x48618 0)))
 (let ((@x49297 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x43805 ?x48472)) $x48620)) (symm @x48812 (= ?x43805 ?x48472)) $x48620)))
 (let ((@x49301 ((_ th-lemma arith farkas -1 -1 -1 1 1 1 1 1) @x49300 @x49297 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44721) $x44725)) @x47597 $x44725) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49238) $x49240)) @x49266 $x49240) (hypothesis (<= (+ ?x47943 (* (- 1) ?x49156)) 0)) @x49285 @x48718 @x49091 false)))
 (let ((@x49303 (lemma @x49301 (not (<= (+ ?x47943 (* (- 1) ?x49156)) 0)))))
 (let (($x49157 (>= ?x49156 0)))
 (let ((@x49246 (hypothesis $x48814)))
 (let (($x49241 (>= ?x49239 0)))
 (let (($x47110 (>= ?x44947 8)))
 (let ((@x49278 ((_ th-lemma arith farkas -1 1 1 -1 1) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47114) $x47110)) @x48738 $x47110) @x49273 (hypothesis (not $x49157)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x49238) $x49241)) @x49266 $x49241) @x49246 false)))
 (let ((@x49280 (lemma @x49278 (or $x49157 $x48846))))
 (let (($x14110 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13740 (not $x821)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4686 (sized A&.)))
 (let (($x14060 (not $x4686)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type k! INT)))
 (let (($x13854 (not $x4257)))
 (let (($x4684 (has_type j! INT)))
 (let (($x14100 (not $x4684)))
 (or (not (has_type s! (TYPE%vstd!seq.Seq. A&. A&))) $x14100 $x13854 $x271 $x14060 (not (>= (%I j!) 0)) (not (<= (+ (%I j!) (* (- 1) (%I k!))) 0)) (not $x4711) $x13740 $x4741 $x4703)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4682 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x45070 (= $x4682 $x1590)))
 (let ((@x45072 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_index.) (or (not $x30) $x45070)) @x44825 (hypothesis (not $x45070)) false)))
 (let ((@x45084 (lemma @x45072 $x45070)))
 (let ((@x45077 (def-axiom (or (not $x45070) $x4682 $x13187))))
 (let ((@x49353 (unit-resolution @x45077 (unit-resolution (def-axiom (or $x13192 $x1590)) @x47581 $x1590) (or (not $x45070) $x4682))))
 (let (($x4749 (not $x4682)))
 (let (($x14115 (or $x4749 $x14110)))
 (let (($x4774 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (or (not $x4685) $x4759 $x4703)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4779 (or $x4749 $x4774)))
 (let ((?x10949 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (refl (~ $x4769 $x4769)))))))))))))))))))))))
 ))
 (let ((@x10954 (monotonicity (refl (~ $x4749 $x4749)) (nnf-pos (proof-bind ?x10949) (~ $x4774 $x4774)) (~ $x4779 $x4779))))
 (let (($x4707 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(! (let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) (%I j!))))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let ((?x1186 (%I j!)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4686 (sized A&.)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (=> (and $x4685 $x4697) $x4703))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) ) :qid user_vstd__seq__axiom_seq_subrange_index_10))
 ))
 (let (($x4708 (=> $x4682 $x4707)))
 (let ((?x4775 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly) )(let ((?x4699 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)))
 (let (($x4703 (= ?x4699 (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!)))))))
 (let (($x4741 (>= (+ (%I i!) (* (- 1) (Sub (%I k!) (%I j!)))) 0)))
 (let (($x4746 (not $x4741)))
 (let ((?x264 (%I i!)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4711 (<= (+ (%I k!) (* (- 1) (vstd!seq.Seq.len.? A&. A& s!))) 0)))
 (let (($x4714 (<= (+ (%I j!) (* (- 1) (%I k!))) 0)))
 (let ((?x1186 (%I j!)))
 (let (($x4710 (>= ?x1186 0)))
 (let (($x4686 (sized A&.)))
 (let (($x4745 (and $x4686 $x4710 $x4714 $x4711 $x821 $x4746)))
 (let (($x4759 (not $x4745)))
 (let (($x263 (has_type i! INT)))
 (let (($x4257 (has_type k! INT)))
 (let (($x4684 (has_type j! INT)))
 (let ((?x4402 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4683 (has_type s! ?x4402)))
 (let (($x4685 (and $x4683 $x4684 $x4257 $x263)))
 (let (($x4769 (or (not $x4685) $x4759 $x4703)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4696 (and $x816 (< ?x264 (Sub (%I k!) ?x1186)))))
 (let ((?x4690 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x1191 (%I k!)))
 (let (($x4691 (<= ?x1191 ?x4690)))
 (let (($x4687 (<= 0 ?x1186)))
 (let (($x4689 (and $x4687 (<= ?x1186 ?x1191))))
 (let (($x4692 (and $x4689 $x4691)))
 (let (($x4693 (and $x4686 $x4692)))
 (let (($x4697 (and $x4693 $x4696)))
 (let (($x4704 (=> $x4697 $x4703)))
 (let (($x4705 (=> (and $x4685 $x4697) $x4703)))
 (let ((@x4734 (rewrite (= (and $x4686 (and $x4710 $x4714 $x4711)) (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4723 (monotonicity (rewrite (= $x4689 (and $x4710 $x4714))) (rewrite (= $x4691 $x4711)) (= $x4692 (and (and $x4710 $x4714) $x4711)))))
 (let ((@x4728 (trans @x4723 (rewrite (= (and (and $x4710 $x4714) $x4711) (and $x4710 $x4714 $x4711))) (= $x4692 (and $x4710 $x4714 $x4711)))))
 (let ((@x4736 (trans (monotonicity @x4728 (= $x4693 (and $x4686 (and $x4710 $x4714 $x4711)))) @x4734 (= $x4693 (and $x4686 $x4710 $x4714 $x4711)))))
 (let ((@x4742 (monotonicity @x4736 (rewrite (= $x4696 (and $x821 $x4746))) (= $x4697 (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746))))))
 (let ((@x4755 (trans @x4742 (rewrite (= (and (and $x4686 $x4710 $x4714 $x4711) (and $x821 $x4746)) $x4745)) (= $x4697 $x4745))))
 (let ((@x4764 (trans (monotonicity @x4755 (= $x4704 (=> $x4745 $x4703))) (rewrite (= (=> $x4745 $x4703) (or $x4759 $x4703))) (= $x4704 (or $x4759 $x4703)))))
 (trans (monotonicity @x4764 (= $x4705 (=> $x4685 (or $x4759 $x4703)))) (rewrite (= (=> $x4685 (or $x4759 $x4703)) $x4769)) (= $x4705 $x4769))))))))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4747 (monotonicity (quant-intro (proof-bind ?x4775) (= $x4707 $x4774)) (= $x4708 (=> $x4682 $x4774)))))
 (let ((@x4784 (mp (asserted $x4708) (trans @x4747 (rewrite (= (=> $x4682 $x4774) $x4779)) (= $x4708 $x4779)) $x4779)))
 (let ((@x14117 (mp (mp (mp~ @x4784 @x10954 $x4779) (rewrite (= $x4779 $x4779)) $x4779) (rewrite (= $x4779 $x14115)) $x14115)))
 (let ((@x49355 (unit-resolution @x14117 (unit-resolution @x49353 @x45084 $x4682) $x14110)))
 (let ((?x49192 (* (- 1) ?x49156)))
 (let ((?x49214 (+ ?x47943 ?x49192)))
 (let (($x49215 (<= ?x49214 0)))
 (let (($x49173 (not $x49157)))
 (let (($x49224 (not $x14110)))
 (let (($x49225 (or $x49224 $x44446 $x44753 $x44710 $x49207 $x44969 $x47855 $x47937 $x47959 $x49173 $x49215 $x49182)))
 (let ((?x49174 (+ ?x49156 ?x49111)))
 (let (($x49177 (>= ?x49174 0)))
 (let ((?x49105 (+ ?x44786 ?x47952)))
 (let (($x49106 (<= ?x49105 0)))
 (let (($x49107 (not $x49106)))
 (let (($x49183 (or $x44446 $x44753 $x44710 $x49207 $x44969 $x47855 $x49107 $x47940 $x49173 $x49177 $x49182)))
 (let (($x49230 (or $x49224 $x49183)))
 (let (($x49160 (or $x44446 $x44753 $x44710 $x49207 $x44969 $x47855 $x47937 $x47959 $x49173 $x49215 $x49182)))
 (let (($x49232 (or $x49224 $x49160)))
 (let (($x49161 (= $x49183 $x49160)))
 (let ((@x49191 (monotonicity (rewrite (= ?x49174 (+ ?x49111 ?x49156))) (= $x49177 (>= (+ ?x49111 ?x49156) 0)))))
 (let ((@x49219 (trans @x49191 (rewrite (= (>= (+ ?x49111 ?x49156) 0) $x49215)) (= $x49177 $x49215))))
 (let ((@x47962 (rewrite (= $x47940 $x47959))))
 (let ((@x49186 (rewrite (= $x49107 $x47937))))
 (let ((@x49223 (trans (monotonicity @x49186 @x47962 @x49219 $x49161) (rewrite (= $x49160 $x49160)) $x49161)))
 (let ((@x49237 (trans (monotonicity @x49223 (= $x49230 $x49232)) (rewrite (= $x49232 $x49225)) (= $x49230 $x49225))))
 (let ((@x49358 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I ?x7830) (I pmemlog!logimpl_v.header_size.?) (I ?x49108)) $x49230) @x49237 $x49225) @x175 @x49355 @x46849 @x46996 @x46972 @x47996 @x48003 @x47989 (unit-resolution @x49280 @x49246 $x49157) @x49303 (or $x49207 $x49182))))
 (let ((@x49359 (unit-resolution @x49358 (mp @x49213 (symm (monotonicity @x49259 (= $x49194 $x49056)) $x49205) $x49194) $x49182)))
 (let ((@x49417 (monotonicity (trans* @x48024 @x48020 (= ?x47941 ?x46925)) @x49259 (= ?x49178 (vstd!seq.Seq.index.? $ ?x1876 ?x46925 ?x48842)))))
 (let ((?x48843 (vstd!seq.Seq.index.? $ ?x1876 ?x46925 ?x48842)))
 (let ((?x48629 (vstd!seq.Seq.index.? $ ?x1876 ?x48572 ?x48410)))
 (let (($x48844 (= ?x48629 ?x48843)))
 (let ((?x48838 (* (- 1) ?x48640)))
 (let ((?x48871 (+ ?x48472 ?x48838)))
 (let (($x48879 (<= ?x48871 0)))
 (let (($x48870 (= ?x48472 ?x48640)))
 (let ((@x49098 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x48870) $x48879)) (trans* (symm (monotonicity @x48783 $x48790) (= ?x48472 ?x48632)) @x48759 $x48870) $x48879)))
 (let ((@x49102 (lemma ((_ th-lemma arith farkas -1 1 1) (hypothesis (>= (+ ?x48470 ?x48838) 0)) @x49098 @x49091 false) (not (>= (+ ?x48470 ?x48838) 0)))))
 (let (($x14267 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x4282 (sized A&.)))
 (let (($x13880 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x14208 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x13844 (not $x4256)))
 (or $x13844 $x14208 $x271 $x13880 $x4555 $x5071 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5048 (fuel_bool fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x45130 (= $x5048 $x1594)))
 (let ((@x45132 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index2.) (or (not $x30) $x45130)) @x44825 (hypothesis (not $x45130)) false)))
 (let ((@x45144 (lemma @x45132 $x45130)))
 (let ((@x45137 (def-axiom (or (not $x45130) $x5048 $x13191))))
 (let ((@x49337 (unit-resolution @x45137 (unit-resolution (def-axiom (or $x13192 $x1594)) @x47581 $x1594) (or (not $x45130) $x5048))))
 (let (($x5079 (not $x5048)))
 (let (($x14272 (or $x5079 $x14267)))
 (let (($x5101 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5087 $x5059)))))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5106 (or $x5079 $x5101)))
 (let ((?x11012 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (refl (~ $x5096 $x5096)))))))))))))))))))))))
 ))
 (let ((@x11017 (monotonicity (refl (~ $x5079 $x5079)) (nnf-pos (proof-bind ?x11012) (~ $x5101 $x5101)) (~ $x5106 $x5106))))
 (let (($x5062 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x4282 (sized A&.)))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x5055) $x5059)))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index2_14))
 ))
 (let (($x5063 (=> $x5048 $x5062)))
 (let ((?x5102 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x5058 (vstd!seq.Seq.index.? A&. A& s2! (I (Sub (%I i!) (vstd!seq.Seq.len.? A&. A& s1!))))))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x5059 (= ?x4997 ?x5058)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s1!)))
 (let ((?x5052 (nClip (Add ?x4235 (vstd!seq.Seq.len.? A&. A& s2!)))))
 (let ((?x264 (%I i!)))
 (let (($x5071 (>= (+ ?x264 (* (- 1) ?x5052)) 0)))
 (let (($x5076 (not $x5071)))
 (let ((?x4249 (+ ?x264 (* (- 1) ?x4235))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5075 (and $x4282 $x4552 $x5076)))
 (let (($x5087 (not $x5075)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5096 (or $x5031 $x5087 $x5059)))
 (let (($x5054 (and (<= ?x4235 ?x264) (< ?x264 ?x5052))))
 (let (($x5055 (and $x4282 $x5054)))
 (let (($x5060 (=> $x5055 $x5059)))
 (let (($x5061 (=> (and $x4994 $x5055) $x5059)))
 (let ((@x5072 (monotonicity (rewrite (= $x5054 (and $x4552 $x5076))) (= $x5055 (and $x4282 (and $x4552 $x5076))))))
 (let ((@x5083 (trans @x5072 (rewrite (= (and $x4282 (and $x4552 $x5076)) $x5075)) (= $x5055 $x5075))))
 (let ((@x5092 (trans (monotonicity @x5083 (= $x5060 (=> $x5075 $x5059))) (rewrite (= (=> $x5075 $x5059) (or $x5087 $x5059))) (= $x5060 (or $x5087 $x5059)))))
 (trans (monotonicity @x5092 (= $x5061 (=> $x4994 (or $x5087 $x5059)))) (rewrite (= (=> $x4994 (or $x5087 $x5059)) $x5096)) (= $x5061 $x5096))))))))))))))))))))))))))))))
 ))
 (let ((@x5077 (monotonicity (quant-intro (proof-bind ?x5102) (= $x5062 $x5101)) (= $x5063 (=> $x5048 $x5101)))))
 (let ((@x5111 (mp (asserted $x5063) (trans @x5077 (rewrite (= (=> $x5048 $x5101) $x5106)) (= $x5063 $x5106)) $x5106)))
 (let ((@x14274 (mp (mp (mp~ @x5111 @x11017 $x5106) (rewrite (= $x5106 $x5106)) $x5106) (rewrite (= $x5106 $x14272)) $x14272)))
 (let ((?x48839 (+ ?x48470 ?x48838)))
 (let (($x48840 (>= ?x48839 0)))
 (let (($x48855 (not $x14267)))
 (let (($x48856 (or $x48855 $x44971 $x47852 $x48478 $x44969 $x48846 $x48840 $x48844)))
 (let ((?x47424 (* (- 1) ?x44947)))
 (let ((?x48671 (+ ?x48470 ?x47424)))
 (let (($x48672 (>= ?x48671 0)))
 (let (($x48837 (not $x48672)))
 (let (($x48845 (or $x44971 $x47852 $x48478 $x44969 $x48837 $x48840 $x48844)))
 (let (($x48857 (or $x48855 $x48845)))
 (let ((@x48863 (rewrite (= (or $x48855 (or $x44971 $x47852 $x48478 $x44969 $x48846 $x48840 $x48844)) $x48856))))
 (let (($x48848 (or $x44971 $x47852 $x48478 $x44969 $x48846 $x48840 $x48844)))
 (let (($x48850 (= $x48845 $x48848)))
 (let ((@x48854 (trans (monotonicity (rewrite (= $x48837 $x48846)) $x48850) (rewrite (= $x48848 $x48848)) $x48850)))
 (let ((@x48865 (trans (monotonicity @x48854 (= $x48857 (or $x48855 $x48848))) @x48863 (= $x48857 $x48856))))
 (let ((@x48866 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x43832) (Poly%vstd!seq.Seq<u8.>. ?x43859) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x43804 ?x43873 ?x1876 $)) $x48857) @x48865 $x48856)))
 (let ((@x49342 (unit-resolution @x48866 @x175 (unit-resolution @x14274 (unit-resolution @x49337 @x45144 $x5048) $x14267) @x48753 @x48758 @x49340 (or $x48846 $x48840 $x48844))))
 (let ((@x49423 (symm (monotonicity @x48783 (= ?x48629 ?x48468)) (= ?x48468 ?x48629))))
 (let ((@x49428 (trans* @x49423 (unit-resolution (unit-resolution @x49342 @x49102 (or $x48846 $x48844)) @x49246 $x48844) (symm @x49417 (= ?x48843 ?x49178)) @x49359 (symm (monotonicity @x49411 (= ?x48411 ?x49181)) (= ?x49181 ?x48411)) $x48469)))
 (let (($x48551 (not $x48469)))
 (let ((@x48553 (def-axiom (or $x48527 $x48551))))
 (let ((@x49429 (unit-resolution @x48553 @x49090 $x48551)))
 (let ((@x49431 (lemma (unit-resolution @x49429 @x49428 false) $x48846)))
 (let ((@x49529 (unit-resolution ((_ th-lemma arith assign-bounds -1 -1 1 -1) (or $x49523 (not $x49460) (not $x49464) (not $x47115) $x48814)) @x49431 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47114) $x47115)) @x48738 $x47115) @x49519 @x49512 $x49523)))
 (let (($x49176 (has_type ?x48867 INT)))
 (let ((@x49533 (symm (monotonicity (symm @x49405 (= ?x48867 ?x48410)) (= $x49176 $x48477)) (= $x48477 $x49176))))
 (let (($x49169 (>= ?x49171 0)))
 (let ((@x48547 (def-axiom (or $x48527 $x48475))))
 (let ((@x49465 (unit-resolution @x48547 @x49090 $x48475)))
 (let ((@x49486 (unit-resolution @x49480 (symm (monotonicity (symm @x49405 (= ?x48867 ?x48410)) $x49483) $x49461) $x49463)))
 (let ((@x49489 (lemma ((_ th-lemma arith farkas -1 -1 1) (hypothesis (not $x49169)) @x49486 @x49465 false) $x49169)))
 (let (($x49172 (not $x49169)))
 (let (($x49170 (not $x49176)))
 (let (($x49447 (or $x49224 $x44446 $x44749 $x44753 $x49170 $x44969 $x47452 $x47482 $x47497 $x49172 $x49436 $x49308)))
 (let ((?x49152 (* (- 1) ?x47466)))
 (let ((?x49158 (+ ?x49171 ?x49152)))
 (let (($x49226 (>= ?x49158 0)))
 (let (($x49309 (or $x44446 $x44749 $x44753 $x49170 $x44969 $x47452 $x47482 $x47465 $x49172 $x49226 $x49308)))
 (let (($x49448 (or $x49224 $x49309)))
 (let (($x49441 (or $x44446 $x44749 $x44753 $x49170 $x44969 $x47452 $x47482 $x47497 $x49172 $x49436 $x49308)))
 (let (($x49450 (or $x49224 $x49441)))
 (let (($x49442 (= $x49309 $x49441)))
 (let ((@x49433 (monotonicity (rewrite (= ?x49158 (+ ?x49152 ?x49171))) (= $x49226 (>= (+ ?x49152 ?x49171) 0)))))
 (let ((@x49440 (trans @x49433 (rewrite (= (>= (+ ?x49152 ?x49171) 0) $x49436)) (= $x49226 $x49436))))
 (let ((@x47500 (rewrite (= $x47465 $x47497))))
 (let ((@x49452 (monotonicity (trans (monotonicity @x47500 @x49440 $x49442) (rewrite (= $x49441 $x49441)) $x49442) (= $x49448 $x49450))))
 (let ((@x49457 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. header_bytes!) (I pmemlog!logimpl_v.header_crc_offset.?) (I ?x7830) (I ?x48470)) $x49448) (trans @x49452 (rewrite (= $x49450 $x49447)) (= $x49448 $x49447)) $x49447)))
 (let ((@x49536 (unit-resolution @x49457 @x175 @x49355 @x46849 @x47025 @x46972 @x47593 @x47613 @x47541 (or $x49170 $x49172 $x49436 $x49308))))
 (let ((@x49482 (symm @x49405 (= ?x48867 ?x48410))))
 (let ((@x49571 (monotonicity @x48183 @x49482 (= ?x49228 (vstd!seq.Seq.index.? $ ?x1876 ?x43833 ?x48410)))))
 (let ((?x48664 (vstd!seq.Seq.index.? $ ?x1876 ?x43833 ?x48410)))
 (let (($x48665 (= ?x48629 ?x48664)))
 (let (($x14239 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x821 (>= ?x264 0)))
 (let (($x13740 (not $x821)))
 (let (($x4282 (sized A&.)))
 (let (($x13880 (not $x4282)))
 (let (($x263 (has_type i! INT)))
 (let (($x271 (not $x263)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x14208 (not $x4993)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x13844 (not $x4256)))
 (or $x13844 $x14208 $x271 $x13880 $x13740 $x4552 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x4992 (fuel_bool fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x45115 (= $x4992 $x1593)))
 (let ((@x45117 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_add_index1.) (or (not $x30) $x45115)) @x44825 (hypothesis (not $x45115)) false)))
 (let ((@x45129 (lemma @x45117 $x45115)))
 (let ((@x45122 (def-axiom (or (not $x45115) $x4992 $x13190))))
 (let ((@x49503 (unit-resolution @x45122 (unit-resolution (def-axiom (or $x13192 $x1593)) @x47581 $x1593) (or (not $x45115) $x4992))))
 (let (($x5013 (not $x4992)))
 (let (($x14244 (or $x5013 $x14239)))
 (let (($x5037 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (or $x5031 $x5022 $x4998)))))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5042 (or $x5013 $x5037)))
 (let ((?x10998 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (refl (~ $x5032 $x5032)))))))))))))))))))))
 ))
 (let ((@x11003 (monotonicity (refl (~ $x5013 $x5013)) (nnf-pos (proof-bind ?x10998) (~ $x5037 $x5037)) (~ $x5042 $x5042))))
 (let (($x5002 (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(! (let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4282 (sized A&.)))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (=> (and $x4994 $x4995) $x4998))))))))))))))) :pattern ( (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!) ) :qid user_vstd__seq__axiom_seq_add_index1_13))
 ))
 (let (($x5003 (=> $x4992 $x5002)))
 (let ((?x5038 (lambda ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (i! Poly) )(let ((?x4532 (vstd!seq.Seq.index.? A&. A& s1! i!)))
 (let ((?x4997 (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1! s2!) i!)))
 (let (($x4998 (= ?x4997 ?x4532)))
 (let ((?x264 (%I i!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4552 (>= ?x4249 0)))
 (let (($x4555 (not $x4552)))
 (let (($x821 (>= ?x264 0)))
 (let (($x4282 (sized A&.)))
 (let (($x5010 (and $x4282 $x821 $x4555)))
 (let (($x5022 (not $x5010)))
 (let (($x263 (has_type i! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4993 (has_type s2! ?x4244)))
 (let (($x4256 (has_type s1! ?x4244)))
 (let (($x4994 (and $x4256 $x4993 $x263)))
 (let (($x5031 (not $x4994)))
 (let (($x5032 (or $x5031 $x5022 $x4998)))
 (let (($x816 (<= 0 ?x264)))
 (let (($x4531 (and $x816 (< ?x264 (vstd!seq.Seq.len.? A&. A& s1!)))))
 (let (($x4995 (and $x4282 $x4531)))
 (let (($x4999 (=> $x4995 $x4998)))
 (let (($x5000 (=> (and $x4994 $x4995) $x4998)))
 (let ((@x5009 (monotonicity (rewrite (= $x4531 (and $x821 $x4555))) (= $x4995 (and $x4282 (and $x821 $x4555))))))
 (let ((@x5018 (trans @x5009 (rewrite (= (and $x4282 (and $x821 $x4555)) $x5010)) (= $x4995 $x5010))))
 (let ((@x5027 (trans (monotonicity @x5018 (= $x4999 (=> $x5010 $x4998))) (rewrite (= (=> $x5010 $x4998) (or $x5022 $x4998))) (= $x4999 (or $x5022 $x4998)))))
 (trans (monotonicity @x5027 (= $x5000 (=> $x4994 (or $x5022 $x4998)))) (rewrite (= (=> $x4994 (or $x5022 $x4998)) $x5032)) (= $x5000 $x5032)))))))))))))))))))))))))))))
 ))
 (let ((@x5011 (monotonicity (quant-intro (proof-bind ?x5038) (= $x5002 $x5037)) (= $x5003 (=> $x4992 $x5037)))))
 (let ((@x5047 (mp (asserted $x5003) (trans @x5011 (rewrite (= (=> $x4992 $x5037) $x5042)) (= $x5003 $x5042)) $x5042)))
 (let ((@x14246 (mp (mp (mp~ @x5047 @x11003 $x5042) (rewrite (= $x5042 $x5042)) $x5042) (rewrite (= $x5042 $x14244)) $x14244)))
 (let (($x48825 (not $x14239)))
 (let (($x48826 (or $x48825 $x44971 $x47852 $x48478 $x44969 $x48476 $x48814 $x48665)))
 (let ((@x48833 (rewrite (= (or $x48825 (or $x44971 $x47852 $x48478 $x44969 $x48476 $x48814 $x48665)) $x48826))))
 (let (($x48819 (or $x44971 $x47852 $x48478 $x44969 $x48476 $x48814 $x48665)))
 (let (($x48829 (or $x48825 $x48819)))
 (let (($x48666 (or $x44971 $x47852 $x48478 $x44969 $x48476 $x48672 $x48665)))
 (let (($x48827 (or $x48825 $x48666)))
 (let (($x48820 (= $x48666 $x48819)))
 (let ((@x48704 (rewrite (= ?x48671 (+ ?x47424 ?x48470)))))
 (let ((@x48818 (trans (monotonicity @x48704 (= $x48672 (>= (+ ?x47424 ?x48470) 0))) (rewrite (= (>= (+ ?x47424 ?x48470) 0) $x48814)) (= $x48672 $x48814))))
 (let ((@x48831 (monotonicity (trans (monotonicity @x48818 $x48820) (rewrite (= $x48819 $x48819)) $x48820) (= $x48827 $x48829))))
 (let ((@x48836 (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x43832) (Poly%vstd!seq.Seq<u8.>. ?x43859) (i$!skolem_user_vstd__seq__axiom_seq_ext_equal_5!2 ?x43804 ?x43873 ?x1876 $)) $x48827) (trans @x48831 @x48833 (= $x48827 $x48826)) $x48826)))
 (let ((@x49507 (unit-resolution @x48836 @x175 (unit-resolution @x14246 (unit-resolution @x49503 @x45129 $x4992) $x14239) @x48753 @x48758 @x49340 @x49465 (or $x48814 $x48665))))
 (let ((@x49578 (trans* @x49423 (unit-resolution @x49507 @x49431 $x48665) (symm @x49571 (= ?x48664 ?x49228)) (unit-resolution @x49536 @x49489 (mp @x49340 @x49533 $x49176) @x49529 $x49308) (symm (monotonicity @x49565 (= ?x48411 ?x49175)) (= ?x49175 ?x48411)) $x48469)))
 (unit-resolution @x49429 @x49578 false))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

