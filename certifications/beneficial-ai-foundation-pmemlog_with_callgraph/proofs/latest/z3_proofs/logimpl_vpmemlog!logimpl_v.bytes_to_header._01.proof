(:max-memory   21.66
 :memory       21.66
 :num-allocs   752311
 :rlimit-count 10302)
(:version "4.12.5")
unsat
((proof
(let ((?x43930 (Poly%slice%<u8.>. bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x43931 (vstd!view.View.view.? $slice ?x2028 ?x43930)))
 (let ((?x43991 (pmemlog!logimpl_v.spec_bytes_to_header.? ?x43931)))
 (let ((?x43992 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x43991)))
 (let ((?x46803 (%Poly%pmemlog!logimpl_v.PersistentHeader. ?x43992)))
 (let ((?x46614 (Poly%pmemlog!logimpl_v.PersistentHeader. ?x46803)))
 (let ((?x43990 (Poly%pmemlog!logimpl_v.PersistentHeader. out!)))
 (let (($x47470 (= ?x43990 ?x46614)))
 (let (($x46860 (= ?x43992 ?x46614)))
 (let (($x44462 (has_type ?x43992 TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x44389 (has_type ?x43931 ?x1968)))
 (let ((?x44402 (proj%vstd!view.View./V $slice ?x2028)))
 (let (($x46905 (= ?x44402 ?x1968)))
 (let (($x3936 (forall ((T&. Dcr) (T& Type) )(! (let ((?x3809 (TYPE%vstd!seq.Seq. T&. T&)))
 (let ((?x3927 (SLICE T&. T&)))
 (let ((?x3933 (proj%vstd!view.View./V $slice ?x3927)))
 (= ?x3933 ?x3809)))) :pattern ( (proj%vstd!view.View./V $slice (SLICE T&. T&)) ) :qid internal_proj__vstd!view.View./V_assoc_type_impl_false_definition))
 ))
 (let ((?x10550 (lambda ((T&. Dcr) (T& Type) )(let ((?x3809 (TYPE%vstd!seq.Seq. T&. T&)))
 (let ((?x3927 (SLICE T&. T&)))
 (let ((?x3933 (proj%vstd!view.View./V $slice ?x3927)))
 (let (($x3934 (= ?x3933 ?x3809)))
 (refl (~ $x3934 $x3934)))))))
 ))
 (let ((@x10554 (mp~ (asserted $x3936) (nnf-pos (proof-bind ?x10550) (~ $x3936 $x3936)) $x3936)))
 (let (($x46798 (or (not $x3936) $x46905)))
 (let ((@x46799 ((_ quant-inst $ (UINT 8)) $x46798)))
 (let ((@x47562 (monotonicity (unit-resolution @x46799 @x10554 $x46905) (= (has_type ?x43931 ?x44402) $x44389))))
 (let (($x44403 (has_type ?x43931 ?x44402)))
 (let (($x44393 (has_type ?x43930 ?x2028)))
 (let (($x2049 (forall ((x slice%<u8.>.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x2022 (Poly%slice%<u8.>. x)))
 (has_type ?x2022 ?x2028)))) :pattern ( (has_type (Poly%slice%<u8.>. x) (SLICE $ (UINT 8))) ) :qid internal_crate__slice__<u8.>_has_type_always_definition))
 ))
 (let ((?x9591 (lambda ((x slice%<u8.>.) )(let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x2022 (Poly%slice%<u8.>. x)))
 (let (($x2047 (has_type ?x2022 ?x2028)))
 (refl (~ $x2047 $x2047)))))))
 ))
 (let ((@x9595 (mp~ (asserted $x2049) (nnf-pos (proof-bind ?x9591) (~ $x2049 $x2049)) $x2049)))
 (let ((@x47302 (unit-resolution ((_ quant-inst bytes!) (or (not $x2049) $x44393)) @x9595 (hypothesis (not $x44393)) false)))
 (let ((@x47306 (lemma @x47302 $x44393)))
 (let (($x44394 (not $x44393)))
 (let (($x44404 (or $x44394 $x44403)))
 (let (($x5331 (forall ((Self%&. Dcr) (Self%& Type) (self! Poly) )(! (let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (or $x2120 $x5323))))) :pattern ( (vstd!view.View.view.? Self%&. Self%& self!) ) :qid internal_vstd!view.View.view.?_pre_post_definition))
 ))
 (let ((?x11194 (lambda ((Self%&. Dcr) (Self%& Type) (self! Poly) )(let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (let (($x5328 (or $x2120 $x5323)))
 (refl (~ $x5328 $x5328))))))))
 ))
 (let (($x5326 (forall ((Self%&. Dcr) (Self%& Type) (self! Poly) )(! (let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (=> $x92 $x5323)))) :pattern ( (vstd!view.View.view.? Self%&. Self%& self!) ) :qid internal_vstd!view.View.view.?_pre_post_definition))
 ))
 (let ((?x5332 (lambda ((Self%&. Dcr) (Self%& Type) (self! Poly) )(let ((?x5321 (vstd!view.View.view.? Self%&. Self%& self!)))
 (let (($x5323 (has_type ?x5321 (proj%vstd!view.View./V Self%&. Self%&))))
 (let (($x92 (has_type self! Self%&)))
 (let (($x2120 (not $x92)))
 (let (($x5328 (or $x2120 $x5323)))
 (let (($x5324 (=> $x92 $x5323)))
 (rewrite (= $x5324 $x5328)))))))))
 ))
 (let ((@x5336 (mp (asserted $x5326) (quant-intro (proof-bind ?x5332) (= $x5326 $x5331)) $x5331)))
 (let ((@x11198 (mp~ @x5336 (nnf-pos (proof-bind ?x11194) (~ $x5331 $x5331)) $x5331)))
 (let (($x44407 (not $x5331)))
 (let (($x44408 (or $x44407 $x44394 $x44403)))
 (let ((@x44413 (mp ((_ quant-inst $slice (SLICE $ ?x1876) (Poly%slice%<u8.>. bytes!)) (or $x44407 $x44404)) (rewrite (= (or $x44407 $x44404) $x44408)) $x44408)))
 (let ((@x47563 (mp (unit-resolution (unit-resolution @x44413 @x11198 $x44404) @x47306 $x44403) @x47562 $x44389)))
 (let (($x44390 (not $x44389)))
 (let (($x44477 (or $x44390 $x44462)))
 (let (($x7861 (forall ((header_seq! Poly) )(! (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x7854))))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_pre_post_definition))
 ))
 (let ((?x12438 (lambda ((header_seq! Poly) )(let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7858 (or $x1977 $x7854)))
 (refl (~ $x7858 $x7858))))))))))
 ))
 (let (($x7856 (forall ((header_seq! Poly) )(! (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (=> $x1969 $x7854)))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_pre_post_definition))
 ))
 (let ((?x7862 (lambda ((header_seq! Poly) )(let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7854 (has_type (Poly%pmemlog!logimpl_v.PersistentHeader. ?x7828) TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type header_seq! ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x7858 (or $x1977 $x7854)))
 (let (($x7855 (=> $x1969 $x7854)))
 (rewrite (= $x7855 $x7858)))))))))))
 ))
 (let ((@x7866 (mp (asserted $x7856) (quant-intro (proof-bind ?x7862) (= $x7856 $x7861)) $x7861)))
 (let ((@x12442 (mp~ @x7866 (nnf-pos (proof-bind ?x12438) (~ $x7861 $x7861)) $x7861)))
 (let (($x44483 (not $x7861)))
 (let (($x44484 (or $x44483 $x44390 $x44462)))
 (let ((@x44489 (mp ((_ quant-inst (vstd!view.View.view.? $slice ?x2028 ?x43930)) (or $x44483 $x44477)) (rewrite (= (or $x44483 $x44477) $x44484)) $x44484)))
 (let (($x2631 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let (($x2622 (= x (Poly%pmemlog!logimpl_v.PersistentHeader. ?x2620))))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (or $x2627 $x2622))))) :pattern ( (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog__logimpl_v__PersistentHeader_unbox_axiom_definition))
 ))
 (let ((?x9864 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let (($x2622 (= x (Poly%pmemlog!logimpl_v.PersistentHeader. ?x2620))))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2628 (or $x2627 $x2622)))
 (refl (~ $x2628 $x2628))))))))
 ))
 (let (($x2625 (forall ((x Poly) )(! (let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let (($x2622 (= x (Poly%pmemlog!logimpl_v.PersistentHeader. ?x2620))))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (=> $x2619 $x2622)))) :pattern ( (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.) ) :qid internal_pmemlog__logimpl_v__PersistentHeader_unbox_axiom_definition))
 ))
 (let ((?x2632 (lambda ((x Poly) )(let ((?x2620 (%Poly%pmemlog!logimpl_v.PersistentHeader. x)))
 (let (($x2622 (= x (Poly%pmemlog!logimpl_v.PersistentHeader. ?x2620))))
 (let (($x2619 (has_type x TYPE%pmemlog!logimpl_v.PersistentHeader.)))
 (let (($x2627 (not $x2619)))
 (let (($x2628 (or $x2627 $x2622)))
 (let (($x2623 (=> $x2619 $x2622)))
 (rewrite (= $x2623 $x2628)))))))))
 ))
 (let ((@x2636 (mp (asserted $x2625) (quant-intro (proof-bind ?x2632) (= $x2625 $x2631)) $x2631)))
 (let ((@x9868 (mp~ @x2636 (nnf-pos (proof-bind ?x9864) (~ $x2631 $x2631)) $x2631)))
 (let (($x46802 (not $x44462)))
 (let (($x46885 (not $x2631)))
 (let (($x46888 (or $x46885 $x46802 $x46860)))
 (let ((@x46870 (mp ((_ quant-inst (Poly%pmemlog!logimpl_v.PersistentHeader. ?x43991)) (or $x46885 (or $x46802 $x46860))) (rewrite (= (or $x46885 (or $x46802 $x46860)) $x46888)) $x46888)))
 (let ((@x48255 (unit-resolution @x46870 @x9868 (unit-resolution (unit-resolution @x44489 @x12442 $x44477) @x47563 $x44462) $x46860)))
 (let (($x48376 (= ?x43990 ?x43992)))
 (let (($x48374 (= out! ?x43991)))
 (let ((?x44274 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43991)))
 (let ((?x44276 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x43991)))
 (let ((?x44277 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x44276 ?x44274)))
 (let (($x44278 (= ?x43991 ?x44277)))
 (let ((@x48256 ((_ th-lemma datatype) $x44278)))
 (let ((@x48373 (symm @x48256 (= ?x44277 ?x43991))))
 (let ((?x43985 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. tmp%9)))
 (let ((?x43986 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x43985)))
 (let ((?x43983 (I tmp%10)))
 (let ((?x43984 (%I ?x43983)))
 (let ((?x43987 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x43984 ?x43986)))
 (let (($x48370 (= ?x43987 ?x44277)))
 (let (($x48336 (= ?x43986 ?x44274)))
 (let ((?x44254 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x44277)))
 (let (($x44257 (= ?x44254 ?x44274)))
 (let ((@x48257 ((_ th-lemma datatype) $x44257)))
 (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x45830 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 ?x7834 ?x7835)))
 (let ((?x45831 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x45830)))
 (let ((?x45832 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x45831)))
 (let ((?x45833 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x45832)))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x45824 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 ?x7829 ?x7831)))
 (let ((?x45814 (vstd!bytes.spec_u64_from_le_bytes.? ?x45824)))
 (let ((?x45815 (I ?x45814)))
 (let ((?x45829 (%I ?x45815)))
 (let ((?x45834 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader ?x45829 ?x45833)))
 (let ((?x45864 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x45834)))
 (let (($x45835 (= ?x43991 ?x45834)))
 (let (($x7845 (forall ((header_seq! Poly) )(! (let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7837 (pmemlog!logimpl_v.spec_bytes_to_metadata.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7834 ?x7835))))
 (let ((?x7841 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7837))))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7833 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7829 ?x7831))))
 (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (= ?x7828 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I ?x7833)) ?x7841)))))))))))) :pattern ( (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!) ) :qid internal_pmemlog!logimpl_v.spec_bytes_to_header.?_definition))
 ))
 (let (($x7827 (fuel_bool fuel%pmemlog!logimpl_v.spec_bytes_to_header.)))
 (let (($x7825 (fuel_bool_default fuel%pmemlog!logimpl_v.spec_bytes_to_header.)))
 (let (($x45799 (= $x7827 $x7825)))
 (let (($x30 (forall ((id FuelId) )(! (let (($x26 (fuel_bool id)))
 (= $x26 (fuel_bool_default id))) :pattern ( (fuel_bool id) ) :qid prelude_fuel_defaults))
 ))
 (let ((@x43928 (asserted fuel_defaults)))
 (let (($x33 (not fuel_defaults)))
 (let (($x34 (or $x33 $x30)))
 (let ((?x8779 (lambda ((id FuelId) )(let (($x26 (fuel_bool id)))
 (let (($x28 (= $x26 (fuel_bool_default id))))
 (refl (~ $x28 $x28)))))
 ))
 (let ((@x8784 (monotonicity (refl (~ $x33 $x33)) (nnf-pos (proof-bind ?x8779) (~ $x30 $x30)) (~ $x34 $x34))))
 (let ((@x37 (mp (asserted (=> fuel_defaults $x30)) (rewrite (= (=> fuel_defaults $x30) $x34)) $x34)))
 (let ((@x8788 (mp (mp~ @x37 @x8784 $x34) (rewrite (= $x34 $x34)) $x34)))
 (let ((@x44497 (unit-resolution @x8788 @x43928 $x30)))
 (let ((@x45825 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.spec_bytes_to_header.) (or (not $x30) $x45799)) @x44497 (hypothesis (not $x45799)) false)))
 (let ((@x45838 (lemma @x45825 $x45799)))
 (let ((@x7826 (asserted $x7825)))
 (let ((@x45818 (def-axiom (or (not $x45799) $x7827 (not $x7825)))))
 (let ((@x48260 (unit-resolution (unit-resolution @x45818 @x7826 (or (not $x45799) $x7827)) @x45838 $x7827)))
 (let (($x7848 (not $x7827)))
 (let (($x7849 (or $x7848 $x7845)))
 (let ((?x12426 (lambda ((header_seq! Poly) )(let ((?x7835 (I pmemlog!logimpl_v.header_size.?)))
 (let ((?x7834 (I pmemlog!logimpl_v.header_head_offset.?)))
 (let ((?x1876 (UINT 8)))
 (let ((?x7837 (pmemlog!logimpl_v.spec_bytes_to_metadata.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7834 ?x7835))))
 (let ((?x7841 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x7837))))
 (let ((?x7830 (Add pmemlog!logimpl_v.header_crc_offset.? 8)))
 (let ((?x7831 (I ?x7830)))
 (let ((?x7829 (I pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x7833 (vstd!bytes.spec_u64_from_le_bytes.? (vstd!seq.Seq.subrange.? $ ?x1876 header_seq! ?x7829 ?x7831))))
 (let ((?x7828 (pmemlog!logimpl_v.spec_bytes_to_header.? header_seq!)))
 (let (($x7843 (= ?x7828 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader (%I (I ?x7833)) ?x7841))))
 (refl (~ $x7843 $x7843))))))))))))))
 ))
 (let ((@x12431 (monotonicity (refl (~ $x7848 $x7848)) (nnf-pos (proof-bind ?x12426) (~ $x7845 $x7845)) (~ $x7849 $x7849))))
 (let ((@x7852 (mp (asserted (=> $x7827 $x7845)) (rewrite (= (=> $x7827 $x7845) $x7849)) $x7849)))
 (let ((@x12435 (mp (mp~ @x7852 @x12431 $x7849) (rewrite (= $x7849 $x7849)) $x7849)))
 (let (($x45798 (or (not $x7845) $x45835)))
 (let ((@x45839 ((_ quant-inst (vstd!view.View.view.? $slice ?x2028 ?x43930)) $x45798)))
 (let ((@x48264 (symm (unit-resolution @x45839 (unit-resolution @x12435 @x48260 $x7845) $x45835) (= ?x45834 ?x43991))))
 (let ((@x48266 (trans* @x48264 @x48256 (= ?x45834 ?x44277))))
 (let ((@x48335 (monotonicity @x48266 (= ?x45864 ?x44254))))
 (let (($x45865 (= ?x45833 ?x45864)))
 (let ((@x48267 ((_ th-lemma datatype) $x45865)))
 (let ((?x45842 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x45831)))
 (let ((?x45841 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x45831)))
 (let ((?x45840 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x45831)))
 (let ((?x45843 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x45840 ?x45841 ?x45842)))
 (let ((?x45983 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x45843)))
 (let ((?x45984 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x45983)))
 (let ((@x48272 (monotonicity (symm ((_ th-lemma datatype) (= ?x45831 ?x45843)) (= ?x45843 ?x45831)) (= ?x45983 ?x45832))))
 (let ((@x48333 (monotonicity @x48272 (= ?x45984 ?x45833))))
 (let (($x45985 (= ?x45843 ?x45984)))
 (let (($x2729 (forall ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))) :pattern ( (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x) ) :qid internal_pmemlog__logimpl_v__PersistentHeaderMetadata_box_axiom_definition))
 ))
 (let ((?x9913 (lambda ((x pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. x)))
 (let (($x2727 (= x (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x2639))))
 (refl (~ $x2727 $x2727)))))
 ))
 (let ((@x9917 (mp~ (asserted $x2729) (nnf-pos (proof-bind ?x9913) (~ $x2729 $x2729)) $x2729)))
 (let (($x44463 (not $x2729)))
 (let (($x45988 (or $x44463 $x45985)))
 (let ((@x45989 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x45840 ?x45841 ?x45842)) $x45988)))
 (let ((@x48273 (unit-resolution @x45989 @x9917 $x45985)))
 (let (($x45844 (= ?x45831 ?x45843)))
 (let ((@x48268 ((_ th-lemma datatype) $x45844)))
 (let ((?x43968 (%Poly%slice%<u8.>. tmp%5)))
 (let ((?x47025 (Poly%slice%<u8.>. ?x43968)))
 (let ((?x47710 (vstd!view.View.view.? $slice ?x2028 ?x47025)))
 (let ((?x48104 (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x47710)))
 (let (($x48330 (= ?x48104 ?x45831)))
 (let (($x48274 (= ?x47710 ?x45830)))
 (let (($x7320 (= pmemlog!logimpl_v.header_size.? 32)))
 (let (($x7318 (fuel_bool fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x7316 (fuel_bool_default fuel%pmemlog!logimpl_v.header_size.)))
 (let (($x45439 (= $x7318 $x7316)))
 (let ((@x45452 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_size.) (or (not $x30) $x45439)) @x44497 (hypothesis (not $x45439)) false)))
 (let ((@x45465 (lemma @x45452 $x45439)))
 (let ((@x7317 (asserted $x7316)))
 (let ((@x45445 (def-axiom (or (not $x45439) $x7318 (not $x7316)))))
 (let ((@x46702 (unit-resolution (unit-resolution @x45445 @x7317 (or (not $x45439) $x7318)) @x45465 $x7318)))
 (let (($x7323 (not $x7318)))
 (let (($x7324 (or $x7323 $x7320)))
 (let ((@x7327 (mp (asserted (=> $x7318 $x7320)) (rewrite (= (=> $x7318 $x7320) $x7324)) $x7324)))
 (let ((@x46703 (unit-resolution @x7327 @x46702 $x7320)))
 (let ((@x47862 (symm @x46703 (= 32 pmemlog!logimpl_v.header_size.?))))
 (let ((@x47864 (monotonicity @x47862 (= (I 32) ?x7835))))
 (let (($x7277 (= pmemlog!logimpl_v.header_head_offset.? 8)))
 (let (($x7275 (fuel_bool fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x7273 (fuel_bool_default fuel%pmemlog!logimpl_v.header_head_offset.)))
 (let (($x45386 (= $x7275 $x7273)))
 (let ((@x45398 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_head_offset.) (or (not $x30) $x45386)) @x44497 (hypothesis (not $x45386)) false)))
 (let ((@x45411 (lemma @x45398 $x45386)))
 (let ((@x7274 (asserted $x7273)))
 (let ((@x45392 (def-axiom (or (not $x45386) $x7275 (not $x7273)))))
 (let ((@x46711 (unit-resolution (unit-resolution @x45392 @x7274 (or (not $x45386) $x7275)) @x45411 $x7275)))
 (let (($x7280 (not $x7275)))
 (let (($x7281 (or $x7280 $x7277)))
 (let ((@x7284 (mp (asserted (=> $x7275 $x7277)) (rewrite (= (=> $x7275 $x7277) $x7281)) $x7281)))
 (let ((@x46712 (unit-resolution @x7284 @x46711 $x7277)))
 (let ((@x46737 (symm @x46712 (= 8 pmemlog!logimpl_v.header_head_offset.?))))
 (let ((@x47437 (monotonicity @x46737 (= (I 8) ?x7834))))
 (let ((@x48211 (monotonicity @x47437 @x47864 (= (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 (I 8) (I 32)) ?x45830))))
 (let ((?x45927 (I 32)))
 (let ((?x45948 (I 8)))
 (let ((?x46967 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 ?x45948 ?x45927)))
 (let ((?x46966 (vstd!view.View.view.? $slice ?x2028 tmp%5)))
 (let (($x47041 (= ?x46966 ?x46967)))
 (let (($x47042 (not $x47041)))
 (let (($x46997 (has_type tmp%5 ?x2028)))
 (let (($x46998 (not $x46997)))
 (let (($x47045 (or $x46998 $x47042)))
 (let (($x48195 (not $x47045)))
 (let (($x47048 (ens%vstd!slice.slice_subrange. $ ?x1876 ?x43930 8 32 tmp%5)))
 (let (($x47024 (= $x47045 $x47048)))
 (let (($x47023 (not $x47024)))
 (let (($x14961 (forall ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) (out! Poly) )(! (let (($x6225 (ens%vstd!slice.slice_subrange. T&. T& slice! i! j! out!)))
 (let ((?x6202 (I j!)))
 (let ((?x6237 (I i!)))
 (let ((?x6238 (vstd!seq.Seq.subrange.? T&. T& (vstd!view.View.view.? $slice (SLICE T&. T&) slice!) ?x6237 ?x6202)))
 (let ((?x6081 (SLICE T&. T&)))
 (let ((?x6083 (vstd!view.View.view.? $slice ?x6081 out!)))
 (let (($x6240 (= ?x6083 ?x6238)))
 (let (($x6082 (has_type out! ?x6081)))
 (let (($x14814 (not $x6082)))
 (let (($x14945 (or $x14814 (not $x6240))))
 (not (= $x14945 $x6225)))))))))))) :pattern ( (ens%vstd!slice.slice_subrange. T&. T& slice! i! j! out!) ) :qid internal_ens__vstd!slice.slice_subrange._definition))
 ))
 (let (($x6244 (forall ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) (out! Poly) )(! (let ((?x6202 (I j!)))
 (let ((?x6237 (I i!)))
 (let ((?x6238 (vstd!seq.Seq.subrange.? T&. T& (vstd!view.View.view.? $slice (SLICE T&. T&) slice!) ?x6237 ?x6202)))
 (let ((?x6081 (SLICE T&. T&)))
 (let ((?x6083 (vstd!view.View.view.? $slice ?x6081 out!)))
 (let (($x6240 (= ?x6083 ?x6238)))
 (let (($x6082 (has_type out! ?x6081)))
 (let (($x6241 (and $x6082 $x6240)))
 (let (($x6225 (ens%vstd!slice.slice_subrange. T&. T& slice! i! j! out!)))
 (= $x6225 $x6241)))))))))) :pattern ( (ens%vstd!slice.slice_subrange. T&. T& slice! i! j! out!) ) :qid internal_ens__vstd!slice.slice_subrange._definition))
 ))
 (let ((?x14962 (lambda ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) (out! Poly) )(let (($x6225 (ens%vstd!slice.slice_subrange. T&. T& slice! i! j! out!)))
 (let ((?x6202 (I j!)))
 (let ((?x6237 (I i!)))
 (let ((?x6238 (vstd!seq.Seq.subrange.? T&. T& (vstd!view.View.view.? $slice (SLICE T&. T&) slice!) ?x6237 ?x6202)))
 (let ((?x6081 (SLICE T&. T&)))
 (let ((?x6083 (vstd!view.View.view.? $slice ?x6081 out!)))
 (let (($x6240 (= ?x6083 ?x6238)))
 (let (($x6082 (has_type out! ?x6081)))
 (let (($x14814 (not $x6082)))
 (let (($x14945 (or $x14814 (not $x6240))))
 (let (($x14953 (not (= $x14945 $x6225))))
 (let (($x6241 (and $x6082 $x6240)))
 (let (($x6242 (= $x6225 $x6241)))
 (let (($x14956 (= $x6242 $x14953)))
 (let ((@x14951 (monotonicity (rewrite (= $x6241 (not $x14945))) (= $x6242 (= $x6225 (not $x14945))))))
 (trans (trans @x14951 (rewrite (= (= $x6225 (not $x14945)) $x14953)) $x14956) (rewrite (= $x14953 $x14953)) $x14956)))))))))))))))))
 ))
 (let ((?x11681 (lambda ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) (out! Poly) )(let ((?x6202 (I j!)))
 (let ((?x6237 (I i!)))
 (let ((?x6238 (vstd!seq.Seq.subrange.? T&. T& (vstd!view.View.view.? $slice (SLICE T&. T&) slice!) ?x6237 ?x6202)))
 (let ((?x6081 (SLICE T&. T&)))
 (let ((?x6083 (vstd!view.View.view.? $slice ?x6081 out!)))
 (let (($x6240 (= ?x6083 ?x6238)))
 (let (($x6082 (has_type out! ?x6081)))
 (let (($x6241 (and $x6082 $x6240)))
 (let (($x6225 (ens%vstd!slice.slice_subrange. T&. T& slice! i! j! out!)))
 (let (($x6242 (= $x6225 $x6241)))
 (refl (~ $x6242 $x6242)))))))))))))
 ))
 (let ((@x14966 (mp (mp~ (asserted $x6244) (nnf-pos (proof-bind ?x11681) (~ $x6244 $x6244)) $x6244) (quant-intro (proof-bind ?x14962) (= $x6244 $x14961)) $x14961)))
 (let (($x47343 (not $x14961)))
 (let (($x48180 (or $x47343 $x47023)))
 (let ((@x48181 ((_ quant-inst $ (UINT 8) (Poly%slice%<u8.>. bytes!) 8 32 tmp%5) $x48180)))
 (let (($x43966 (ens%vstd!slice.slice_subrange. $ ?x1876 ?x43930 tmp%6 tmp%7 tmp%5)))
 (let (($x47112 (= 32 tmp%7)))
 (let ((?x43960 (uClip SZ pmemlog!logimpl_v.header_size.?)))
 (let (($x47110 (= ?x43960 tmp%7)))
 (let (($x43961 (= tmp%7 ?x43960)))
 (let (($x43993 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeader. ?x43990 ?x43992)))
 (let (($x44036 (not %%location_label%%5)))
 (let (($x43988 (= out! ?x43987)))
 (let (($x44043 (not $x43988)))
 (let (($x43981 (ens%pmemlog!logimpl_v.bytes_to_metadata. metadata_bytes@ tmp%9)))
 (let (($x44052 (not $x43981)))
 (let (($x44053 (or $x44052 $x44043 $x44036 $x43993)))
 (let (($x44071 (not $x44053)))
 (let (($x43978 (req%pmemlog!logimpl_v.bytes_to_metadata. metadata_bytes@)))
 (let (($x44032 (not %%location_label%%4)))
 (let (($x44033 (or $x44032 $x43978)))
 (let (($x44070 (not $x44033)))
 (let (($x44072 (or $x44070 $x44071)))
 (let (($x44073 (not $x44072)))
 (let (($x43976 (= tmp%10 tmp%8)))
 (let (($x44040 (not $x43976)))
 (let (($x43974 (ens%vstd!bytes.u64_from_le_bytes. crc_bytes@ tmp%8)))
 (let (($x44050 (not $x43974)))
 (let (($x44079 (or $x44050 $x44040 $x44073)))
 (let (($x44090 (not $x44079)))
 (let (($x43971 (req%vstd!bytes.u64_from_le_bytes. crc_bytes@)))
 (let (($x44028 (not %%location_label%%3)))
 (let (($x44029 (or $x44028 $x43971)))
 (let (($x44089 (not $x44029)))
 (let (($x44091 (or $x44089 $x44090)))
 (let (($x44092 (not $x44091)))
 (let (($x43969 (= metadata_bytes@ ?x43968)))
 (let (($x44038 (not $x43969)))
 (let (($x44049 (not $x43966)))
 (let (($x44097 (or $x44049 $x44038 $x44092)))
 (let (($x44107 (not $x44097)))
 (let (($x43963 (req%vstd!slice.slice_subrange. $ ?x1876 ?x43930 tmp%6 tmp%7)))
 (let (($x44024 (not %%location_label%%2)))
 (let (($x44025 (or $x44024 $x43963)))
 (let (($x44106 (not $x44025)))
 (let (($x44108 (or $x44106 $x44107)))
 (let (($x44109 (not $x44108)))
 (let (($x44061 (not $x43961)))
 (let ((?x43957 (uClip SZ pmemlog!logimpl_v.header_head_offset.?)))
 (let (($x43958 (= tmp%6 ?x43957)))
 (let (($x44048 (not $x43958)))
 (let ((?x43954 (%Poly%slice%<u8.>. tmp%3)))
 (let (($x43955 (= crc_bytes@ ?x43954)))
 (let (($x44066 (not $x43955)))
 (let ((?x43948 (Poly%slice%<u8.>. tmp%1)))
 (let (($x43952 (ens%vstd!slice.slice_subrange. $ ?x1876 ?x43948 tmp%2 tmp%4 tmp%3)))
 (let (($x44075 (not $x43952)))
 (let (($x44114 (or $x44075 $x44066 $x44048 $x44061 $x44109)))
 (let (($x44124 (not $x44114)))
 (let (($x43949 (req%vstd!slice.slice_subrange. $ ?x1876 ?x43948 tmp%2 tmp%4)))
 (let (($x44020 (not %%location_label%%1)))
 (let (($x44021 (or $x44020 $x43949)))
 (let ((?x46405 (uClip SZ 8)))
 (let (($x46433 (= ?x46405 8)))
 (let ((?x43944 (uClip 64 ?x7830)))
 (let ((?x43945 (uClip SZ ?x43944)))
 (let (($x46286 (= ?x43944 ?x43945)))
 (let (($x47972 (= ?x43945 ?x43944)))
 (let ((?x46299 (uClip 64 8)))
 (let (($x46401 (= ?x43944 ?x46299)))
 (let ((?x46002 (Add 0 8)))
 (let (($x46019 (= ?x46002 8)))
 (let (($x920 (forall ((x Int) (y Int) )(! (= (+ y x (* (- 1) (Add x y))) 0) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x9183 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (refl (~ $x913 $x913))))
 ))
 (let (($x905 (forall ((x Int) (y Int) )(! (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (= ?x901 ?x902))) :pattern ( (Add x y) ) :qid prelude_add))
 ))
 (let ((?x921 (lambda ((x Int) (y Int) )(let (($x913 (= (+ y x (* (- 1) (Add x y))) 0)))
 (let ((?x902 (+ x y)))
 (let ((?x901 (Add x y)))
 (let (($x903 (= ?x901 ?x902)))
 (let ((@x912 (monotonicity (rewrite (= ?x902 (+ y x))) (= $x903 (= ?x901 (+ y x))))))
 (trans @x912 (rewrite (= (= ?x901 (+ y x)) $x913)) (= $x903 $x913))))))))
 ))
 (let ((@x925 (mp (asserted $x905) (quant-intro (proof-bind ?x921) (= $x905 $x920)) $x920)))
 (let ((@x9187 (mp~ @x925 (nnf-pos (proof-bind ?x9183) (~ $x920 $x920)) $x920)))
 (let (($x45655 (not $x920)))
 (let (($x46024 (or $x45655 $x46019)))
 (let ((?x46003 (* (- 1) ?x46002)))
 (let ((?x46011 (+ 8 0 ?x46003)))
 (let (($x46012 (= ?x46011 0)))
 (let (($x46025 (or $x45655 $x46012)))
 (let (($x46027 (= $x46025 $x46024)))
 (let ((@x46018 (monotonicity (rewrite (= ?x46011 (+ 8 ?x46003))) (= $x46012 (= (+ 8 ?x46003) 0)))))
 (let ((@x46023 (trans @x46018 (rewrite (= (= (+ 8 ?x46003) 0) $x46019)) (= $x46012 $x46019))))
 (let ((@x46032 (mp ((_ quant-inst 0 8) $x46025) (trans (monotonicity @x46023 $x46027) (rewrite (= $x46024 $x46024)) $x46027) $x46024)))
 (let ((@x46726 (unit-resolution @x46032 @x9187 $x46019)))
 (let (($x7263 (= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x7261 (fuel_bool fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x7259 (fuel_bool_default fuel%pmemlog!logimpl_v.header_crc_offset.)))
 (let (($x45369 (= $x7261 $x7259)))
 (let ((@x45381 (unit-resolution ((_ quant-inst fuel%pmemlog!logimpl_v.header_crc_offset.) (or (not $x30) $x45369)) @x44497 (hypothesis (not $x45369)) false)))
 (let ((@x45394 (lemma @x45381 $x45369)))
 (let ((@x7260 (asserted $x7259)))
 (let ((@x45375 (def-axiom (or (not $x45369) $x7261 (not $x7259)))))
 (let ((@x46729 (unit-resolution (unit-resolution @x45375 @x7260 (or (not $x45369) $x7261)) @x45394 $x7261)))
 (let (($x7266 (not $x7261)))
 (let (($x7267 (or $x7266 $x7263)))
 (let ((@x7270 (mp (asserted (=> $x7261 $x7263)) (rewrite (= (=> $x7261 $x7263) $x7267)) $x7267)))
 (let ((@x46730 (unit-resolution @x7270 @x46729 $x7263)))
 (let ((@x46732 (monotonicity @x46730 (= ?x7830 ?x46002))))
 (let ((@x46735 (monotonicity (trans* @x46732 @x46726 (= ?x7830 8)) $x46401)))
 (let ((@x47980 (symm @x46735 (= ?x46299 ?x43944))))
 (let (($x46327 (= 8 ?x46299)))
 (let (($x46357 (= ?x46299 8)))
 (let ((?x441 (uHi 64)))
 (let (($x46354 (<= ?x441 8)))
 (let (($x46363 (or $x46354 $x46357)))
 (let (($x46368 (not $x46363)))
 (let ((?x46338 (* (- 1) ?x46299)))
 (let ((?x46339 (+ ?x441 ?x46338)))
 (let (($x46340 (<= ?x46339 0)))
 (let (($x46301 (>= ?x46299 0)))
 (let (($x46320 (not $x46301)))
 (let (($x46370 (or $x46320 $x46340 $x46368)))
 (let (($x46377 (not $x46370)))
 (let (($x12812 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12796 (or $x540 $x578 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (not (or (not (>= ?x543 0)) $x564 (not $x12796)))))))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let (($x586 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (and $x558 $x569 $x587)))))))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let ((?x12813 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12796 (or $x540 $x578 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x12807 (not (or (not (>= ?x543 0)) $x564 (not $x12796)))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (let ((@x12785 (rewrite (= $x584 (not (or $x540 $x578))))))
 (let ((@x12792 (trans (monotonicity @x12785 (= $x581 (not (not (or $x540 $x578))))) (rewrite (= (not (not (or $x540 $x578))) (or $x540 $x578))) (= $x581 (or $x540 $x578)))))
 (let ((@x12800 (trans (monotonicity @x12792 (= $x587 (or (or $x540 $x578) $x550))) (rewrite (= (or (or $x540 $x578) $x550) $x12796)) (= $x587 $x12796))))
 (trans (monotonicity @x12800 (= $x593 (and $x558 $x569 $x12796))) (rewrite (= (and $x558 $x569 $x12796) $x12807)) (= $x593 $x12807))))))))))))))))))))
 ))
 (let ((?x9043 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (refl (~ $x593 $x593)))))))))))))
 ))
 (let (($x554 (forall ((bits Int) (i Int) )(! (let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (and (<= 0 ?x543) (< ?x543 (uHi bits)) (=> $x548 $x550)))))) :pattern ( (uClip bits i) ) :qid prelude_u_clip))
 ))
 (let ((?x588 (lambda ((bits Int) (i Int) )(let ((?x543 (uClip bits i)))
 (let (($x550 (= i ?x543)))
 (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x581 (not $x584)))
 (let (($x587 (or $x581 $x550)))
 (let (($x564 (>= (+ ?x543 (* (- 1) (uHi bits))) 0)))
 (let (($x569 (not $x564)))
 (let (($x558 (>= ?x543 0)))
 (let (($x593 (and $x558 $x569 $x587)))
 (let (($x552 (and (<= 0 ?x543) (< ?x543 (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) $x550))))
 (rewrite (= $x552 $x593))))))))))))))
 ))
 (let ((@x571 (mp (asserted $x554) (quant-intro (proof-bind ?x588) (= $x554 $x586)) $x586)))
 (let ((@x12817 (mp (mp~ @x571 (nnf-pos (proof-bind ?x9043) (~ $x586 $x586)) $x586) (quant-intro (proof-bind ?x12813) (= $x586 $x12812)) $x12812)))
 (let (($x44432 (not $x12812)))
 (let (($x46369 (or $x44432 $x46377)))
 (let (($x46326 (>= (+ 8 (* (- 1) ?x441)) 0)))
 (let (($x46323 (>= 8 0)))
 (let (($x46324 (not $x46323)))
 (let (($x46328 (or $x46324 $x46326 $x46327)))
 (let ((?x43215 (* (- 1) ?x441)))
 (let ((?x46321 (+ ?x46299 ?x43215)))
 (let (($x46322 (>= ?x46321 0)))
 (let (($x46331 (not (or $x46320 $x46322 (not $x46328)))))
 (let (($x46371 (or $x44432 $x46331)))
 (let (($x46373 (= $x46371 $x46369)))
 (let ((@x46379 (trans (monotonicity (rewrite (= $x46331 $x46377)) $x46373) (rewrite (= $x46369 $x46369)) $x46373)))
 (let ((@x46381 (mp ((_ quant-inst 64 8) $x46371) @x46379 $x46369)))
 (let ((@x46398 (def-axiom (or $x46370 $x46363))))
 (let (($x46384 (not $x46354)))
 (let (($x43924 (>= ?x441 18446744073709551616)))
 (let (($x443 (= ?x441 18446744073709551616)))
 (let ((@x444 (asserted $x443)))
 (let ((@x46719 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x443) $x43924)) @x444 $x43924)))
 (let ((@x46720 (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x46384 (not $x43924))) @x46719 $x46384)))
 (let ((@x46391 (def-axiom (or $x46368 $x46354 $x46357))))
 (let ((@x46725 (unit-resolution (unit-resolution @x46391 @x46720 (or $x46368 $x46357)) (unit-resolution @x46398 (unit-resolution @x46381 @x12817 $x46377) $x46363) $x46357)))
 (let ((@x47977 (symm @x46725 $x46327)))
 (let ((@x46757 (monotonicity (trans* @x46735 @x46725 @x46737 (= ?x43944 pmemlog!logimpl_v.header_head_offset.?)) (= ?x43945 ?x43957))))
 (let ((@x46764 (symm @x46757 (= ?x43957 ?x43945))))
 (let ((@x47986 (monotonicity (trans* (monotonicity @x46737 (= ?x46405 ?x43957)) @x46764 (= ?x46405 ?x43945)) (trans* @x47977 @x47980 (= 8 ?x43944)) (= $x46433 $x47972))))
 (let ((@x47994 (symm (trans @x47986 (commutativity (= $x47972 $x46286)) (= $x46433 $x46286)) (= $x46286 $x46433))))
 (let ((@x47764 (trans* @x46712 (symm @x46726 (= 8 ?x46002)) (symm @x46732 (= ?x46002 ?x7830)) (= pmemlog!logimpl_v.header_head_offset.? ?x7830))))
 (let (($x424 (= SZ 64)))
 (let (($x422 (= SZ 32)))
 (let (($x47133 (not $x422)))
 (let ((?x46668 (uClip 32 32)))
 (let (($x46848 (= ?x46668 32)))
 (let ((?x437 (uHi 32)))
 (let (($x46845 (<= ?x437 32)))
 (let (($x46853 (or $x46845 $x46848)))
 (let (($x46592 (not $x46853)))
 (let (($x46833 (<= (+ ?x437 (* (- 1) ?x46668)) 0)))
 (let (($x46669 (>= ?x46668 0)))
 (let (($x46812 (not $x46669)))
 (let (($x46809 (or $x46812 $x46833 $x46592)))
 (let (($x46875 (not $x46809)))
 (let (($x46582 (or $x44432 $x46875)))
 (let (($x46820 (= 32 ?x46668)))
 (let (($x46819 (>= (+ 32 (* (- 1) ?x437)) 0)))
 (let (($x46816 (>= 32 0)))
 (let (($x46817 (not $x46816)))
 (let (($x46821 (or $x46817 $x46819 $x46820)))
 (let ((?x46813 (* (- 1) ?x437)))
 (let ((?x46814 (+ ?x46668 ?x46813)))
 (let (($x46815 (>= ?x46814 0)))
 (let (($x46824 (not (or $x46812 $x46815 (not $x46821)))))
 (let (($x46810 (or $x44432 $x46824)))
 (let (($x46598 (= $x46810 $x46582)))
 (let ((@x46877 (trans (monotonicity (rewrite (= $x46824 $x46875)) $x46598) (rewrite (= $x46582 $x46582)) $x46598)))
 (let ((@x47033 (unit-resolution (def-axiom (or $x46809 $x46853)) (unit-resolution (mp ((_ quant-inst 32 32) $x46810) @x46877 $x46582) @x12817 $x46875) $x46853)))
 (let (($x46881 (not $x46845)))
 (let (($x46864 (>= ?x437 4294967296)))
 (let (($x439 (= ?x437 4294967296)))
 (let ((@x440 (asserted $x439)))
 (let ((@x47059 (unit-resolution ((_ th-lemma arith farkas 1 1) (or (not $x46864) $x46881)) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x439) $x46864)) @x440 $x46864) $x46881)))
 (let ((@x47060 (unit-resolution (def-axiom (or $x46592 $x46845 $x46848)) @x47059 @x47033 $x46848)))
 (let ((@x47061 (hypothesis $x422)))
 (let ((@x47106 (monotonicity @x47061 @x46703 (= ?x43960 ?x46668))))
 (let ((@x47879 (monotonicity (trans* @x47106 @x47060 @x47862 (= ?x43960 pmemlog!logimpl_v.header_size.?)) (= (I ?x43960) ?x7835))))
 (let ((@x47902 (monotonicity @x47437 @x47879 (= (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 ?x45948 (I ?x43960)) ?x45830))))
 (let ((?x46865 (I ?x43960)))
 (let ((?x46995 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 ?x45948 ?x46865)))
 (let (($x47137 (= ?x46966 ?x46995)))
 (let (($x47159 (or $x46998 (not $x47137))))
 (let (($x47358 (not $x47159)))
 (let (($x47157 (ens%vstd!slice.slice_subrange. $ ?x1876 ?x43930 8 ?x43960 tmp%5)))
 (let (($x47160 (= $x47159 $x47157)))
 (let (($x47161 (not $x47160)))
 (let ((?x43938 (uClip SZ pmemlog!logimpl_v.header_crc_offset.?)))
 (let (($x44425 (= pmemlog!logimpl_v.header_crc_offset.? ?x43938)))
 (let ((?x44419 (uHi SZ)))
 (let ((?x44420 (* (- 1) ?x44419)))
 (let ((?x44423 (+ pmemlog!logimpl_v.header_crc_offset.? ?x44420)))
 (let (($x44424 (>= ?x44423 0)))
 (let (($x44443 (not $x44424)))
 (let (($x45385 (>= ?x44419 4294967296)))
 (let ((@x47068 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x44419 4294967296)) $x45385)) (trans* (monotonicity @x47061 (= ?x44419 ?x437)) @x440 (= ?x44419 4294967296)) $x45385)))
 (let (($x45380 (<= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let ((@x47076 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7263) $x45380)) @x46730 $x45380)))
 (let ((@x47078 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x44443 (not $x45380) (not $x45385))) @x47076 (or $x44443 (not $x45385)))))
 (let (($x43563 (>= pmemlog!logimpl_v.header_crc_offset.? 0)))
 (let (($x43564 (not $x43563)))
 (let (($x44426 (or $x43564 $x44424 $x44425)))
 (let (($x44427 (not $x44426)))
 (let ((?x44421 (+ ?x43938 ?x44420)))
 (let (($x44422 (>= ?x44421 0)))
 (let (($x44414 (>= ?x43938 0)))
 (let (($x44415 (not $x44414)))
 (let (($x44428 (or $x44415 $x44422 $x44427)))
 (let (($x44429 (not $x44428)))
 (let (($x44434 (or $x44432 $x44429)))
 (let ((@x44433 ((_ quant-inst SZ pmemlog!logimpl_v.header_crc_offset.?) $x44434)))
 (let ((@x44457 (def-axiom (or $x44428 $x44426))))
 (let ((?x43576 (* (- 1) pmemlog!logimpl_v.header_crc_offset.?)))
 (let ((?x43577 (+ ?x441 ?x43576)))
 (let (($x43578 (<= ?x43577 0)))
 (let (($x43583 (or $x43564 $x43578)))
 (let (($x43609 (not $x43583)))
 (let (($x7271 (uInv 64 pmemlog!logimpl_v.header_crc_offset.?)))
 (let (($x43585 (= $x43583 $x7271)))
 (let (($x43588 (not $x43585)))
 (let (($x12907 (forall ((bits Int) (i Int) )(! (let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12782 (or $x540 $x578)))
 (not (= $x12782 $x648))))))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let (($x669 (forall ((bits Int) (i Int) )(! (let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x584)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x12908 (lambda ((bits Int) (i Int) )(let (($x648 (uInv bits i)))
 (let (($x578 (>= (+ i (* (- 1) (uHi bits))) 0)))
 (let (($x536 (>= i 0)))
 (let (($x540 (not $x536)))
 (let (($x12782 (or $x540 $x578)))
 (let (($x12899 (not (= $x12782 $x648))))
 (let (($x584 (and $x536 (not $x578))))
 (let (($x667 (= $x648 $x584)))
 (let (($x12902 (= $x667 $x12899)))
 (let ((@x12785 (rewrite (= $x584 (not $x12782)))))
 (let ((@x12903 (trans (monotonicity @x12785 (= $x667 (= $x648 (not $x12782)))) (rewrite (= (= $x648 (not $x12782)) $x12899)) $x12902)))
 (trans @x12903 (rewrite (= $x12899 $x12899)) $x12902)))))))))))))
 ))
 (let ((?x9064 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (refl (~ $x667 $x667)))))))
 ))
 (let (($x660 (forall ((bits Int) (i Int) )(! (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x648 (uInv bits i)))
 (= $x648 $x548)))) :pattern ( (uInv bits i) ) :qid prelude_u_inv))
 ))
 (let ((?x674 (lambda ((bits Int) (i Int) )(let (($x536 (>= i 0)))
 (let (($x584 (and $x536 (not (>= (+ i (* (- 1) (uHi bits))) 0)))))
 (let (($x648 (uInv bits i)))
 (let (($x667 (= $x648 $x584)))
 (let (($x524 (<= 0 i)))
 (let (($x548 (and $x524 (< i (uHi bits)))))
 (let (($x658 (= $x648 $x548)))
 (rewrite (= $x658 $x667))))))))))
 ))
 (let ((@x640 (mp (asserted $x660) (quant-intro (proof-bind ?x674) (= $x660 $x669)) $x669)))
 (let ((@x12912 (mp (mp~ @x640 (nnf-pos (proof-bind ?x9064) (~ $x669 $x669)) $x669) (quant-intro (proof-bind ?x12908) (= $x669 $x12907)) $x12907)))
 (let (($x43246 (not $x12907)))
 (let (($x43595 (or $x43246 $x43588)))
 (let ((?x43565 (+ pmemlog!logimpl_v.header_crc_offset.? ?x43215)))
 (let (($x43566 (>= ?x43565 0)))
 (let (($x43567 (or $x43564 $x43566)))
 (let (($x43568 (= $x43567 $x7271)))
 (let (($x43569 (not $x43568)))
 (let (($x43596 (or $x43246 $x43569)))
 (let (($x43598 (= $x43596 $x43595)))
 (let (($x43590 (= $x43569 $x43588)))
 (let ((@x43594 (trans (monotonicity (rewrite (= $x43568 $x43585)) $x43590) (rewrite (= $x43588 $x43588)) $x43590)))
 (let ((@x43603 (mp ((_ quant-inst 64 pmemlog!logimpl_v.header_crc_offset.?) $x43596) (trans (monotonicity @x43594 $x43598) (rewrite (= $x43595 $x43595)) $x43598) $x43595)))
 (let ((@x7272 (asserted $x7271)))
 (let ((@x43620 (def-axiom (or $x43585 $x43609 (not $x7271)))))
 (let ((@x47083 (unit-resolution (unit-resolution @x43620 @x7272 (or $x43585 $x43609)) (unit-resolution @x43603 @x12912 $x43588) $x43609)))
 (let ((@x43605 (def-axiom (or $x43583 $x43563))))
 (let ((@x44450 (def-axiom (or $x44427 $x43564 $x44424 $x44425))))
 (let ((@x47086 (unit-resolution @x44450 (unit-resolution @x43605 @x47083 $x43563) (or $x44427 $x44424 $x44425))))
 (let ((@x47090 (unit-resolution @x47086 (unit-resolution @x44457 (unit-resolution @x44433 @x12817 $x44429) $x44426) (or $x44424 $x44425))))
 (let ((@x47091 (unit-resolution @x47090 (unit-resolution @x47078 @x47068 $x44443) $x44425)))
 (let (($x46430 (<= ?x44419 8)))
 (let (($x46460 (not $x46430)))
 (let (($x46439 (or $x46430 $x46433)))
 (let (($x46444 (not $x46439)))
 (let ((?x46423 (* (- 1) ?x46405)))
 (let ((?x46424 (+ ?x44419 ?x46423)))
 (let (($x46425 (<= ?x46424 0)))
 (let (($x46406 (>= ?x46405 0)))
 (let (($x46407 (not $x46406)))
 (let (($x46446 (or $x46407 $x46425 $x46444)))
 (let (($x46453 (not $x46446)))
 (let (($x46445 (or $x44432 $x46453)))
 (let ((?x46408 (+ ?x46405 ?x44420)))
 (let (($x46409 (>= ?x46408 0)))
 (let (($x46415 (or $x46407 $x46409 (not (or $x46324 (>= (+ 8 ?x44420) 0) (= 8 ?x46405))))))
 (let (($x46416 (not $x46415)))
 (let (($x46447 (or $x44432 $x46416)))
 (let (($x46449 (= $x46447 $x46445)))
 (let ((@x46455 (trans (monotonicity (rewrite (= $x46416 $x46453)) $x46449) (rewrite (= $x46445 $x46445)) $x46449)))
 (let ((@x46457 (mp ((_ quant-inst SZ 8) $x46447) @x46455 $x46445)))
 (let ((@x46474 (def-axiom (or $x46446 $x46439))))
 (let ((@x46467 (def-axiom (or $x46444 $x46430 $x46433))))
 (let ((@x47097 (unit-resolution @x46467 (unit-resolution @x46474 (unit-resolution @x46457 @x12817 $x46453) $x46439) $x46439)))
 (let ((@x47098 (unit-resolution @x47097 (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x46460 (not $x45385))) @x47068 $x46460) $x46433)))
 (let (($x46599 (req%vstd!slice.slice_subrange. $ ?x1876 ?x43930 0 8)))
 (let (($x46666 (not $x46599)))
 (let (($x46767 (= 8 tmp%4)))
 (let (($x43946 (= tmp%4 ?x43945)))
 (let (($x44123 (not $x44021)))
 (let (($x44125 (or $x44123 $x44124)))
 (let (($x44126 (not $x44125)))
 (let (($x44062 (not $x43946)))
 (let (($x43941 (uInv 64 ?x7830)))
 (let (($x44047 (not $x43941)))
 (let (($x44131 (or $x44047 $x44062 $x44126)))
 (let (($x44138 (not $x44131)))
 (let (($x44016 (not %%location_label%%0)))
 (let (($x44017 (or $x44016 $x43941)))
 (let (($x6593 (= pmemlog!pmemspec_t.crc_size.? 8)))
 (let (($x6591 (fuel_bool fuel%pmemlog!pmemspec_t.crc_size.)))
 (let (($x6589 (fuel_bool_default fuel%pmemlog!pmemspec_t.crc_size.)))
 (let (($x44990 (= $x6591 $x6589)))
 (let ((@x45002 (unit-resolution ((_ quant-inst fuel%pmemlog!pmemspec_t.crc_size.) (or (not $x30) $x44990)) @x44497 (hypothesis (not $x44990)) false)))
 (let ((@x45015 (lemma @x45002 $x44990)))
 (let ((@x6590 (asserted $x6589)))
 (let ((@x44996 (def-axiom (or (not $x44990) $x6591 (not $x6589)))))
 (let ((@x46742 (unit-resolution (unit-resolution @x44996 @x6590 (or (not $x44990) $x6591)) @x45015 $x6591)))
 (let (($x6596 (not $x6591)))
 (let (($x6597 (or $x6596 $x6593)))
 (let ((@x6600 (mp (asserted (=> $x6591 $x6593)) (rewrite (= (=> $x6591 $x6593) $x6597)) $x6597)))
 (let ((@x46745 (symm (unit-resolution @x6600 @x46742 $x6593) (= 8 pmemlog!pmemspec_t.crc_size.?))))
 (let ((@x46749 (monotonicity (trans* @x46732 @x46726 @x46745 (= ?x7830 pmemlog!pmemspec_t.crc_size.?)) (= $x43941 (uInv 64 pmemlog!pmemspec_t.crc_size.?)))))
 (let (($x6601 (uInv 64 pmemlog!pmemspec_t.crc_size.?)))
 (let ((@x6602 (asserted $x6601)))
 (let ((@x44284 (def-axiom (or $x44017 $x44047))))
 (let (($x44137 (not $x44017)))
 (let (($x44139 (or $x44137 $x44138)))
 (let (($x44159 (not (or $x44070 (not (or (or $x44052 $x44043) (or $x44036 $x43993)))))))
 (let (($x44166 (or $x44050 $x44040)))
 (let (($x44167 (or $x44166 $x44159)))
 (let (($x44173 (not (or $x44089 (not $x44167)))))
 (let (($x44180 (or $x44049 $x44038)))
 (let (($x44181 (or $x44180 $x44173)))
 (let (($x44187 (not (or $x44106 (not $x44181)))))
 (let (($x44195 (or $x44048 $x44061)))
 (let (($x44194 (or $x44075 $x44066)))
 (let (($x44196 (or $x44194 $x44195)))
 (let (($x44197 (or $x44196 $x44187)))
 (let (($x44203 (not (or $x44123 (not $x44197)))))
 (let (($x44210 (or $x44047 $x44062)))
 (let (($x44211 (or $x44210 $x44203)))
 (let (($x44218 (or $x44137 (not $x44211))))
 (let (($x44076 (or $x44075 $x44066 $x44048 $x44061 (and $x44025 (or $x44049 $x44038 (and $x44029 (or $x44050 $x44040 (and $x44033 $x44053))))))))
 (let (($x44081 (and $x44021 $x44076)))
 (let (($x44055 (or $x44047 $x44062 $x44081)))
 (let (($x44027 (and $x44017 $x44055)))
 (let (($x44084 (not $x44027)))
 (let ((@x44144 (trans (monotonicity (rewrite (= $x44055 $x44131)) (= $x44027 (and $x44017 $x44131))) (rewrite (= (and $x44017 $x44131) (not $x44139))) (= $x44027 (not $x44139)))))
 (let ((@x44151 (trans (monotonicity @x44144 (= $x44084 (not (not $x44139)))) (rewrite (= (not (not $x44139)) $x44139)) (= $x44084 $x44139))))
 (let ((@x44057 (monotonicity (monotonicity (rewrite (= $x44081 $x44081)) (= $x44055 $x44055)) (= $x44027 $x44027))))
 (let (($x44019 (not (or (not (= tmp%1 bytes!)) (not (= tmp%2 ?x43938)) $x44027))))
 (let (($x43997 (and (=> %%location_label%%4 $x43978) (=> (and $x43981 $x43988 %%location_label%%5) $x43993))))
 (let (($x44001 (=> $x43969 (and (=> %%location_label%%3 $x43971) (=> (and $x43974 $x43976) $x43997)))))
 (let (($x44005 (=> (and $x43958 $x43961) (and (=> %%location_label%%2 $x43963) (=> (and $x43966 $x43969) (and (=> %%location_label%%3 $x43971) (=> (and $x43974 $x43976) $x43997)))))))
 (let (($x44009 (=> $x43946 (and (=> %%location_label%%1 $x43949) (=> (and $x43952 $x43955 $x43958 $x43961) (and (=> %%location_label%%2 $x43963) (=> (and $x43966 $x43969) (and (=> %%location_label%%3 $x43971) (=> (and $x43974 $x43976) $x43997)))))))))
 (let (($x43939 (= tmp%2 ?x43938)))
 (let (($x43936 (= tmp%1 bytes!)))
 (let (($x44013 (=> (and $x43936 $x43939) (and (=> %%location_label%%0 $x43941) (=> (and $x43941 $x43946) (and (=> %%location_label%%1 $x43949) (=> (and $x43952 $x43955 $x43958 $x43961) (and (=> %%location_label%%2 $x43963) (=> (and $x43966 $x43969) (and (=> %%location_label%%3 $x43971) (=> (and $x43974 $x43976) $x43997)))))))))))
 (let (($x44014 (not $x44013)))
 (let ((@x44063 (mp (asserted $x44014) (rewrite (= $x44014 $x44019)) $x44019)))
 (let ((@x44152 (mp (mp (not-or-elim @x44063 $x44084) (monotonicity @x44057 (= $x44084 $x44084)) $x44084) @x44151 $x44139)))
 (let ((@x44271 (mp (mp @x44152 (rewrite (= $x44139 $x44218)) $x44218) (rewrite (= $x44218 $x44139)) $x44139)))
 (let ((@x46754 (unit-resolution @x44271 (unit-resolution @x44284 (mp @x6602 (symm @x46749 (= $x6601 $x43941)) $x43941) $x44017) $x44138)))
 (let ((@x44378 (def-axiom (or $x44131 $x43946))))
 (let ((@x46766 (symm (unit-resolution @x44378 @x46754 $x43946) (= ?x43945 tmp%4))))
 (let (($x46761 (= ?x46405 ?x43957)))
 (let ((@x46762 (symm (monotonicity @x46712 (= ?x43957 ?x46405)) $x46761)))
 (let (($x46774 (= 0 tmp%2)))
 (let ((@x44082 (not-or-elim @x44063 $x43939)))
 (let ((@x44386 (symm @x44082 (= ?x43938 tmp%2))))
 (let ((@x46773 (symm @x46730 (= 0 pmemlog!logimpl_v.header_crc_offset.?))))
 (let ((@x46779 (symm (monotonicity (not-or-elim @x44063 $x43936) (= ?x43948 ?x43930)) (= ?x43930 ?x43948))))
 (let ((@x46781 (monotonicity @x46779 (trans* @x46773 (hypothesis $x44425) @x44386 $x46774) (trans* (symm (hypothesis $x46433) (= 8 ?x46405)) @x46762 @x46764 @x46766 $x46767) (= $x46599 $x43949))))
 (let ((@x46786 (mp (hypothesis (not $x43949)) (monotonicity (symm @x46781 (= $x43949 $x46599)) (= (not $x43949) $x46666)) $x46666)))
 (let ((?x43932 (vstd!seq.Seq.len.? $ ?x1876 ?x43931)))
 (let (($x46660 (>= ?x43932 8)))
 (let (($x6247 (not %%global_location_label%%8)))
 (let (($x46657 (or $x6247 $x46660)))
 (let (($x46618 (= $x46599 $x46657)))
 (let (($x14937 (forall ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) )(! (let ((?x5488 (SLICE T&. T&)))
 (let ((?x5489 (vstd!view.View.view.? $slice ?x5488 slice!)))
 (let ((?x6216 (vstd!seq.Seq.len.? T&. T& ?x5489)))
 (let (($x6232 (<= (+ j! (* (- 1) ?x6216)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x12937 (not $x1122)))
 (let (($x6247 (not %%global_location_label%%8)))
 (let (($x14936 (or $x6247 (not (or $x12937 (not (>= (+ j! (* (- 1) i!)) 0)) (not $x6232))))))
 (let (($x6212 (req%vstd!slice.slice_subrange. T&. T& slice! i! j!)))
 (= $x6212 $x14936)))))))))) :pattern ( (req%vstd!slice.slice_subrange. T&. T& slice! i! j!) ) :qid internal_req__vstd!slice.slice_subrange._definition))
 ))
 (let (($x6230 (forall ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) )(! (let ((?x5488 (SLICE T&. T&)))
 (let ((?x5489 (vstd!view.View.view.? $slice ?x5488 slice!)))
 (let ((?x6216 (vstd!seq.Seq.len.? T&. T& ?x5489)))
 (let (($x6232 (<= (+ j! (* (- 1) ?x6216)) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x6247 (not %%global_location_label%%8)))
 (let (($x6212 (req%vstd!slice.slice_subrange. T&. T& slice! i! j!)))
 (= $x6212 (or $x6247 (and $x1122 $x6227 $x6232))))))))))) :pattern ( (req%vstd!slice.slice_subrange. T&. T& slice! i! j!) ) :qid internal_req__vstd!slice.slice_subrange._definition))
 ))
 (let ((?x14939 (lambda ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) )(let ((?x5488 (SLICE T&. T&)))
 (let ((?x5489 (vstd!view.View.view.? $slice ?x5488 slice!)))
 (let ((?x6216 (vstd!seq.Seq.len.? T&. T& ?x5489)))
 (let (($x6232 (<= (+ j! (* (- 1) ?x6216)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x12937 (not $x1122)))
 (let (($x6247 (not %%global_location_label%%8)))
 (let (($x14936 (or $x6247 (not (or $x12937 (not (>= (+ j! (* (- 1) i!)) 0)) (not $x6232))))))
 (let (($x6212 (req%vstd!slice.slice_subrange. T&. T& slice! i! j!)))
 (let (($x14934 (= $x6212 $x14936)))
 (let (($x6253 (= $x6212 (or $x6247 (and $x1122 (>= (+ j! (* (- 1) i!)) 0) $x6232)))))
 (rewrite (= $x6253 $x14934))))))))))))))
 ))
 (let ((?x11674 (lambda ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) )(let ((?x5488 (SLICE T&. T&)))
 (let ((?x5489 (vstd!view.View.view.? $slice ?x5488 slice!)))
 (let ((?x6216 (vstd!seq.Seq.len.? T&. T& ?x5489)))
 (let (($x6232 (<= (+ j! (* (- 1) ?x6216)) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x6247 (not %%global_location_label%%8)))
 (let (($x6212 (req%vstd!slice.slice_subrange. T&. T& slice! i! j!)))
 (let (($x6253 (= $x6212 (or $x6247 (and $x1122 $x6227 $x6232)))))
 (refl (~ $x6253 $x6253))))))))))))
 ))
 (let (($x6222 (forall ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) )(! (let ((?x5488 (SLICE T&. T&)))
 (let ((?x5489 (vstd!view.View.view.? $slice ?x5488 slice!)))
 (let ((?x6216 (vstd!seq.Seq.len.? T&. T& ?x5489)))
 (let (($x6219 (=> %%global_location_label%%8 (and (and (<= 0 i!) (<= i! j!)) (<= j! ?x6216)))))
 (let (($x6212 (req%vstd!slice.slice_subrange. T&. T& slice! i! j!)))
 (= $x6212 $x6219)))))) :pattern ( (req%vstd!slice.slice_subrange. T&. T& slice! i! j!) ) :qid internal_req__vstd!slice.slice_subrange._definition))
 ))
 (let ((?x6231 (lambda ((T&. Dcr) (T& Type) (slice! Poly) (i! Int) (j! Int) )(let ((?x5488 (SLICE T&. T&)))
 (let ((?x5489 (vstd!view.View.view.? $slice ?x5488 slice!)))
 (let ((?x6216 (vstd!seq.Seq.len.? T&. T& ?x5489)))
 (let (($x6232 (<= (+ j! (* (- 1) ?x6216)) 0)))
 (let (($x6227 (>= (+ j! (* (- 1) i!)) 0)))
 (let (($x1122 (>= i! 0)))
 (let (($x6247 (not %%global_location_label%%8)))
 (let (($x6212 (req%vstd!slice.slice_subrange. T&. T& slice! i! j!)))
 (let (($x6253 (= $x6212 (or $x6247 (and $x1122 $x6227 $x6232)))))
 (let (($x6219 (=> %%global_location_label%%8 (and (and (<= 0 i!) (<= i! j!)) (<= j! ?x6216)))))
 (let (($x6220 (= $x6212 $x6219)))
 (rewrite (= $x6220 $x6253))))))))))))))
 ))
 (let ((@x6224 (mp (asserted $x6222) (quant-intro (proof-bind ?x6231) (= $x6222 $x6230)) $x6230)))
 (let ((@x14943 (mp (mp~ @x6224 (nnf-pos (proof-bind ?x11674) (~ $x6230 $x6230)) $x6230) (quant-intro (proof-bind ?x14939) (= $x6230 $x14937)) $x14937)))
 (let (($x46659 (not $x14937)))
 (let (($x46664 (or $x46659 $x46618)))
 (let (($x46613 (>= 0 0)))
 (let (($x46625 (not $x46613)))
 (let (($x46633 (or $x46625 (not (>= (+ 8 (* (- 1) 0)) 0)) (not (<= (+ 8 (* (- 1) ?x43932)) 0)))))
 (let (($x46636 (= $x46599 (or $x6247 (not $x46633)))))
 (let (($x46674 (or $x46659 $x46636)))
 (let (($x46656 (= $x46674 $x46664)))
 (let ((@x46682 (trans (monotonicity (rewrite (= $x46636 $x46618)) $x46656) (rewrite (= $x46664 $x46664)) $x46656)))
 (let ((?x44482 (* (- 1) ?x43932)))
 (let ((?x44490 (+ pmemlog!logimpl_v.header_size.? ?x44482)))
 (let (($x44491 (<= ?x44490 0)))
 (let (($x44481 (= pmemlog!logimpl_v.header_size.? ?x43932)))
 (let (($x43933 (= ?x43932 pmemlog!logimpl_v.header_size.?)))
 (let ((@x43934 (asserted $x43933)))
 (let ((@x46696 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x44481) $x44491)) (symm @x43934 $x44481) $x44491)))
 (let (($x45441 (>= pmemlog!logimpl_v.header_size.? 32)))
 (let ((@x46704 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x7320) $x45441)) @x46703 $x45441)))
 (let ((@x46706 (lemma ((_ th-lemma arith farkas 1 1 1) @x46704 @x46696 (hypothesis (not $x46660)) false) $x46660)))
 (let ((@x46790 (unit-resolution (def-axiom (or (not $x46618) $x46599 (not $x46657))) (unit-resolution (def-axiom (or $x46657 (not $x46660))) @x46706 $x46657) (or (not $x46618) $x46599))))
 (let ((@x46791 (unit-resolution @x46790 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%slice%<u8.>. bytes!) 0 8) $x46674) @x46682 $x46664) @x14943 $x46618) $x46599)))
 (let ((@x46794 (lemma (unit-resolution @x46791 @x46786 false) (or $x43949 (not $x46433) (not $x44425)))))
 (let ((@x44101 (def-axiom (or $x44021 (not $x43949)))))
 (let ((@x44374 (def-axiom (or $x44126 $x44123 $x44124))))
 (let ((@x47102 (unit-resolution @x44374 (unit-resolution (def-axiom (or $x44131 $x44125)) @x46754 $x44125) $x44125)))
 (let ((@x47103 (unit-resolution @x47102 (unit-resolution @x44101 (unit-resolution @x46794 @x47098 @x47091 $x43949) $x44021) $x44124)))
 (let ((@x44364 (def-axiom (or $x44114 $x43961))))
 (let ((@x47111 (symm (unit-resolution @x44364 @x47103 $x43961) $x47110)))
 (let (($x47118 (= 8 tmp%6)))
 (let (($x47116 (= ?x43957 tmp%6)))
 (let (($x46412 (= 8 ?x46405)))
 (let ((@x47115 (symm @x47098 $x46412)))
 (let ((@x47119 (trans* @x47115 @x46762 (symm (unit-resolution (def-axiom (or $x44114 $x43958)) @x47103 $x43958) $x47116) $x47118)))
 (let (($x46985 (req%vstd!slice.slice_subrange. $ ?x1876 ?x43930 8 32)))
 (let (($x47055 (not $x46985)))
 (let (($x44301 (not $x43963)))
 (let (($x47124 (= $x44301 $x47055)))
 (let (($x47122 (= $x43963 $x46985)))
 (let (($x47120 (= $x46985 $x43963)))
 (let ((@x47121 (monotonicity @x47119 (trans* (symm @x47060 $x46820) (symm @x47106 (= ?x46668 ?x43960)) @x47111 $x47112) $x47120)))
 (let ((@x47032 (hypothesis $x44301)))
 (let (($x47027 (>= ?x43932 32)))
 (let (($x47053 (or $x6247 $x47027)))
 (let (($x46964 (= $x46985 $x47053)))
 (let (($x47054 (or $x46659 $x46964)))
 (let (($x47004 (or $x46324 (not (>= (+ 32 (* (- 1) 8)) 0)) (not (<= (+ 32 ?x44482) 0)))))
 (let (($x47007 (= $x46985 (or $x6247 (not $x47004)))))
 (let (($x47049 (or $x46659 $x47007)))
 (let (($x47046 (= $x47049 $x47054)))
 (let ((@x47039 (trans (monotonicity (rewrite (= $x47007 $x46964)) $x47046) (rewrite (= $x47054 $x47054)) $x47046)))
 (let ((@x47040 (mp ((_ quant-inst $ (UINT 8) (Poly%slice%<u8.>. bytes!) 8 32) $x47049) @x47039 $x47054)))
 (let ((@x47058 (lemma ((_ th-lemma arith farkas -1 1 1) @x46704 @x46696 (hypothesis (not $x47027)) false) $x47027)))
 (let ((@x47043 (def-axiom (or $x47053 (not $x47027)))))
 (let ((@x47052 (def-axiom (or (not $x46964) $x46985 (not $x47053)))))
 (let ((@x47130 (unit-resolution @x47052 (unit-resolution @x47043 @x47058 $x47053) (or (not $x46964) $x46985))))
 (let ((@x47131 (unit-resolution @x47130 (unit-resolution @x47040 @x14943 $x46964) $x46985)))
 (let ((@x47132 (unit-resolution @x47131 (mp @x47032 (monotonicity (symm @x47121 $x47122) $x47124) $x47055) false)))
 (let ((@x44303 (def-axiom (or $x44025 $x44301))))
 (let ((@x47882 (unit-resolution @x44303 (unit-resolution (lemma @x47132 (or $x43963 $x47133)) @x47061 $x43963) $x44025)))
 (let ((@x44356 (def-axiom (or $x44109 $x44106 $x44107))))
 (let ((@x47884 (unit-resolution @x44356 (unit-resolution (def-axiom (or $x44114 $x44108)) @x47103 $x44108) @x47882 $x44107)))
 (let ((@x44344 (def-axiom (or $x44097 $x43966))))
 (let ((@x47890 (mp (unit-resolution @x44344 @x47884 $x43966) (symm (monotonicity @x47119 @x47111 (= $x47157 $x43966)) (= $x43966 $x47157)) $x47157)))
 (let ((@x47891 (unit-resolution (def-axiom (or $x47160 $x47358 (not $x47157))) @x47890 (unit-resolution ((_ quant-inst $ (UINT 8) (Poly%slice%<u8.>. bytes!) 8 (uClip SZ pmemlog!logimpl_v.header_size.?) tmp%5) (or $x47343 $x47161)) @x14966 $x47161) $x47358)))
 (let ((@x47892 (unit-resolution (def-axiom (or $x47159 $x47137)) @x47891 $x47137)))
 (let (($x47899 (= ?x47710 ?x46966)))
 (let (($x47895 (= ?x47025 tmp%5)))
 (let (($x47047 (= tmp%5 ?x47025)))
 (let (($x2041 (forall ((x Poly) )(! (let (($x2032 (= x (Poly%slice%<u8.>. (%Poly%slice%<u8.>. x)))))
 (or (not (has_type x (SLICE $ (UINT 8)))) $x2032)) :pattern ( (has_type x (SLICE $ (UINT 8))) ) :qid internal_crate__slice__<u8.>_unbox_axiom_definition))
 ))
 (let ((?x9584 (lambda ((x Poly) )(let (($x2032 (= x (Poly%slice%<u8.>. (%Poly%slice%<u8.>. x)))))
 (let (($x2038 (or (not (has_type x (SLICE $ (UINT 8)))) $x2032)))
 (refl (~ $x2038 $x2038)))))
 ))
 (let (($x2035 (forall ((x Poly) )(! (let (($x2032 (= x (Poly%slice%<u8.>. (%Poly%slice%<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let (($x2029 (has_type x ?x2028)))
 (=> $x2029 $x2032))))) :pattern ( (has_type x (SLICE $ (UINT 8))) ) :qid internal_crate__slice__<u8.>_unbox_axiom_definition))
 ))
 (let ((?x2042 (lambda ((x Poly) )(let (($x2032 (= x (Poly%slice%<u8.>. (%Poly%slice%<u8.>. x)))))
 (let (($x2038 (or (not (has_type x (SLICE $ (UINT 8)))) $x2032)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let (($x2029 (has_type x ?x2028)))
 (let (($x2033 (=> $x2029 $x2032)))
 (rewrite (= $x2033 $x2038)))))))))
 ))
 (let ((@x2046 (mp (asserted $x2035) (quant-intro (proof-bind ?x2042) (= $x2035 $x2041)) $x2041)))
 (let ((@x9588 (mp~ @x2046 (nnf-pos (proof-bind ?x9584) (~ $x2041 $x2041)) $x2041)))
 (let (($x47391 (not $x2041)))
 (let (($x47399 (or $x47391 $x46998 $x47047)))
 (let ((@x47459 (mp ((_ quant-inst tmp%5) (or $x47391 (or $x46998 $x47047))) (rewrite (= (or $x47391 (or $x46998 $x47047)) $x47399)) $x47399)))
 (let ((@x47894 (unit-resolution @x47459 @x9588 (unit-resolution (def-axiom (or $x47159 $x46997)) @x47891 $x46997) $x47047)))
 (let ((@x47900 (monotonicity (symm @x47894 $x47895) $x47899)))
 (let ((?x44112 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x43986)))
 (let ((?x44111 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x43986)))
 (let ((?x44110 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x43986)))
 (let ((?x44113 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44110 ?x44111 ?x44112)))
 (let (($x48129 (= ?x44113 ?x48104)))
 (let (($x48132 (not $x48129)))
 (let ((?x48120 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44113)))
 (let (($x48123 (has_type ?x48120 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x48126 (not $x48123)))
 (let (($x48135 (or $x48126 $x48132)))
 (let (($x48179 (not $x48135)))
 (let (($x48142 (ens%pmemlog!logimpl_v.bytes_to_metadata. ?x43968 ?x44113)))
 (let (($x48144 (= $x48135 $x48142)))
 (let (($x48147 (not $x48144)))
 (let (($x16015 (forall ((bytes! slice%<u8.>.) (out! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let (($x8740 (ens%pmemlog!logimpl_v.bytes_to_metadata. bytes! out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. bytes!))))
 (let (($x8742 (= out! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6191))))
 (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. out!)))
 (let (($x2641 (has_type ?x2639 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x13502 (not $x2641)))
 (let (($x15999 (or $x13502 (not $x8742))))
 (not (= $x15999 $x8740))))))))))) :pattern ( (ens%pmemlog!logimpl_v.bytes_to_metadata. bytes! out!) ) :qid internal_ens__pmemlog!logimpl_v.bytes_to_metadata._definition))
 ))
 (let (($x8746 (forall ((bytes! slice%<u8.>.) (out! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(! (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. bytes!))))
 (let (($x8742 (= out! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6191))))
 (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. out!)))
 (let (($x2641 (has_type ?x2639 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x8743 (and $x2641 $x8742)))
 (let (($x8740 (ens%pmemlog!logimpl_v.bytes_to_metadata. bytes! out!)))
 (= $x8740 $x8743))))))))) :pattern ( (ens%pmemlog!logimpl_v.bytes_to_metadata. bytes! out!) ) :qid internal_ens__pmemlog!logimpl_v.bytes_to_metadata._definition))
 ))
 (let ((?x16016 (lambda ((bytes! slice%<u8.>.) (out! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let (($x8740 (ens%pmemlog!logimpl_v.bytes_to_metadata. bytes! out!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. bytes!))))
 (let (($x8742 (= out! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6191))))
 (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. out!)))
 (let (($x2641 (has_type ?x2639 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x13502 (not $x2641)))
 (let (($x15999 (or $x13502 (not $x8742))))
 (let (($x16007 (not (= $x15999 $x8740))))
 (let (($x8743 (and $x2641 $x8742)))
 (let (($x8744 (= $x8740 $x8743)))
 (let (($x16010 (= $x8744 $x16007)))
 (let ((@x16005 (monotonicity (rewrite (= $x8743 (not $x15999))) (= $x8744 (= $x8740 (not $x15999))))))
 (trans (trans @x16005 (rewrite (= (= $x8740 (not $x15999)) $x16007)) $x16010) (rewrite (= $x16007 $x16007)) $x16010))))))))))))))))
 ))
 (let ((?x12758 (lambda ((bytes! slice%<u8.>.) (out! pmemlog!logimpl_v.PersistentHeaderMetadata.) )(let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. bytes!))))
 (let (($x8742 (= out! (pmemlog!logimpl_v.spec_bytes_to_metadata.? ?x6191))))
 (let ((?x2639 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. out!)))
 (let (($x2641 (has_type ?x2639 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x8743 (and $x2641 $x8742)))
 (let (($x8740 (ens%pmemlog!logimpl_v.bytes_to_metadata. bytes! out!)))
 (let (($x8744 (= $x8740 $x8743)))
 (refl (~ $x8744 $x8744))))))))))))
 ))
 (let ((@x16020 (mp (mp~ (asserted $x8746) (nnf-pos (proof-bind ?x12758) (~ $x8746 $x8746)) $x8746) (quant-intro (proof-bind ?x16016) (= $x8746 $x16015)) $x16015)))
 (let (($x48154 (not $x16015)))
 (let (($x48155 (or $x48154 $x48147)))
 (let ((?x44130 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?metadata ?x43987)))
 (let ((?x44238 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size ?x44130)))
 (let ((?x44235 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail ?x44130)))
 (let ((?x44232 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head ?x44130)))
 (let ((?x44236 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44232 ?x44235 ?x44238)))
 (let (($x48108 (ens%pmemlog!logimpl_v.bytes_to_metadata. ?x43968 ?x44236)))
 (let (($x48105 (= ?x44236 ?x48104)))
 (let (($x48106 (not $x48105)))
 (let ((?x48069 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44236)))
 (let (($x48102 (has_type ?x48069 TYPE%pmemlog!logimpl_v.PersistentHeaderMetadata.)))
 (let (($x48103 (not $x48102)))
 (let (($x48107 (or $x48103 $x48106)))
 (let (($x48109 (= $x48107 $x48108)))
 (let (($x48110 (not $x48109)))
 (let (($x48156 (or $x48154 $x48110)))
 (let (($x48158 (= $x48156 $x48155)))
 (let (($x48149 (= $x48110 $x48147)))
 (let ((@x48153 (trans (monotonicity (rewrite (= $x48109 $x48144)) $x48149) (rewrite (= $x48147 $x48147)) $x48149)))
 (let ((@x48163 (mp ((_ quant-inst (%Poly%slice%<u8.>. tmp%5) (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44232 ?x44235 ?x44238)) $x48156) (trans (monotonicity @x48153 $x48158) (rewrite (= $x48155 $x48155)) $x48158) $x48155)))
 (let ((@x48276 (unit-resolution @x48163 @x16020 $x48147)))
 (let (($x48325 (= $x43981 $x48142)))
 (let (($x48323 (= $x48142 $x43981)))
 (let ((?x44262 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?log_size tmp%9)))
 (let ((?x44234 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?tail tmp%9)))
 (let ((?x44233 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata/?head tmp%9)))
 (let ((?x44265 (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44233 ?x44234 ?x44262)))
 (let ((@x48308 (symm ((_ th-lemma datatype) (= tmp%9 ?x44265)) (= ?x44265 tmp%9))))
 (let ((?x44438 (Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44265)))
 (let ((?x44440 (%Poly%pmemlog!logimpl_v.PersistentHeaderMetadata. ?x44438)))
 (let (($x44460 (= ?x44265 ?x44440)))
 (let (($x44464 (or $x44463 $x44460)))
 (let ((@x44465 ((_ quant-inst (pmemlog!logimpl_v.PersistentHeaderMetadata./PersistentHeaderMetadata ?x44233 ?x44234 ?x44262)) $x44464)))
 (let ((@x48317 (symm (monotonicity (monotonicity @x48308 (= ?x44438 ?x43985)) (= ?x44440 ?x43986)) (= ?x43986 ?x44440))))
 (let ((@x48321 (trans* (symm ((_ th-lemma datatype) (= ?x43986 ?x44113)) (= ?x44113 ?x43986)) @x48317 (symm (unit-resolution @x44465 @x9917 $x44460) (= ?x44440 ?x44265)) @x48308 (= ?x44113 tmp%9))))
 (let (($x47947 (= ?x43968 metadata_bytes@)))
 (let ((@x44346 (def-axiom (or $x44097 $x43969))))
 (let ((@x48300 (unit-resolution @x44346 @x47884 $x43969)))
 (let ((@x44360 (def-axiom (or $x44114 $x43955))))
 (let ((@x48278 (unit-resolution @x44360 @x47103 $x43955)))
 (let ((?x46893 (Poly%slice%<u8.>. ?x43954)))
 (let ((?x47174 (vstd!view.View.view.? $slice ?x2028 ?x46893)))
 (let ((?x47193 (vstd!seq.Seq.len.? $ ?x1876 ?x47174)))
 (let (($x47194 (= ?x47193 8)))
 (let ((?x7131 (I 0)))
 (let ((?x46621 (vstd!seq.Seq.subrange.? $ ?x1876 ?x43931 ?x7131 ?x45948)))
 (let ((?x46620 (vstd!view.View.view.? $slice ?x2028 tmp%3)))
 (let (($x46685 (= ?x46620 ?x46621)))
 (let (($x46686 (not $x46685)))
 (let (($x46671 (has_type tmp%3 ?x2028)))
 (let (($x46673 (not $x46671)))
 (let (($x46690 (or $x46673 $x46686)))
 (let (($x47347 (not $x46690)))
 (let (($x46681 (ens%vstd!slice.slice_subrange. $ ?x1876 ?x43930 0 8 tmp%3)))
 (let (($x46665 (= $x46690 $x46681)))
 (let (($x46667 (not $x46665)))
 (let (($x47320 (or $x47343 $x46667)))
 (let ((@x47344 ((_ quant-inst $ (UINT 8) (Poly%slice%<u8.>. bytes!) 0 8 tmp%3) $x47320)))
 (let ((@x48279 (unit-resolution @x47344 @x14966 $x46667)))
 (let (($x48287 (= $x43952 $x46681)))
 (let (($x48285 (= $x46681 $x43952)))
 (let ((@x48286 (monotonicity @x46779 (trans* @x46773 @x47091 @x44386 $x46774) (trans* @x47115 @x46762 @x46764 @x46766 $x46767) $x48285)))
 (let ((@x48289 (mp (unit-resolution (def-axiom (or $x44114 $x43952)) @x47103 $x43952) (symm @x48286 $x48287) $x46681)))
 (let ((@x47315 (def-axiom (or $x46665 $x47347 (not $x46681)))))
 (let ((@x48290 (unit-resolution @x47315 @x48289 @x48279 $x47347)))
 (let ((@x47336 (def-axiom (or $x46690 $x46685))))
 (let ((@x48291 (unit-resolution @x47336 @x48290 $x46685)))
 (let (($x46894 (= tmp%3 ?x46893)))
 (let (($x47392 (or $x47391 $x46673 $x46894)))
 (let ((@x47394 (mp ((_ quant-inst tmp%3) (or $x47391 (or $x46673 $x46894))) (rewrite (= (or $x47391 (or $x46673 $x46894)) $x47392)) $x47392)))
 (let ((@x48293 (unit-resolution @x47394 @x9588 (unit-resolution (def-axiom (or $x46690 $x46671)) @x48290 $x46671) $x46894)))
 (let ((?x47517 (Sub 8 0)))
 (let (($x47531 (= ?x47517 8)))
 (let (($x951 (forall ((x Int) (y Int) )(! (= (+ y (* (- 1) x) (Sub x y)) 0) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x9190 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (refl (~ $x946 $x946))))
 ))
 (let (($x930 (forall ((x Int) (y Int) )(! (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (= ?x926 ?x927))) :pattern ( (Sub x y) ) :qid prelude_sub))
 ))
 (let ((?x952 (lambda ((x Int) (y Int) )(let (($x946 (= (+ y (* (- 1) x) (Sub x y)) 0)))
 (let ((?x927 (- x y)))
 (let ((?x926 (Sub x y)))
 (let (($x928 (= ?x926 ?x927)))
 (let ((@x940 (trans (rewrite (= ?x927 (+ x (* (- 1) y)))) (rewrite (= (+ x (* (- 1) y)) (+ (* (- 1) y) x))) (= ?x927 (+ (* (- 1) y) x)))))
 (trans (monotonicity @x940 (= $x928 (= ?x926 (+ (* (- 1) y) x)))) (rewrite (= (= ?x926 (+ (* (- 1) y) x)) $x946)) (= $x928 $x946))))))))
 ))
 (let ((@x956 (mp (asserted $x930) (quant-intro (proof-bind ?x952) (= $x930 $x951)) $x951)))
 (let ((@x9194 (mp~ @x956 (nnf-pos (proof-bind ?x9190) (~ $x951 $x951)) $x951)))
 (let (($x46189 (not $x951)))
 (let (($x47536 (or $x46189 $x47531)))
 (let ((?x46183 (* (- 1) 8)))
 (let ((?x47518 (+ 0 ?x46183 ?x47517)))
 (let (($x47519 (= ?x47518 0)))
 (let (($x47537 (or $x46189 $x47519)))
 (let (($x47539 (= $x47537 $x47536)))
 (let ((@x47527 (trans (monotonicity (rewrite (= ?x46183 (- 8))) (= ?x47518 (+ 0 (- 8) ?x47517))) (rewrite (= (+ 0 (- 8) ?x47517) (+ (- 8) ?x47517))) (= ?x47518 (+ (- 8) ?x47517)))))
 (let ((@x47535 (trans (monotonicity @x47527 (= $x47519 (= (+ (- 8) ?x47517) 0))) (rewrite (= (= (+ (- 8) ?x47517) 0) $x47531)) (= $x47519 $x47531))))
 (let ((@x47544 (mp ((_ quant-inst 8 0) $x47537) (trans (monotonicity @x47535 $x47539) (rewrite (= $x47536 $x47536)) $x47539) $x47536)))
 (let ((?x47222 (%I ?x7829)))
 (let (($x46680 (= ?x47222 0)))
 (let ((?x7132 (%I ?x7131)))
 (let (($x45972 (= ?x7132 0)))
 (let (($x237 (forall ((x Int) )(! (= x (%I (I x))) :pattern ( (I x) ) :qid prelude_unbox_box_int))
 ))
 (let ((?x8945 (lambda ((x Int) )(refl (~ (= x (%I (I x))) (= x (%I (I x))))))
 ))
 (let ((@x8949 (mp~ (asserted $x237) (nnf-pos (proof-bind ?x8945) (~ $x237 $x237)) $x237)))
 (let (($x44478 (not $x237)))
 (let (($x45974 (or $x44478 $x45972)))
 (let (($x45968 (= 0 ?x7132)))
 (let (($x45975 (or $x44478 $x45968)))
 (let (($x45977 (= $x45975 $x45974)))
 (let ((@x45981 (trans (monotonicity (rewrite (= $x45968 $x45972)) $x45977) (rewrite (= $x45974 $x45974)) $x45977)))
 (let ((@x45982 (mp ((_ quant-inst 0) $x45975) @x45981 $x45974)))
 (let ((@x47550 (monotonicity (symm (monotonicity @x46773 (= ?x7131 ?x7829)) (= ?x7829 ?x7131)) (= ?x47222 ?x7132))))
 (let ((@x47551 (trans* @x47550 (unit-resolution @x45982 @x8949 $x45972) $x46680)))
 (let ((?x47231 (%I ?x7834)))
 (let (($x46615 (= ?x47231 8)))
 (let ((?x45949 (%I ?x45948)))
 (let (($x45952 (= ?x45949 8)))
 (let (($x45954 (or $x44478 $x45952)))
 (let (($x45950 (= 8 ?x45949)))
 (let (($x45955 (or $x44478 $x45950)))
 (let (($x45957 (= $x45955 $x45954)))
 (let ((@x45961 (trans (monotonicity (rewrite (= $x45950 $x45952)) $x45957) (rewrite (= $x45954 $x45954)) $x45957)))
 (let ((@x45962 (mp ((_ quant-inst 8) $x45955) @x45961 $x45954)))
 (let ((@x47557 (trans* (monotonicity (symm @x47437 (= ?x7834 ?x45948)) (= ?x47231 ?x45949)) (unit-resolution @x45962 @x8949 $x45952) $x46615)))
 (let ((?x47241 (Sub ?x47231 ?x47222)))
 (let ((?x46670 (%Poly%vstd!seq.Seq<u8.>. ?x43931)))
 (let ((?x46796 (Poly%vstd!seq.Seq<u8.>. ?x46670)))
 (let ((?x47385 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46796 ?x7829 ?x7834)))
 (let ((?x47386 (vstd!seq.Seq.len.? $ ?x1876 ?x47385)))
 (let (($x47387 (= ?x47386 ?x47241)))
 (let (($x47339 (has_type ?x46796 ?x1968)))
 (let (($x46800 (= ?x43931 ?x46796)))
 (let (($x1981 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (or $x1977 $x1972)))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x9542 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (refl (~ $x1978 $x1978)))))))))
 ))
 (let (($x1975 (forall ((x Poly) )(! (let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (=> $x1969 $x1972))))) :pattern ( (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) ) :qid internal_vstd__seq__Seq<u8.>_unbox_axiom_definition))
 ))
 (let ((?x1982 (lambda ((x Poly) )(let (($x1972 (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))))
 (let ((?x1876 (UINT 8)))
 (let ((?x1968 (TYPE%vstd!seq.Seq. $ ?x1876)))
 (let (($x1969 (has_type x ?x1968)))
 (let (($x1977 (not $x1969)))
 (let (($x1978 (or $x1977 $x1972)))
 (let (($x1973 (=> $x1969 $x1972)))
 (rewrite (= $x1973 $x1978))))))))))
 ))
 (let ((@x1986 (mp (asserted $x1975) (quant-intro (proof-bind ?x1982) (= $x1975 $x1981)) $x1981)))
 (let ((@x9546 (mp~ @x1986 (nnf-pos (proof-bind ?x9542) (~ $x1981 $x1981)) $x1981)))
 (let (($x46804 (not $x1981)))
 (let (($x46805 (or $x46804 $x44390 $x46800)))
 (let ((@x46624 (mp ((_ quant-inst (vstd!view.View.view.? $slice ?x2028 ?x43930)) (or $x46804 (or $x44390 $x46800))) (rewrite (= (or $x46804 (or $x44390 $x46800)) $x46805)) $x46805)))
 (let ((@x47566 (symm (unit-resolution @x46624 @x9546 @x47563 $x46800) (= ?x46796 ?x43931))))
 (let ((@x47571 (mp @x47563 (symm (monotonicity @x47566 (= $x47339 $x44389)) (= $x44389 $x47339)) $x47339)))
 (let ((?x47380 (vstd!seq.Seq.len.? $ ?x1876 ?x46796)))
 (let ((?x47381 (* (- 1) ?x47380)))
 (let ((?x47382 (+ ?x47231 ?x47381)))
 (let (($x47383 (<= ?x47382 0)))
 (let (($x47296 (<= ?x47231 8)))
 (let ((@x47611 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46615) $x47296)) @x47557 $x47296)))
 (let ((?x47408 (+ ?x43932 ?x47381)))
 (let (($x47409 (<= ?x47408 0)))
 (let ((@x47608 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x43932 ?x47380)) $x47409)) (symm (monotonicity @x47566 (= ?x47380 ?x43932)) (= ?x43932 ?x47380)) $x47409)))
 (let ((@x47612 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1 1) (or $x47383 (not $x47296) (not $x47409) (not $x45441) (not $x44491))) @x47608 @x47611 @x46704 @x46696 $x47383)))
 (let (($x47229 (>= ?x47222 0)))
 (let ((?x47250 (* (- 1) ?x47231)))
 (let ((?x47251 (+ ?x47222 ?x47250)))
 (let (($x47252 (<= ?x47251 0)))
 (let (($x47294 (<= ?x47222 0)))
 (let (($x47297 (>= ?x47231 8)))
 (let ((@x47587 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46615) $x47297)) @x47557 $x47297)))
 (let ((@x47592 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x47252 (not $x47294) (not $x47297))) @x47587 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46680) $x47294)) @x47551 $x47294) $x47252)))
 (let (($x45914 (has_type ?x7829 INT)))
 (let (($x47414 (has_type ?x7131 INT)))
 (let (($x47425 (not $x47414)))
 (let ((@x47424 (symm (monotonicity (monotonicity @x46773 (= ?x7131 ?x7829)) (= $x47414 $x45914)) (= $x45914 $x47414))))
 (let ((@x47428 (mp (hypothesis (not $x45914)) (monotonicity @x47424 (= (not $x45914) $x47425)) $x47425)))
 (let (($x698 (forall ((x Int) )(! (let ((?x233 (I x)))
 (has_type ?x233 INT)) :pattern ( (has_type (I x) INT) ) :qid prelude_has_type_int))
 ))
 (let ((?x9085 (lambda ((x Int) )(refl (~ (has_type (I x) INT) (has_type (I x) INT))))
 ))
 (let ((@x9089 (mp~ (asserted $x698) (nnf-pos (proof-bind ?x9085) (~ $x698 $x698)) $x698)))
 (let ((@x47430 (unit-resolution (unit-resolution ((_ quant-inst 0) (or (not $x698) $x47414)) @x9089 $x47414) @x47428 false)))
 (let ((@x47431 (lemma @x47430 $x45914)))
 (let (($x45900 (has_type ?x7834 INT)))
 (let (($x47432 (has_type ?x45948 INT)))
 (let (($x47442 (not $x47432)))
 (let ((@x47444 (monotonicity (symm (monotonicity @x47437 (= $x47432 $x45900)) (= $x45900 $x47432)) (= (not $x45900) $x47442))))
 (let ((@x47447 (unit-resolution (unit-resolution ((_ quant-inst 8) (or (not $x698) $x47432)) @x9089 $x47432) (mp (hypothesis (not $x45900)) @x47444 $x47442) false)))
 (let ((@x47448 (lemma @x47447 $x45900)))
 (let (($x14122 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let (($x13922 (not $x4252)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x13921 (not $x4245)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x13126 (not $x1320)))
 (let (($x4282 (sized A&.)))
 (let (($x13962 (not $x4282)))
 (let (($x263 (has_type k! INT)))
 (let (($x271 (not $x263)))
 (let (($x4257 (has_type j! INT)))
 (let (($x13936 (not $x4257)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x13926 (not $x4256)))
 (or $x13926 $x13936 $x271 $x13962 $x13126 $x13921 $x13922 $x4643)))))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4641 (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x1589 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.)))
 (let (($x44619 (= $x4641 $x1589)))
 (let ((@x44621 (unit-resolution ((_ quant-inst fuel%vstd!seq.axiom_seq_subrange_len.) (or (not $x30) $x44619)) @x44497 (hypothesis (not $x44619)) false)))
 (let ((@x44633 (lemma @x44621 $x44619)))
 (let (($x1594 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index2.)))
 (let (($x13273 (not $x1594)))
 (let (($x1593 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_index1.)))
 (let (($x13272 (not $x1593)))
 (let (($x1592 (fuel_bool_default fuel%vstd!seq.axiom_seq_add_len.)))
 (let (($x13271 (not $x1592)))
 (let (($x1591 (fuel_bool_default fuel%vstd!seq.lemma_seq_two_subranges_index.)))
 (let (($x13270 (not $x1591)))
 (let (($x1590 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.)))
 (let (($x13269 (not $x1590)))
 (let (($x13268 (not $x1589)))
 (let (($x1588 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.)))
 (let (($x13267 (not $x1588)))
 (let (($x1587 (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.)))
 (let (($x13266 (not $x1587)))
 (let (($x1586 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.)))
 (let (($x13265 (not $x1586)))
 (let (($x1585 (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.)))
 (let (($x13264 (not $x1585)))
 (let (($x1584 (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.)))
 (let (($x13263 (not $x1584)))
 (let (($x1583 (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.)))
 (let (($x13262 (not $x1583)))
 (let (($x1582 (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.)))
 (let (($x13261 (not $x1582)))
 (let (($x13274 (or $x13261 $x13262 $x13263 $x13264 $x13265 $x13266 $x13267 $x13268 $x13269 $x13270 $x13271 $x13272 $x13273)))
 (let (($x13275 (not $x13274)))
 (let (($x1581 (fuel_bool_default fuel%vstd!seq.group_seq_axioms.)))
 (let (($x1665 (fuel_bool_default fuel%vstd!std_specs.hash.group_hash_axioms.)))
 (let (($x13338 (not $x1665)))
 (let (($x1664 (fuel_bool_default fuel%vstd!std_specs.vecdeque.group_vec_dequeue_axioms.)))
 (let (($x13337 (not $x1664)))
 (let (($x1638 (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.)))
 (let (($x1644 (not $x1638)))
 (let (($x1663 (fuel_bool_default fuel%vstd!std_specs.manually_drop.group_manually_drop_axioms.)))
 (let (($x13336 (not $x1663)))
 (let (($x1662 (fuel_bool_default fuel%vstd!std_specs.slice.group_slice_axioms.)))
 (let (($x13335 (not $x1662)))
 (let (($x1661 (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.)))
 (let (($x13334 (not $x1661)))
 (let (($x1660 (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.)))
 (let (($x13333 (not $x1660)))
 (let (($x1659 (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.)))
 (let (($x13332 (not $x1659)))
 (let (($x1658 (fuel_bool_default fuel%vstd!layout.group_layout_axioms.)))
 (let (($x13331 (not $x1658)))
 (let (($x1570 (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.)))
 (let (($x1576 (not $x1570)))
 (let (($x1657 (fuel_bool_default fuel%vstd!string.group_string_axioms.)))
 (let (($x13330 (not $x1657)))
 (let (($x1656 (fuel_bool_default fuel%vstd!array.group_array_axioms.)))
 (let (($x13329 (not $x1656)))
 (let (($x1626 (fuel_bool_default fuel%vstd!slice.group_slice_axioms.)))
 (let (($x1633 (not $x1626)))
 (let (($x1655 (fuel_bool_default fuel%vstd!laws_cmp.group_laws_cmp.)))
 (let (($x13328 (not $x1655)))
 (let (($x1548 (fuel_bool_default fuel%vstd!laws_eq.group_laws_eq.)))
 (let (($x1565 (not $x1548)))
 (let (($x1654 (fuel_bool_default fuel%vstd!function.group_function_axioms.)))
 (let (($x13327 (not $x1654)))
 (let (($x1653 (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.)))
 (let (($x13326 (not $x1653)))
 (let (($x1652 (fuel_bool_default fuel%vstd!set_lib.group_set_lib_default.)))
 (let (($x13325 (not $x1652)))
 (let (($x1615 (fuel_bool_default fuel%vstd!set.group_set_axioms.)))
 (let (($x1621 (not $x1615)))
 (let (($x1651 (fuel_bool_default fuel%vstd!map.group_map_axioms.)))
 (let (($x13324 (not $x1651)))
 (let (($x1603 (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.)))
 (let (($x1610 (not $x1603)))
 (let (($x1598 (not $x1581)))
 (let (($x13339 (or $x1598 $x1610 $x13324 $x1621 $x13325 $x13326 $x13327 $x1565 $x13328 $x1633 $x13329 $x13330 $x1576 $x13331 $x13332 $x13333 $x13334 $x13335 $x13336 $x1644 $x13337 $x13338)))
 (let (($x13340 (not $x13339)))
 (let (($x1649 (fuel_bool_default fuel%vstd!group_vstd_default.)))
 (let ((@x1650 (asserted $x1649)))
 (let (($x1669 (not $x1649)))
 (let (($x13343 (or $x1669 $x13340)))
 (let (($x1666 (and $x1581 $x1603 $x1651 $x1615 $x1652 $x1653 $x1654 $x1548 $x1655 $x1626 $x1656 $x1657 $x1570 $x1658 $x1659 $x1660 $x1661 $x1662 $x1663 $x1638 $x1664 $x1665)))
 (let (($x1670 (or $x1669 $x1666)))
 (let ((@x1673 (mp (asserted (=> $x1649 $x1666)) (rewrite (= (=> $x1649 $x1666) $x1670)) $x1670)))
 (let ((@x13345 (mp @x1673 (rewrite (= $x1670 $x13343)) $x13343)))
 (let ((@x42118 (def-axiom (or $x13339 $x1581))))
 (let (($x13278 (or $x1598 $x13275)))
 (let (($x1595 (and $x1582 $x1583 $x1584 $x1585 $x1586 $x1587 $x1588 $x1589 $x1590 $x1591 $x1592 $x1593 $x1594)))
 (let (($x1599 (or $x1598 $x1595)))
 (let ((@x1602 (mp (asserted (=> $x1581 $x1595)) (rewrite (= (=> $x1581 $x1595) $x1599)) $x1599)))
 (let ((@x13280 (mp @x1602 (rewrite (= $x1599 $x13278)) $x13278)))
 (let ((@x47574 (unit-resolution @x13280 (unit-resolution @x42118 (unit-resolution @x13345 @x1650 $x13340) $x1581) $x13275)))
 (let ((@x42076 (def-axiom (or $x13274 $x1589))))
 (let ((@x44626 (def-axiom (or (not $x44619) $x4641 $x13268))))
 (let ((@x47577 (unit-resolution @x44626 (unit-resolution @x42076 @x47574 $x1589) (or (not $x44619) $x4641))))
 (let (($x4675 (not $x4641)))
 (let (($x14173 (or $x4675 $x14122)))
 (let (($x4669 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (or $x4266 $x4655 $x4643))))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4676 (or $x4675 $x4669)))
 (let ((?x10971 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (refl (~ $x4664 $x4664))))))))))))))))))))))))
 ))
 (let ((@x10994 (monotonicity (refl (~ $x4675 $x4675)) (nnf-pos (proof-bind ?x10971) (~ $x4669 $x4669)) (~ $x4676 $x4676))))
 (let (($x4647 (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(! (let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let ((?x264 (%I k!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let ((?x1191 (%I j!)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4282 (sized A&.)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (=> (and $x4258 $x4283) $x4643))))))))))))))))))) :pattern ( (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) ) :qid user_vstd__seq__axiom_seq_subrange_len_9))
 ))
 (let (($x4648 (=> $x4641 $x4647)))
 (let ((?x4670 (lambda ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) )(let ((?x4260 (vstd!seq.Seq.subrange.? A&. A& s! j! k!)))
 (let ((?x4284 (vstd!seq.Seq.len.? A&. A& ?x4260)))
 (let (($x4643 (= ?x4284 (Sub (%I k!) (%I j!)))))
 (let ((?x264 (%I k!)))
 (let ((?x4249 (+ ?x264 (* (- 1) (vstd!seq.Seq.len.? A&. A& s!)))))
 (let (($x4252 (<= ?x4249 0)))
 (let ((?x1191 (%I j!)))
 (let ((?x4247 (* (- 1) ?x1191)))
 (let ((?x4248 (+ ?x264 ?x4247)))
 (let (($x4245 (>= ?x4248 0)))
 (let (($x1320 (>= ?x1191 0)))
 (let (($x4282 (sized A&.)))
 (let (($x4312 (and $x4282 $x1320 $x4245 $x4252)))
 (let (($x4655 (not $x4312)))
 (let (($x263 (has_type k! INT)))
 (let (($x4257 (has_type j! INT)))
 (let ((?x4244 (TYPE%vstd!seq.Seq. A&. A&)))
 (let (($x4256 (has_type s! ?x4244)))
 (let (($x4258 (and $x4256 $x4257 $x263)))
 (let (($x4266 (not $x4258)))
 (let (($x4664 (or $x4266 $x4655 $x4643)))
 (let ((?x4235 (vstd!seq.Seq.len.? A&. A& s!)))
 (let (($x4236 (<= ?x264 ?x4235)))
 (let (($x1310 (<= 0 ?x1191)))
 (let (($x4234 (and $x1310 (<= ?x1191 ?x264))))
 (let (($x4237 (and $x4234 $x4236)))
 (let (($x4283 (and $x4282 $x4237)))
 (let (($x4644 (=> $x4283 $x4643)))
 (let (($x4645 (=> (and $x4258 $x4283) $x4643)))
 (let ((@x4304 (monotonicity (rewrite (= $x4234 (and $x1320 $x4245))) (rewrite (= $x4236 $x4252)) (= $x4237 (and (and $x1320 $x4245) $x4252)))))
 (let ((@x4308 (trans @x4304 (rewrite (= (and (and $x1320 $x4245) $x4252) (and $x1320 $x4245 $x4252))) (= $x4237 (and $x1320 $x4245 $x4252)))))
 (let ((@x4316 (trans (monotonicity @x4308 (= $x4283 (and $x4282 (and $x1320 $x4245 $x4252)))) (rewrite (= (and $x4282 (and $x1320 $x4245 $x4252)) $x4312)) (= $x4283 $x4312))))
 (let ((@x4660 (trans (monotonicity @x4316 (= $x4644 (=> $x4312 $x4643))) (rewrite (= (=> $x4312 $x4643) (or $x4655 $x4643))) (= $x4644 (or $x4655 $x4643)))))
 (trans (monotonicity @x4660 (= $x4645 (=> $x4258 (or $x4655 $x4643)))) (rewrite (= (=> $x4258 (or $x4655 $x4643)) $x4664)) (= $x4645 $x4664))))))))))))))))))))))))))))))))))))
 ))
 (let ((@x4674 (monotonicity (quant-intro (proof-bind ?x4670) (= $x4647 $x4669)) (= $x4648 (=> $x4641 $x4669)))))
 (let ((@x4681 (mp (asserted $x4648) (trans @x4674 (rewrite (= (=> $x4641 $x4669) $x4676)) (= $x4648 $x4676)) $x4676)))
 (let ((@x14175 (mp (mp (mp~ @x4681 @x10994 $x4676) (rewrite (= $x4676 $x4676)) $x4676) (rewrite (= $x4676 $x14173)) $x14173)))
 (let ((@x47579 (unit-resolution @x14175 (unit-resolution @x47577 @x44633 $x4641) $x14122)))
 (let (($x174 (sized $)))
 (let ((@x175 (asserted $x174)))
 (let (($x47384 (not $x47383)))
 (let (($x47257 (not $x47252)))
 (let (($x47230 (not $x47229)))
 (let (($x47221 (not $x174)))
 (let (($x45901 (not $x45900)))
 (let (($x45915 (not $x45914)))
 (let (($x47340 (not $x47339)))
 (let (($x47502 (not $x14122)))
 (let (($x47503 (or $x47502 $x47340 $x45915 $x45901 $x47221 $x47230 $x47257 $x47384 $x47387)))
 (let ((?x47232 (* (- 1) ?x47222)))
 (let ((?x47233 (+ ?x47231 ?x47232)))
 (let (($x47234 (>= ?x47233 0)))
 (let (($x47235 (not $x47234)))
 (let (($x47388 (or $x47340 $x45915 $x45901 $x47221 $x47230 $x47235 $x47384 $x47387)))
 (let (($x47504 (or $x47502 $x47388)))
 (let ((@x47510 (rewrite (= (or $x47502 (or $x47340 $x45915 $x45901 $x47221 $x47230 $x47257 $x47384 $x47387)) $x47503))))
 (let (($x47490 (or $x47340 $x45915 $x45901 $x47221 $x47230 $x47257 $x47384 $x47387)))
 (let (($x47491 (= $x47388 $x47490)))
 (let ((@x47501 (trans (monotonicity (rewrite (= $x47235 $x47257)) $x47491) (rewrite (= $x47490 $x47490)) $x47491)))
 (let ((@x47512 (trans (monotonicity @x47501 (= $x47504 (or $x47502 $x47490))) @x47510 (= $x47504 $x47503))))
 (let ((@x47614 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x46670) (I pmemlog!logimpl_v.header_crc_offset.?) (I pmemlog!logimpl_v.header_head_offset.?)) $x47504) @x47512 $x47503) @x175 @x47579 @x47448 @x47431 @x47592 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x46680) $x47229)) @x47551 $x47229) @x47612 (or $x47340 $x47387))))
 (let ((@x47619 (monotonicity (trans* @x46732 @x46726 @x46737 (= ?x7830 pmemlog!logimpl_v.header_head_offset.?)) (= ?x7831 ?x7834))))
 (let ((@x47621 (symm @x47619 (= ?x7834 ?x7831))))
 (let ((@x47420 (monotonicity @x46773 (= ?x7131 ?x7829))))
 (let ((@x47631 (monotonicity @x47420 (trans* @x47437 @x47621 (= ?x45948 ?x7831)) (= ?x46621 ?x45824))))
 (let ((@x47637 (trans* (monotonicity (symm (hypothesis $x46894) (= ?x46893 tmp%3)) (= ?x47174 ?x46620)) (hypothesis $x46685) @x47631 (symm (monotonicity @x47566 @x47621 (= ?x47385 ?x45824)) (= ?x45824 ?x47385)) (= ?x47174 ?x47385))))
 (let ((@x47642 (trans* (monotonicity @x47637 (= ?x47193 ?x47386)) (unit-resolution @x47614 @x47571 $x47387) (monotonicity @x47557 @x47551 (= ?x47241 ?x47517)) (unit-resolution @x47544 @x9194 $x47531) $x47194)))
 (let ((@x47647 (lemma (unit-resolution (hypothesis (not $x47194)) @x47642 false) (or $x47194 $x46686 (not $x46894)))))
 (let (($x47173 (req%vstd!bytes.u64_from_le_bytes. ?x43954)))
 (let (($x47496 (not $x47173)))
 (let ((@x47653 (monotonicity (symm (hypothesis $x43955) (= ?x43954 crc_bytes@)) (= $x47173 $x43971))))
 (let ((@x47658 (mp (hypothesis (not $x43971)) (monotonicity (symm @x47653 (= $x43971 $x47173)) (= (not $x43971) $x47496)) $x47496)))
 (let (($x6157 (not %%global_location_label%%7)))
 (let (($x47195 (or $x6157 $x47194)))
 (let (($x47196 (= $x47173 $x47195)))
 (let (($x6159 (forall ((s! slice%<u8.>.) )(! (let ((?x2022 (Poly%slice%<u8.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x6174 (= ?x6173 8)))
 (let (($x6157 (not %%global_location_label%%7)))
 (let (($x6169 (req%vstd!bytes.u64_from_le_bytes. s!)))
 (= $x6169 (or $x6157 $x6174))))))))) :pattern ( (req%vstd!bytes.u64_from_le_bytes. s!) ) :qid internal_req__vstd!bytes.u64_from_le_bytes._definition))
 ))
 (let ((?x11642 (lambda ((s! slice%<u8.>.) )(let ((?x2022 (Poly%slice%<u8.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x6174 (= ?x6173 8)))
 (let (($x6157 (not %%global_location_label%%7)))
 (let (($x6169 (req%vstd!bytes.u64_from_le_bytes. s!)))
 (let (($x6181 (= $x6169 (or $x6157 $x6174))))
 (refl (~ $x6181 $x6181)))))))))))
 ))
 (let (($x6154 (forall ((s! slice%<u8.>.) )(! (let ((?x2022 (Poly%slice%<u8.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x6174 (= ?x6173 8)))
 (let (($x6169 (req%vstd!bytes.u64_from_le_bytes. s!)))
 (= $x6169 (=> %%global_location_label%%7 $x6174)))))))) :pattern ( (req%vstd!bytes.u64_from_le_bytes. s!) ) :qid internal_req__vstd!bytes.u64_from_le_bytes._definition))
 ))
 (let ((?x6179 (lambda ((s! slice%<u8.>.) )(let ((?x2022 (Poly%slice%<u8.>. s!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x6174 (= ?x6173 8)))
 (let (($x6157 (not %%global_location_label%%7)))
 (let (($x6169 (req%vstd!bytes.u64_from_le_bytes. s!)))
 (let (($x6181 (= $x6169 (or $x6157 $x6174))))
 (let (($x6176 (= $x6169 (=> %%global_location_label%%7 $x6174))))
 (rewrite (= $x6176 $x6181))))))))))))
 ))
 (let ((@x6187 (mp (asserted $x6154) (quant-intro (proof-bind ?x6179) (= $x6154 $x6159)) $x6159)))
 (let ((@x11650 (mp~ @x6187 (nnf-pos (proof-bind ?x11642) (~ $x6159 $x6159)) $x6159)))
 (let ((@x47661 (unit-resolution (def-axiom (or $x47195 (not $x47194))) (hypothesis $x47194) $x47195)))
 (let ((@x47663 (unit-resolution (def-axiom (or (not $x47196) $x47173 (not $x47195))) @x47661 (or (not $x47196) $x47173))))
 (let ((@x47664 (unit-resolution @x47663 (unit-resolution ((_ quant-inst (%Poly%slice%<u8.>. tmp%3)) (or (not $x6159) $x47196)) @x11650 $x47196) $x47173)))
 (let ((@x47667 (lemma (unit-resolution @x47664 @x47658 false) (or $x43971 $x44066 (not $x47194)))))
 (let ((@x44290 (def-axiom (or $x44029 (not $x43971)))))
 (let ((@x48296 (unit-resolution @x44290 (unit-resolution @x47667 (unit-resolution @x47647 @x48293 @x48291 $x47194) @x48278 $x43971) $x44029)))
 (let ((@x44342 (def-axiom (or $x44092 $x44089 $x44090))))
 (let ((@x48297 (unit-resolution @x44342 @x48296 (unit-resolution (def-axiom (or $x44097 $x44091)) @x47884 $x44091) $x44090)))
 (let ((@x44334 (def-axiom (or $x44079 $x44072))))
 (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x47723 (vstd!seq.Seq.len.? $ ?x1876 ?x47710)))
 (let (($x47724 (= ?x47723 ?x8522)))
 (let ((?x47791 (%I ?x7835)))
 (let ((?x47800 (Sub ?x47791 ?x47231)))
 (let ((?x47798 (vstd!seq.Seq.subrange.? $ ?x1876 ?x46796 ?x7834 ?x7835)))
 (let ((?x47799 (vstd!seq.Seq.len.? $ ?x1876 ?x47798)))
 (let (($x47801 (= ?x47799 ?x47800)))
 (let (($x47917 (not $x47801)))
 (let (($x47732 (not $x47724)))
 (let (($x47918 (= $x47732 $x47917)))
 (let (($x47915 (= $x47724 $x47801)))
 (let (($x47913 (= $x47801 $x47724)))
 (let ((?x45928 (%I ?x45927)))
 (let (($x45938 (= ?x45928 32)))
 (let (($x45939 (or $x44478 $x45938)))
 (let (($x45935 (= 32 ?x45928)))
 (let (($x45940 (or $x44478 $x45935)))
 (let (($x45942 (= $x45940 $x45939)))
 (let ((@x45946 (trans (monotonicity (rewrite (= $x45935 $x45938)) $x45942) (rewrite (= $x45939 $x45939)) $x45942)))
 (let ((@x45947 (mp ((_ quant-inst 32) $x45940) @x45946 $x45939)))
 (let ((@x47326 (unit-resolution @x45947 @x8949 $x45938)))
 (let ((@x47464 (monotonicity (symm @x47864 (= ?x7835 ?x45927)) (= ?x47791 ?x45928))))
 (let ((@x47856 (monotonicity (trans* @x47464 @x47326 @x47862 (= ?x47791 pmemlog!logimpl_v.header_size.?)) @x47557 (= ?x47800 ?x8522))))
 (let (($x47911 (= ?x47799 ?x47723)))
 (let (($x47909 (= ?x47798 ?x47710)))
 (let ((@x47898 (monotonicity @x47566 (= ?x47798 ?x45830))))
 (let ((@x47910 (trans* @x47898 (symm @x47902 (= ?x45830 ?x46995)) (symm @x47892 (= ?x46995 ?x46966)) (symm @x47900 (= ?x46966 ?x47710)) $x47909)))
 (let ((@x47919 (monotonicity (symm (monotonicity (monotonicity @x47910 $x47911) @x47856 $x47913) $x47915) $x47918)))
 (let ((@x47207 (hypothesis $x47732)))
 (let (($x47783 (>= ?x47231 0)))
 (let ((?x47809 (* (- 1) ?x47791)))
 (let ((?x47825 (+ ?x47380 ?x47809)))
 (let (($x47826 (>= ?x47825 0)))
 (let (($x47852 (<= ?x47791 32)))
 (let (($x47213 (= ?x47791 32)))
 (let ((@x47924 (trans* @x47464 @x47326 $x47213)))
 (let ((@x47936 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 -1 1) (or $x47826 (not $x47852) (not $x47409) (not $x45441) (not $x44491))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47213) $x47852)) @x47924 $x47852) @x47608 @x46704 @x46696 $x47826)))
 (let ((?x47810 (+ ?x47231 ?x47809)))
 (let (($x47811 (<= ?x47810 0)))
 (let (($x47853 (>= ?x47791 32)))
 (let ((@x47929 (unit-resolution ((_ th-lemma arith assign-bounds 1 1) (or $x47811 (not $x47296) (not $x47853))) (unit-resolution ((_ th-lemma arith triangle-eq) (or (not $x47213) $x47853)) @x47924 $x47853) @x47611 $x47811)))
 (let (($x45911 (has_type ?x7835 INT)))
 (let (($x47857 (has_type ?x45927 INT)))
 (let (($x47869 (not $x47857)))
 (let ((@x47871 (monotonicity (symm (monotonicity @x47864 (= $x47857 $x45911)) (= $x45911 $x47857)) (= (not $x45911) $x47869))))
 (let ((@x47874 (unit-resolution (unit-resolution ((_ quant-inst 32) (or (not $x698) $x47857)) @x9089 $x47857) (mp (hypothesis (not $x45911)) @x47871 $x47869) false)))
 (let ((@x47875 (lemma @x47874 $x45911)))
 (let (($x47831 (not $x47826)))
 (let (($x47816 (not $x47811)))
 (let (($x47784 (not $x47783)))
 (let (($x45912 (not $x45911)))
 (let (($x47836 (or $x47502 $x47340 $x45901 $x45912 $x47221 $x47784 $x47816 $x47831 $x47801)))
 (let ((?x47795 (+ ?x47791 ?x47381)))
 (let (($x47796 (<= ?x47795 0)))
 (let (($x47797 (not $x47796)))
 (let ((?x47792 (+ ?x47791 ?x47250)))
 (let (($x47793 (>= ?x47792 0)))
 (let (($x47794 (not $x47793)))
 (let (($x47802 (or $x47340 $x45901 $x45912 $x47221 $x47784 $x47794 $x47797 $x47801)))
 (let (($x47837 (or $x47502 $x47802)))
 (let ((@x47840 (rewrite (= (or $x47502 (or $x47340 $x45901 $x45912 $x47221 $x47784 $x47816 $x47831 $x47801)) $x47836))))
 (let (($x47778 (or $x47340 $x45901 $x45912 $x47221 $x47784 $x47816 $x47831 $x47801)))
 (let (($x47779 (= $x47802 $x47778)))
 (let ((@x47835 (trans (monotonicity (rewrite (= $x47794 $x47816)) (rewrite (= $x47797 $x47831)) $x47779) (rewrite (= $x47778 $x47778)) $x47779)))
 (let ((@x47847 (trans (monotonicity @x47835 (= $x47837 (or $x47502 $x47778))) @x47840 (= $x47837 $x47836))))
 (let ((@x47941 (unit-resolution (mp ((_ quant-inst $ (UINT 8) (Poly%vstd!seq.Seq<u8.>. ?x46670) (I pmemlog!logimpl_v.header_head_offset.?) (I pmemlog!logimpl_v.header_size.?)) $x47837) @x47847 $x47836) @x175 @x47579 @x47448 @x47875 @x47929 @x47936 (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x47783 (not $x47297))) @x47587 $x47783) (or $x47340 $x47801))))
 (let ((@x47944 (lemma (unit-resolution @x47941 (mp @x47207 @x47919 $x47917) @x47571 false) (or $x47724 $x47133))))
 (let (($x47709 (req%pmemlog!logimpl_v.bytes_to_metadata. ?x43968)))
 (let (($x47789 (not $x47709)))
 (let ((@x47952 (symm (monotonicity (symm (hypothesis $x43969) $x47947) (= $x47709 $x43978)) (= $x43978 $x47709))))
 (let ((@x47955 (mp (hypothesis (not $x43978)) (monotonicity @x47952 (= (not $x43978) $x47789)) $x47789)))
 (let (($x8729 (not %%global_location_label%%47)))
 (let (($x47725 (or $x8729 $x47724)))
 (let (($x47726 (= $x47709 $x47725)))
 (let (($x8731 (forall ((bytes! slice%<u8.>.) )(! (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x2022 (Poly%slice%<u8.>. bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x8723 (= ?x6173 ?x8522)))
 (let (($x8729 (not %%global_location_label%%47)))
 (let (($x8721 (req%pmemlog!logimpl_v.bytes_to_metadata. bytes!)))
 (= $x8721 (or $x8729 $x8723)))))))))) :pattern ( (req%pmemlog!logimpl_v.bytes_to_metadata. bytes!) ) :qid internal_req__pmemlog!logimpl_v.bytes_to_metadata._definition))
 ))
 (let ((?x12751 (lambda ((bytes! slice%<u8.>.) )(let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x2022 (Poly%slice%<u8.>. bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x8723 (= ?x6173 ?x8522)))
 (let (($x8729 (not %%global_location_label%%47)))
 (let (($x8721 (req%pmemlog!logimpl_v.bytes_to_metadata. bytes!)))
 (let (($x8733 (= $x8721 (or $x8729 $x8723))))
 (refl (~ $x8733 $x8733))))))))))))
 ))
 (let (($x8727 (forall ((bytes! slice%<u8.>.) )(! (let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x2022 (Poly%slice%<u8.>. bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x8723 (= ?x6173 ?x8522)))
 (let (($x8721 (req%pmemlog!logimpl_v.bytes_to_metadata. bytes!)))
 (= $x8721 (=> %%global_location_label%%47 $x8723))))))))) :pattern ( (req%pmemlog!logimpl_v.bytes_to_metadata. bytes!) ) :qid internal_req__pmemlog!logimpl_v.bytes_to_metadata._definition))
 ))
 (let ((?x8732 (lambda ((bytes! slice%<u8.>.) )(let ((?x8522 (Sub pmemlog!logimpl_v.header_size.? 8)))
 (let ((?x2022 (Poly%slice%<u8.>. bytes!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6173 (vstd!seq.Seq.len.? $ ?x1876 (vstd!view.View.view.? $slice ?x2028 ?x2022))))
 (let (($x8723 (= ?x6173 ?x8522)))
 (let (($x8729 (not %%global_location_label%%47)))
 (let (($x8721 (req%pmemlog!logimpl_v.bytes_to_metadata. bytes!)))
 (let (($x8733 (= $x8721 (or $x8729 $x8723))))
 (let (($x8725 (= $x8721 (=> %%global_location_label%%47 $x8723))))
 (rewrite (= $x8725 $x8733)))))))))))))
 ))
 (let ((@x8739 (mp (asserted $x8727) (quant-intro (proof-bind ?x8732) (= $x8727 $x8731)) $x8731)))
 (let ((@x12755 (mp~ @x8739 (nnf-pos (proof-bind ?x12751) (~ $x8731 $x8731)) $x8731)))
 (let ((@x47960 (unit-resolution (def-axiom (or (not $x47726) $x47709 (not $x47725))) (unit-resolution (def-axiom (or $x47725 $x47732)) (hypothesis $x47724) $x47725) (or (not $x47726) $x47709))))
 (let ((@x47961 (unit-resolution @x47960 (unit-resolution ((_ quant-inst (%Poly%slice%<u8.>. tmp%5)) (or (not $x8731) $x47726)) @x12755 $x47726) $x47709)))
 (let ((@x47964 (lemma (unit-resolution @x47961 @x47955 false) (or $x43978 $x44038 $x47732))))
 (let ((@x44296 (def-axiom (or $x44033 (not $x43978)))))
 (let ((@x48302 (unit-resolution @x44296 (unit-resolution @x47964 @x48300 (unit-resolution @x47944 @x47061 $x47724) $x43978) $x44033)))
 (let ((@x44328 (def-axiom (or $x44073 $x44070 $x44071))))
 (let ((@x48303 (unit-resolution @x44328 @x48302 (unit-resolution @x44334 @x48297 $x44072) $x44071)))
 (let ((@x44313 (def-axiom (or $x44053 $x43981))))
 (let ((@x48327 (mp (unit-resolution @x44313 @x48303 $x43981) (symm (monotonicity (symm @x48300 $x47947) @x48321 $x48323) $x48325) $x48142)))
 (let ((@x48190 (def-axiom (or $x48144 $x48179 (not $x48142)))))
 (let ((@x48178 (def-axiom (or $x48135 $x48129))))
 (let (($x44115 (= ?x43986 ?x44113)))
 (let ((@x48305 ((_ th-lemma datatype) $x44115)))
 (let ((@x48337 (trans* @x48305 (unit-resolution @x48178 (unit-resolution @x48190 @x48327 @x48276 $x48179) $x48129) (monotonicity (trans* @x47900 @x47892 @x47902 $x48274) $x48330) @x48268 @x48273 @x48333 @x48267 @x48335 @x48257 $x48336)))
 (let (($x48367 (= ?x43984 ?x44276)))
 (let ((?x44253 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x44277)))
 (let (($x44256 (= ?x44253 ?x44276)))
 (let ((@x48338 ((_ th-lemma datatype) $x44256)))
 (let ((@x48366 (monotonicity @x48266 (= (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x45834) ?x44253))))
 (let ((?x45862 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x45834)))
 (let (($x45863 (= ?x45829 ?x45862)))
 (let ((@x48339 ((_ th-lemma datatype) $x45863)))
 (let (($x45963 (= ?x45814 ?x45829)))
 (let (($x45966 (or $x44478 $x45963)))
 (let ((@x45967 ((_ quant-inst (vstd!bytes.spec_u64_from_le_bytes.? ?x45824)) $x45966)))
 (let ((@x48340 (unit-resolution @x45967 @x8949 $x45963)))
 (let ((?x47474 (vstd!bytes.spec_u64_from_le_bytes.? ?x47174)))
 (let (($x48363 (= ?x47474 ?x45814)))
 (let (($x48343 (= ?x47174 ?x45824)))
 (let ((@x48344 (trans* (monotonicity (symm @x48293 (= ?x46893 tmp%3)) (= ?x47174 ?x46620)) @x48291 @x47631 $x48343)))
 (let (($x47514 (= ?x43984 ?x47474)))
 (let (($x47648 (not $x47514)))
 (let (($x47484 (uInv 64 ?x43984)))
 (let (($x47468 (not $x47484)))
 (let (($x47669 (or $x47468 $x47648)))
 (let (($x47707 (not $x47669)))
 (let (($x47668 (ens%vstd!bytes.u64_from_le_bytes. ?x43954 ?x43984)))
 (let (($x47389 (= $x47669 $x47668)))
 (let (($x47460 (not $x47389)))
 (let (($x14900 (forall ((s! slice%<u8.>.) (x! Int) )(! (let (($x6189 (ens%vstd!bytes.u64_from_le_bytes. s! x!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. s!))))
 (let (($x6193 (= x! (vstd!bytes.spec_u64_from_le_bytes.? ?x6191))))
 (let (($x2750 (uInv 64 x!)))
 (let (($x3158 (not $x2750)))
 (let (($x14848 (or $x3158 (not $x6193))))
 (not (= $x14848 $x6189)))))))))) :pattern ( (ens%vstd!bytes.u64_from_le_bytes. s! x!) ) :qid internal_ens__vstd!bytes.u64_from_le_bytes._definition))
 ))
 (let (($x6197 (forall ((s! slice%<u8.>.) (x! Int) )(! (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. s!))))
 (let (($x6193 (= x! (vstd!bytes.spec_u64_from_le_bytes.? ?x6191))))
 (let (($x2750 (uInv 64 x!)))
 (let (($x6194 (and $x2750 $x6193)))
 (let (($x6189 (ens%vstd!bytes.u64_from_le_bytes. s! x!)))
 (= $x6189 $x6194)))))))) :pattern ( (ens%vstd!bytes.u64_from_le_bytes. s! x!) ) :qid internal_ens__vstd!bytes.u64_from_le_bytes._definition))
 ))
 (let ((?x14901 (lambda ((s! slice%<u8.>.) (x! Int) )(let (($x6189 (ens%vstd!bytes.u64_from_le_bytes. s! x!)))
 (let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. s!))))
 (let (($x6193 (= x! (vstd!bytes.spec_u64_from_le_bytes.? ?x6191))))
 (let (($x2750 (uInv 64 x!)))
 (let (($x3158 (not $x2750)))
 (let (($x14848 (or $x3158 (not $x6193))))
 (let (($x14857 (not (= $x14848 $x6189))))
 (let (($x6194 (and $x2750 $x6193)))
 (let (($x6195 (= $x6189 $x6194)))
 (let (($x14895 (= $x6195 $x14857)))
 (let ((@x14852 (monotonicity (rewrite (= $x6194 (not $x14848))) (= $x6195 (= $x6189 (not $x14848))))))
 (trans (trans @x14852 (rewrite (= (= $x6189 (not $x14848)) $x14857)) $x14895) (rewrite (= $x14857 $x14857)) $x14895)))))))))))))))
 ))
 (let ((?x11643 (lambda ((s! slice%<u8.>.) (x! Int) )(let ((?x1876 (UINT 8)))
 (let ((?x2028 (SLICE $ ?x1876)))
 (let ((?x6191 (vstd!view.View.view.? $slice ?x2028 (Poly%slice%<u8.>. s!))))
 (let (($x6193 (= x! (vstd!bytes.spec_u64_from_le_bytes.? ?x6191))))
 (let (($x2750 (uInv 64 x!)))
 (let (($x6194 (and $x2750 $x6193)))
 (let (($x6189 (ens%vstd!bytes.u64_from_le_bytes. s! x!)))
 (let (($x6195 (= $x6189 $x6194)))
 (refl (~ $x6195 $x6195)))))))))))
 ))
 (let ((@x14905 (mp (mp~ (asserted $x6197) (nnf-pos (proof-bind ?x11643) (~ $x6197 $x6197)) $x6197) (quant-intro (proof-bind ?x14901) (= $x6197 $x14900)) $x14900)))
 (let (($x47695 (not $x14900)))
 (let (($x47696 (or $x47695 $x47460)))
 (let ((?x44128 (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x43987)))
 (let (($x47478 (ens%vstd!bytes.u64_from_le_bytes. ?x43954 ?x44128)))
 (let (($x47472 (uInv 64 ?x44128)))
 (let (($x47473 (not $x47472)))
 (let (($x47477 (or $x47473 (not (= ?x44128 ?x47474)))))
 (let (($x47479 (= $x47477 $x47478)))
 (let (($x47480 (not $x47479)))
 (let (($x47697 (or $x47695 $x47480)))
 (let (($x47699 (= $x47697 $x47696)))
 (let (($x47461 (= $x47480 $x47460)))
 (let ((@x47694 (trans (monotonicity (rewrite (= $x47479 $x47389)) $x47461) (rewrite (= $x47460 $x47460)) $x47461)))
 (let ((@x47702 (mp ((_ quant-inst (%Poly%slice%<u8.>. tmp%3) (pmemlog!logimpl_v.PersistentHeader./PersistentHeader/?crc ?x43987)) $x47697) (trans (monotonicity @x47694 $x47699) (rewrite (= $x47696 $x47696)) $x47699) $x47696)))
 (let ((@x48345 (unit-resolution @x47702 @x14905 $x47460)))
 (let (($x48358 (= $x43974 $x47668)))
 (let (($x48356 (= $x47668 $x43974)))
 (let (($x48353 (= ?x43984 tmp%8)))
 (let (($x44461 (= tmp%10 ?x43984)))
 (let (($x44479 (or $x44478 $x44461)))
 (let ((@x44480 ((_ quant-inst tmp%10) $x44479)))
 (let ((@x48352 (symm (unit-resolution @x44480 @x8949 $x44461) (= ?x43984 tmp%10))))
 (let ((@x48354 (trans* @x48352 (unit-resolution (def-axiom (or $x44079 $x43976)) @x48297 $x43976) $x48353)))
 (let ((@x48360 (mp (unit-resolution (def-axiom (or $x44079 $x43974)) @x48297 $x43974) (symm (monotonicity (symm @x48278 (= ?x43954 crc_bytes@)) @x48354 $x48356) $x48358) $x47668)))
 (let ((@x47682 (def-axiom (or $x47389 $x47707 (not $x47668)))))
 (let ((@x47706 (def-axiom (or $x47669 $x47514))))
 (let ((@x48368 (trans* (unit-resolution @x47706 (unit-resolution @x47682 @x48360 @x48345 $x47707) $x47514) (monotonicity @x48344 $x48363) @x48340 @x48339 @x48366 @x48338 $x48367)))
 (let ((@x48375 (trans* (unit-resolution (def-axiom (or $x44053 $x43988)) @x48303 $x43988) (monotonicity @x48368 @x48337 $x48370) @x48373 $x48374)))
 (let (($x48060 (not $x47470)))
 (let (($x47790 (ext_eq false TYPE%pmemlog!logimpl_v.PersistentHeader. ?x43990 ?x46614)))
 (let (($x47850 (= $x47470 $x47790)))
 (let (($x418 (forall ((deep Bool) (t Type) (x Poly) (y Poly) )(! (let (($x415 (ext_eq deep t x y)))
 (= (= x y) $x415)) :pattern ( (ext_eq deep t x y) ) :qid prelude_ext_eq))
 ))
 (let ((?x9029 (lambda ((deep Bool) (t Type) (x Poly) (y Poly) )(let (($x415 (ext_eq deep t x y)))
 (let (($x416 (= (= x y) $x415)))
 (refl (~ $x416 $x416)))))
 ))
 (let ((@x9033 (mp~ (asserted $x418) (nnf-pos (proof-bind ?x9029) (~ $x418 $x418)) $x418)))
 (let (($x48054 (or (not $x418) $x47850)))
 (let ((@x48055 ((_ quant-inst false TYPE%pmemlog!logimpl_v.PersistentHeader. (Poly%pmemlog!logimpl_v.PersistentHeader. out!) (Poly%pmemlog!logimpl_v.PersistentHeader. ?x46803)) $x48054)))
 (let ((@x48379 (unit-resolution @x48055 @x9033 $x47850)))
 (let (($x48057 (not $x47790)))
 (let ((@x48386 (symm (monotonicity (symm @x48255 (= ?x46614 ?x43992)) (= $x47790 $x43993)) (= $x43993 $x47790))))
 (let ((@x48388 (monotonicity @x48386 (= (not $x43993) $x48057))))
 (let ((@x48389 (mp (unit-resolution (def-axiom (or $x44053 (not $x43993))) @x48303 (not $x43993)) @x48388 $x48057)))
 (let ((@x48062 (def-axiom (or (not $x47850) $x48060 $x47790))))
 (let ((@x48391 (unit-resolution (unit-resolution @x48062 @x48389 @x48379 $x48060) (trans* (monotonicity @x48375 $x48376) @x48255 $x47470) false)))
 (let ((@x48392 (lemma @x48391 $x47133)))
 (let (($x425 (or $x422 $x424)))
 (let ((@x426 (asserted $x425)))
 (let ((@x48223 (unit-resolution @x426 @x48392 $x424)))
 (let ((@x47975 (symm (monotonicity @x48223 @x47764 (= ?x43957 ?x43944)) (= ?x43944 ?x43957))))
 (let ((?x47199 (+ ?x441 ?x44420)))
 (let (($x47331 (<= ?x47199 0)))
 (let ((@x48253 (unit-resolution ((_ th-lemma arith triangle-eq) (or (not (= ?x441 ?x44419)) $x47331)) (symm (monotonicity @x48223 (= ?x44419 ?x441)) (= ?x441 ?x44419)) $x47331)))
 (let ((@x48254 (unit-resolution ((_ th-lemma arith assign-bounds 1 1 1) (or $x44443 (not $x45380) $x46354 (not $x47331))) @x47076 @x46720 @x48253 $x44443)))
 (let ((@x47317 (unit-resolution @x47090 @x48254 $x44425)))
 (let ((@x47996 (unit-resolution @x46794 @x47317 (mp (trans* @x47975 @x46764 $x46286) @x47994 $x46433) $x43949)))
 (let ((@x47998 (unit-resolution @x47102 (unit-resolution @x44101 @x47996 $x44021) $x44124)))
 (let ((@x48001 (symm (monotonicity @x48223 @x46703 (= ?x43960 (uClip 64 32))) (= (uClip 64 32) ?x43960))))
 (let ((?x47330 (uClip 64 32)))
 (let (($x47202 (= 32 ?x47330)))
 (let (($x47690 (= ?x47330 32)))
 (let (($x47680 (<= ?x441 32)))
 (let (($x47716 (or $x47680 $x47690)))
 (let (($x47689 (not $x47716)))
 (let ((?x47708 (* (- 1) ?x47330)))
 (let ((?x47683 (+ ?x441 ?x47708)))
 (let (($x47686 (<= ?x47683 0)))
 (let (($x47333 (>= ?x47330 0)))
 (let (($x47209 (not $x47333)))
 (let (($x47712 (or $x47209 $x47686 $x47689)))
 (let (($x47741 (not $x47712)))
 (let (($x47711 (or $x44432 $x47741)))
 (let ((?x47407 (+ ?x47330 ?x43215)))
 (let (($x47321 (>= ?x47407 0)))
 (let (($x47413 (not (or $x47209 $x47321 (not (or $x46817 (>= (+ 32 ?x43215) 0) $x47202))))))
 (let (($x47733 (or $x44432 $x47413)))
 (let (($x47735 (= $x47733 $x47711)))
 (let ((@x47743 (trans (monotonicity (rewrite (= $x47413 $x47741)) $x47735) (rewrite (= $x47711 $x47711)) $x47735)))
 (let ((@x47720 (mp ((_ quant-inst 64 32) $x47733) @x47743 $x47711)))
 (let ((@x48066 (def-axiom (or $x47712 $x47716))))
 (let (($x47722 (not $x47680)))
 (let ((@x47968 (def-axiom (or $x47689 $x47680 $x47690))))
 (let ((@x48226 (unit-resolution @x47968 (unit-resolution ((_ th-lemma arith farkas 1 1) (or $x47722 (not $x43924))) @x46719 $x47722) (or $x47689 $x47690))))
 (let ((@x48224 (unit-resolution @x48226 (unit-resolution @x48066 (unit-resolution @x47720 @x12817 $x47741) $x47716) $x47690)))
 (let ((@x48005 (trans* (symm @x48224 $x47202) @x48001 (symm (unit-resolution @x44364 @x47998 $x43961) $x47110) $x47112)))
 (let ((@x48009 (trans* @x47977 @x47980 @x47975 (symm (unit-resolution (def-axiom (or $x44114 $x43958)) @x47998 $x43958) $x47116) $x47118)))
 (let ((@x48013 (mp @x47032 (monotonicity (symm (monotonicity @x48009 @x48005 $x47120) $x47122) $x47124) $x47055)))
 (let ((@x48008 (lemma (unit-resolution @x47131 @x48013 false) $x43963)))
 (let ((@x48171 (unit-resolution @x44356 (unit-resolution (def-axiom (or $x44114 $x44108)) @x47998 $x44108) $x44108)))
 (let ((@x48172 (unit-resolution @x48171 (unit-resolution @x44303 @x48008 $x44025) $x44107)))
 (let ((@x48209 (mp (unit-resolution @x44344 @x48172 $x43966) (symm (monotonicity @x48009 @x48005 (= $x47048 $x43966)) (= $x43966 $x47048)) $x47048)))
 (let ((@x48022 (def-axiom (or $x47024 $x48195 (not $x47048)))))
 (let ((@x48210 (unit-resolution @x48022 @x48209 (unit-resolution @x48181 @x14966 $x47023) $x48195)))
 (let ((@x48176 (def-axiom (or $x47045 $x47041))))
 (let ((@x48212 (unit-resolution @x48176 @x48210 $x47041)))
 (let ((@x48214 (unit-resolution @x47459 @x9588 (unit-resolution (def-axiom (or $x47045 $x46997)) @x48210 $x46997) $x47047)))
 (let ((@x48216 (monotonicity (symm @x48214 $x47895) $x47899)))
 (let ((@x48600 (symm (monotonicity (symm (unit-resolution @x44346 @x48172 $x43969) $x47947) @x48321 $x48323) $x48325)))
 (let ((@x48586 (unit-resolution @x44360 @x47998 $x43955)))
 (let ((@x48578 (monotonicity @x46779 (trans* @x46773 @x47317 @x44386 $x46774) (trans* @x47977 @x47980 @x47975 @x46764 @x46766 $x46767) $x48285)))
 (let ((@x48580 (mp (unit-resolution (def-axiom (or $x44114 $x43952)) @x47998 $x43952) (symm @x48578 $x48287) $x46681)))
 (let ((@x48581 (unit-resolution @x47315 @x48580 @x48279 $x47347)))
 (let ((@x48584 (unit-resolution @x47336 @x48581 $x46685)))
 (let ((@x48583 (unit-resolution @x47394 @x9588 (unit-resolution (def-axiom (or $x46690 $x46671)) @x48581 $x46671) $x46894)))
 (let ((@x48588 (unit-resolution @x44290 (unit-resolution @x47667 (unit-resolution @x47647 @x48583 @x48584 $x47194) @x48586 $x43971) $x44029)))
 (let ((@x48591 (unit-resolution (unit-resolution @x44342 @x48588 (or $x44092 $x44090)) (unit-resolution (def-axiom (or $x44097 $x44091)) @x48172 $x44091) $x44090)))
 (let ((@x48593 (unit-resolution @x44346 @x48172 $x43969)))
 (let ((@x48239 (trans* @x47898 (symm @x48211 (= ?x45830 ?x46967)) (symm @x48212 (= ?x46967 ?x46966)) (symm @x48216 (= ?x46966 ?x47710)) $x47909)))
 (let ((@x48243 (monotonicity (symm (monotonicity (monotonicity @x48239 $x47911) @x47856 $x47913) $x47915) $x47918)))
 (let ((@x48350 (lemma (unit-resolution @x47941 (mp @x47207 @x48243 $x47917) @x47571 false) $x47724)))
 (let ((@x48596 (unit-resolution @x44328 (unit-resolution @x44296 (unit-resolution @x47964 @x48350 @x48593 $x43978) $x44033) (unit-resolution @x44334 @x48591 $x44072) $x44071)))
 (let ((@x48602 (unit-resolution @x48190 (mp (unit-resolution @x44313 @x48596 $x43981) @x48600 $x48142) @x48276 $x48179)))
 (let ((@x48605 (trans* @x48305 (unit-resolution @x48178 @x48602 $x48129) (monotonicity (trans* @x48216 @x48212 @x48211 $x48274) $x48330) @x48268 @x48273 @x48333 @x48267 @x48335 @x48257 $x48336)))
 (let ((@x48608 (trans* (monotonicity (symm @x48583 (= ?x46893 tmp%3)) (= ?x47174 ?x46620)) @x48584 @x47631 $x48343)))
 (let ((@x48613 (trans* @x48352 (unit-resolution (def-axiom (or $x44079 $x43976)) @x48591 $x43976) $x48353)))
 (let ((@x48617 (mp (unit-resolution (def-axiom (or $x44079 $x43974)) @x48591 $x43974) (symm (monotonicity (symm @x48586 (= ?x43954 crc_bytes@)) @x48613 $x48356) $x48358) $x47668)))
 (let ((@x48621 (trans* (unit-resolution @x47706 (unit-resolution @x47682 @x48617 @x48345 $x47707) $x47514) (monotonicity @x48608 $x48363) @x48340 @x48339 @x48366 @x48338 $x48367)))
 (let ((@x48624 (trans* (unit-resolution (def-axiom (or $x44053 $x43988)) @x48596 $x43988) (monotonicity @x48621 @x48605 $x48370) @x48373 $x48374)))
 (let ((@x48628 (mp (unit-resolution (def-axiom (or $x44053 (not $x43993))) @x48596 (not $x43993)) @x48388 $x48057)))
 (unit-resolution (unit-resolution @x48062 @x48628 @x48379 $x48060) (trans* (monotonicity @x48624 $x48376) @x48255 $x47470) false)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

